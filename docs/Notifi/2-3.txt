### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/delaystepresponsedto.ts
Tamaño: 10855 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { collectExtraKeys as collectExtraKeys$, safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  DelayControlsMetadataResponseDto,
  DelayControlsMetadataResponseDto$inboundSchema,
  DelayControlsMetadataResponseDto$Outbound,
  DelayControlsMetadataResponseDto$outboundSchema,
} from './delaycontrolsmetadataresponsedto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  StepIssuesDto,
  StepIssuesDto$inboundSchema,
  StepIssuesDto$Outbound,
  StepIssuesDto$outboundSchema,
} from './stepissuesdto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Type of the delay. Currently only 'regular' is supported by the schema.
 */
export const DelayStepResponseDtoType = {
  Regular: 'regular',
  Timed: 'timed',
} as const;
/**
 * Type of the delay. Currently only 'regular' is supported by the schema.
 */
export type DelayStepResponseDtoType = ClosedEnum<typeof DelayStepResponseDtoType>;

/**
 * Unit of time for the delay amount.
 */
export const DelayStepResponseDtoUnit = {
  Seconds: 'seconds',
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
  Weeks: 'weeks',
  Months: 'months',
} as const;
/**
 * Unit of time for the delay amount.
 */
export type DelayStepResponseDtoUnit = ClosedEnum<typeof DelayStepResponseDtoUnit>;

/**
 * Control values for the delay step
 */
export type DelayStepResponseDtoControlValues = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * Type of the delay. Currently only 'regular' is supported by the schema.
   */
  type?: DelayStepResponseDtoType | undefined;
  /**
   * Amount of time to delay.
   */
  amount?: number | undefined;
  /**
   * Unit of time for the delay amount.
   */
  unit?: DelayStepResponseDtoUnit | undefined;
  /**
   * Cron expression for the delay. Min length 1.
   */
  cron?: string | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type DelayStepResponseDto = {
  /**
   * Controls metadata for the delay step
   */
  controls: DelayControlsMetadataResponseDto;
  /**
   * Control values for the delay step
   */
  controlValues?: DelayStepResponseDtoControlValues | undefined;
  /**
   * JSON Schema for variables, follows the JSON Schema standard
   */
  variables: { [k: string]: any };
  /**
   * Unique identifier of the step
   */
  stepId: string;
  /**
   * Database identifier of the step
   */
  id: string;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Slug of the step
   */
  slug: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow database identifier
   */
  workflowDatabaseId: string;
  /**
   * Issues associated with the step
   */
  issues?: StepIssuesDto | undefined;
};

/** @internal */
export const DelayStepResponseDtoType$inboundSchema: z.ZodNativeEnum<typeof DelayStepResponseDtoType> =
  z.nativeEnum(DelayStepResponseDtoType);

/** @internal */
export const DelayStepResponseDtoType$outboundSchema: z.ZodNativeEnum<typeof DelayStepResponseDtoType> =
  DelayStepResponseDtoType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DelayStepResponseDtoType$ {
  /** @deprecated use `DelayStepResponseDtoType$inboundSchema` instead. */
  export const inboundSchema = DelayStepResponseDtoType$inboundSchema;
  /** @deprecated use `DelayStepResponseDtoType$outboundSchema` instead. */
  export const outboundSchema = DelayStepResponseDtoType$outboundSchema;
}

/** @internal */
export const DelayStepResponseDtoUnit$inboundSchema: z.ZodNativeEnum<typeof DelayStepResponseDtoUnit> =
  z.nativeEnum(DelayStepResponseDtoUnit);

/** @internal */
export const DelayStepResponseDtoUnit$outboundSchema: z.ZodNativeEnum<typeof DelayStepResponseDtoUnit> =
  DelayStepResponseDtoUnit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DelayStepResponseDtoUnit$ {
  /** @deprecated use `DelayStepResponseDtoUnit$inboundSchema` instead. */
  export const inboundSchema = DelayStepResponseDtoUnit$inboundSchema;
  /** @deprecated use `DelayStepResponseDtoUnit$outboundSchema` instead. */
  export const outboundSchema = DelayStepResponseDtoUnit$outboundSchema;
}

/** @internal */
export const DelayStepResponseDtoControlValues$inboundSchema: z.ZodType<
  DelayStepResponseDtoControlValues,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z
    .object({
      skip: z.record(z.any()).optional(),
      type: DelayStepResponseDtoType$inboundSchema.default('regular'),
      amount: z.number().optional(),
      unit: DelayStepResponseDtoUnit$inboundSchema.optional(),
      cron: z.string().optional(),
    })
    .catchall(z.any()),
  'additionalProperties',
  true
);

/** @internal */
export type DelayStepResponseDtoControlValues$Outbound = {
  skip?: { [k: string]: any } | undefined;
  type: string;
  amount?: number | undefined;
  unit?: string | undefined;
  cron?: string | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const DelayStepResponseDtoControlValues$outboundSchema: z.ZodType<
  DelayStepResponseDtoControlValues$Outbound,
  z.ZodTypeDef,
  DelayStepResponseDtoControlValues
> = z
  .object({
    skip: z.record(z.any()).optional(),
    type: DelayStepResponseDtoType$outboundSchema.default('regular'),
    amount: z.number().optional(),
    unit: DelayStepResponseDtoUnit$outboundSchema.optional(),
    cron: z.string().optional(),
    additionalProperties: z.record(z.any()).optional(),
  })
  .transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DelayStepResponseDtoControlValues$ {
  /** @deprecated use `DelayStepResponseDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = DelayStepResponseDtoControlValues$inboundSchema;
  /** @deprecated use `DelayStepResponseDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = DelayStepResponseDtoControlValues$outboundSchema;
  /** @deprecated use `DelayStepResponseDtoControlValues$Outbound` instead. */
  export type Outbound = DelayStepResponseDtoControlValues$Outbound;
}

export function delayStepResponseDtoControlValuesToJSON(
  delayStepResponseDtoControlValues: DelayStepResponseDtoControlValues
): string {
  return JSON.stringify(DelayStepResponseDtoControlValues$outboundSchema.parse(delayStepResponseDtoControlValues));
}

export function delayStepResponseDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<DelayStepResponseDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DelayStepResponseDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DelayStepResponseDtoControlValues' from JSON`
  );
}

/** @internal */
export const DelayStepResponseDto$inboundSchema: z.ZodType<DelayStepResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    controls: DelayControlsMetadataResponseDto$inboundSchema,
    controlValues: z.lazy(() => DelayStepResponseDtoControlValues$inboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    _id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$inboundSchema,
    origin: ResourceOriginEnum$inboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type DelayStepResponseDto$Outbound = {
  controls: DelayControlsMetadataResponseDto$Outbound;
  controlValues?: DelayStepResponseDtoControlValues$Outbound | undefined;
  variables: { [k: string]: any };
  stepId: string;
  _id: string;
  name: string;
  slug: string;
  type: string;
  origin: string;
  workflowId: string;
  workflowDatabaseId: string;
  issues?: StepIssuesDto$Outbound | undefined;
};

/** @internal */
export const DelayStepResponseDto$outboundSchema: z.ZodType<
  DelayStepResponseDto$Outbound,
  z.ZodTypeDef,
  DelayStepResponseDto
> = z
  .object({
    controls: DelayControlsMetadataResponseDto$outboundSchema,
    controlValues: z.lazy(() => DelayStepResponseDtoControlValues$outboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$outboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DelayStepResponseDto$ {
  /** @deprecated use `DelayStepResponseDto$inboundSchema` instead. */
  export const inboundSchema = DelayStepResponseDto$inboundSchema;
  /** @deprecated use `DelayStepResponseDto$outboundSchema` instead. */
  export const outboundSchema = DelayStepResponseDto$outboundSchema;
  /** @deprecated use `DelayStepResponseDto$Outbound` instead. */
  export type Outbound = DelayStepResponseDto$Outbound;
}

export function delayStepResponseDtoToJSON(delayStepResponseDto: DelayStepResponseDto): string {
  return JSON.stringify(DelayStepResponseDto$outboundSchema.parse(delayStepResponseDto));
}

export function delayStepResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<DelayStepResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DelayStepResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DelayStepResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - delayStepResponseDtoControlValuesToJSON(delayStepResponseDtoControlValues: DelayStepResponseDtoControlValues)
 - delayStepResponseDtoControlValuesFromJSON(jsonString: string)
 - delayStepResponseDtoToJSON(delayStepResponseDto: DelayStepResponseDto)
 - delayStepResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DelayStepResponseDtoControlValues$Outbound;
}

export function delayStepResponseDtoControlValuesToJS...)
 - Outbound(DelayStepResponseDto$Outbound;
}

export function delayStepResponseDtoToJSON(delayStepResponseDto: D...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function delayStepResponseDtoControlValuesToJSON
- export function delayStepResponseDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function delayStepResponseDtoToJSON
- export function delayStepResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/delaystepupsertdto.ts
Tamaño: 5248 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  DelayControlDto,
  DelayControlDto$inboundSchema,
  DelayControlDto$Outbound,
  DelayControlDto$outboundSchema,
} from './delaycontroldto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the Delay step.
 */
export type DelayStepUpsertDtoControlValues =
  | DelayControlDto
  | {
      [k: string]: any;
    };

export type DelayStepUpsertDto = {
  /**
   * Database identifier of the step. Used for updating the step.
   */
  id?: string | undefined;
  /**
   * Unique identifier for the step
   */
  stepId?: string | undefined;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Control values for the Delay step.
   */
  controlValues?: DelayControlDto | { [k: string]: any } | undefined;
};

/** @internal */
export const DelayStepUpsertDtoControlValues$inboundSchema: z.ZodType<
  DelayStepUpsertDtoControlValues,
  z.ZodTypeDef,
  unknown
> = z.union([DelayControlDto$inboundSchema, z.record(z.any())]);

/** @internal */
export type DelayStepUpsertDtoControlValues$Outbound = DelayControlDto$Outbound | { [k: string]: any };

/** @internal */
export const DelayStepUpsertDtoControlValues$outboundSchema: z.ZodType<
  DelayStepUpsertDtoControlValues$Outbound,
  z.ZodTypeDef,
  DelayStepUpsertDtoControlValues
> = z.union([DelayControlDto$outboundSchema, z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DelayStepUpsertDtoControlValues$ {
  /** @deprecated use `DelayStepUpsertDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = DelayStepUpsertDtoControlValues$inboundSchema;
  /** @deprecated use `DelayStepUpsertDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = DelayStepUpsertDtoControlValues$outboundSchema;
  /** @deprecated use `DelayStepUpsertDtoControlValues$Outbound` instead. */
  export type Outbound = DelayStepUpsertDtoControlValues$Outbound;
}

export function delayStepUpsertDtoControlValuesToJSON(
  delayStepUpsertDtoControlValues: DelayStepUpsertDtoControlValues
): string {
  return JSON.stringify(DelayStepUpsertDtoControlValues$outboundSchema.parse(delayStepUpsertDtoControlValues));
}

export function delayStepUpsertDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<DelayStepUpsertDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DelayStepUpsertDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DelayStepUpsertDtoControlValues' from JSON`
  );
}

/** @internal */
export const DelayStepUpsertDto$inboundSchema: z.ZodType<DelayStepUpsertDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$inboundSchema,
    controlValues: z.union([DelayControlDto$inboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type DelayStepUpsertDto$Outbound = {
  _id?: string | undefined;
  stepId?: string | undefined;
  name: string;
  type: string;
  controlValues?: DelayControlDto$Outbound | { [k: string]: any } | undefined;
};

/** @internal */
export const DelayStepUpsertDto$outboundSchema: z.ZodType<
  DelayStepUpsertDto$Outbound,
  z.ZodTypeDef,
  DelayStepUpsertDto
> = z
  .object({
    id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$outboundSchema,
    controlValues: z.union([DelayControlDto$outboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DelayStepUpsertDto$ {
  /** @deprecated use `DelayStepUpsertDto$inboundSchema` instead. */
  export const inboundSchema = DelayStepUpsertDto$inboundSchema;
  /** @deprecated use `DelayStepUpsertDto$outboundSchema` instead. */
  export const outboundSchema = DelayStepUpsertDto$outboundSchema;
  /** @deprecated use `DelayStepUpsertDto$Outbound` instead. */
  export type Outbound = DelayStepUpsertDto$Outbound;
}

export function delayStepUpsertDtoToJSON(delayStepUpsertDto: DelayStepUpsertDto): string {
  return JSON.stringify(DelayStepUpsertDto$outboundSchema.parse(delayStepUpsertDto));
}

export function delayStepUpsertDtoFromJSON(
  jsonString: string
): SafeParseResult<DelayStepUpsertDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DelayStepUpsertDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DelayStepUpsertDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - delayStepUpsertDtoControlValuesToJSON(delayStepUpsertDtoControlValues: DelayStepUpsertDtoControlValues)
 - delayStepUpsertDtoControlValuesFromJSON(jsonString: string)
 - delayStepUpsertDtoToJSON(delayStepUpsertDto: DelayStepUpsertDto)
 - delayStepUpsertDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DelayStepUpsertDtoControlValues$Outbound;
}

export function delayStepUpsertDtoControlValuesToJSON(
...)
 - Outbound(DelayStepUpsertDto$Outbound;
}

export function delayStepUpsertDtoToJSON(delayStepUpsertDto: DelaySt...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function delayStepUpsertDtoControlValuesToJSON
- export function delayStepUpsertDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function delayStepUpsertDtoToJSON
- export function delayStepUpsertDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/deletemessageresponsedto.ts
Tamaño: 3518 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * The status enum for the performed action
 */
export const DeleteMessageResponseDtoStatus = {
  Deleted: 'deleted',
} as const;
/**
 * The status enum for the performed action
 */
export type DeleteMessageResponseDtoStatus = ClosedEnum<typeof DeleteMessageResponseDtoStatus>;

export type DeleteMessageResponseDto = {
  /**
   * A boolean stating the success of the action
   */
  acknowledged: boolean;
  /**
   * The status enum for the performed action
   */
  status: DeleteMessageResponseDtoStatus;
};

/** @internal */
export const DeleteMessageResponseDtoStatus$inboundSchema: z.ZodNativeEnum<typeof DeleteMessageResponseDtoStatus> =
  z.nativeEnum(DeleteMessageResponseDtoStatus);

/** @internal */
export const DeleteMessageResponseDtoStatus$outboundSchema: z.ZodNativeEnum<typeof DeleteMessageResponseDtoStatus> =
  DeleteMessageResponseDtoStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeleteMessageResponseDtoStatus$ {
  /** @deprecated use `DeleteMessageResponseDtoStatus$inboundSchema` instead. */
  export const inboundSchema = DeleteMessageResponseDtoStatus$inboundSchema;
  /** @deprecated use `DeleteMessageResponseDtoStatus$outboundSchema` instead. */
  export const outboundSchema = DeleteMessageResponseDtoStatus$outboundSchema;
}

/** @internal */
export const DeleteMessageResponseDto$inboundSchema: z.ZodType<DeleteMessageResponseDto, z.ZodTypeDef, unknown> =
  z.object({
    acknowledged: z.boolean(),
    status: DeleteMessageResponseDtoStatus$inboundSchema,
  });

/** @internal */
export type DeleteMessageResponseDto$Outbound = {
  acknowledged: boolean;
  status: string;
};

/** @internal */
export const DeleteMessageResponseDto$outboundSchema: z.ZodType<
  DeleteMessageResponseDto$Outbound,
  z.ZodTypeDef,
  DeleteMessageResponseDto
> = z.object({
  acknowledged: z.boolean(),
  status: DeleteMessageResponseDtoStatus$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeleteMessageResponseDto$ {
  /** @deprecated use `DeleteMessageResponseDto$inboundSchema` instead. */
  export const inboundSchema = DeleteMessageResponseDto$inboundSchema;
  /** @deprecated use `DeleteMessageResponseDto$outboundSchema` instead. */
  export const outboundSchema = DeleteMessageResponseDto$outboundSchema;
  /** @deprecated use `DeleteMessageResponseDto$Outbound` instead. */
  export type Outbound = DeleteMessageResponseDto$Outbound;
}

export function deleteMessageResponseDtoToJSON(deleteMessageResponseDto: DeleteMessageResponseDto): string {
  return JSON.stringify(DeleteMessageResponseDto$outboundSchema.parse(deleteMessageResponseDto));
}

export function deleteMessageResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<DeleteMessageResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeleteMessageResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeleteMessageResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - deleteMessageResponseDtoToJSON(deleteMessageResponseDto: DeleteMessageResponseDto)
 - deleteMessageResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DeleteMessageResponseDto$Outbound;
}

export function deleteMessageResponseDtoToJSON(deleteMessageRe...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function deleteMessageResponseDtoToJSON
- export function deleteMessageResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/deletetopicresponsedto.ts
Tamaño: 2007 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type DeleteTopicResponseDto = {
  /**
   * Indicates if the operation was acknowledged
   */
  acknowledged: boolean;
};

/** @internal */
export const DeleteTopicResponseDto$inboundSchema: z.ZodType<DeleteTopicResponseDto, z.ZodTypeDef, unknown> = z.object({
  acknowledged: z.boolean(),
});

/** @internal */
export type DeleteTopicResponseDto$Outbound = {
  acknowledged: boolean;
};

/** @internal */
export const DeleteTopicResponseDto$outboundSchema: z.ZodType<
  DeleteTopicResponseDto$Outbound,
  z.ZodTypeDef,
  DeleteTopicResponseDto
> = z.object({
  acknowledged: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeleteTopicResponseDto$ {
  /** @deprecated use `DeleteTopicResponseDto$inboundSchema` instead. */
  export const inboundSchema = DeleteTopicResponseDto$inboundSchema;
  /** @deprecated use `DeleteTopicResponseDto$outboundSchema` instead. */
  export const outboundSchema = DeleteTopicResponseDto$outboundSchema;
  /** @deprecated use `DeleteTopicResponseDto$Outbound` instead. */
  export type Outbound = DeleteTopicResponseDto$Outbound;
}

export function deleteTopicResponseDtoToJSON(deleteTopicResponseDto: DeleteTopicResponseDto): string {
  return JSON.stringify(DeleteTopicResponseDto$outboundSchema.parse(deleteTopicResponseDto));
}

export function deleteTopicResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<DeleteTopicResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeleteTopicResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeleteTopicResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - deleteTopicResponseDtoToJSON(deleteTopicResponseDto: DeleteTopicResponseDto)
 - deleteTopicResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DeleteTopicResponseDto$Outbound;
}

export function deleteTopicResponseDtoToJSON(deleteTopicResponse...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function deleteTopicResponseDtoToJSON
- export function deleteTopicResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/deletetopicsubscriptionsrequestdto.ts
Tamaño: 2355 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type DeleteTopicSubscriptionsRequestDto = {
  /**
   * List of subscriber identifiers to unsubscribe from the topic (max: 100)
   */
  subscriberIds: Array<string>;
};

/** @internal */
export const DeleteTopicSubscriptionsRequestDto$inboundSchema: z.ZodType<
  DeleteTopicSubscriptionsRequestDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  subscriberIds: z.array(z.string()),
});

/** @internal */
export type DeleteTopicSubscriptionsRequestDto$Outbound = {
  subscriberIds: Array<string>;
};

/** @internal */
export const DeleteTopicSubscriptionsRequestDto$outboundSchema: z.ZodType<
  DeleteTopicSubscriptionsRequestDto$Outbound,
  z.ZodTypeDef,
  DeleteTopicSubscriptionsRequestDto
> = z.object({
  subscriberIds: z.array(z.string()),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeleteTopicSubscriptionsRequestDto$ {
  /** @deprecated use `DeleteTopicSubscriptionsRequestDto$inboundSchema` instead. */
  export const inboundSchema = DeleteTopicSubscriptionsRequestDto$inboundSchema;
  /** @deprecated use `DeleteTopicSubscriptionsRequestDto$outboundSchema` instead. */
  export const outboundSchema = DeleteTopicSubscriptionsRequestDto$outboundSchema;
  /** @deprecated use `DeleteTopicSubscriptionsRequestDto$Outbound` instead. */
  export type Outbound = DeleteTopicSubscriptionsRequestDto$Outbound;
}

export function deleteTopicSubscriptionsRequestDtoToJSON(
  deleteTopicSubscriptionsRequestDto: DeleteTopicSubscriptionsRequestDto
): string {
  return JSON.stringify(DeleteTopicSubscriptionsRequestDto$outboundSchema.parse(deleteTopicSubscriptionsRequestDto));
}

export function deleteTopicSubscriptionsRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<DeleteTopicSubscriptionsRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeleteTopicSubscriptionsRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeleteTopicSubscriptionsRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - deleteTopicSubscriptionsRequestDtoToJSON(deleteTopicSubscriptionsRequestDto: DeleteTopicSubscriptionsRequestDto)
 - deleteTopicSubscriptionsRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DeleteTopicSubscriptionsRequestDto$Outbound;
}

export function deleteTopicSubscriptionsRequestDtoTo...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function deleteTopicSubscriptionsRequestDtoToJSON
- export function deleteTopicSubscriptionsRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/deletetopicsubscriptionsresponsedto.ts
Tamaño: 3347 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { MetaDto, MetaDto$inboundSchema, MetaDto$Outbound, MetaDto$outboundSchema } from './metadto.js';
import {
  SubscriptionDto,
  SubscriptionDto$inboundSchema,
  SubscriptionDto$Outbound,
  SubscriptionDto$outboundSchema,
} from './subscriptiondto.js';
import {
  SubscriptionsDeleteErrorDto,
  SubscriptionsDeleteErrorDto$inboundSchema,
  SubscriptionsDeleteErrorDto$Outbound,
  SubscriptionsDeleteErrorDto$outboundSchema,
} from './subscriptionsdeleteerrordto.js';

export type DeleteTopicSubscriptionsResponseDto = {
  /**
   * The list of successfully deleted subscriptions
   */
  data: Array<SubscriptionDto>;
  /**
   * Metadata about the operation
   */
  meta: MetaDto;
  /**
   * The list of errors for failed deletion attempts
   */
  errors?: Array<SubscriptionsDeleteErrorDto> | undefined;
};

/** @internal */
export const DeleteTopicSubscriptionsResponseDto$inboundSchema: z.ZodType<
  DeleteTopicSubscriptionsResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.array(SubscriptionDto$inboundSchema),
  meta: MetaDto$inboundSchema,
  errors: z.array(SubscriptionsDeleteErrorDto$inboundSchema).optional(),
});

/** @internal */
export type DeleteTopicSubscriptionsResponseDto$Outbound = {
  data: Array<SubscriptionDto$Outbound>;
  meta: MetaDto$Outbound;
  errors?: Array<SubscriptionsDeleteErrorDto$Outbound> | undefined;
};

/** @internal */
export const DeleteTopicSubscriptionsResponseDto$outboundSchema: z.ZodType<
  DeleteTopicSubscriptionsResponseDto$Outbound,
  z.ZodTypeDef,
  DeleteTopicSubscriptionsResponseDto
> = z.object({
  data: z.array(SubscriptionDto$outboundSchema),
  meta: MetaDto$outboundSchema,
  errors: z.array(SubscriptionsDeleteErrorDto$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeleteTopicSubscriptionsResponseDto$ {
  /** @deprecated use `DeleteTopicSubscriptionsResponseDto$inboundSchema` instead. */
  export const inboundSchema = DeleteTopicSubscriptionsResponseDto$inboundSchema;
  /** @deprecated use `DeleteTopicSubscriptionsResponseDto$outboundSchema` instead. */
  export const outboundSchema = DeleteTopicSubscriptionsResponseDto$outboundSchema;
  /** @deprecated use `DeleteTopicSubscriptionsResponseDto$Outbound` instead. */
  export type Outbound = DeleteTopicSubscriptionsResponseDto$Outbound;
}

export function deleteTopicSubscriptionsResponseDtoToJSON(
  deleteTopicSubscriptionsResponseDto: DeleteTopicSubscriptionsResponseDto
): string {
  return JSON.stringify(DeleteTopicSubscriptionsResponseDto$outboundSchema.parse(deleteTopicSubscriptionsResponseDto));
}

export function deleteTopicSubscriptionsResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<DeleteTopicSubscriptionsResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeleteTopicSubscriptionsResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeleteTopicSubscriptionsResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - deleteTopicSubscriptionsResponseDtoToJSON(deleteTopicSubscriptionsResponseDto: DeleteTopicSubscriptionsResponseDto)
 - deleteTopicSubscriptionsResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DeleteTopicSubscriptionsResponseDto$Outbound;
}

export function deleteTopicSubscriptionsResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function deleteTopicSubscriptionsResponseDtoToJSON
- export function deleteTopicSubscriptionsResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/digestcontroldto.ts
Tamaño: 6052 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  LookBackWindowDto,
  LookBackWindowDto$inboundSchema,
  LookBackWindowDto$Outbound,
  LookBackWindowDto$outboundSchema,
} from './lookbackwindowdto.js';

/**
 * The type of digest strategy. Determines which fields are applicable.
 */
export const DigestControlDtoType = {
  Regular: 'regular',
  Timed: 'timed',
} as const;
/**
 * The type of digest strategy. Determines which fields are applicable.
 */
export type DigestControlDtoType = ClosedEnum<typeof DigestControlDtoType>;

/**
 * The unit of time for the digest interval (for REGULAR type).
 */
export const DigestControlDtoUnit = {
  Seconds: 'seconds',
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
  Weeks: 'weeks',
  Months: 'months',
} as const;
/**
 * The unit of time for the digest interval (for REGULAR type).
 */
export type DigestControlDtoUnit = ClosedEnum<typeof DigestControlDtoUnit>;

export type DigestControlDto = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * The type of digest strategy. Determines which fields are applicable.
   */
  type?: DigestControlDtoType | undefined;
  /**
   * The amount of time for the digest interval (for REGULAR type). Min 1.
   */
  amount?: number | undefined;
  /**
   * The unit of time for the digest interval (for REGULAR type).
   */
  unit?: DigestControlDtoUnit | undefined;
  /**
   * Configuration for look-back window (for REGULAR type).
   */
  lookBackWindow?: LookBackWindowDto | undefined;
  /**
   * Cron expression for TIMED digest. Min length 1.
   */
  cron?: string | undefined;
  /**
   * Specify a custom key for digesting events instead of the default event key.
   */
  digestKey?: string | undefined;
};

/** @internal */
export const DigestControlDtoType$inboundSchema: z.ZodNativeEnum<typeof DigestControlDtoType> =
  z.nativeEnum(DigestControlDtoType);

/** @internal */
export const DigestControlDtoType$outboundSchema: z.ZodNativeEnum<typeof DigestControlDtoType> =
  DigestControlDtoType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestControlDtoType$ {
  /** @deprecated use `DigestControlDtoType$inboundSchema` instead. */
  export const inboundSchema = DigestControlDtoType$inboundSchema;
  /** @deprecated use `DigestControlDtoType$outboundSchema` instead. */
  export const outboundSchema = DigestControlDtoType$outboundSchema;
}

/** @internal */
export const DigestControlDtoUnit$inboundSchema: z.ZodNativeEnum<typeof DigestControlDtoUnit> =
  z.nativeEnum(DigestControlDtoUnit);

/** @internal */
export const DigestControlDtoUnit$outboundSchema: z.ZodNativeEnum<typeof DigestControlDtoUnit> =
  DigestControlDtoUnit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestControlDtoUnit$ {
  /** @deprecated use `DigestControlDtoUnit$inboundSchema` instead. */
  export const inboundSchema = DigestControlDtoUnit$inboundSchema;
  /** @deprecated use `DigestControlDtoUnit$outboundSchema` instead. */
  export const outboundSchema = DigestControlDtoUnit$outboundSchema;
}

/** @internal */
export const DigestControlDto$inboundSchema: z.ZodType<DigestControlDto, z.ZodTypeDef, unknown> = z.object({
  skip: z.record(z.any()).optional(),
  type: DigestControlDtoType$inboundSchema.optional(),
  amount: z.number().optional(),
  unit: DigestControlDtoUnit$inboundSchema.optional(),
  lookBackWindow: LookBackWindowDto$inboundSchema.optional(),
  cron: z.string().optional(),
  digestKey: z.string().optional(),
});

/** @internal */
export type DigestControlDto$Outbound = {
  skip?: { [k: string]: any } | undefined;
  type?: string | undefined;
  amount?: number | undefined;
  unit?: string | undefined;
  lookBackWindow?: LookBackWindowDto$Outbound | undefined;
  cron?: string | undefined;
  digestKey?: string | undefined;
};

/** @internal */
export const DigestControlDto$outboundSchema: z.ZodType<DigestControlDto$Outbound, z.ZodTypeDef, DigestControlDto> =
  z.object({
    skip: z.record(z.any()).optional(),
    type: DigestControlDtoType$outboundSchema.optional(),
    amount: z.number().optional(),
    unit: DigestControlDtoUnit$outboundSchema.optional(),
    lookBackWindow: LookBackWindowDto$outboundSchema.optional(),
    cron: z.string().optional(),
    digestKey: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestControlDto$ {
  /** @deprecated use `DigestControlDto$inboundSchema` instead. */
  export const inboundSchema = DigestControlDto$inboundSchema;
  /** @deprecated use `DigestControlDto$outboundSchema` instead. */
  export const outboundSchema = DigestControlDto$outboundSchema;
  /** @deprecated use `DigestControlDto$Outbound` instead. */
  export type Outbound = DigestControlDto$Outbound;
}

export function digestControlDtoToJSON(digestControlDto: DigestControlDto): string {
  return JSON.stringify(DigestControlDto$outboundSchema.parse(digestControlDto));
}

export function digestControlDtoFromJSON(jsonString: string): SafeParseResult<DigestControlDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DigestControlDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DigestControlDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - digestControlDtoToJSON(digestControlDto: DigestControlDto)
 - digestControlDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DigestControlDto$Outbound;
}

export function digestControlDtoToJSON(digestControlDto: DigestControl...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function digestControlDtoToJSON
- export function digestControlDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/digestcontrolsmetadataresponsedto.ts
Tamaño: 3012 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  DigestControlDto,
  DigestControlDto$inboundSchema,
  DigestControlDto$Outbound,
  DigestControlDto$outboundSchema,
} from './digestcontroldto.js';
import { UiSchema, UiSchema$inboundSchema, UiSchema$Outbound, UiSchema$outboundSchema } from './uischema.js';

export type DigestControlsMetadataResponseDto = {
  /**
   * JSON Schema for data
   */
  dataSchema?: { [k: string]: any } | undefined;
  /**
   * UI Schema for rendering
   */
  uiSchema?: UiSchema | undefined;
  /**
   * Control values specific to Digest
   */
  values: DigestControlDto;
};

/** @internal */
export const DigestControlsMetadataResponseDto$inboundSchema: z.ZodType<
  DigestControlsMetadataResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$inboundSchema.optional(),
  values: DigestControlDto$inboundSchema,
});

/** @internal */
export type DigestControlsMetadataResponseDto$Outbound = {
  dataSchema?: { [k: string]: any } | undefined;
  uiSchema?: UiSchema$Outbound | undefined;
  values: DigestControlDto$Outbound;
};

/** @internal */
export const DigestControlsMetadataResponseDto$outboundSchema: z.ZodType<
  DigestControlsMetadataResponseDto$Outbound,
  z.ZodTypeDef,
  DigestControlsMetadataResponseDto
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$outboundSchema.optional(),
  values: DigestControlDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestControlsMetadataResponseDto$ {
  /** @deprecated use `DigestControlsMetadataResponseDto$inboundSchema` instead. */
  export const inboundSchema = DigestControlsMetadataResponseDto$inboundSchema;
  /** @deprecated use `DigestControlsMetadataResponseDto$outboundSchema` instead. */
  export const outboundSchema = DigestControlsMetadataResponseDto$outboundSchema;
  /** @deprecated use `DigestControlsMetadataResponseDto$Outbound` instead. */
  export type Outbound = DigestControlsMetadataResponseDto$Outbound;
}

export function digestControlsMetadataResponseDtoToJSON(
  digestControlsMetadataResponseDto: DigestControlsMetadataResponseDto
): string {
  return JSON.stringify(DigestControlsMetadataResponseDto$outboundSchema.parse(digestControlsMetadataResponseDto));
}

export function digestControlsMetadataResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<DigestControlsMetadataResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DigestControlsMetadataResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DigestControlsMetadataResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - digestControlsMetadataResponseDtoToJSON(digestControlsMetadataResponseDto: DigestControlsMetadataResponseDto)
 - digestControlsMetadataResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DigestControlsMetadataResponseDto$Outbound;
}

export function digestControlsMetadataResponseDtoToJS...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function digestControlsMetadataResponseDtoToJSON
- export function digestControlsMetadataResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/digestmetadatadto.ts
Tamaño: 5473 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  DigestTimedConfigDto,
  DigestTimedConfigDto$inboundSchema,
  DigestTimedConfigDto$Outbound,
  DigestTimedConfigDto$outboundSchema,
} from './digesttimedconfigdto.js';
import { DigestTypeEnum, DigestTypeEnum$inboundSchema, DigestTypeEnum$outboundSchema } from './digesttypeenum.js';
import { DigestUnitEnum, DigestUnitEnum$inboundSchema, DigestUnitEnum$outboundSchema } from './digestunitenum.js';

/**
 * Unit of the digest
 */
export const DigestMetadataDtoUnit = {
  Seconds: 'seconds',
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
  Weeks: 'weeks',
  Months: 'months',
} as const;
/**
 * Unit of the digest
 */
export type DigestMetadataDtoUnit = ClosedEnum<typeof DigestMetadataDtoUnit>;

export type DigestMetadataDto = {
  /**
   * Optional key for the digest
   */
  digestKey?: string | undefined;
  /**
   * Amount for the digest
   */
  amount?: number | undefined;
  /**
   * Unit of the digest
   */
  unit?: DigestMetadataDtoUnit | undefined;
  /**
   * The Digest Type
   */
  type: DigestTypeEnum;
  /**
   * Optional array of events associated with the digest, represented as key-value pairs
   */
  events?: Array<{ [k: string]: any }> | undefined;
  /**
   * Regular digest: Indicates if backoff is enabled for the regular digest
   */
  backoff?: boolean | undefined;
  /**
   * Regular digest: Amount for backoff
   */
  backoffAmount?: number | undefined;
  /**
   * Regular digest: Unit for backoff
   */
  backoffUnit?: DigestUnitEnum | undefined;
  /**
   * Regular digest: Indicates if the digest should update
   */
  updateMode?: boolean | undefined;
  /**
   * Configuration for timed digest
   */
  timed?: DigestTimedConfigDto | undefined;
};

/** @internal */
export const DigestMetadataDtoUnit$inboundSchema: z.ZodNativeEnum<typeof DigestMetadataDtoUnit> =
  z.nativeEnum(DigestMetadataDtoUnit);

/** @internal */
export const DigestMetadataDtoUnit$outboundSchema: z.ZodNativeEnum<typeof DigestMetadataDtoUnit> =
  DigestMetadataDtoUnit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestMetadataDtoUnit$ {
  /** @deprecated use `DigestMetadataDtoUnit$inboundSchema` instead. */
  export const inboundSchema = DigestMetadataDtoUnit$inboundSchema;
  /** @deprecated use `DigestMetadataDtoUnit$outboundSchema` instead. */
  export const outboundSchema = DigestMetadataDtoUnit$outboundSchema;
}

/** @internal */
export const DigestMetadataDto$inboundSchema: z.ZodType<DigestMetadataDto, z.ZodTypeDef, unknown> = z.object({
  digestKey: z.string().optional(),
  amount: z.number().optional(),
  unit: DigestMetadataDtoUnit$inboundSchema.optional(),
  type: DigestTypeEnum$inboundSchema,
  events: z.array(z.record(z.any())).optional(),
  backoff: z.boolean().optional(),
  backoffAmount: z.number().optional(),
  backoffUnit: DigestUnitEnum$inboundSchema.optional(),
  updateMode: z.boolean().optional(),
  timed: DigestTimedConfigDto$inboundSchema.optional(),
});

/** @internal */
export type DigestMetadataDto$Outbound = {
  digestKey?: string | undefined;
  amount?: number | undefined;
  unit?: string | undefined;
  type: string;
  events?: Array<{ [k: string]: any }> | undefined;
  backoff?: boolean | undefined;
  backoffAmount?: number | undefined;
  backoffUnit?: string | undefined;
  updateMode?: boolean | undefined;
  timed?: DigestTimedConfigDto$Outbound | undefined;
};

/** @internal */
export const DigestMetadataDto$outboundSchema: z.ZodType<DigestMetadataDto$Outbound, z.ZodTypeDef, DigestMetadataDto> =
  z.object({
    digestKey: z.string().optional(),
    amount: z.number().optional(),
    unit: DigestMetadataDtoUnit$outboundSchema.optional(),
    type: DigestTypeEnum$outboundSchema,
    events: z.array(z.record(z.any())).optional(),
    backoff: z.boolean().optional(),
    backoffAmount: z.number().optional(),
    backoffUnit: DigestUnitEnum$outboundSchema.optional(),
    updateMode: z.boolean().optional(),
    timed: DigestTimedConfigDto$outboundSchema.optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestMetadataDto$ {
  /** @deprecated use `DigestMetadataDto$inboundSchema` instead. */
  export const inboundSchema = DigestMetadataDto$inboundSchema;
  /** @deprecated use `DigestMetadataDto$outboundSchema` instead. */
  export const outboundSchema = DigestMetadataDto$outboundSchema;
  /** @deprecated use `DigestMetadataDto$Outbound` instead. */
  export type Outbound = DigestMetadataDto$Outbound;
}

export function digestMetadataDtoToJSON(digestMetadataDto: DigestMetadataDto): string {
  return JSON.stringify(DigestMetadataDto$outboundSchema.parse(digestMetadataDto));
}

export function digestMetadataDtoFromJSON(jsonString: string): SafeParseResult<DigestMetadataDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DigestMetadataDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DigestMetadataDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - digestMetadataDtoToJSON(digestMetadataDto: DigestMetadataDto)
 - digestMetadataDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DigestMetadataDto$Outbound;
}

export function digestMetadataDtoToJSON(digestMetadataDto: DigestMeta...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function digestMetadataDtoToJSON
- export function digestMetadataDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/digestregularmetadata.ts
Tamaño: 6119 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export const DigestRegularMetadataUnit = {
  Seconds: 'seconds',
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
  Weeks: 'weeks',
  Months: 'months',
} as const;
export type DigestRegularMetadataUnit = ClosedEnum<typeof DigestRegularMetadataUnit>;

export const DigestRegularMetadataType = {
  Regular: 'regular',
  Backoff: 'backoff',
} as const;
export type DigestRegularMetadataType = ClosedEnum<typeof DigestRegularMetadataType>;

export const BackoffUnit = {
  Seconds: 'seconds',
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
  Weeks: 'weeks',
  Months: 'months',
} as const;
export type BackoffUnit = ClosedEnum<typeof BackoffUnit>;

export type DigestRegularMetadata = {
  amount?: number | undefined;
  unit?: DigestRegularMetadataUnit | undefined;
  digestKey?: string | undefined;
  type: DigestRegularMetadataType;
  backoff?: boolean | undefined;
  backoffAmount?: number | undefined;
  backoffUnit?: BackoffUnit | undefined;
  updateMode?: boolean | undefined;
};

/** @internal */
export const DigestRegularMetadataUnit$inboundSchema: z.ZodNativeEnum<typeof DigestRegularMetadataUnit> =
  z.nativeEnum(DigestRegularMetadataUnit);

/** @internal */
export const DigestRegularMetadataUnit$outboundSchema: z.ZodNativeEnum<typeof DigestRegularMetadataUnit> =
  DigestRegularMetadataUnit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestRegularMetadataUnit$ {
  /** @deprecated use `DigestRegularMetadataUnit$inboundSchema` instead. */
  export const inboundSchema = DigestRegularMetadataUnit$inboundSchema;
  /** @deprecated use `DigestRegularMetadataUnit$outboundSchema` instead. */
  export const outboundSchema = DigestRegularMetadataUnit$outboundSchema;
}

/** @internal */
export const DigestRegularMetadataType$inboundSchema: z.ZodNativeEnum<typeof DigestRegularMetadataType> =
  z.nativeEnum(DigestRegularMetadataType);

/** @internal */
export const DigestRegularMetadataType$outboundSchema: z.ZodNativeEnum<typeof DigestRegularMetadataType> =
  DigestRegularMetadataType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestRegularMetadataType$ {
  /** @deprecated use `DigestRegularMetadataType$inboundSchema` instead. */
  export const inboundSchema = DigestRegularMetadataType$inboundSchema;
  /** @deprecated use `DigestRegularMetadataType$outboundSchema` instead. */
  export const outboundSchema = DigestRegularMetadataType$outboundSchema;
}

/** @internal */
export const BackoffUnit$inboundSchema: z.ZodNativeEnum<typeof BackoffUnit> = z.nativeEnum(BackoffUnit);

/** @internal */
export const BackoffUnit$outboundSchema: z.ZodNativeEnum<typeof BackoffUnit> = BackoffUnit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackoffUnit$ {
  /** @deprecated use `BackoffUnit$inboundSchema` instead. */
  export const inboundSchema = BackoffUnit$inboundSchema;
  /** @deprecated use `BackoffUnit$outboundSchema` instead. */
  export const outboundSchema = BackoffUnit$outboundSchema;
}

/** @internal */
export const DigestRegularMetadata$inboundSchema: z.ZodType<DigestRegularMetadata, z.ZodTypeDef, unknown> = z.object({
  amount: z.number().optional(),
  unit: DigestRegularMetadataUnit$inboundSchema.optional(),
  digestKey: z.string().optional(),
  type: DigestRegularMetadataType$inboundSchema,
  backoff: z.boolean().optional(),
  backoffAmount: z.number().optional(),
  backoffUnit: BackoffUnit$inboundSchema.optional(),
  updateMode: z.boolean().optional(),
});

/** @internal */
export type DigestRegularMetadata$Outbound = {
  amount?: number | undefined;
  unit?: string | undefined;
  digestKey?: string | undefined;
  type: string;
  backoff?: boolean | undefined;
  backoffAmount?: number | undefined;
  backoffUnit?: string | undefined;
  updateMode?: boolean | undefined;
};

/** @internal */
export const DigestRegularMetadata$outboundSchema: z.ZodType<
  DigestRegularMetadata$Outbound,
  z.ZodTypeDef,
  DigestRegularMetadata
> = z.object({
  amount: z.number().optional(),
  unit: DigestRegularMetadataUnit$outboundSchema.optional(),
  digestKey: z.string().optional(),
  type: DigestRegularMetadataType$outboundSchema,
  backoff: z.boolean().optional(),
  backoffAmount: z.number().optional(),
  backoffUnit: BackoffUnit$outboundSchema.optional(),
  updateMode: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestRegularMetadata$ {
  /** @deprecated use `DigestRegularMetadata$inboundSchema` instead. */
  export const inboundSchema = DigestRegularMetadata$inboundSchema;
  /** @deprecated use `DigestRegularMetadata$outboundSchema` instead. */
  export const outboundSchema = DigestRegularMetadata$outboundSchema;
  /** @deprecated use `DigestRegularMetadata$Outbound` instead. */
  export type Outbound = DigestRegularMetadata$Outbound;
}

export function digestRegularMetadataToJSON(digestRegularMetadata: DigestRegularMetadata): string {
  return JSON.stringify(DigestRegularMetadata$outboundSchema.parse(digestRegularMetadata));
}

export function digestRegularMetadataFromJSON(
  jsonString: string
): SafeParseResult<DigestRegularMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DigestRegularMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DigestRegularMetadata' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - digestRegularMetadataToJSON(digestRegularMetadata: DigestRegularMetadata)
 - digestRegularMetadataFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DigestRegularMetadata$Outbound;
}

export function digestRegularMetadataToJSON(digestRegularMetadata...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function digestRegularMetadataToJSON
- export function digestRegularMetadataFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/digestregularoutput.ts
Tamaño: 4002 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { TimeUnitEnum, TimeUnitEnum$inboundSchema, TimeUnitEnum$outboundSchema } from './timeunitenum.js';

/**
 * Look back window configuration
 */
export type LookBackWindow = {};

export type DigestRegularOutput = {
  /**
   * Amount of time units
   */
  amount: number;
  /**
   * Time unit
   */
  unit: TimeUnitEnum;
  /**
   * Optional digest key
   */
  digestKey?: string | undefined;
  /**
   * Look back window configuration
   */
  lookBackWindow?: LookBackWindow | undefined;
};

/** @internal */
export const LookBackWindow$inboundSchema: z.ZodType<LookBackWindow, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type LookBackWindow$Outbound = {};

/** @internal */
export const LookBackWindow$outboundSchema: z.ZodType<LookBackWindow$Outbound, z.ZodTypeDef, LookBackWindow> = z.object(
  {}
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LookBackWindow$ {
  /** @deprecated use `LookBackWindow$inboundSchema` instead. */
  export const inboundSchema = LookBackWindow$inboundSchema;
  /** @deprecated use `LookBackWindow$outboundSchema` instead. */
  export const outboundSchema = LookBackWindow$outboundSchema;
  /** @deprecated use `LookBackWindow$Outbound` instead. */
  export type Outbound = LookBackWindow$Outbound;
}

export function lookBackWindowToJSON(lookBackWindow: LookBackWindow): string {
  return JSON.stringify(LookBackWindow$outboundSchema.parse(lookBackWindow));
}

export function lookBackWindowFromJSON(jsonString: string): SafeParseResult<LookBackWindow, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LookBackWindow$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LookBackWindow' from JSON`
  );
}

/** @internal */
export const DigestRegularOutput$inboundSchema: z.ZodType<DigestRegularOutput, z.ZodTypeDef, unknown> = z.object({
  amount: z.number(),
  unit: TimeUnitEnum$inboundSchema,
  digestKey: z.string().optional(),
  lookBackWindow: z.lazy(() => LookBackWindow$inboundSchema).optional(),
});

/** @internal */
export type DigestRegularOutput$Outbound = {
  amount: number;
  unit: string;
  digestKey?: string | undefined;
  lookBackWindow?: LookBackWindow$Outbound | undefined;
};

/** @internal */
export const DigestRegularOutput$outboundSchema: z.ZodType<
  DigestRegularOutput$Outbound,
  z.ZodTypeDef,
  DigestRegularOutput
> = z.object({
  amount: z.number(),
  unit: TimeUnitEnum$outboundSchema,
  digestKey: z.string().optional(),
  lookBackWindow: z.lazy(() => LookBackWindow$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestRegularOutput$ {
  /** @deprecated use `DigestRegularOutput$inboundSchema` instead. */
  export const inboundSchema = DigestRegularOutput$inboundSchema;
  /** @deprecated use `DigestRegularOutput$outboundSchema` instead. */
  export const outboundSchema = DigestRegularOutput$outboundSchema;
  /** @deprecated use `DigestRegularOutput$Outbound` instead. */
  export type Outbound = DigestRegularOutput$Outbound;
}

export function digestRegularOutputToJSON(digestRegularOutput: DigestRegularOutput): string {
  return JSON.stringify(DigestRegularOutput$outboundSchema.parse(digestRegularOutput));
}

export function digestRegularOutputFromJSON(
  jsonString: string
): SafeParseResult<DigestRegularOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DigestRegularOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DigestRegularOutput' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - lookBackWindowToJSON(lookBackWindow: LookBackWindow)
 - lookBackWindowFromJSON(jsonString: string)
 - digestRegularOutputToJSON(digestRegularOutput: DigestRegularOutput)
 - digestRegularOutputFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LookBackWindow$Outbound;
}

export function lookBackWindowToJSON(lookBackWindow: LookBackWindow): st...)
 - Outbound(DigestRegularOutput$Outbound;
}

export function digestRegularOutputToJSON(digestRegularOutput: Dige...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function lookBackWindowToJSON
- export function lookBackWindowFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function digestRegularOutputToJSON
- export function digestRegularOutputFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/digeststepresponsedto.ts
Tamaño: 11780 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { collectExtraKeys as collectExtraKeys$, safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  DigestControlsMetadataResponseDto,
  DigestControlsMetadataResponseDto$inboundSchema,
  DigestControlsMetadataResponseDto$Outbound,
  DigestControlsMetadataResponseDto$outboundSchema,
} from './digestcontrolsmetadataresponsedto.js';
import {
  LookBackWindowDto,
  LookBackWindowDto$inboundSchema,
  LookBackWindowDto$Outbound,
  LookBackWindowDto$outboundSchema,
} from './lookbackwindowdto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  StepIssuesDto,
  StepIssuesDto$inboundSchema,
  StepIssuesDto$Outbound,
  StepIssuesDto$outboundSchema,
} from './stepissuesdto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * The type of digest strategy. Determines which fields are applicable.
 */
export const DigestStepResponseDtoType = {
  Regular: 'regular',
  Timed: 'timed',
} as const;
/**
 * The type of digest strategy. Determines which fields are applicable.
 */
export type DigestStepResponseDtoType = ClosedEnum<typeof DigestStepResponseDtoType>;

/**
 * The unit of time for the digest interval (for REGULAR type).
 */
export const DigestStepResponseDtoUnit = {
  Seconds: 'seconds',
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
  Weeks: 'weeks',
  Months: 'months',
} as const;
/**
 * The unit of time for the digest interval (for REGULAR type).
 */
export type DigestStepResponseDtoUnit = ClosedEnum<typeof DigestStepResponseDtoUnit>;

/**
 * Control values for the digest step
 */
export type DigestStepResponseDtoControlValues = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * The type of digest strategy. Determines which fields are applicable.
   */
  type?: DigestStepResponseDtoType | undefined;
  /**
   * The amount of time for the digest interval (for REGULAR type). Min 1.
   */
  amount?: number | undefined;
  /**
   * The unit of time for the digest interval (for REGULAR type).
   */
  unit?: DigestStepResponseDtoUnit | undefined;
  /**
   * Configuration for look-back window (for REGULAR type).
   */
  lookBackWindow?: LookBackWindowDto | undefined;
  /**
   * Cron expression for TIMED digest. Min length 1.
   */
  cron?: string | undefined;
  /**
   * Specify a custom key for digesting events instead of the default event key.
   */
  digestKey?: string | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type DigestStepResponseDto = {
  /**
   * Controls metadata for the digest step
   */
  controls: DigestControlsMetadataResponseDto;
  /**
   * Control values for the digest step
   */
  controlValues?: DigestStepResponseDtoControlValues | undefined;
  /**
   * JSON Schema for variables, follows the JSON Schema standard
   */
  variables: { [k: string]: any };
  /**
   * Unique identifier of the step
   */
  stepId: string;
  /**
   * Database identifier of the step
   */
  id: string;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Slug of the step
   */
  slug: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow database identifier
   */
  workflowDatabaseId: string;
  /**
   * Issues associated with the step
   */
  issues?: StepIssuesDto | undefined;
};

/** @internal */
export const DigestStepResponseDtoType$inboundSchema: z.ZodNativeEnum<typeof DigestStepResponseDtoType> =
  z.nativeEnum(DigestStepResponseDtoType);

/** @internal */
export const DigestStepResponseDtoType$outboundSchema: z.ZodNativeEnum<typeof DigestStepResponseDtoType> =
  DigestStepResponseDtoType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestStepResponseDtoType$ {
  /** @deprecated use `DigestStepResponseDtoType$inboundSchema` instead. */
  export const inboundSchema = DigestStepResponseDtoType$inboundSchema;
  /** @deprecated use `DigestStepResponseDtoType$outboundSchema` instead. */
  export const outboundSchema = DigestStepResponseDtoType$outboundSchema;
}

/** @internal */
export const DigestStepResponseDtoUnit$inboundSchema: z.ZodNativeEnum<typeof DigestStepResponseDtoUnit> =
  z.nativeEnum(DigestStepResponseDtoUnit);

/** @internal */
export const DigestStepResponseDtoUnit$outboundSchema: z.ZodNativeEnum<typeof DigestStepResponseDtoUnit> =
  DigestStepResponseDtoUnit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestStepResponseDtoUnit$ {
  /** @deprecated use `DigestStepResponseDtoUnit$inboundSchema` instead. */
  export const inboundSchema = DigestStepResponseDtoUnit$inboundSchema;
  /** @deprecated use `DigestStepResponseDtoUnit$outboundSchema` instead. */
  export const outboundSchema = DigestStepResponseDtoUnit$outboundSchema;
}

/** @internal */
export const DigestStepResponseDtoControlValues$inboundSchema: z.ZodType<
  DigestStepResponseDtoControlValues,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z
    .object({
      skip: z.record(z.any()).optional(),
      type: DigestStepResponseDtoType$inboundSchema.optional(),
      amount: z.number().optional(),
      unit: DigestStepResponseDtoUnit$inboundSchema.optional(),
      lookBackWindow: LookBackWindowDto$inboundSchema.optional(),
      cron: z.string().optional(),
      digestKey: z.string().optional(),
    })
    .catchall(z.any()),
  'additionalProperties',
  true
);

/** @internal */
export type DigestStepResponseDtoControlValues$Outbound = {
  skip?: { [k: string]: any } | undefined;
  type?: string | undefined;
  amount?: number | undefined;
  unit?: string | undefined;
  lookBackWindow?: LookBackWindowDto$Outbound | undefined;
  cron?: string | undefined;
  digestKey?: string | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const DigestStepResponseDtoControlValues$outboundSchema: z.ZodType<
  DigestStepResponseDtoControlValues$Outbound,
  z.ZodTypeDef,
  DigestStepResponseDtoControlValues
> = z
  .object({
    skip: z.record(z.any()).optional(),
    type: DigestStepResponseDtoType$outboundSchema.optional(),
    amount: z.number().optional(),
    unit: DigestStepResponseDtoUnit$outboundSchema.optional(),
    lookBackWindow: LookBackWindowDto$outboundSchema.optional(),
    cron: z.string().optional(),
    digestKey: z.string().optional(),
    additionalProperties: z.record(z.any()).optional(),
  })
  .transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestStepResponseDtoControlValues$ {
  /** @deprecated use `DigestStepResponseDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = DigestStepResponseDtoControlValues$inboundSchema;
  /** @deprecated use `DigestStepResponseDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = DigestStepResponseDtoControlValues$outboundSchema;
  /** @deprecated use `DigestStepResponseDtoControlValues$Outbound` instead. */
  export type Outbound = DigestStepResponseDtoControlValues$Outbound;
}

export function digestStepResponseDtoControlValuesToJSON(
  digestStepResponseDtoControlValues: DigestStepResponseDtoControlValues
): string {
  return JSON.stringify(DigestStepResponseDtoControlValues$outboundSchema.parse(digestStepResponseDtoControlValues));
}

export function digestStepResponseDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<DigestStepResponseDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DigestStepResponseDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DigestStepResponseDtoControlValues' from JSON`
  );
}

/** @internal */
export const DigestStepResponseDto$inboundSchema: z.ZodType<DigestStepResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    controls: DigestControlsMetadataResponseDto$inboundSchema,
    controlValues: z.lazy(() => DigestStepResponseDtoControlValues$inboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    _id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$inboundSchema,
    origin: ResourceOriginEnum$inboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type DigestStepResponseDto$Outbound = {
  controls: DigestControlsMetadataResponseDto$Outbound;
  controlValues?: DigestStepResponseDtoControlValues$Outbound | undefined;
  variables: { [k: string]: any };
  stepId: string;
  _id: string;
  name: string;
  slug: string;
  type: string;
  origin: string;
  workflowId: string;
  workflowDatabaseId: string;
  issues?: StepIssuesDto$Outbound | undefined;
};

/** @internal */
export const DigestStepResponseDto$outboundSchema: z.ZodType<
  DigestStepResponseDto$Outbound,
  z.ZodTypeDef,
  DigestStepResponseDto
> = z
  .object({
    controls: DigestControlsMetadataResponseDto$outboundSchema,
    controlValues: z.lazy(() => DigestStepResponseDtoControlValues$outboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$outboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestStepResponseDto$ {
  /** @deprecated use `DigestStepResponseDto$inboundSchema` instead. */
  export const inboundSchema = DigestStepResponseDto$inboundSchema;
  /** @deprecated use `DigestStepResponseDto$outboundSchema` instead. */
  export const outboundSchema = DigestStepResponseDto$outboundSchema;
  /** @deprecated use `DigestStepResponseDto$Outbound` instead. */
  export type Outbound = DigestStepResponseDto$Outbound;
}

export function digestStepResponseDtoToJSON(digestStepResponseDto: DigestStepResponseDto): string {
  return JSON.stringify(DigestStepResponseDto$outboundSchema.parse(digestStepResponseDto));
}

export function digestStepResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<DigestStepResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DigestStepResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DigestStepResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - digestStepResponseDtoControlValuesToJSON(digestStepResponseDtoControlValues: DigestStepResponseDtoControlValues)
 - digestStepResponseDtoControlValuesFromJSON(jsonString: string)
 - digestStepResponseDtoToJSON(digestStepResponseDto: DigestStepResponseDto)
 - digestStepResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DigestStepResponseDtoControlValues$Outbound;
}

export function digestStepResponseDtoControlValuesTo...)
 - Outbound(DigestStepResponseDto$Outbound;
}

export function digestStepResponseDtoToJSON(digestStepResponseDto...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function digestStepResponseDtoControlValuesToJSON
- export function digestStepResponseDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function digestStepResponseDtoToJSON
- export function digestStepResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/digeststepupsertdto.ts
Tamaño: 5309 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  DigestControlDto,
  DigestControlDto$inboundSchema,
  DigestControlDto$Outbound,
  DigestControlDto$outboundSchema,
} from './digestcontroldto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the Digest step.
 */
export type DigestStepUpsertDtoControlValues =
  | DigestControlDto
  | {
      [k: string]: any;
    };

export type DigestStepUpsertDto = {
  /**
   * Database identifier of the step. Used for updating the step.
   */
  id?: string | undefined;
  /**
   * Unique identifier for the step
   */
  stepId?: string | undefined;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Control values for the Digest step.
   */
  controlValues?: DigestControlDto | { [k: string]: any } | undefined;
};

/** @internal */
export const DigestStepUpsertDtoControlValues$inboundSchema: z.ZodType<
  DigestStepUpsertDtoControlValues,
  z.ZodTypeDef,
  unknown
> = z.union([DigestControlDto$inboundSchema, z.record(z.any())]);

/** @internal */
export type DigestStepUpsertDtoControlValues$Outbound = DigestControlDto$Outbound | { [k: string]: any };

/** @internal */
export const DigestStepUpsertDtoControlValues$outboundSchema: z.ZodType<
  DigestStepUpsertDtoControlValues$Outbound,
  z.ZodTypeDef,
  DigestStepUpsertDtoControlValues
> = z.union([DigestControlDto$outboundSchema, z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestStepUpsertDtoControlValues$ {
  /** @deprecated use `DigestStepUpsertDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = DigestStepUpsertDtoControlValues$inboundSchema;
  /** @deprecated use `DigestStepUpsertDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = DigestStepUpsertDtoControlValues$outboundSchema;
  /** @deprecated use `DigestStepUpsertDtoControlValues$Outbound` instead. */
  export type Outbound = DigestStepUpsertDtoControlValues$Outbound;
}

export function digestStepUpsertDtoControlValuesToJSON(
  digestStepUpsertDtoControlValues: DigestStepUpsertDtoControlValues
): string {
  return JSON.stringify(DigestStepUpsertDtoControlValues$outboundSchema.parse(digestStepUpsertDtoControlValues));
}

export function digestStepUpsertDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<DigestStepUpsertDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DigestStepUpsertDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DigestStepUpsertDtoControlValues' from JSON`
  );
}

/** @internal */
export const DigestStepUpsertDto$inboundSchema: z.ZodType<DigestStepUpsertDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$inboundSchema,
    controlValues: z.union([DigestControlDto$inboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type DigestStepUpsertDto$Outbound = {
  _id?: string | undefined;
  stepId?: string | undefined;
  name: string;
  type: string;
  controlValues?: DigestControlDto$Outbound | { [k: string]: any } | undefined;
};

/** @internal */
export const DigestStepUpsertDto$outboundSchema: z.ZodType<
  DigestStepUpsertDto$Outbound,
  z.ZodTypeDef,
  DigestStepUpsertDto
> = z
  .object({
    id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$outboundSchema,
    controlValues: z.union([DigestControlDto$outboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestStepUpsertDto$ {
  /** @deprecated use `DigestStepUpsertDto$inboundSchema` instead. */
  export const inboundSchema = DigestStepUpsertDto$inboundSchema;
  /** @deprecated use `DigestStepUpsertDto$outboundSchema` instead. */
  export const outboundSchema = DigestStepUpsertDto$outboundSchema;
  /** @deprecated use `DigestStepUpsertDto$Outbound` instead. */
  export type Outbound = DigestStepUpsertDto$Outbound;
}

export function digestStepUpsertDtoToJSON(digestStepUpsertDto: DigestStepUpsertDto): string {
  return JSON.stringify(DigestStepUpsertDto$outboundSchema.parse(digestStepUpsertDto));
}

export function digestStepUpsertDtoFromJSON(
  jsonString: string
): SafeParseResult<DigestStepUpsertDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DigestStepUpsertDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DigestStepUpsertDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - digestStepUpsertDtoControlValuesToJSON(digestStepUpsertDtoControlValues: DigestStepUpsertDtoControlValues)
 - digestStepUpsertDtoControlValuesFromJSON(jsonString: string)
 - digestStepUpsertDtoToJSON(digestStepUpsertDto: DigestStepUpsertDto)
 - digestStepUpsertDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DigestStepUpsertDtoControlValues$Outbound;
}

export function digestStepUpsertDtoControlValuesToJSON...)
 - Outbound(DigestStepUpsertDto$Outbound;
}

export function digestStepUpsertDtoToJSON(digestStepUpsertDto: Dige...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function digestStepUpsertDtoControlValuesToJSON
- export function digestStepUpsertDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function digestStepUpsertDtoToJSON
- export function digestStepUpsertDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/digesttimedconfigdto.ts
Tamaño: 4833 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { MonthlyTypeEnum, MonthlyTypeEnum$inboundSchema, MonthlyTypeEnum$outboundSchema } from './monthlytypeenum.js';
import { OrdinalEnum, OrdinalEnum$inboundSchema, OrdinalEnum$outboundSchema } from './ordinalenum.js';
import {
  OrdinalValueEnum,
  OrdinalValueEnum$inboundSchema,
  OrdinalValueEnum$outboundSchema,
} from './ordinalvalueenum.js';

export const WeekDays = {
  Monday: 'monday',
  Tuesday: 'tuesday',
  Wednesday: 'wednesday',
  Thursday: 'thursday',
  Friday: 'friday',
  Saturday: 'saturday',
  Sunday: 'sunday',
} as const;
export type WeekDays = ClosedEnum<typeof WeekDays>;

export type DigestTimedConfigDto = {
  /**
   * Time at which the digest is triggered
   */
  atTime?: string | undefined;
  /**
   * Days of the week for the digest
   */
  weekDays?: Array<WeekDays> | undefined;
  /**
   * Specific days of the month for the digest
   */
  monthDays?: Array<number> | undefined;
  /**
   * Ordinal position for the digest
   */
  ordinal?: OrdinalEnum | undefined;
  /**
   * Value of the ordinal
   */
  ordinalValue?: OrdinalValueEnum | undefined;
  /**
   * Type of monthly schedule
   */
  monthlyType?: MonthlyTypeEnum | undefined;
  /**
   * Cron expression for scheduling
   */
  cronExpression?: string | undefined;
  /**
   * Until date for scheduling
   */
  untilDate?: string | undefined;
};

/** @internal */
export const WeekDays$inboundSchema: z.ZodNativeEnum<typeof WeekDays> = z.nativeEnum(WeekDays);

/** @internal */
export const WeekDays$outboundSchema: z.ZodNativeEnum<typeof WeekDays> = WeekDays$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WeekDays$ {
  /** @deprecated use `WeekDays$inboundSchema` instead. */
  export const inboundSchema = WeekDays$inboundSchema;
  /** @deprecated use `WeekDays$outboundSchema` instead. */
  export const outboundSchema = WeekDays$outboundSchema;
}

/** @internal */
export const DigestTimedConfigDto$inboundSchema: z.ZodType<DigestTimedConfigDto, z.ZodTypeDef, unknown> = z.object({
  atTime: z.string().optional(),
  weekDays: z.array(WeekDays$inboundSchema).optional(),
  monthDays: z.array(z.number()).optional(),
  ordinal: OrdinalEnum$inboundSchema.optional(),
  ordinalValue: OrdinalValueEnum$inboundSchema.optional(),
  monthlyType: MonthlyTypeEnum$inboundSchema.optional(),
  cronExpression: z.string().optional(),
  untilDate: z.string().optional(),
});

/** @internal */
export type DigestTimedConfigDto$Outbound = {
  atTime?: string | undefined;
  weekDays?: Array<string> | undefined;
  monthDays?: Array<number> | undefined;
  ordinal?: string | undefined;
  ordinalValue?: string | undefined;
  monthlyType?: string | undefined;
  cronExpression?: string | undefined;
  untilDate?: string | undefined;
};

/** @internal */
export const DigestTimedConfigDto$outboundSchema: z.ZodType<
  DigestTimedConfigDto$Outbound,
  z.ZodTypeDef,
  DigestTimedConfigDto
> = z.object({
  atTime: z.string().optional(),
  weekDays: z.array(WeekDays$outboundSchema).optional(),
  monthDays: z.array(z.number()).optional(),
  ordinal: OrdinalEnum$outboundSchema.optional(),
  ordinalValue: OrdinalValueEnum$outboundSchema.optional(),
  monthlyType: MonthlyTypeEnum$outboundSchema.optional(),
  cronExpression: z.string().optional(),
  untilDate: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestTimedConfigDto$ {
  /** @deprecated use `DigestTimedConfigDto$inboundSchema` instead. */
  export const inboundSchema = DigestTimedConfigDto$inboundSchema;
  /** @deprecated use `DigestTimedConfigDto$outboundSchema` instead. */
  export const outboundSchema = DigestTimedConfigDto$outboundSchema;
  /** @deprecated use `DigestTimedConfigDto$Outbound` instead. */
  export type Outbound = DigestTimedConfigDto$Outbound;
}

export function digestTimedConfigDtoToJSON(digestTimedConfigDto: DigestTimedConfigDto): string {
  return JSON.stringify(DigestTimedConfigDto$outboundSchema.parse(digestTimedConfigDto));
}

export function digestTimedConfigDtoFromJSON(
  jsonString: string
): SafeParseResult<DigestTimedConfigDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DigestTimedConfigDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DigestTimedConfigDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - digestTimedConfigDtoToJSON(digestTimedConfigDto: DigestTimedConfigDto)
 - digestTimedConfigDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DigestTimedConfigDto$Outbound;
}

export function digestTimedConfigDtoToJSON(digestTimedConfigDto: D...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function digestTimedConfigDtoToJSON
- export function digestTimedConfigDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/digesttimedmetadata.ts
Tamaño: 4768 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  TimedConfig,
  TimedConfig$inboundSchema,
  TimedConfig$Outbound,
  TimedConfig$outboundSchema,
} from './timedconfig.js';

export const DigestTimedMetadataUnit = {
  Seconds: 'seconds',
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
  Weeks: 'weeks',
  Months: 'months',
} as const;
export type DigestTimedMetadataUnit = ClosedEnum<typeof DigestTimedMetadataUnit>;

export const DigestTimedMetadataType = {
  Timed: 'timed',
} as const;
export type DigestTimedMetadataType = ClosedEnum<typeof DigestTimedMetadataType>;

export type DigestTimedMetadata = {
  amount?: number | undefined;
  unit?: DigestTimedMetadataUnit | undefined;
  digestKey?: string | undefined;
  type: DigestTimedMetadataType;
  timed?: TimedConfig | undefined;
};

/** @internal */
export const DigestTimedMetadataUnit$inboundSchema: z.ZodNativeEnum<typeof DigestTimedMetadataUnit> =
  z.nativeEnum(DigestTimedMetadataUnit);

/** @internal */
export const DigestTimedMetadataUnit$outboundSchema: z.ZodNativeEnum<typeof DigestTimedMetadataUnit> =
  DigestTimedMetadataUnit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestTimedMetadataUnit$ {
  /** @deprecated use `DigestTimedMetadataUnit$inboundSchema` instead. */
  export const inboundSchema = DigestTimedMetadataUnit$inboundSchema;
  /** @deprecated use `DigestTimedMetadataUnit$outboundSchema` instead. */
  export const outboundSchema = DigestTimedMetadataUnit$outboundSchema;
}

/** @internal */
export const DigestTimedMetadataType$inboundSchema: z.ZodNativeEnum<typeof DigestTimedMetadataType> =
  z.nativeEnum(DigestTimedMetadataType);

/** @internal */
export const DigestTimedMetadataType$outboundSchema: z.ZodNativeEnum<typeof DigestTimedMetadataType> =
  DigestTimedMetadataType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestTimedMetadataType$ {
  /** @deprecated use `DigestTimedMetadataType$inboundSchema` instead. */
  export const inboundSchema = DigestTimedMetadataType$inboundSchema;
  /** @deprecated use `DigestTimedMetadataType$outboundSchema` instead. */
  export const outboundSchema = DigestTimedMetadataType$outboundSchema;
}

/** @internal */
export const DigestTimedMetadata$inboundSchema: z.ZodType<DigestTimedMetadata, z.ZodTypeDef, unknown> = z.object({
  amount: z.number().optional(),
  unit: DigestTimedMetadataUnit$inboundSchema.optional(),
  digestKey: z.string().optional(),
  type: DigestTimedMetadataType$inboundSchema,
  timed: TimedConfig$inboundSchema.optional(),
});

/** @internal */
export type DigestTimedMetadata$Outbound = {
  amount?: number | undefined;
  unit?: string | undefined;
  digestKey?: string | undefined;
  type: string;
  timed?: TimedConfig$Outbound | undefined;
};

/** @internal */
export const DigestTimedMetadata$outboundSchema: z.ZodType<
  DigestTimedMetadata$Outbound,
  z.ZodTypeDef,
  DigestTimedMetadata
> = z.object({
  amount: z.number().optional(),
  unit: DigestTimedMetadataUnit$outboundSchema.optional(),
  digestKey: z.string().optional(),
  type: DigestTimedMetadataType$outboundSchema,
  timed: TimedConfig$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestTimedMetadata$ {
  /** @deprecated use `DigestTimedMetadata$inboundSchema` instead. */
  export const inboundSchema = DigestTimedMetadata$inboundSchema;
  /** @deprecated use `DigestTimedMetadata$outboundSchema` instead. */
  export const outboundSchema = DigestTimedMetadata$outboundSchema;
  /** @deprecated use `DigestTimedMetadata$Outbound` instead. */
  export type Outbound = DigestTimedMetadata$Outbound;
}

export function digestTimedMetadataToJSON(digestTimedMetadata: DigestTimedMetadata): string {
  return JSON.stringify(DigestTimedMetadata$outboundSchema.parse(digestTimedMetadata));
}

export function digestTimedMetadataFromJSON(
  jsonString: string
): SafeParseResult<DigestTimedMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DigestTimedMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DigestTimedMetadata' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - digestTimedMetadataToJSON(digestTimedMetadata: DigestTimedMetadata)
 - digestTimedMetadataFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DigestTimedMetadata$Outbound;
}

export function digestTimedMetadataToJSON(digestTimedMetadata: Dige...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function digestTimedMetadataToJSON
- export function digestTimedMetadataFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/digesttypeenum.ts
Tamaño: 1094 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * The Digest Type
 */
export const DigestTypeEnum = {
  Regular: 'regular',
  Backoff: 'backoff',
  Timed: 'timed',
} as const;
/**
 * The Digest Type
 */
export type DigestTypeEnum = ClosedEnum<typeof DigestTypeEnum>;

/** @internal */
export const DigestTypeEnum$inboundSchema: z.ZodNativeEnum<typeof DigestTypeEnum> = z.nativeEnum(DigestTypeEnum);

/** @internal */
export const DigestTypeEnum$outboundSchema: z.ZodNativeEnum<typeof DigestTypeEnum> = DigestTypeEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestTypeEnum$ {
  /** @deprecated use `DigestTypeEnum$inboundSchema` instead. */
  export const inboundSchema = DigestTypeEnum$inboundSchema;
  /** @deprecated use `DigestTypeEnum$outboundSchema` instead. */
  export const outboundSchema = DigestTypeEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/digestunitenum.ts
Tamaño: 1182 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Regular digest: Unit for backoff
 */
export const DigestUnitEnum = {
  Seconds: 'seconds',
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
  Weeks: 'weeks',
  Months: 'months',
} as const;
/**
 * Regular digest: Unit for backoff
 */
export type DigestUnitEnum = ClosedEnum<typeof DigestUnitEnum>;

/** @internal */
export const DigestUnitEnum$inboundSchema: z.ZodNativeEnum<typeof DigestUnitEnum> = z.nativeEnum(DigestUnitEnum);

/** @internal */
export const DigestUnitEnum$outboundSchema: z.ZodNativeEnum<typeof DigestUnitEnum> = DigestUnitEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DigestUnitEnum$ {
  /** @deprecated use `DigestUnitEnum$inboundSchema` instead. */
  export const inboundSchema = DigestUnitEnum$inboundSchema;
  /** @deprecated use `DigestUnitEnum$outboundSchema` instead. */
  export const outboundSchema = DigestUnitEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/directionenum.ts
Tamaño: 994 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

export const DirectionEnum = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;
export type DirectionEnum = ClosedEnum<typeof DirectionEnum>;

/** @internal */
export const DirectionEnum$inboundSchema: z.ZodNativeEnum<typeof DirectionEnum> = z.nativeEnum(DirectionEnum);

/** @internal */
export const DirectionEnum$outboundSchema: z.ZodNativeEnum<typeof DirectionEnum> = DirectionEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DirectionEnum$ {
  /** @deprecated use `DirectionEnum$inboundSchema` instead. */
  export const inboundSchema = DirectionEnum$inboundSchema;
  /** @deprecated use `DirectionEnum$outboundSchema` instead. */
  export const outboundSchema = DirectionEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/duplicatelayoutdto.ts
Tamaño: 2101 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type DuplicateLayoutDto = {
  /**
   * Name of the layout
   */
  name: string;
  /**
   * Enable or disable translations for this layout
   */
  isTranslationEnabled?: boolean | undefined;
};

/** @internal */
export const DuplicateLayoutDto$inboundSchema: z.ZodType<DuplicateLayoutDto, z.ZodTypeDef, unknown> = z.object({
  name: z.string(),
  isTranslationEnabled: z.boolean().default(false),
});

/** @internal */
export type DuplicateLayoutDto$Outbound = {
  name: string;
  isTranslationEnabled: boolean;
};

/** @internal */
export const DuplicateLayoutDto$outboundSchema: z.ZodType<
  DuplicateLayoutDto$Outbound,
  z.ZodTypeDef,
  DuplicateLayoutDto
> = z.object({
  name: z.string(),
  isTranslationEnabled: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateLayoutDto$ {
  /** @deprecated use `DuplicateLayoutDto$inboundSchema` instead. */
  export const inboundSchema = DuplicateLayoutDto$inboundSchema;
  /** @deprecated use `DuplicateLayoutDto$outboundSchema` instead. */
  export const outboundSchema = DuplicateLayoutDto$outboundSchema;
  /** @deprecated use `DuplicateLayoutDto$Outbound` instead. */
  export type Outbound = DuplicateLayoutDto$Outbound;
}

export function duplicateLayoutDtoToJSON(duplicateLayoutDto: DuplicateLayoutDto): string {
  return JSON.stringify(DuplicateLayoutDto$outboundSchema.parse(duplicateLayoutDto));
}

export function duplicateLayoutDtoFromJSON(
  jsonString: string
): SafeParseResult<DuplicateLayoutDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateLayoutDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateLayoutDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - duplicateLayoutDtoToJSON(duplicateLayoutDto: DuplicateLayoutDto)
 - duplicateLayoutDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DuplicateLayoutDto$Outbound;
}

export function duplicateLayoutDtoToJSON(duplicateLayoutDto: Duplica...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function duplicateLayoutDtoToJSON
- export function duplicateLayoutDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/duplicateworkflowdto.ts
Tamaño: 2595 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type DuplicateWorkflowDto = {
  /**
   * Name of the workflow
   */
  name?: string | undefined;
  /**
   * Tags associated with the workflow
   */
  tags?: Array<string> | undefined;
  /**
   * Description of the workflow
   */
  description?: string | undefined;
  /**
   * Enable or disable translations for this workflow
   */
  isTranslationEnabled?: boolean | undefined;
};

/** @internal */
export const DuplicateWorkflowDto$inboundSchema: z.ZodType<DuplicateWorkflowDto, z.ZodTypeDef, unknown> = z.object({
  name: z.string().optional(),
  tags: z.array(z.string()).optional(),
  description: z.string().optional(),
  isTranslationEnabled: z.boolean().default(false),
});

/** @internal */
export type DuplicateWorkflowDto$Outbound = {
  name?: string | undefined;
  tags?: Array<string> | undefined;
  description?: string | undefined;
  isTranslationEnabled: boolean;
};

/** @internal */
export const DuplicateWorkflowDto$outboundSchema: z.ZodType<
  DuplicateWorkflowDto$Outbound,
  z.ZodTypeDef,
  DuplicateWorkflowDto
> = z.object({
  name: z.string().optional(),
  tags: z.array(z.string()).optional(),
  description: z.string().optional(),
  isTranslationEnabled: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateWorkflowDto$ {
  /** @deprecated use `DuplicateWorkflowDto$inboundSchema` instead. */
  export const inboundSchema = DuplicateWorkflowDto$inboundSchema;
  /** @deprecated use `DuplicateWorkflowDto$outboundSchema` instead. */
  export const outboundSchema = DuplicateWorkflowDto$outboundSchema;
  /** @deprecated use `DuplicateWorkflowDto$Outbound` instead. */
  export type Outbound = DuplicateWorkflowDto$Outbound;
}

export function duplicateWorkflowDtoToJSON(duplicateWorkflowDto: DuplicateWorkflowDto): string {
  return JSON.stringify(DuplicateWorkflowDto$outboundSchema.parse(duplicateWorkflowDto));
}

export function duplicateWorkflowDtoFromJSON(
  jsonString: string
): SafeParseResult<DuplicateWorkflowDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateWorkflowDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateWorkflowDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - duplicateWorkflowDtoToJSON(duplicateWorkflowDto: DuplicateWorkflowDto)
 - duplicateWorkflowDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DuplicateWorkflowDto$Outbound;
}

export function duplicateWorkflowDtoToJSON(duplicateWorkflowDto: D...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function duplicateWorkflowDtoToJSON
- export function duplicateWorkflowDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/emailblock.ts
Tamaño: 2571 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  EmailBlockStyles,
  EmailBlockStyles$inboundSchema,
  EmailBlockStyles$Outbound,
  EmailBlockStyles$outboundSchema,
} from './emailblockstyles.js';
import {
  EmailBlockTypeEnum,
  EmailBlockTypeEnum$inboundSchema,
  EmailBlockTypeEnum$outboundSchema,
} from './emailblocktypeenum.js';

export type EmailBlock = {
  /**
   * Type of the email block
   */
  type: EmailBlockTypeEnum;
  /**
   * Content of the email block
   */
  content: string;
  /**
   * URL associated with the email block, if any
   */
  url?: string | undefined;
  /**
   * Styles applied to the email block
   */
  styles?: EmailBlockStyles | undefined;
};

/** @internal */
export const EmailBlock$inboundSchema: z.ZodType<EmailBlock, z.ZodTypeDef, unknown> = z.object({
  type: EmailBlockTypeEnum$inboundSchema,
  content: z.string(),
  url: z.string().optional(),
  styles: EmailBlockStyles$inboundSchema.optional(),
});

/** @internal */
export type EmailBlock$Outbound = {
  type: string;
  content: string;
  url?: string | undefined;
  styles?: EmailBlockStyles$Outbound | undefined;
};

/** @internal */
export const EmailBlock$outboundSchema: z.ZodType<EmailBlock$Outbound, z.ZodTypeDef, EmailBlock> = z.object({
  type: EmailBlockTypeEnum$outboundSchema,
  content: z.string(),
  url: z.string().optional(),
  styles: EmailBlockStyles$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailBlock$ {
  /** @deprecated use `EmailBlock$inboundSchema` instead. */
  export const inboundSchema = EmailBlock$inboundSchema;
  /** @deprecated use `EmailBlock$outboundSchema` instead. */
  export const outboundSchema = EmailBlock$outboundSchema;
  /** @deprecated use `EmailBlock$Outbound` instead. */
  export type Outbound = EmailBlock$Outbound;
}

export function emailBlockToJSON(emailBlock: EmailBlock): string {
  return JSON.stringify(EmailBlock$outboundSchema.parse(emailBlock));
}

export function emailBlockFromJSON(jsonString: string): SafeParseResult<EmailBlock, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmailBlock$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmailBlock' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - emailBlockToJSON(emailBlock: EmailBlock)
 - emailBlockFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EmailBlock$Outbound;
}

export function emailBlockToJSON(emailBlock: EmailBlock): string {
  return ...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function emailBlockToJSON
- export function emailBlockFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/emailblockstyles.ts
Tamaño: 1991 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { TextAlignEnum, TextAlignEnum$inboundSchema, TextAlignEnum$outboundSchema } from './textalignenum.js';

export type EmailBlockStyles = {
  /**
   * Text alignment for the email block
   */
  textAlign: TextAlignEnum;
};

/** @internal */
export const EmailBlockStyles$inboundSchema: z.ZodType<EmailBlockStyles, z.ZodTypeDef, unknown> = z.object({
  textAlign: TextAlignEnum$inboundSchema,
});

/** @internal */
export type EmailBlockStyles$Outbound = {
  textAlign: string;
};

/** @internal */
export const EmailBlockStyles$outboundSchema: z.ZodType<EmailBlockStyles$Outbound, z.ZodTypeDef, EmailBlockStyles> =
  z.object({
    textAlign: TextAlignEnum$outboundSchema,
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailBlockStyles$ {
  /** @deprecated use `EmailBlockStyles$inboundSchema` instead. */
  export const inboundSchema = EmailBlockStyles$inboundSchema;
  /** @deprecated use `EmailBlockStyles$outboundSchema` instead. */
  export const outboundSchema = EmailBlockStyles$outboundSchema;
  /** @deprecated use `EmailBlockStyles$Outbound` instead. */
  export type Outbound = EmailBlockStyles$Outbound;
}

export function emailBlockStylesToJSON(emailBlockStyles: EmailBlockStyles): string {
  return JSON.stringify(EmailBlockStyles$outboundSchema.parse(emailBlockStyles));
}

export function emailBlockStylesFromJSON(jsonString: string): SafeParseResult<EmailBlockStyles, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmailBlockStyles$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmailBlockStyles' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - emailBlockStylesToJSON(emailBlockStyles: EmailBlockStyles)
 - emailBlockStylesFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EmailBlockStyles$Outbound;
}

export function emailBlockStylesToJSON(emailBlockStyles: EmailBlockSty...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function emailBlockStylesToJSON
- export function emailBlockStylesFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/emailblocktypeenum.ts
Tamaño: 1144 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Type of the email block
 */
export const EmailBlockTypeEnum = {
  Button: 'button',
  Text: 'text',
} as const;
/**
 * Type of the email block
 */
export type EmailBlockTypeEnum = ClosedEnum<typeof EmailBlockTypeEnum>;

/** @internal */
export const EmailBlockTypeEnum$inboundSchema: z.ZodNativeEnum<typeof EmailBlockTypeEnum> =
  z.nativeEnum(EmailBlockTypeEnum);

/** @internal */
export const EmailBlockTypeEnum$outboundSchema: z.ZodNativeEnum<typeof EmailBlockTypeEnum> =
  EmailBlockTypeEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailBlockTypeEnum$ {
  /** @deprecated use `EmailBlockTypeEnum$inboundSchema` instead. */
  export const inboundSchema = EmailBlockTypeEnum$inboundSchema;
  /** @deprecated use `EmailBlockTypeEnum$outboundSchema` instead. */
  export const outboundSchema = EmailBlockTypeEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/emailchanneloverrides.ts
Tamaño: 2072 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EmailChannelOverrides = {
  /**
   * Override or remove the layout for all email steps in the workflow
   */
  layoutId?: string | null | undefined;
};

/** @internal */
export const EmailChannelOverrides$inboundSchema: z.ZodType<EmailChannelOverrides, z.ZodTypeDef, unknown> = z.object({
  layoutId: z.nullable(z.string()).optional(),
});

/** @internal */
export type EmailChannelOverrides$Outbound = {
  layoutId?: string | null | undefined;
};

/** @internal */
export const EmailChannelOverrides$outboundSchema: z.ZodType<
  EmailChannelOverrides$Outbound,
  z.ZodTypeDef,
  EmailChannelOverrides
> = z.object({
  layoutId: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailChannelOverrides$ {
  /** @deprecated use `EmailChannelOverrides$inboundSchema` instead. */
  export const inboundSchema = EmailChannelOverrides$inboundSchema;
  /** @deprecated use `EmailChannelOverrides$outboundSchema` instead. */
  export const outboundSchema = EmailChannelOverrides$outboundSchema;
  /** @deprecated use `EmailChannelOverrides$Outbound` instead. */
  export type Outbound = EmailChannelOverrides$Outbound;
}

export function emailChannelOverridesToJSON(emailChannelOverrides: EmailChannelOverrides): string {
  return JSON.stringify(EmailChannelOverrides$outboundSchema.parse(emailChannelOverrides));
}

export function emailChannelOverridesFromJSON(
  jsonString: string
): SafeParseResult<EmailChannelOverrides, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmailChannelOverrides$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmailChannelOverrides' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - emailChannelOverridesToJSON(emailChannelOverrides: EmailChannelOverrides)
 - emailChannelOverridesFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EmailChannelOverrides$Outbound;
}

export function emailChannelOverridesToJSON(emailChannelOverrides...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function emailChannelOverridesToJSON
- export function emailChannelOverridesFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/emailcontroldto.ts
Tamaño: 4356 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Type of editor to use for the body.
 */
export const EmailControlDtoEditorType = {
  Block: 'block',
  Html: 'html',
} as const;
/**
 * Type of editor to use for the body.
 */
export type EmailControlDtoEditorType = ClosedEnum<typeof EmailControlDtoEditorType>;

export type EmailControlDto = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * Subject of the email.
   */
  subject: string;
  /**
   * Body content of the email, either a valid Maily JSON object, or html string.
   */
  body?: string | undefined;
  /**
   * Type of editor to use for the body.
   */
  editorType?: EmailControlDtoEditorType | undefined;
  /**
   * Disable sanitization of the output.
   */
  disableOutputSanitization?: boolean | undefined;
  /**
   * Layout ID to use for the email. Null means no layout, undefined means default layout.
   */
  layoutId?: string | null | undefined;
};

/** @internal */
export const EmailControlDtoEditorType$inboundSchema: z.ZodNativeEnum<typeof EmailControlDtoEditorType> =
  z.nativeEnum(EmailControlDtoEditorType);

/** @internal */
export const EmailControlDtoEditorType$outboundSchema: z.ZodNativeEnum<typeof EmailControlDtoEditorType> =
  EmailControlDtoEditorType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailControlDtoEditorType$ {
  /** @deprecated use `EmailControlDtoEditorType$inboundSchema` instead. */
  export const inboundSchema = EmailControlDtoEditorType$inboundSchema;
  /** @deprecated use `EmailControlDtoEditorType$outboundSchema` instead. */
  export const outboundSchema = EmailControlDtoEditorType$outboundSchema;
}

/** @internal */
export const EmailControlDto$inboundSchema: z.ZodType<EmailControlDto, z.ZodTypeDef, unknown> = z.object({
  skip: z.record(z.any()).optional(),
  subject: z.string(),
  body: z.string().default(''),
  editorType: EmailControlDtoEditorType$inboundSchema.default('block'),
  disableOutputSanitization: z.boolean().default(false),
  layoutId: z.nullable(z.string()).optional(),
});

/** @internal */
export type EmailControlDto$Outbound = {
  skip?: { [k: string]: any } | undefined;
  subject: string;
  body: string;
  editorType: string;
  disableOutputSanitization: boolean;
  layoutId?: string | null | undefined;
};

/** @internal */
export const EmailControlDto$outboundSchema: z.ZodType<EmailControlDto$Outbound, z.ZodTypeDef, EmailControlDto> =
  z.object({
    skip: z.record(z.any()).optional(),
    subject: z.string(),
    body: z.string().default(''),
    editorType: EmailControlDtoEditorType$outboundSchema.default('block'),
    disableOutputSanitization: z.boolean().default(false),
    layoutId: z.nullable(z.string()).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailControlDto$ {
  /** @deprecated use `EmailControlDto$inboundSchema` instead. */
  export const inboundSchema = EmailControlDto$inboundSchema;
  /** @deprecated use `EmailControlDto$outboundSchema` instead. */
  export const outboundSchema = EmailControlDto$outboundSchema;
  /** @deprecated use `EmailControlDto$Outbound` instead. */
  export type Outbound = EmailControlDto$Outbound;
}

export function emailControlDtoToJSON(emailControlDto: EmailControlDto): string {
  return JSON.stringify(EmailControlDto$outboundSchema.parse(emailControlDto));
}

export function emailControlDtoFromJSON(jsonString: string): SafeParseResult<EmailControlDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmailControlDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmailControlDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - emailControlDtoToJSON(emailControlDto: EmailControlDto)
 - emailControlDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EmailControlDto$Outbound;
}

export function emailControlDtoToJSON(emailControlDto: EmailControlDto)...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function emailControlDtoToJSON
- export function emailControlDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/emailcontrolsdto.ts
Tamaño: 2904 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Editor type of the layout.
 */
export const EditorType = {
  Html: 'html',
  Block: 'block',
} as const;
/**
 * Editor type of the layout.
 */
export type EditorType = ClosedEnum<typeof EditorType>;

export type EmailControlsDto = {
  /**
   * Body of the layout.
   */
  body: string;
  /**
   * Editor type of the layout.
   */
  editorType: EditorType;
};

/** @internal */
export const EditorType$inboundSchema: z.ZodNativeEnum<typeof EditorType> = z.nativeEnum(EditorType);

/** @internal */
export const EditorType$outboundSchema: z.ZodNativeEnum<typeof EditorType> = EditorType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EditorType$ {
  /** @deprecated use `EditorType$inboundSchema` instead. */
  export const inboundSchema = EditorType$inboundSchema;
  /** @deprecated use `EditorType$outboundSchema` instead. */
  export const outboundSchema = EditorType$outboundSchema;
}

/** @internal */
export const EmailControlsDto$inboundSchema: z.ZodType<EmailControlsDto, z.ZodTypeDef, unknown> = z.object({
  body: z.string(),
  editorType: EditorType$inboundSchema,
});

/** @internal */
export type EmailControlsDto$Outbound = {
  body: string;
  editorType: string;
};

/** @internal */
export const EmailControlsDto$outboundSchema: z.ZodType<EmailControlsDto$Outbound, z.ZodTypeDef, EmailControlsDto> =
  z.object({
    body: z.string(),
    editorType: EditorType$outboundSchema,
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailControlsDto$ {
  /** @deprecated use `EmailControlsDto$inboundSchema` instead. */
  export const inboundSchema = EmailControlsDto$inboundSchema;
  /** @deprecated use `EmailControlsDto$outboundSchema` instead. */
  export const outboundSchema = EmailControlsDto$outboundSchema;
  /** @deprecated use `EmailControlsDto$Outbound` instead. */
  export type Outbound = EmailControlsDto$Outbound;
}

export function emailControlsDtoToJSON(emailControlsDto: EmailControlsDto): string {
  return JSON.stringify(EmailControlsDto$outboundSchema.parse(emailControlsDto));
}

export function emailControlsDtoFromJSON(jsonString: string): SafeParseResult<EmailControlsDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmailControlsDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmailControlsDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - emailControlsDtoToJSON(emailControlsDto: EmailControlsDto)
 - emailControlsDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EmailControlsDto$Outbound;
}

export function emailControlsDtoToJSON(emailControlsDto: EmailControls...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function emailControlsDtoToJSON
- export function emailControlsDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/emailcontrolsmetadataresponsedto.ts
Tamaño: 2979 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  EmailControlDto,
  EmailControlDto$inboundSchema,
  EmailControlDto$Outbound,
  EmailControlDto$outboundSchema,
} from './emailcontroldto.js';
import { UiSchema, UiSchema$inboundSchema, UiSchema$Outbound, UiSchema$outboundSchema } from './uischema.js';

export type EmailControlsMetadataResponseDto = {
  /**
   * JSON Schema for data
   */
  dataSchema?: { [k: string]: any } | undefined;
  /**
   * UI Schema for rendering
   */
  uiSchema?: UiSchema | undefined;
  /**
   * Control values specific to Email
   */
  values: EmailControlDto;
};

/** @internal */
export const EmailControlsMetadataResponseDto$inboundSchema: z.ZodType<
  EmailControlsMetadataResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$inboundSchema.optional(),
  values: EmailControlDto$inboundSchema,
});

/** @internal */
export type EmailControlsMetadataResponseDto$Outbound = {
  dataSchema?: { [k: string]: any } | undefined;
  uiSchema?: UiSchema$Outbound | undefined;
  values: EmailControlDto$Outbound;
};

/** @internal */
export const EmailControlsMetadataResponseDto$outboundSchema: z.ZodType<
  EmailControlsMetadataResponseDto$Outbound,
  z.ZodTypeDef,
  EmailControlsMetadataResponseDto
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$outboundSchema.optional(),
  values: EmailControlDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailControlsMetadataResponseDto$ {
  /** @deprecated use `EmailControlsMetadataResponseDto$inboundSchema` instead. */
  export const inboundSchema = EmailControlsMetadataResponseDto$inboundSchema;
  /** @deprecated use `EmailControlsMetadataResponseDto$outboundSchema` instead. */
  export const outboundSchema = EmailControlsMetadataResponseDto$outboundSchema;
  /** @deprecated use `EmailControlsMetadataResponseDto$Outbound` instead. */
  export type Outbound = EmailControlsMetadataResponseDto$Outbound;
}

export function emailControlsMetadataResponseDtoToJSON(
  emailControlsMetadataResponseDto: EmailControlsMetadataResponseDto
): string {
  return JSON.stringify(EmailControlsMetadataResponseDto$outboundSchema.parse(emailControlsMetadataResponseDto));
}

export function emailControlsMetadataResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<EmailControlsMetadataResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmailControlsMetadataResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmailControlsMetadataResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - emailControlsMetadataResponseDtoToJSON(emailControlsMetadataResponseDto: EmailControlsMetadataResponseDto)
 - emailControlsMetadataResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EmailControlsMetadataResponseDto$Outbound;
}

export function emailControlsMetadataResponseDtoToJSON...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function emailControlsMetadataResponseDtoToJSON
- export function emailControlsMetadataResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/emaillayoutrenderoutput.ts
Tamaño: 1977 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EmailLayoutRenderOutput = {
  /**
   * Content of the email
   */
  body: string;
};

/** @internal */
export const EmailLayoutRenderOutput$inboundSchema: z.ZodType<EmailLayoutRenderOutput, z.ZodTypeDef, unknown> =
  z.object({
    body: z.string(),
  });

/** @internal */
export type EmailLayoutRenderOutput$Outbound = {
  body: string;
};

/** @internal */
export const EmailLayoutRenderOutput$outboundSchema: z.ZodType<
  EmailLayoutRenderOutput$Outbound,
  z.ZodTypeDef,
  EmailLayoutRenderOutput
> = z.object({
  body: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailLayoutRenderOutput$ {
  /** @deprecated use `EmailLayoutRenderOutput$inboundSchema` instead. */
  export const inboundSchema = EmailLayoutRenderOutput$inboundSchema;
  /** @deprecated use `EmailLayoutRenderOutput$outboundSchema` instead. */
  export const outboundSchema = EmailLayoutRenderOutput$outboundSchema;
  /** @deprecated use `EmailLayoutRenderOutput$Outbound` instead. */
  export type Outbound = EmailLayoutRenderOutput$Outbound;
}

export function emailLayoutRenderOutputToJSON(emailLayoutRenderOutput: EmailLayoutRenderOutput): string {
  return JSON.stringify(EmailLayoutRenderOutput$outboundSchema.parse(emailLayoutRenderOutput));
}

export function emailLayoutRenderOutputFromJSON(
  jsonString: string
): SafeParseResult<EmailLayoutRenderOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmailLayoutRenderOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmailLayoutRenderOutput' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - emailLayoutRenderOutputToJSON(emailLayoutRenderOutput: EmailLayoutRenderOutput)
 - emailLayoutRenderOutputFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EmailLayoutRenderOutput$Outbound;
}

export function emailLayoutRenderOutputToJSON(emailLayoutRender...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function emailLayoutRenderOutputToJSON
- export function emailLayoutRenderOutputFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/emailrenderoutput.ts
Tamaño: 1948 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EmailRenderOutput = {
  /**
   * Subject of the email
   */
  subject: string;
  /**
   * Body of the email
   */
  body: string;
};

/** @internal */
export const EmailRenderOutput$inboundSchema: z.ZodType<EmailRenderOutput, z.ZodTypeDef, unknown> = z.object({
  subject: z.string(),
  body: z.string(),
});

/** @internal */
export type EmailRenderOutput$Outbound = {
  subject: string;
  body: string;
};

/** @internal */
export const EmailRenderOutput$outboundSchema: z.ZodType<EmailRenderOutput$Outbound, z.ZodTypeDef, EmailRenderOutput> =
  z.object({
    subject: z.string(),
    body: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailRenderOutput$ {
  /** @deprecated use `EmailRenderOutput$inboundSchema` instead. */
  export const inboundSchema = EmailRenderOutput$inboundSchema;
  /** @deprecated use `EmailRenderOutput$outboundSchema` instead. */
  export const outboundSchema = EmailRenderOutput$outboundSchema;
  /** @deprecated use `EmailRenderOutput$Outbound` instead. */
  export type Outbound = EmailRenderOutput$Outbound;
}

export function emailRenderOutputToJSON(emailRenderOutput: EmailRenderOutput): string {
  return JSON.stringify(EmailRenderOutput$outboundSchema.parse(emailRenderOutput));
}

export function emailRenderOutputFromJSON(jsonString: string): SafeParseResult<EmailRenderOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmailRenderOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmailRenderOutput' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - emailRenderOutputToJSON(emailRenderOutput: EmailRenderOutput)
 - emailRenderOutputFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EmailRenderOutput$Outbound;
}

export function emailRenderOutputToJSON(emailRenderOutput: EmailRende...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function emailRenderOutputToJSON
- export function emailRenderOutputFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/emailstepresponsedto.ts
Tamaño: 9956 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { collectExtraKeys as collectExtraKeys$, safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  EmailControlsMetadataResponseDto,
  EmailControlsMetadataResponseDto$inboundSchema,
  EmailControlsMetadataResponseDto$Outbound,
  EmailControlsMetadataResponseDto$outboundSchema,
} from './emailcontrolsmetadataresponsedto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  StepIssuesDto,
  StepIssuesDto$inboundSchema,
  StepIssuesDto$Outbound,
  StepIssuesDto$outboundSchema,
} from './stepissuesdto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Type of editor to use for the body.
 */
export const EmailStepResponseDtoEditorType = {
  Block: 'block',
  Html: 'html',
} as const;
/**
 * Type of editor to use for the body.
 */
export type EmailStepResponseDtoEditorType = ClosedEnum<typeof EmailStepResponseDtoEditorType>;

/**
 * Control values for the email step
 */
export type EmailStepResponseDtoControlValues = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * Subject of the email.
   */
  subject: string;
  /**
   * Body content of the email, either a valid Maily JSON object, or html string.
   */
  body?: string | undefined;
  /**
   * Type of editor to use for the body.
   */
  editorType?: EmailStepResponseDtoEditorType | undefined;
  /**
   * Disable sanitization of the output.
   */
  disableOutputSanitization?: boolean | undefined;
  /**
   * Layout ID to use for the email. Null means no layout, undefined means default layout.
   */
  layoutId?: string | null | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type EmailStepResponseDto = {
  /**
   * Controls metadata for the email step
   */
  controls: EmailControlsMetadataResponseDto;
  /**
   * Control values for the email step
   */
  controlValues?: EmailStepResponseDtoControlValues | undefined;
  /**
   * JSON Schema for variables, follows the JSON Schema standard
   */
  variables: { [k: string]: any };
  /**
   * Unique identifier of the step
   */
  stepId: string;
  /**
   * Database identifier of the step
   */
  id: string;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Slug of the step
   */
  slug: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow database identifier
   */
  workflowDatabaseId: string;
  /**
   * Issues associated with the step
   */
  issues?: StepIssuesDto | undefined;
};

/** @internal */
export const EmailStepResponseDtoEditorType$inboundSchema: z.ZodNativeEnum<typeof EmailStepResponseDtoEditorType> =
  z.nativeEnum(EmailStepResponseDtoEditorType);

/** @internal */
export const EmailStepResponseDtoEditorType$outboundSchema: z.ZodNativeEnum<typeof EmailStepResponseDtoEditorType> =
  EmailStepResponseDtoEditorType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailStepResponseDtoEditorType$ {
  /** @deprecated use `EmailStepResponseDtoEditorType$inboundSchema` instead. */
  export const inboundSchema = EmailStepResponseDtoEditorType$inboundSchema;
  /** @deprecated use `EmailStepResponseDtoEditorType$outboundSchema` instead. */
  export const outboundSchema = EmailStepResponseDtoEditorType$outboundSchema;
}

/** @internal */
export const EmailStepResponseDtoControlValues$inboundSchema: z.ZodType<
  EmailStepResponseDtoControlValues,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z
    .object({
      skip: z.record(z.any()).optional(),
      subject: z.string(),
      body: z.string().default(''),
      editorType: EmailStepResponseDtoEditorType$inboundSchema.default('block'),
      disableOutputSanitization: z.boolean().default(false),
      layoutId: z.nullable(z.string()).optional(),
    })
    .catchall(z.any()),
  'additionalProperties',
  true
);

/** @internal */
export type EmailStepResponseDtoControlValues$Outbound = {
  skip?: { [k: string]: any } | undefined;
  subject: string;
  body: string;
  editorType: string;
  disableOutputSanitization: boolean;
  layoutId?: string | null | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const EmailStepResponseDtoControlValues$outboundSchema: z.ZodType<
  EmailStepResponseDtoControlValues$Outbound,
  z.ZodTypeDef,
  EmailStepResponseDtoControlValues
> = z
  .object({
    skip: z.record(z.any()).optional(),
    subject: z.string(),
    body: z.string().default(''),
    editorType: EmailStepResponseDtoEditorType$outboundSchema.default('block'),
    disableOutputSanitization: z.boolean().default(false),
    layoutId: z.nullable(z.string()).optional(),
    additionalProperties: z.record(z.any()).optional(),
  })
  .transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailStepResponseDtoControlValues$ {
  /** @deprecated use `EmailStepResponseDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = EmailStepResponseDtoControlValues$inboundSchema;
  /** @deprecated use `EmailStepResponseDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = EmailStepResponseDtoControlValues$outboundSchema;
  /** @deprecated use `EmailStepResponseDtoControlValues$Outbound` instead. */
  export type Outbound = EmailStepResponseDtoControlValues$Outbound;
}

export function emailStepResponseDtoControlValuesToJSON(
  emailStepResponseDtoControlValues: EmailStepResponseDtoControlValues
): string {
  return JSON.stringify(EmailStepResponseDtoControlValues$outboundSchema.parse(emailStepResponseDtoControlValues));
}

export function emailStepResponseDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<EmailStepResponseDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmailStepResponseDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmailStepResponseDtoControlValues' from JSON`
  );
}

/** @internal */
export const EmailStepResponseDto$inboundSchema: z.ZodType<EmailStepResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    controls: EmailControlsMetadataResponseDto$inboundSchema,
    controlValues: z.lazy(() => EmailStepResponseDtoControlValues$inboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    _id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$inboundSchema,
    origin: ResourceOriginEnum$inboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type EmailStepResponseDto$Outbound = {
  controls: EmailControlsMetadataResponseDto$Outbound;
  controlValues?: EmailStepResponseDtoControlValues$Outbound | undefined;
  variables: { [k: string]: any };
  stepId: string;
  _id: string;
  name: string;
  slug: string;
  type: string;
  origin: string;
  workflowId: string;
  workflowDatabaseId: string;
  issues?: StepIssuesDto$Outbound | undefined;
};

/** @internal */
export const EmailStepResponseDto$outboundSchema: z.ZodType<
  EmailStepResponseDto$Outbound,
  z.ZodTypeDef,
  EmailStepResponseDto
> = z
  .object({
    controls: EmailControlsMetadataResponseDto$outboundSchema,
    controlValues: z.lazy(() => EmailStepResponseDtoControlValues$outboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$outboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailStepResponseDto$ {
  /** @deprecated use `EmailStepResponseDto$inboundSchema` instead. */
  export const inboundSchema = EmailStepResponseDto$inboundSchema;
  /** @deprecated use `EmailStepResponseDto$outboundSchema` instead. */
  export const outboundSchema = EmailStepResponseDto$outboundSchema;
  /** @deprecated use `EmailStepResponseDto$Outbound` instead. */
  export type Outbound = EmailStepResponseDto$Outbound;
}

export function emailStepResponseDtoToJSON(emailStepResponseDto: EmailStepResponseDto): string {
  return JSON.stringify(EmailStepResponseDto$outboundSchema.parse(emailStepResponseDto));
}

export function emailStepResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<EmailStepResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmailStepResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmailStepResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - emailStepResponseDtoControlValuesToJSON(emailStepResponseDtoControlValues: EmailStepResponseDtoControlValues)
 - emailStepResponseDtoControlValuesFromJSON(jsonString: string)
 - emailStepResponseDtoToJSON(emailStepResponseDto: EmailStepResponseDto)
 - emailStepResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EmailStepResponseDtoControlValues$Outbound;
}

export function emailStepResponseDtoControlValuesToJS...)
 - Outbound(EmailStepResponseDto$Outbound;
}

export function emailStepResponseDtoToJSON(emailStepResponseDto: E...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function emailStepResponseDtoControlValuesToJSON
- export function emailStepResponseDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function emailStepResponseDtoToJSON
- export function emailStepResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/emailstepupsertdto.ts
Tamaño: 5248 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  EmailControlDto,
  EmailControlDto$inboundSchema,
  EmailControlDto$Outbound,
  EmailControlDto$outboundSchema,
} from './emailcontroldto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the Email step.
 */
export type EmailStepUpsertDtoControlValues =
  | EmailControlDto
  | {
      [k: string]: any;
    };

export type EmailStepUpsertDto = {
  /**
   * Database identifier of the step. Used for updating the step.
   */
  id?: string | undefined;
  /**
   * Unique identifier for the step
   */
  stepId?: string | undefined;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Control values for the Email step.
   */
  controlValues?: EmailControlDto | { [k: string]: any } | undefined;
};

/** @internal */
export const EmailStepUpsertDtoControlValues$inboundSchema: z.ZodType<
  EmailStepUpsertDtoControlValues,
  z.ZodTypeDef,
  unknown
> = z.union([EmailControlDto$inboundSchema, z.record(z.any())]);

/** @internal */
export type EmailStepUpsertDtoControlValues$Outbound = EmailControlDto$Outbound | { [k: string]: any };

/** @internal */
export const EmailStepUpsertDtoControlValues$outboundSchema: z.ZodType<
  EmailStepUpsertDtoControlValues$Outbound,
  z.ZodTypeDef,
  EmailStepUpsertDtoControlValues
> = z.union([EmailControlDto$outboundSchema, z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailStepUpsertDtoControlValues$ {
  /** @deprecated use `EmailStepUpsertDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = EmailStepUpsertDtoControlValues$inboundSchema;
  /** @deprecated use `EmailStepUpsertDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = EmailStepUpsertDtoControlValues$outboundSchema;
  /** @deprecated use `EmailStepUpsertDtoControlValues$Outbound` instead. */
  export type Outbound = EmailStepUpsertDtoControlValues$Outbound;
}

export function emailStepUpsertDtoControlValuesToJSON(
  emailStepUpsertDtoControlValues: EmailStepUpsertDtoControlValues
): string {
  return JSON.stringify(EmailStepUpsertDtoControlValues$outboundSchema.parse(emailStepUpsertDtoControlValues));
}

export function emailStepUpsertDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<EmailStepUpsertDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmailStepUpsertDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmailStepUpsertDtoControlValues' from JSON`
  );
}

/** @internal */
export const EmailStepUpsertDto$inboundSchema: z.ZodType<EmailStepUpsertDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$inboundSchema,
    controlValues: z.union([EmailControlDto$inboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type EmailStepUpsertDto$Outbound = {
  _id?: string | undefined;
  stepId?: string | undefined;
  name: string;
  type: string;
  controlValues?: EmailControlDto$Outbound | { [k: string]: any } | undefined;
};

/** @internal */
export const EmailStepUpsertDto$outboundSchema: z.ZodType<
  EmailStepUpsertDto$Outbound,
  z.ZodTypeDef,
  EmailStepUpsertDto
> = z
  .object({
    id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$outboundSchema,
    controlValues: z.union([EmailControlDto$outboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmailStepUpsertDto$ {
  /** @deprecated use `EmailStepUpsertDto$inboundSchema` instead. */
  export const inboundSchema = EmailStepUpsertDto$inboundSchema;
  /** @deprecated use `EmailStepUpsertDto$outboundSchema` instead. */
  export const outboundSchema = EmailStepUpsertDto$outboundSchema;
  /** @deprecated use `EmailStepUpsertDto$Outbound` instead. */
  export type Outbound = EmailStepUpsertDto$Outbound;
}

export function emailStepUpsertDtoToJSON(emailStepUpsertDto: EmailStepUpsertDto): string {
  return JSON.stringify(EmailStepUpsertDto$outboundSchema.parse(emailStepUpsertDto));
}

export function emailStepUpsertDtoFromJSON(
  jsonString: string
): SafeParseResult<EmailStepUpsertDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmailStepUpsertDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmailStepUpsertDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - emailStepUpsertDtoControlValuesToJSON(emailStepUpsertDtoControlValues: EmailStepUpsertDtoControlValues)
 - emailStepUpsertDtoControlValuesFromJSON(jsonString: string)
 - emailStepUpsertDtoToJSON(emailStepUpsertDto: EmailStepUpsertDto)
 - emailStepUpsertDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EmailStepUpsertDtoControlValues$Outbound;
}

export function emailStepUpsertDtoControlValuesToJSON(
...)
 - Outbound(EmailStepUpsertDto$Outbound;
}

export function emailStepUpsertDtoToJSON(emailStepUpsertDto: EmailSt...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function emailStepUpsertDtoControlValuesToJSON
- export function emailStepUpsertDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function emailStepUpsertDtoToJSON
- export function emailStepUpsertDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/environmentresponsedto.ts
Tamaño: 4955 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { ApiKeyDto, ApiKeyDto$inboundSchema, ApiKeyDto$Outbound, ApiKeyDto$outboundSchema } from './apikeydto.js';

/**
 * Type of the environment
 */
export const EnvironmentResponseDtoType = {
  Dev: 'dev',
  Prod: 'prod',
} as const;
/**
 * Type of the environment
 */
export type EnvironmentResponseDtoType = ClosedEnum<typeof EnvironmentResponseDtoType>;

export type EnvironmentResponseDto = {
  /**
   * Unique identifier of the environment
   */
  id: string;
  /**
   * Name of the environment
   */
  name: string;
  /**
   * Organization ID associated with the environment
   */
  organizationId: string;
  /**
   * Unique identifier for the environment
   */
  identifier: string;
  /**
   * Type of the environment
   */
  type?: EnvironmentResponseDtoType | null | undefined;
  /**
   * List of API keys associated with the environment
   */
  apiKeys?: Array<ApiKeyDto> | undefined;
  /**
   * Parent environment ID
   */
  parentId?: string | undefined;
  /**
   * URL-friendly slug for the environment
   */
  slug?: string | undefined;
};

/** @internal */
export const EnvironmentResponseDtoType$inboundSchema: z.ZodNativeEnum<typeof EnvironmentResponseDtoType> =
  z.nativeEnum(EnvironmentResponseDtoType);

/** @internal */
export const EnvironmentResponseDtoType$outboundSchema: z.ZodNativeEnum<typeof EnvironmentResponseDtoType> =
  EnvironmentResponseDtoType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentResponseDtoType$ {
  /** @deprecated use `EnvironmentResponseDtoType$inboundSchema` instead. */
  export const inboundSchema = EnvironmentResponseDtoType$inboundSchema;
  /** @deprecated use `EnvironmentResponseDtoType$outboundSchema` instead. */
  export const outboundSchema = EnvironmentResponseDtoType$outboundSchema;
}

/** @internal */
export const EnvironmentResponseDto$inboundSchema: z.ZodType<EnvironmentResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    name: z.string(),
    _organizationId: z.string(),
    identifier: z.string(),
    type: z.nullable(EnvironmentResponseDtoType$inboundSchema).optional(),
    apiKeys: z.array(ApiKeyDto$inboundSchema).optional(),
    _parentId: z.string().optional(),
    slug: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      _organizationId: 'organizationId',
      _parentId: 'parentId',
    });
  });

/** @internal */
export type EnvironmentResponseDto$Outbound = {
  _id: string;
  name: string;
  _organizationId: string;
  identifier: string;
  type?: string | null | undefined;
  apiKeys?: Array<ApiKeyDto$Outbound> | undefined;
  _parentId?: string | undefined;
  slug?: string | undefined;
};

/** @internal */
export const EnvironmentResponseDto$outboundSchema: z.ZodType<
  EnvironmentResponseDto$Outbound,
  z.ZodTypeDef,
  EnvironmentResponseDto
> = z
  .object({
    id: z.string(),
    name: z.string(),
    organizationId: z.string(),
    identifier: z.string(),
    type: z.nullable(EnvironmentResponseDtoType$outboundSchema).optional(),
    apiKeys: z.array(ApiKeyDto$outboundSchema).optional(),
    parentId: z.string().optional(),
    slug: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      organizationId: '_organizationId',
      parentId: '_parentId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentResponseDto$ {
  /** @deprecated use `EnvironmentResponseDto$inboundSchema` instead. */
  export const inboundSchema = EnvironmentResponseDto$inboundSchema;
  /** @deprecated use `EnvironmentResponseDto$outboundSchema` instead. */
  export const outboundSchema = EnvironmentResponseDto$outboundSchema;
  /** @deprecated use `EnvironmentResponseDto$Outbound` instead. */
  export type Outbound = EnvironmentResponseDto$Outbound;
}

export function environmentResponseDtoToJSON(environmentResponseDto: EnvironmentResponseDto): string {
  return JSON.stringify(EnvironmentResponseDto$outboundSchema.parse(environmentResponseDto));
}

export function environmentResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - environmentResponseDtoToJSON(environmentResponseDto: EnvironmentResponseDto)
 - environmentResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EnvironmentResponseDto$Outbound;
}

export function environmentResponseDtoToJSON(environmentResponse...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentResponseDtoToJSON
- export function environmentResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/eventbody.ts
Tamaño: 3766 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Status of the event
 */
export const Status = {
  Opened: 'opened',
  Rejected: 'rejected',
  Sent: 'sent',
  Deferred: 'deferred',
  Delivered: 'delivered',
  Bounced: 'bounced',
  Dropped: 'dropped',
  Clicked: 'clicked',
  Blocked: 'blocked',
  Spam: 'spam',
  Unsubscribed: 'unsubscribed',
  Delayed: 'delayed',
  Complaint: 'complaint',
  Created: 'created',
  Accepted: 'accepted',
  Queued: 'queued',
  Sending: 'sending',
  Failed: 'failed',
  Undelivered: 'undelivered',
  Dismissed: 'dismissed',
} as const;
/**
 * Status of the event
 */
export type Status = ClosedEnum<typeof Status>;

export type EventBody = {
  /**
   * Status of the event
   */
  status: Status;
  /**
   * Date of the event
   */
  date: string;
  /**
   * External ID from the provider
   */
  externalId?: string | undefined;
  /**
   * Number of attempts
   */
  attempts?: number | undefined;
  /**
   * Response from the provider
   */
  response?: string | undefined;
  /**
   * Raw content from the provider webhook
   */
  row?: string | undefined;
};

/** @internal */
export const Status$inboundSchema: z.ZodNativeEnum<typeof Status> = z.nativeEnum(Status);

/** @internal */
export const Status$outboundSchema: z.ZodNativeEnum<typeof Status> = Status$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Status$ {
  /** @deprecated use `Status$inboundSchema` instead. */
  export const inboundSchema = Status$inboundSchema;
  /** @deprecated use `Status$outboundSchema` instead. */
  export const outboundSchema = Status$outboundSchema;
}

/** @internal */
export const EventBody$inboundSchema: z.ZodType<EventBody, z.ZodTypeDef, unknown> = z.object({
  status: Status$inboundSchema,
  date: z.string(),
  externalId: z.string().optional(),
  attempts: z.number().optional(),
  response: z.string().optional(),
  row: z.string().optional(),
});

/** @internal */
export type EventBody$Outbound = {
  status: string;
  date: string;
  externalId?: string | undefined;
  attempts?: number | undefined;
  response?: string | undefined;
  row?: string | undefined;
};

/** @internal */
export const EventBody$outboundSchema: z.ZodType<EventBody$Outbound, z.ZodTypeDef, EventBody> = z.object({
  status: Status$outboundSchema,
  date: z.string(),
  externalId: z.string().optional(),
  attempts: z.number().optional(),
  response: z.string().optional(),
  row: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventBody$ {
  /** @deprecated use `EventBody$inboundSchema` instead. */
  export const inboundSchema = EventBody$inboundSchema;
  /** @deprecated use `EventBody$outboundSchema` instead. */
  export const outboundSchema = EventBody$outboundSchema;
  /** @deprecated use `EventBody$Outbound` instead. */
  export type Outbound = EventBody$Outbound;
}

export function eventBodyToJSON(eventBody: EventBody): string {
  return JSON.stringify(EventBody$outboundSchema.parse(eventBody));
}

export function eventBodyFromJSON(jsonString: string): SafeParseResult<EventBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventBody' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - eventBodyToJSON(eventBody: EventBody)
 - eventBodyFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EventBody$Outbound;
}

export function eventBodyToJSON(eventBody: EventBody): string {
  return JSON...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventBodyToJSON
- export function eventBodyFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/executiondetailssourceenum.ts
Tamaño: 1332 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Source of the execution detail
 */
export const ExecutionDetailsSourceEnum = {
  Credentials: 'Credentials',
  Internal: 'Internal',
  Payload: 'Payload',
  Webhook: 'Webhook',
} as const;
/**
 * Source of the execution detail
 */
export type ExecutionDetailsSourceEnum = ClosedEnum<typeof ExecutionDetailsSourceEnum>;

/** @internal */
export const ExecutionDetailsSourceEnum$inboundSchema: z.ZodNativeEnum<typeof ExecutionDetailsSourceEnum> =
  z.nativeEnum(ExecutionDetailsSourceEnum);

/** @internal */
export const ExecutionDetailsSourceEnum$outboundSchema: z.ZodNativeEnum<typeof ExecutionDetailsSourceEnum> =
  ExecutionDetailsSourceEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExecutionDetailsSourceEnum$ {
  /** @deprecated use `ExecutionDetailsSourceEnum$inboundSchema` instead. */
  export const inboundSchema = ExecutionDetailsSourceEnum$inboundSchema;
  /** @deprecated use `ExecutionDetailsSourceEnum$outboundSchema` instead. */
  export const outboundSchema = ExecutionDetailsSourceEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/executiondetailsstatusenum.ts
Tamaño: 1380 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Status of the execution detail
 */
export const ExecutionDetailsStatusEnum = {
  Success: 'Success',
  Warning: 'Warning',
  Failed: 'Failed',
  Pending: 'Pending',
  Queued: 'Queued',
  ReadConfirmation: 'ReadConfirmation',
} as const;
/**
 * Status of the execution detail
 */
export type ExecutionDetailsStatusEnum = ClosedEnum<typeof ExecutionDetailsStatusEnum>;

/** @internal */
export const ExecutionDetailsStatusEnum$inboundSchema: z.ZodNativeEnum<typeof ExecutionDetailsStatusEnum> =
  z.nativeEnum(ExecutionDetailsStatusEnum);

/** @internal */
export const ExecutionDetailsStatusEnum$outboundSchema: z.ZodNativeEnum<typeof ExecutionDetailsStatusEnum> =
  ExecutionDetailsStatusEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExecutionDetailsStatusEnum$ {
  /** @deprecated use `ExecutionDetailsStatusEnum$inboundSchema` instead. */
  export const inboundSchema = ExecutionDetailsStatusEnum$inboundSchema;
  /** @deprecated use `ExecutionDetailsStatusEnum$outboundSchema` instead. */
  export const outboundSchema = ExecutionDetailsStatusEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/failedoperationdto.ts
Tamaño: 2200 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type FailedOperationDto = {
  /**
   * The error message associated with the failed operation.
   */
  message?: string | undefined;
  /**
   * The subscriber ID associated with the failed operation. This field is optional.
   */
  subscriberId?: string | undefined;
};

/** @internal */
export const FailedOperationDto$inboundSchema: z.ZodType<FailedOperationDto, z.ZodTypeDef, unknown> = z.object({
  message: z.string().optional(),
  subscriberId: z.string().optional(),
});

/** @internal */
export type FailedOperationDto$Outbound = {
  message?: string | undefined;
  subscriberId?: string | undefined;
};

/** @internal */
export const FailedOperationDto$outboundSchema: z.ZodType<
  FailedOperationDto$Outbound,
  z.ZodTypeDef,
  FailedOperationDto
> = z.object({
  message: z.string().optional(),
  subscriberId: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FailedOperationDto$ {
  /** @deprecated use `FailedOperationDto$inboundSchema` instead. */
  export const inboundSchema = FailedOperationDto$inboundSchema;
  /** @deprecated use `FailedOperationDto$outboundSchema` instead. */
  export const outboundSchema = FailedOperationDto$outboundSchema;
  /** @deprecated use `FailedOperationDto$Outbound` instead. */
  export type Outbound = FailedOperationDto$Outbound;
}

export function failedOperationDtoToJSON(failedOperationDto: FailedOperationDto): string {
  return JSON.stringify(FailedOperationDto$outboundSchema.parse(failedOperationDto));
}

export function failedOperationDtoFromJSON(
  jsonString: string
): SafeParseResult<FailedOperationDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FailedOperationDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FailedOperationDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - failedOperationDtoToJSON(failedOperationDto: FailedOperationDto)
 - failedOperationDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(FailedOperationDto$Outbound;
}

export function failedOperationDtoToJSON(failedOperationDto: FailedO...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function failedOperationDtoToJSON
- export function failedOperationDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/feedresponsedto.ts
Tamaño: 2794 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  NotificationFeedItemDto,
  NotificationFeedItemDto$inboundSchema,
  NotificationFeedItemDto$Outbound,
  NotificationFeedItemDto$outboundSchema,
} from './notificationfeeditemdto.js';

export type FeedResponseDto = {
  /**
   * Total number of notifications available.
   */
  totalCount?: number | undefined;
  /**
   * Indicates if there are more notifications to load.
   */
  hasMore: boolean;
  /**
   * Array of notifications returned in the response.
   */
  data: Array<NotificationFeedItemDto>;
  /**
   * The number of notifications returned in this response.
   */
  pageSize: number;
  /**
   * The current page number of the notifications.
   */
  page: number;
};

/** @internal */
export const FeedResponseDto$inboundSchema: z.ZodType<FeedResponseDto, z.ZodTypeDef, unknown> = z.object({
  totalCount: z.number().optional(),
  hasMore: z.boolean(),
  data: z.array(NotificationFeedItemDto$inboundSchema),
  pageSize: z.number(),
  page: z.number(),
});

/** @internal */
export type FeedResponseDto$Outbound = {
  totalCount?: number | undefined;
  hasMore: boolean;
  data: Array<NotificationFeedItemDto$Outbound>;
  pageSize: number;
  page: number;
};

/** @internal */
export const FeedResponseDto$outboundSchema: z.ZodType<FeedResponseDto$Outbound, z.ZodTypeDef, FeedResponseDto> =
  z.object({
    totalCount: z.number().optional(),
    hasMore: z.boolean(),
    data: z.array(NotificationFeedItemDto$outboundSchema),
    pageSize: z.number(),
    page: z.number(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeedResponseDto$ {
  /** @deprecated use `FeedResponseDto$inboundSchema` instead. */
  export const inboundSchema = FeedResponseDto$inboundSchema;
  /** @deprecated use `FeedResponseDto$outboundSchema` instead. */
  export const outboundSchema = FeedResponseDto$outboundSchema;
  /** @deprecated use `FeedResponseDto$Outbound` instead. */
  export type Outbound = FeedResponseDto$Outbound;
}

export function feedResponseDtoToJSON(feedResponseDto: FeedResponseDto): string {
  return JSON.stringify(FeedResponseDto$outboundSchema.parse(feedResponseDto));
}

export function feedResponseDtoFromJSON(jsonString: string): SafeParseResult<FeedResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FeedResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeedResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - feedResponseDtoToJSON(feedResponseDto: FeedResponseDto)
 - feedResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(FeedResponseDto$Outbound;
}

export function feedResponseDtoToJSON(feedResponseDto: FeedResponseDto)...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function feedResponseDtoToJSON
- export function feedResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/fieldfilterpartdto.ts
Tamaño: 3885 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export const Operator = {
  Larger: 'LARGER',
  Smaller: 'SMALLER',
  LargerEqual: 'LARGER_EQUAL',
  SmallerEqual: 'SMALLER_EQUAL',
  Equal: 'EQUAL',
  NotEqual: 'NOT_EQUAL',
  AllIn: 'ALL_IN',
  AnyIn: 'ANY_IN',
  NotIn: 'NOT_IN',
  Between: 'BETWEEN',
  NotBetween: 'NOT_BETWEEN',
  Like: 'LIKE',
  NotLike: 'NOT_LIKE',
  In: 'IN',
} as const;
export type Operator = ClosedEnum<typeof Operator>;

export const On = {
  Subscriber: 'subscriber',
  Payload: 'payload',
} as const;
export type On = ClosedEnum<typeof On>;

export type FieldFilterPartDto = {
  field: string;
  value: string;
  operator: Operator;
  on: On;
};

/** @internal */
export const Operator$inboundSchema: z.ZodNativeEnum<typeof Operator> = z.nativeEnum(Operator);

/** @internal */
export const Operator$outboundSchema: z.ZodNativeEnum<typeof Operator> = Operator$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Operator$ {
  /** @deprecated use `Operator$inboundSchema` instead. */
  export const inboundSchema = Operator$inboundSchema;
  /** @deprecated use `Operator$outboundSchema` instead. */
  export const outboundSchema = Operator$outboundSchema;
}

/** @internal */
export const On$inboundSchema: z.ZodNativeEnum<typeof On> = z.nativeEnum(On);

/** @internal */
export const On$outboundSchema: z.ZodNativeEnum<typeof On> = On$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace On$ {
  /** @deprecated use `On$inboundSchema` instead. */
  export const inboundSchema = On$inboundSchema;
  /** @deprecated use `On$outboundSchema` instead. */
  export const outboundSchema = On$outboundSchema;
}

/** @internal */
export const FieldFilterPartDto$inboundSchema: z.ZodType<FieldFilterPartDto, z.ZodTypeDef, unknown> = z.object({
  field: z.string(),
  value: z.string(),
  operator: Operator$inboundSchema,
  on: On$inboundSchema,
});

/** @internal */
export type FieldFilterPartDto$Outbound = {
  field: string;
  value: string;
  operator: string;
  on: string;
};

/** @internal */
export const FieldFilterPartDto$outboundSchema: z.ZodType<
  FieldFilterPartDto$Outbound,
  z.ZodTypeDef,
  FieldFilterPartDto
> = z.object({
  field: z.string(),
  value: z.string(),
  operator: Operator$outboundSchema,
  on: On$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FieldFilterPartDto$ {
  /** @deprecated use `FieldFilterPartDto$inboundSchema` instead. */
  export const inboundSchema = FieldFilterPartDto$inboundSchema;
  /** @deprecated use `FieldFilterPartDto$outboundSchema` instead. */
  export const outboundSchema = FieldFilterPartDto$outboundSchema;
  /** @deprecated use `FieldFilterPartDto$Outbound` instead. */
  export type Outbound = FieldFilterPartDto$Outbound;
}

export function fieldFilterPartDtoToJSON(fieldFilterPartDto: FieldFilterPartDto): string {
  return JSON.stringify(FieldFilterPartDto$outboundSchema.parse(fieldFilterPartDto));
}

export function fieldFilterPartDtoFromJSON(
  jsonString: string
): SafeParseResult<FieldFilterPartDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FieldFilterPartDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FieldFilterPartDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - fieldFilterPartDtoToJSON(fieldFilterPartDto: FieldFilterPartDto)
 - fieldFilterPartDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(FieldFilterPartDto$Outbound;
}

export function fieldFilterPartDtoToJSON(fieldFilterPartDto: FieldFi...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function fieldFilterPartDtoToJSON
- export function fieldFilterPartDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/generatelayoutpreviewresponsedto.ts
Tamaño: 6729 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  EmailLayoutRenderOutput,
  EmailLayoutRenderOutput$inboundSchema,
  EmailLayoutRenderOutput$Outbound,
  EmailLayoutRenderOutput$outboundSchema,
} from './emaillayoutrenderoutput.js';
import {
  LayoutPreviewPayloadDto,
  LayoutPreviewPayloadDto$inboundSchema,
  LayoutPreviewPayloadDto$Outbound,
  LayoutPreviewPayloadDto$outboundSchema,
} from './layoutpreviewpayloaddto.js';

export const ResultType = {
  Email: 'email',
} as const;
export type ResultType = ClosedEnum<typeof ResultType>;

export type One = {
  type?: ResultType | undefined;
  preview?: EmailLayoutRenderOutput | undefined;
};

/**
 * Preview result
 */
export type Result = One;

export type GenerateLayoutPreviewResponseDto = {
  /**
   * Preview payload example
   */
  previewPayloadExample: LayoutPreviewPayloadDto;
  /**
   * The payload schema that was used to generate the preview payload example
   */
  schema?: { [k: string]: any } | null | undefined;
  /**
   * Preview result
   */
  result: One;
};

/** @internal */
export const ResultType$inboundSchema: z.ZodNativeEnum<typeof ResultType> = z.nativeEnum(ResultType);

/** @internal */
export const ResultType$outboundSchema: z.ZodNativeEnum<typeof ResultType> = ResultType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResultType$ {
  /** @deprecated use `ResultType$inboundSchema` instead. */
  export const inboundSchema = ResultType$inboundSchema;
  /** @deprecated use `ResultType$outboundSchema` instead. */
  export const outboundSchema = ResultType$outboundSchema;
}

/** @internal */
export const One$inboundSchema: z.ZodType<One, z.ZodTypeDef, unknown> = z.object({
  type: ResultType$inboundSchema.optional(),
  preview: EmailLayoutRenderOutput$inboundSchema.optional(),
});

/** @internal */
export type One$Outbound = {
  type?: string | undefined;
  preview?: EmailLayoutRenderOutput$Outbound | undefined;
};

/** @internal */
export const One$outboundSchema: z.ZodType<One$Outbound, z.ZodTypeDef, One> = z.object({
  type: ResultType$outboundSchema.optional(),
  preview: EmailLayoutRenderOutput$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace One$ {
  /** @deprecated use `One$inboundSchema` instead. */
  export const inboundSchema = One$inboundSchema;
  /** @deprecated use `One$outboundSchema` instead. */
  export const outboundSchema = One$outboundSchema;
  /** @deprecated use `One$Outbound` instead. */
  export type Outbound = One$Outbound;
}

export function oneToJSON(one: One): string {
  return JSON.stringify(One$outboundSchema.parse(one));
}

export function oneFromJSON(jsonString: string): SafeParseResult<One, SDKValidationError> {
  return safeParse(jsonString, (x) => One$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'One' from JSON`);
}

/** @internal */
export const Result$inboundSchema: z.ZodType<Result, z.ZodTypeDef, unknown> = z.lazy(() => One$inboundSchema);

/** @internal */
export type Result$Outbound = One$Outbound;

/** @internal */
export const Result$outboundSchema: z.ZodType<Result$Outbound, z.ZodTypeDef, Result> = z.lazy(() => One$outboundSchema);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Result$ {
  /** @deprecated use `Result$inboundSchema` instead. */
  export const inboundSchema = Result$inboundSchema;
  /** @deprecated use `Result$outboundSchema` instead. */
  export const outboundSchema = Result$outboundSchema;
  /** @deprecated use `Result$Outbound` instead. */
  export type Outbound = Result$Outbound;
}

export function resultToJSON(result: Result): string {
  return JSON.stringify(Result$outboundSchema.parse(result));
}

export function resultFromJSON(jsonString: string): SafeParseResult<Result, SDKValidationError> {
  return safeParse(jsonString, (x) => Result$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Result' from JSON`);
}

/** @internal */
export const GenerateLayoutPreviewResponseDto$inboundSchema: z.ZodType<
  GenerateLayoutPreviewResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  previewPayloadExample: LayoutPreviewPayloadDto$inboundSchema,
  schema: z.nullable(z.record(z.any())).optional(),
  result: z.lazy(() => One$inboundSchema),
});

/** @internal */
export type GenerateLayoutPreviewResponseDto$Outbound = {
  previewPayloadExample: LayoutPreviewPayloadDto$Outbound;
  schema?: { [k: string]: any } | null | undefined;
  result: One$Outbound;
};

/** @internal */
export const GenerateLayoutPreviewResponseDto$outboundSchema: z.ZodType<
  GenerateLayoutPreviewResponseDto$Outbound,
  z.ZodTypeDef,
  GenerateLayoutPreviewResponseDto
> = z.object({
  previewPayloadExample: LayoutPreviewPayloadDto$outboundSchema,
  schema: z.nullable(z.record(z.any())).optional(),
  result: z.lazy(() => One$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GenerateLayoutPreviewResponseDto$ {
  /** @deprecated use `GenerateLayoutPreviewResponseDto$inboundSchema` instead. */
  export const inboundSchema = GenerateLayoutPreviewResponseDto$inboundSchema;
  /** @deprecated use `GenerateLayoutPreviewResponseDto$outboundSchema` instead. */
  export const outboundSchema = GenerateLayoutPreviewResponseDto$outboundSchema;
  /** @deprecated use `GenerateLayoutPreviewResponseDto$Outbound` instead. */
  export type Outbound = GenerateLayoutPreviewResponseDto$Outbound;
}

export function generateLayoutPreviewResponseDtoToJSON(
  generateLayoutPreviewResponseDto: GenerateLayoutPreviewResponseDto
): string {
  return JSON.stringify(GenerateLayoutPreviewResponseDto$outboundSchema.parse(generateLayoutPreviewResponseDto));
}

export function generateLayoutPreviewResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<GenerateLayoutPreviewResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateLayoutPreviewResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateLayoutPreviewResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - oneToJSON(one: One)
 - oneFromJSON(jsonString: string)
 - resultToJSON(result: Result)
 - resultFromJSON(jsonString: string)
 - generateLayoutPreviewResponseDtoToJSON(generateLayoutPreviewResponseDto: GenerateLayoutPreviewResponseDto)
 - generateLayoutPreviewResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(One$Outbound;
}

export function oneToJSON(one: One): string {
  return JSON.stringify(One$outboundS...)
 - Outbound(Result$Outbound;
}

export function resultToJSON(result: Result): string {
  return JSON.stringify(R...)
 - Outbound(GenerateLayoutPreviewResponseDto$Outbound;
}

export function generateLayoutPreviewResponseDtoToJSON...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function oneToJSON
- export function oneFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function resultToJSON
- export function resultFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function generateLayoutPreviewResponseDtoToJSON
- export function generateLayoutPreviewResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/generatepreviewrequestdto.ts
Tamaño: 2609 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  PreviewPayloadDto,
  PreviewPayloadDto$inboundSchema,
  PreviewPayloadDto$Outbound,
  PreviewPayloadDto$outboundSchema,
} from './previewpayloaddto.js';

export type GeneratePreviewRequestDto = {
  /**
   * Optional control values
   */
  controlValues?: { [k: string]: any } | undefined;
  /**
   * Optional payload for preview generation
   */
  previewPayload?: PreviewPayloadDto | undefined;
};

/** @internal */
export const GeneratePreviewRequestDto$inboundSchema: z.ZodType<GeneratePreviewRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    controlValues: z.record(z.any()).optional(),
    previewPayload: PreviewPayloadDto$inboundSchema.optional(),
  });

/** @internal */
export type GeneratePreviewRequestDto$Outbound = {
  controlValues?: { [k: string]: any } | undefined;
  previewPayload?: PreviewPayloadDto$Outbound | undefined;
};

/** @internal */
export const GeneratePreviewRequestDto$outboundSchema: z.ZodType<
  GeneratePreviewRequestDto$Outbound,
  z.ZodTypeDef,
  GeneratePreviewRequestDto
> = z.object({
  controlValues: z.record(z.any()).optional(),
  previewPayload: PreviewPayloadDto$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GeneratePreviewRequestDto$ {
  /** @deprecated use `GeneratePreviewRequestDto$inboundSchema` instead. */
  export const inboundSchema = GeneratePreviewRequestDto$inboundSchema;
  /** @deprecated use `GeneratePreviewRequestDto$outboundSchema` instead. */
  export const outboundSchema = GeneratePreviewRequestDto$outboundSchema;
  /** @deprecated use `GeneratePreviewRequestDto$Outbound` instead. */
  export type Outbound = GeneratePreviewRequestDto$Outbound;
}

export function generatePreviewRequestDtoToJSON(generatePreviewRequestDto: GeneratePreviewRequestDto): string {
  return JSON.stringify(GeneratePreviewRequestDto$outboundSchema.parse(generatePreviewRequestDto));
}

export function generatePreviewRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<GeneratePreviewRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GeneratePreviewRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GeneratePreviewRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - generatePreviewRequestDtoToJSON(generatePreviewRequestDto: GeneratePreviewRequestDto)
 - generatePreviewRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(GeneratePreviewRequestDto$Outbound;
}

export function generatePreviewRequestDtoToJSON(generatePrevi...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function generatePreviewRequestDtoToJSON
- export function generatePreviewRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/generatepreviewresponsedto.ts
Tamaño: 29528 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChatRenderOutput,
  ChatRenderOutput$inboundSchema,
  ChatRenderOutput$Outbound,
  ChatRenderOutput$outboundSchema,
} from './chatrenderoutput.js';
import {
  DigestRegularOutput,
  DigestRegularOutput$inboundSchema,
  DigestRegularOutput$Outbound,
  DigestRegularOutput$outboundSchema,
} from './digestregularoutput.js';
import {
  EmailRenderOutput,
  EmailRenderOutput$inboundSchema,
  EmailRenderOutput$Outbound,
  EmailRenderOutput$outboundSchema,
} from './emailrenderoutput.js';
import {
  InAppRenderOutput,
  InAppRenderOutput$inboundSchema,
  InAppRenderOutput$Outbound,
  InAppRenderOutput$outboundSchema,
} from './inapprenderoutput.js';
import {
  PreviewPayloadDto,
  PreviewPayloadDto$inboundSchema,
  PreviewPayloadDto$Outbound,
  PreviewPayloadDto$outboundSchema,
} from './previewpayloaddto.js';
import {
  PushRenderOutput,
  PushRenderOutput$inboundSchema,
  PushRenderOutput$Outbound,
  PushRenderOutput$outboundSchema,
} from './pushrenderoutput.js';
import {
  SmsRenderOutput,
  SmsRenderOutput$inboundSchema,
  SmsRenderOutput$Outbound,
  SmsRenderOutput$outboundSchema,
} from './smsrenderoutput.js';

export const GeneratePreviewResponseDtoResult9Type = {
  Digest: 'digest',
} as const;
export type GeneratePreviewResponseDtoResult9Type = ClosedEnum<typeof GeneratePreviewResponseDtoResult9Type>;

export type Nine = {
  type?: GeneratePreviewResponseDtoResult9Type | undefined;
  preview?: DigestRegularOutput | undefined;
};

export const GeneratePreviewResponseDtoResult8Type = {
  Delay: 'delay',
} as const;
export type GeneratePreviewResponseDtoResult8Type = ClosedEnum<typeof GeneratePreviewResponseDtoResult8Type>;

export type Eight = {
  type?: GeneratePreviewResponseDtoResult8Type | undefined;
  preview?: DigestRegularOutput | undefined;
};

export const GeneratePreviewResponseDtoResult7Type = {
  Chat: 'chat',
} as const;
export type GeneratePreviewResponseDtoResult7Type = ClosedEnum<typeof GeneratePreviewResponseDtoResult7Type>;

export type Seven = {
  type?: GeneratePreviewResponseDtoResult7Type | undefined;
  preview?: ChatRenderOutput | undefined;
};

export const GeneratePreviewResponseDtoResult6Type = {
  Push: 'push',
} as const;
export type GeneratePreviewResponseDtoResult6Type = ClosedEnum<typeof GeneratePreviewResponseDtoResult6Type>;

export type Six = {
  type?: GeneratePreviewResponseDtoResult6Type | undefined;
  preview?: PushRenderOutput | undefined;
};

export const GeneratePreviewResponseDtoResult5Type = {
  Sms: 'sms',
} as const;
export type GeneratePreviewResponseDtoResult5Type = ClosedEnum<typeof GeneratePreviewResponseDtoResult5Type>;

export type Result5 = {
  type?: GeneratePreviewResponseDtoResult5Type | undefined;
  preview?: SmsRenderOutput | undefined;
};

export const GeneratePreviewResponseDtoResult4Type = {
  InApp: 'in_app',
} as const;
export type GeneratePreviewResponseDtoResult4Type = ClosedEnum<typeof GeneratePreviewResponseDtoResult4Type>;

export type Result4 = {
  type?: GeneratePreviewResponseDtoResult4Type | undefined;
  preview?: InAppRenderOutput | undefined;
};

export const GeneratePreviewResponseDtoResult3Type = {
  Email: 'email',
} as const;
export type GeneratePreviewResponseDtoResult3Type = ClosedEnum<typeof GeneratePreviewResponseDtoResult3Type>;

export type Three = {
  type?: GeneratePreviewResponseDtoResult3Type | undefined;
  preview?: EmailRenderOutput | undefined;
};

export const GeneratePreviewResponseDtoResultType = {
  Email: 'email',
} as const;
export type GeneratePreviewResponseDtoResultType = ClosedEnum<typeof GeneratePreviewResponseDtoResultType>;

export type Result2 = {
  type?: GeneratePreviewResponseDtoResultType | undefined;
  preview?: EmailRenderOutput | undefined;
};

/**
 * Preview result
 */
export type GeneratePreviewResponseDtoResult =
  | { [k: string]: any }
  | Result2
  | Three
  | Result4
  | Result5
  | Six
  | Seven
  | Eight
  | Nine;

export type GeneratePreviewResponseDto = {
  /**
   * Preview payload example
   */
  previewPayloadExample: PreviewPayloadDto;
  /**
   * The payload schema that was used to generate the preview payload example
   */
  schema?: { [k: string]: any } | null | undefined;
  /**
   * Preview result
   */
  result: { [k: string]: any } | Result2 | Three | Result4 | Result5 | Six | Seven | Eight | Nine;
};

/** @internal */
export const GeneratePreviewResponseDtoResult9Type$inboundSchema: z.ZodNativeEnum<
  typeof GeneratePreviewResponseDtoResult9Type
> = z.nativeEnum(GeneratePreviewResponseDtoResult9Type);

/** @internal */
export const GeneratePreviewResponseDtoResult9Type$outboundSchema: z.ZodNativeEnum<
  typeof GeneratePreviewResponseDtoResult9Type
> = GeneratePreviewResponseDtoResult9Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GeneratePreviewResponseDtoResult9Type$ {
  /** @deprecated use `GeneratePreviewResponseDtoResult9Type$inboundSchema` instead. */
  export const inboundSchema = GeneratePreviewResponseDtoResult9Type$inboundSchema;
  /** @deprecated use `GeneratePreviewResponseDtoResult9Type$outboundSchema` instead. */
  export const outboundSchema = GeneratePreviewResponseDtoResult9Type$outboundSchema;
}

/** @internal */
export const Nine$inboundSchema: z.ZodType<Nine, z.ZodTypeDef, unknown> = z.object({
  type: GeneratePreviewResponseDtoResult9Type$inboundSchema.optional(),
  preview: DigestRegularOutput$inboundSchema.optional(),
});

/** @internal */
export type Nine$Outbound = {
  type?: string | undefined;
  preview?: DigestRegularOutput$Outbound | undefined;
};

/** @internal */
export const Nine$outboundSchema: z.ZodType<Nine$Outbound, z.ZodTypeDef, Nine> = z.object({
  type: GeneratePreviewResponseDtoResult9Type$outboundSchema.optional(),
  preview: DigestRegularOutput$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Nine$ {
  /** @deprecated use `Nine$inboundSchema` instead. */
  export const inboundSchema = Nine$inboundSchema;
  /** @deprecated use `Nine$outboundSchema` instead. */
  export const outboundSchema = Nine$outboundSchema;
  /** @deprecated use `Nine$Outbound` instead. */
  export type Outbound = Nine$Outbound;
}

export function nineToJSON(nine: Nine): string {
  return JSON.stringify(Nine$outboundSchema.parse(nine));
}

export function nineFromJSON(jsonString: string): SafeParseResult<Nine, SDKValidationError> {
  return safeParse(jsonString, (x) => Nine$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Nine' from JSON`);
}

/** @internal */
export const GeneratePreviewResponseDtoResult8Type$inboundSchema: z.ZodNativeEnum<
  typeof GeneratePreviewResponseDtoResult8Type
> = z.nativeEnum(GeneratePreviewResponseDtoResult8Type);

/** @internal */
export const GeneratePreviewResponseDtoResult8Type$outboundSchema: z.ZodNativeEnum<
  typeof GeneratePreviewResponseDtoResult8Type
> = GeneratePreviewResponseDtoResult8Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GeneratePreviewResponseDtoResult8Type$ {
  /** @deprecated use `GeneratePreviewResponseDtoResult8Type$inboundSchema` instead. */
  export const inboundSchema = GeneratePreviewResponseDtoResult8Type$inboundSchema;
  /** @deprecated use `GeneratePreviewResponseDtoResult8Type$outboundSchema` instead. */
  export const outboundSchema = GeneratePreviewResponseDtoResult8Type$outboundSchema;
}

/** @internal */
export const Eight$inboundSchema: z.ZodType<Eight, z.ZodTypeDef, unknown> = z.object({
  type: GeneratePreviewResponseDtoResult8Type$inboundSchema.optional(),
  preview: DigestRegularOutput$inboundSchema.optional(),
});

/** @internal */
export type Eight$Outbound = {
  type?: string | undefined;
  preview?: DigestRegularOutput$Outbound | undefined;
};

/** @internal */
export const Eight$outboundSchema: z.ZodType<Eight$Outbound, z.ZodTypeDef, Eight> = z.object({
  type: GeneratePreviewResponseDtoResult8Type$outboundSchema.optional(),
  preview: DigestRegularOutput$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Eight$ {
  /** @deprecated use `Eight$inboundSchema` instead. */
  export const inboundSchema = Eight$inboundSchema;
  /** @deprecated use `Eight$outboundSchema` instead. */
  export const outboundSchema = Eight$outboundSchema;
  /** @deprecated use `Eight$Outbound` instead. */
  export type Outbound = Eight$Outbound;
}

export function eightToJSON(eight: Eight): string {
  return JSON.stringify(Eight$outboundSchema.parse(eight));
}

export function eightFromJSON(jsonString: string): SafeParseResult<Eight, SDKValidationError> {
  return safeParse(jsonString, (x) => Eight$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Eight' from JSON`);
}

/** @internal */
export const GeneratePreviewResponseDtoResult7Type$inboundSchema: z.ZodNativeEnum<
  typeof GeneratePreviewResponseDtoResult7Type
> = z.nativeEnum(GeneratePreviewResponseDtoResult7Type);

/** @internal */
export const GeneratePreviewResponseDtoResult7Type$outboundSchema: z.ZodNativeEnum<
  typeof GeneratePreviewResponseDtoResult7Type
> = GeneratePreviewResponseDtoResult7Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GeneratePreviewResponseDtoResult7Type$ {
  /** @deprecated use `GeneratePreviewResponseDtoResult7Type$inboundSchema` instead. */
  export const inboundSchema = GeneratePreviewResponseDtoResult7Type$inboundSchema;
  /** @deprecated use `GeneratePreviewResponseDtoResult7Type$outboundSchema` instead. */
  export const outboundSchema = GeneratePreviewResponseDtoResult7Type$outboundSchema;
}

/** @internal */
export const Seven$inboundSchema: z.ZodType<Seven, z.ZodTypeDef, unknown> = z.object({
  type: GeneratePreviewResponseDtoResult7Type$inboundSchema.optional(),
  preview: ChatRenderOutput$inboundSchema.optional(),
});

/** @internal */
export type Seven$Outbound = {
  type?: string | undefined;
  preview?: ChatRenderOutput$Outbound | undefined;
};

/** @internal */
export const Seven$outboundSchema: z.ZodType<Seven$Outbound, z.ZodTypeDef, Seven> = z.object({
  type: GeneratePreviewResponseDtoResult7Type$outboundSchema.optional(),
  preview: ChatRenderOutput$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Seven$ {
  /** @deprecated use `Seven$inboundSchema` instead. */
  export const inboundSchema = Seven$inboundSchema;
  /** @deprecated use `Seven$outboundSchema` instead. */
  export const outboundSchema = Seven$outboundSchema;
  /** @deprecated use `Seven$Outbound` instead. */
  export type Outbound = Seven$Outbound;
}

export function sevenToJSON(seven: Seven): string {
  return JSON.stringify(Seven$outboundSchema.parse(seven));
}

export function sevenFromJSON(jsonString: string): SafeParseResult<Seven, SDKValidationError> {
  return safeParse(jsonString, (x) => Seven$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Seven' from JSON`);
}

/** @internal */
export const GeneratePreviewResponseDtoResult6Type$inboundSchema: z.ZodNativeEnum<
  typeof GeneratePreviewResponseDtoResult6Type
> = z.nativeEnum(GeneratePreviewResponseDtoResult6Type);

/** @internal */
export const GeneratePreviewResponseDtoResult6Type$outboundSchema: z.ZodNativeEnum<
  typeof GeneratePreviewResponseDtoResult6Type
> = GeneratePreviewResponseDtoResult6Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GeneratePreviewResponseDtoResult6Type$ {
  /** @deprecated use `GeneratePreviewResponseDtoResult6Type$inboundSchema` instead. */
  export const inboundSchema = GeneratePreviewResponseDtoResult6Type$inboundSchema;
  /** @deprecated use `GeneratePreviewResponseDtoResult6Type$outboundSchema` instead. */
  export const outboundSchema = GeneratePreviewResponseDtoResult6Type$outboundSchema;
}

/** @internal */
export const Six$inboundSchema: z.ZodType<Six, z.ZodTypeDef, unknown> = z.object({
  type: GeneratePreviewResponseDtoResult6Type$inboundSchema.optional(),
  preview: PushRenderOutput$inboundSchema.optional(),
});

/** @internal */
export type Six$Outbound = {
  type?: string | undefined;
  preview?: PushRenderOutput$Outbound | undefined;
};

/** @internal */
export const Six$outboundSchema: z.ZodType<Six$Outbound, z.ZodTypeDef, Six> = z.object({
  type: GeneratePreviewResponseDtoResult6Type$outboundSchema.optional(),
  preview: PushRenderOutput$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Six$ {
  /** @deprecated use `Six$inboundSchema` instead. */
  export const inboundSchema = Six$inboundSchema;
  /** @deprecated use `Six$outboundSchema` instead. */
  export const outboundSchema = Six$outboundSchema;
  /** @deprecated use `Six$Outbound` instead. */
  export type Outbound = Six$Outbound;
}

export function sixToJSON(six: Six): string {
  return JSON.stringify(Six$outboundSchema.parse(six));
}

export function sixFromJSON(jsonString: string): SafeParseResult<Six, SDKValidationError> {
  return safeParse(jsonString, (x) => Six$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Six' from JSON`);
}

/** @internal */
export const GeneratePreviewResponseDtoResult5Type$inboundSchema: z.ZodNativeEnum<
  typeof GeneratePreviewResponseDtoResult5Type
> = z.nativeEnum(GeneratePreviewResponseDtoResult5Type);

/** @internal */
export const GeneratePreviewResponseDtoResult5Type$outboundSchema: z.ZodNativeEnum<
  typeof GeneratePreviewResponseDtoResult5Type
> = GeneratePreviewResponseDtoResult5Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GeneratePreviewResponseDtoResult5Type$ {
  /** @deprecated use `GeneratePreviewResponseDtoResult5Type$inboundSchema` instead. */
  export const inboundSchema = GeneratePreviewResponseDtoResult5Type$inboundSchema;
  /** @deprecated use `GeneratePreviewResponseDtoResult5Type$outboundSchema` instead. */
  export const outboundSchema = GeneratePreviewResponseDtoResult5Type$outboundSchema;
}

/** @internal */
export const Result5$inboundSchema: z.ZodType<Result5, z.ZodTypeDef, unknown> = z.object({
  type: GeneratePreviewResponseDtoResult5Type$inboundSchema.optional(),
  preview: SmsRenderOutput$inboundSchema.optional(),
});

/** @internal */
export type Result5$Outbound = {
  type?: string | undefined;
  preview?: SmsRenderOutput$Outbound | undefined;
};

/** @internal */
export const Result5$outboundSchema: z.ZodType<Result5$Outbound, z.ZodTypeDef, Result5> = z.object({
  type: GeneratePreviewResponseDtoResult5Type$outboundSchema.optional(),
  preview: SmsRenderOutput$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Result5$ {
  /** @deprecated use `Result5$inboundSchema` instead. */
  export const inboundSchema = Result5$inboundSchema;
  /** @deprecated use `Result5$outboundSchema` instead. */
  export const outboundSchema = Result5$outboundSchema;
  /** @deprecated use `Result5$Outbound` instead. */
  export type Outbound = Result5$Outbound;
}

export function result5ToJSON(result5: Result5): string {
  return JSON.stringify(Result5$outboundSchema.parse(result5));
}

export function result5FromJSON(jsonString: string): SafeParseResult<Result5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Result5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Result5' from JSON`
  );
}

/** @internal */
export const GeneratePreviewResponseDtoResult4Type$inboundSchema: z.ZodNativeEnum<
  typeof GeneratePreviewResponseDtoResult4Type
> = z.nativeEnum(GeneratePreviewResponseDtoResult4Type);

/** @internal */
export const GeneratePreviewResponseDtoResult4Type$outboundSchema: z.ZodNativeEnum<
  typeof GeneratePreviewResponseDtoResult4Type
> = GeneratePreviewResponseDtoResult4Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GeneratePreviewResponseDtoResult4Type$ {
  /** @deprecated use `GeneratePreviewResponseDtoResult4Type$inboundSchema` instead. */
  export const inboundSchema = GeneratePreviewResponseDtoResult4Type$inboundSchema;
  /** @deprecated use `GeneratePreviewResponseDtoResult4Type$outboundSchema` instead. */
  export const outboundSchema = GeneratePreviewResponseDtoResult4Type$outboundSchema;
}

/** @internal */
export const Result4$inboundSchema: z.ZodType<Result4, z.ZodTypeDef, unknown> = z.object({
  type: GeneratePreviewResponseDtoResult4Type$inboundSchema.optional(),
  preview: InAppRenderOutput$inboundSchema.optional(),
});

/** @internal */
export type Result4$Outbound = {
  type?: string | undefined;
  preview?: InAppRenderOutput$Outbound | undefined;
};

/** @internal */
export const Result4$outboundSchema: z.ZodType<Result4$Outbound, z.ZodTypeDef, Result4> = z.object({
  type: GeneratePreviewResponseDtoResult4Type$outboundSchema.optional(),
  preview: InAppRenderOutput$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Result4$ {
  /** @deprecated use `Result4$inboundSchema` instead. */
  export const inboundSchema = Result4$inboundSchema;
  /** @deprecated use `Result4$outboundSchema` instead. */
  export const outboundSchema = Result4$outboundSchema;
  /** @deprecated use `Result4$Outbound` instead. */
  export type Outbound = Result4$Outbound;
}

export function result4ToJSON(result4: Result4): string {
  return JSON.stringify(Result4$outboundSchema.parse(result4));
}

export function result4FromJSON(jsonString: string): SafeParseResult<Result4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Result4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Result4' from JSON`
  );
}

/** @internal */
export const GeneratePreviewResponseDtoResult3Type$inboundSchema: z.ZodNativeEnum<
  typeof GeneratePreviewResponseDtoResult3Type
> = z.nativeEnum(GeneratePreviewResponseDtoResult3Type);

/** @internal */
export const GeneratePreviewResponseDtoResult3Type$outboundSchema: z.ZodNativeEnum<
  typeof GeneratePreviewResponseDtoResult3Type
> = GeneratePreviewResponseDtoResult3Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GeneratePreviewResponseDtoResult3Type$ {
  /** @deprecated use `GeneratePreviewResponseDtoResult3Type$inboundSchema` instead. */
  export const inboundSchema = GeneratePreviewResponseDtoResult3Type$inboundSchema;
  /** @deprecated use `GeneratePreviewResponseDtoResult3Type$outboundSchema` instead. */
  export const outboundSchema = GeneratePreviewResponseDtoResult3Type$outboundSchema;
}

/** @internal */
export const Three$inboundSchema: z.ZodType<Three, z.ZodTypeDef, unknown> = z.object({
  type: GeneratePreviewResponseDtoResult3Type$inboundSchema.optional(),
  preview: EmailRenderOutput$inboundSchema.optional(),
});

/** @internal */
export type Three$Outbound = {
  type?: string | undefined;
  preview?: EmailRenderOutput$Outbound | undefined;
};

/** @internal */
export const Three$outboundSchema: z.ZodType<Three$Outbound, z.ZodTypeDef, Three> = z.object({
  type: GeneratePreviewResponseDtoResult3Type$outboundSchema.optional(),
  preview: EmailRenderOutput$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Three$ {
  /** @deprecated use `Three$inboundSchema` instead. */
  export const inboundSchema = Three$inboundSchema;
  /** @deprecated use `Three$outboundSchema` instead. */
  export const outboundSchema = Three$outboundSchema;
  /** @deprecated use `Three$Outbound` instead. */
  export type Outbound = Three$Outbound;
}

export function threeToJSON(three: Three): string {
  return JSON.stringify(Three$outboundSchema.parse(three));
}

export function threeFromJSON(jsonString: string): SafeParseResult<Three, SDKValidationError> {
  return safeParse(jsonString, (x) => Three$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Three' from JSON`);
}

/** @internal */
export const GeneratePreviewResponseDtoResultType$inboundSchema: z.ZodNativeEnum<
  typeof GeneratePreviewResponseDtoResultType
> = z.nativeEnum(GeneratePreviewResponseDtoResultType);

/** @internal */
export const GeneratePreviewResponseDtoResultType$outboundSchema: z.ZodNativeEnum<
  typeof GeneratePreviewResponseDtoResultType
> = GeneratePreviewResponseDtoResultType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GeneratePreviewResponseDtoResultType$ {
  /** @deprecated use `GeneratePreviewResponseDtoResultType$inboundSchema` instead. */
  export const inboundSchema = GeneratePreviewResponseDtoResultType$inboundSchema;
  /** @deprecated use `GeneratePreviewResponseDtoResultType$outboundSchema` instead. */
  export const outboundSchema = GeneratePreviewResponseDtoResultType$outboundSchema;
}

/** @internal */
export const Result2$inboundSchema: z.ZodType<Result2, z.ZodTypeDef, unknown> = z.object({
  type: GeneratePreviewResponseDtoResultType$inboundSchema.optional(),
  preview: EmailRenderOutput$inboundSchema.optional(),
});

/** @internal */
export type Result2$Outbound = {
  type?: string | undefined;
  preview?: EmailRenderOutput$Outbound | undefined;
};

/** @internal */
export const Result2$outboundSchema: z.ZodType<Result2$Outbound, z.ZodTypeDef, Result2> = z.object({
  type: GeneratePreviewResponseDtoResultType$outboundSchema.optional(),
  preview: EmailRenderOutput$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Result2$ {
  /** @deprecated use `Result2$inboundSchema` instead. */
  export const inboundSchema = Result2$inboundSchema;
  /** @deprecated use `Result2$outboundSchema` instead. */
  export const outboundSchema = Result2$outboundSchema;
  /** @deprecated use `Result2$Outbound` instead. */
  export type Outbound = Result2$Outbound;
}

export function result2ToJSON(result2: Result2): string {
  return JSON.stringify(Result2$outboundSchema.parse(result2));
}

export function result2FromJSON(jsonString: string): SafeParseResult<Result2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Result2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Result2' from JSON`
  );
}

/** @internal */
export const GeneratePreviewResponseDtoResult$inboundSchema: z.ZodType<
  GeneratePreviewResponseDtoResult,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.record(z.any()),
  z.lazy(() => Result2$inboundSchema),
  z.lazy(() => Three$inboundSchema),
  z.lazy(() => Result4$inboundSchema),
  z.lazy(() => Result5$inboundSchema),
  z.lazy(() => Six$inboundSchema),
  z.lazy(() => Seven$inboundSchema),
  z.lazy(() => Eight$inboundSchema),
  z.lazy(() => Nine$inboundSchema),
]);

/** @internal */
export type GeneratePreviewResponseDtoResult$Outbound =
  | { [k: string]: any }
  | Result2$Outbound
  | Three$Outbound
  | Result4$Outbound
  | Result5$Outbound
  | Six$Outbound
  | Seven$Outbound
  | Eight$Outbound
  | Nine$Outbound;

/** @internal */
export const GeneratePreviewResponseDtoResult$outboundSchema: z.ZodType<
  GeneratePreviewResponseDtoResult$Outbound,
  z.ZodTypeDef,
  GeneratePreviewResponseDtoResult
> = z.union([
  z.record(z.any()),
  z.lazy(() => Result2$outboundSchema),
  z.lazy(() => Three$outboundSchema),
  z.lazy(() => Result4$outboundSchema),
  z.lazy(() => Result5$outboundSchema),
  z.lazy(() => Six$outboundSchema),
  z.lazy(() => Seven$outboundSchema),
  z.lazy(() => Eight$outboundSchema),
  z.lazy(() => Nine$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GeneratePreviewResponseDtoResult$ {
  /** @deprecated use `GeneratePreviewResponseDtoResult$inboundSchema` instead. */
  export const inboundSchema = GeneratePreviewResponseDtoResult$inboundSchema;
  /** @deprecated use `GeneratePreviewResponseDtoResult$outboundSchema` instead. */
  export const outboundSchema = GeneratePreviewResponseDtoResult$outboundSchema;
  /** @deprecated use `GeneratePreviewResponseDtoResult$Outbound` instead. */
  export type Outbound = GeneratePreviewResponseDtoResult$Outbound;
}

export function generatePreviewResponseDtoResultToJSON(
  generatePreviewResponseDtoResult: GeneratePreviewResponseDtoResult
): string {
  return JSON.stringify(GeneratePreviewResponseDtoResult$outboundSchema.parse(generatePreviewResponseDtoResult));
}

export function generatePreviewResponseDtoResultFromJSON(
  jsonString: string
): SafeParseResult<GeneratePreviewResponseDtoResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GeneratePreviewResponseDtoResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GeneratePreviewResponseDtoResult' from JSON`
  );
}

/** @internal */
export const GeneratePreviewResponseDto$inboundSchema: z.ZodType<GeneratePreviewResponseDto, z.ZodTypeDef, unknown> =
  z.object({
    previewPayloadExample: PreviewPayloadDto$inboundSchema,
    schema: z.nullable(z.record(z.any())).optional(),
    result: z.union([
      z.record(z.any()),
      z.lazy(() => Result2$inboundSchema),
      z.lazy(() => Three$inboundSchema),
      z.lazy(() => Result4$inboundSchema),
      z.lazy(() => Result5$inboundSchema),
      z.lazy(() => Six$inboundSchema),
      z.lazy(() => Seven$inboundSchema),
      z.lazy(() => Eight$inboundSchema),
      z.lazy(() => Nine$inboundSchema),
    ]),
  });

/** @internal */
export type GeneratePreviewResponseDto$Outbound = {
  previewPayloadExample: PreviewPayloadDto$Outbound;
  schema?: { [k: string]: any } | null | undefined;
  result:
    | { [k: string]: any }
    | Result2$Outbound
    | Three$Outbound
    | Result4$Outbound
    | Result5$Outbound
    | Six$Outbound
    | Seven$Outbound
    | Eight$Outbound
    | Nine$Outbound;
};

/** @internal */
export const GeneratePreviewResponseDto$outboundSchema: z.ZodType<
  GeneratePreviewResponseDto$Outbound,
  z.ZodTypeDef,
  GeneratePreviewResponseDto
> = z.object({
  previewPayloadExample: PreviewPayloadDto$outboundSchema,
  schema: z.nullable(z.record(z.any())).optional(),
  result: z.union([
    z.record(z.any()),
    z.lazy(() => Result2$outboundSchema),
    z.lazy(() => Three$outboundSchema),
    z.lazy(() => Result4$outboundSchema),
    z.lazy(() => Result5$outboundSchema),
    z.lazy(() => Six$outboundSchema),
    z.lazy(() => Seven$outboundSchema),
    z.lazy(() => Eight$outboundSchema),
    z.lazy(() => Nine$outboundSchema),
  ]),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GeneratePreviewResponseDto$ {
  /** @deprecated use `GeneratePreviewResponseDto$inboundSchema` instead. */
  export const inboundSchema = GeneratePreviewResponseDto$inboundSchema;
  /** @deprecated use `GeneratePreviewResponseDto$outboundSchema` instead. */
  export const outboundSchema = GeneratePreviewResponseDto$outboundSchema;
  /** @deprecated use `GeneratePreviewResponseDto$Outbound` instead. */
  export type Outbound = GeneratePreviewResponseDto$Outbound;
}

export function generatePreviewResponseDtoToJSON(generatePreviewResponseDto: GeneratePreviewResponseDto): string {
  return JSON.stringify(GeneratePreviewResponseDto$outboundSchema.parse(generatePreviewResponseDto));
}

export function generatePreviewResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<GeneratePreviewResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GeneratePreviewResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GeneratePreviewResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - nineToJSON(nine: Nine)
 - nineFromJSON(jsonString: string)
 - eightToJSON(eight: Eight)
 - eightFromJSON(jsonString: string)
 - sevenToJSON(seven: Seven)
 - sevenFromJSON(jsonString: string)
 - sixToJSON(six: Six)
 - sixFromJSON(jsonString: string)
 - result5ToJSON(result5: Result5)
 - result5FromJSON(jsonString: string)
 - result4ToJSON(result4: Result4)
 - result4FromJSON(jsonString: string)
 - threeToJSON(three: Three)
 - threeFromJSON(jsonString: string)
 - result2ToJSON(result2: Result2)
 - result2FromJSON(jsonString: string)
 - generatePreviewResponseDtoResultToJSON(generatePreviewResponseDtoResult: GeneratePreviewResponseDtoResult)
 - generatePreviewResponseDtoResultFromJSON(jsonString: string)
 - generatePreviewResponseDtoToJSON(generatePreviewResponseDto: GeneratePreviewResponseDto)
 - generatePreviewResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Nine$Outbound;
}

export function nineToJSON(nine: Nine): string {
  return JSON.stringify(Nine$outb...)
 - Outbound(Eight$Outbound;
}

export function eightToJSON(eight: Eight): string {
  return JSON.stringify(Eight...)
 - Outbound(Seven$Outbound;
}

export function sevenToJSON(seven: Seven): string {
  return JSON.stringify(Seven...)
 - Outbound(Six$Outbound;
}

export function sixToJSON(six: Six): string {
  return JSON.stringify(Six$outboundS...)
 - Outbound(Result5$Outbound;
}

export function result5ToJSON(result5: Result5): string {
  return JSON.stringi...)
 - Outbound(Result4$Outbound;
}

export function result4ToJSON(result4: Result4): string {
  return JSON.stringi...)
 - Outbound(Three$Outbound;
}

export function threeToJSON(three: Three): string {
  return JSON.stringify(Three...)
 - Outbound(Result2$Outbound;
}

export function result2ToJSON(result2: Result2): string {
  return JSON.stringi...)
 - Outbound(GeneratePreviewResponseDtoResult$Outbound;
}

export function generatePreviewResponseDtoResultToJSON...)
 - Outbound(GeneratePreviewResponseDto$Outbound;
}

export function generatePreviewResponseDtoToJSON(generatePre...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  type
- export  type
- export  const
- export  type
- export  type
- export  const
- export  type
- export  type
- export  const
- export  type
- export  type
- export  const
- export  type
- export  type
- export  const
- export  type
- export  type
- export  const
- export  type
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function nineToJSON
- export function nineFromJSON
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eightToJSON
- export function eightFromJSON
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function sevenToJSON
- export function sevenFromJSON
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function sixToJSON
- export function sixFromJSON
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function result5ToJSON
- export function result5FromJSON
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function result4ToJSON
- export function result4FromJSON
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function threeToJSON
- export function threeFromJSON
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function result2ToJSON
- export function result2FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function generatePreviewResponseDtoResultToJSON
- export function generatePreviewResponseDtoResultFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function generatePreviewResponseDtoToJSON
- export function generatePreviewResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/getchartsresponsedto.ts
Tamaño: 3645 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Chart sections
 */
export type GetChartsResponseDtoData = {};

export type GetChartsResponseDto = {
  /**
   * Chart sections
   */
  data: GetChartsResponseDtoData;
};

/** @internal */
export const GetChartsResponseDtoData$inboundSchema: z.ZodType<GetChartsResponseDtoData, z.ZodTypeDef, unknown> =
  z.object({});

/** @internal */
export type GetChartsResponseDtoData$Outbound = {};

/** @internal */
export const GetChartsResponseDtoData$outboundSchema: z.ZodType<
  GetChartsResponseDtoData$Outbound,
  z.ZodTypeDef,
  GetChartsResponseDtoData
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetChartsResponseDtoData$ {
  /** @deprecated use `GetChartsResponseDtoData$inboundSchema` instead. */
  export const inboundSchema = GetChartsResponseDtoData$inboundSchema;
  /** @deprecated use `GetChartsResponseDtoData$outboundSchema` instead. */
  export const outboundSchema = GetChartsResponseDtoData$outboundSchema;
  /** @deprecated use `GetChartsResponseDtoData$Outbound` instead. */
  export type Outbound = GetChartsResponseDtoData$Outbound;
}

export function getChartsResponseDtoDataToJSON(getChartsResponseDtoData: GetChartsResponseDtoData): string {
  return JSON.stringify(GetChartsResponseDtoData$outboundSchema.parse(getChartsResponseDtoData));
}

export function getChartsResponseDtoDataFromJSON(
  jsonString: string
): SafeParseResult<GetChartsResponseDtoData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetChartsResponseDtoData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetChartsResponseDtoData' from JSON`
  );
}

/** @internal */
export const GetChartsResponseDto$inboundSchema: z.ZodType<GetChartsResponseDto, z.ZodTypeDef, unknown> = z.object({
  data: z.lazy(() => GetChartsResponseDtoData$inboundSchema),
});

/** @internal */
export type GetChartsResponseDto$Outbound = {
  data: GetChartsResponseDtoData$Outbound;
};

/** @internal */
export const GetChartsResponseDto$outboundSchema: z.ZodType<
  GetChartsResponseDto$Outbound,
  z.ZodTypeDef,
  GetChartsResponseDto
> = z.object({
  data: z.lazy(() => GetChartsResponseDtoData$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetChartsResponseDto$ {
  /** @deprecated use `GetChartsResponseDto$inboundSchema` instead. */
  export const inboundSchema = GetChartsResponseDto$inboundSchema;
  /** @deprecated use `GetChartsResponseDto$outboundSchema` instead. */
  export const outboundSchema = GetChartsResponseDto$outboundSchema;
  /** @deprecated use `GetChartsResponseDto$Outbound` instead. */
  export type Outbound = GetChartsResponseDto$Outbound;
}

export function getChartsResponseDtoToJSON(getChartsResponseDto: GetChartsResponseDto): string {
  return JSON.stringify(GetChartsResponseDto$outboundSchema.parse(getChartsResponseDto));
}

export function getChartsResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<GetChartsResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetChartsResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetChartsResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getChartsResponseDtoDataToJSON(getChartsResponseDtoData: GetChartsResponseDtoData)
 - getChartsResponseDtoDataFromJSON(jsonString: string)
 - getChartsResponseDtoToJSON(getChartsResponseDto: GetChartsResponseDto)
 - getChartsResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(GetChartsResponseDtoData$Outbound;
}

export function getChartsResponseDtoDataToJSON(getChartsRespon...)
 - Outbound(GetChartsResponseDto$Outbound;
}

export function getChartsResponseDtoToJSON(getChartsResponseDto: G...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function getChartsResponseDtoDataToJSON
- export function getChartsResponseDtoDataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function getChartsResponseDtoToJSON
- export function getChartsResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/getcontextresponsedto.ts
Tamaño: 3957 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type GetContextResponseDtoData = {};

export type GetContextResponseDto = {
  type: string;
  id: string;
  data: GetContextResponseDtoData;
  createdAt: string;
  updatedAt: string;
};

/** @internal */
export const GetContextResponseDtoData$inboundSchema: z.ZodType<GetContextResponseDtoData, z.ZodTypeDef, unknown> =
  z.object({});

/** @internal */
export type GetContextResponseDtoData$Outbound = {};

/** @internal */
export const GetContextResponseDtoData$outboundSchema: z.ZodType<
  GetContextResponseDtoData$Outbound,
  z.ZodTypeDef,
  GetContextResponseDtoData
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetContextResponseDtoData$ {
  /** @deprecated use `GetContextResponseDtoData$inboundSchema` instead. */
  export const inboundSchema = GetContextResponseDtoData$inboundSchema;
  /** @deprecated use `GetContextResponseDtoData$outboundSchema` instead. */
  export const outboundSchema = GetContextResponseDtoData$outboundSchema;
  /** @deprecated use `GetContextResponseDtoData$Outbound` instead. */
  export type Outbound = GetContextResponseDtoData$Outbound;
}

export function getContextResponseDtoDataToJSON(getContextResponseDtoData: GetContextResponseDtoData): string {
  return JSON.stringify(GetContextResponseDtoData$outboundSchema.parse(getContextResponseDtoData));
}

export function getContextResponseDtoDataFromJSON(
  jsonString: string
): SafeParseResult<GetContextResponseDtoData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetContextResponseDtoData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetContextResponseDtoData' from JSON`
  );
}

/** @internal */
export const GetContextResponseDto$inboundSchema: z.ZodType<GetContextResponseDto, z.ZodTypeDef, unknown> = z.object({
  type: z.string(),
  id: z.string(),
  data: z.lazy(() => GetContextResponseDtoData$inboundSchema),
  createdAt: z.string(),
  updatedAt: z.string(),
});

/** @internal */
export type GetContextResponseDto$Outbound = {
  type: string;
  id: string;
  data: GetContextResponseDtoData$Outbound;
  createdAt: string;
  updatedAt: string;
};

/** @internal */
export const GetContextResponseDto$outboundSchema: z.ZodType<
  GetContextResponseDto$Outbound,
  z.ZodTypeDef,
  GetContextResponseDto
> = z.object({
  type: z.string(),
  id: z.string(),
  data: z.lazy(() => GetContextResponseDtoData$outboundSchema),
  createdAt: z.string(),
  updatedAt: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetContextResponseDto$ {
  /** @deprecated use `GetContextResponseDto$inboundSchema` instead. */
  export const inboundSchema = GetContextResponseDto$inboundSchema;
  /** @deprecated use `GetContextResponseDto$outboundSchema` instead. */
  export const outboundSchema = GetContextResponseDto$outboundSchema;
  /** @deprecated use `GetContextResponseDto$Outbound` instead. */
  export type Outbound = GetContextResponseDto$Outbound;
}

export function getContextResponseDtoToJSON(getContextResponseDto: GetContextResponseDto): string {
  return JSON.stringify(GetContextResponseDto$outboundSchema.parse(getContextResponseDto));
}

export function getContextResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<GetContextResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetContextResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetContextResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getContextResponseDtoDataToJSON(getContextResponseDtoData: GetContextResponseDtoData)
 - getContextResponseDtoDataFromJSON(jsonString: string)
 - getContextResponseDtoToJSON(getContextResponseDto: GetContextResponseDto)
 - getContextResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(GetContextResponseDtoData$Outbound;
}

export function getContextResponseDtoDataToJSON(getContextRes...)
 - Outbound(GetContextResponseDto$Outbound;
}

export function getContextResponseDtoToJSON(getContextResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function getContextResponseDtoDataToJSON
- export function getContextResponseDtoDataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function getContextResponseDtoToJSON
- export function getContextResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/getenvironmenttagsdto.ts
Tamaño: 1887 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type GetEnvironmentTagsDto = {
  name: string;
};

/** @internal */
export const GetEnvironmentTagsDto$inboundSchema: z.ZodType<GetEnvironmentTagsDto, z.ZodTypeDef, unknown> = z.object({
  name: z.string(),
});

/** @internal */
export type GetEnvironmentTagsDto$Outbound = {
  name: string;
};

/** @internal */
export const GetEnvironmentTagsDto$outboundSchema: z.ZodType<
  GetEnvironmentTagsDto$Outbound,
  z.ZodTypeDef,
  GetEnvironmentTagsDto
> = z.object({
  name: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetEnvironmentTagsDto$ {
  /** @deprecated use `GetEnvironmentTagsDto$inboundSchema` instead. */
  export const inboundSchema = GetEnvironmentTagsDto$inboundSchema;
  /** @deprecated use `GetEnvironmentTagsDto$outboundSchema` instead. */
  export const outboundSchema = GetEnvironmentTagsDto$outboundSchema;
  /** @deprecated use `GetEnvironmentTagsDto$Outbound` instead. */
  export type Outbound = GetEnvironmentTagsDto$Outbound;
}

export function getEnvironmentTagsDtoToJSON(getEnvironmentTagsDto: GetEnvironmentTagsDto): string {
  return JSON.stringify(GetEnvironmentTagsDto$outboundSchema.parse(getEnvironmentTagsDto));
}

export function getEnvironmentTagsDtoFromJSON(
  jsonString: string
): SafeParseResult<GetEnvironmentTagsDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetEnvironmentTagsDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetEnvironmentTagsDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getEnvironmentTagsDtoToJSON(getEnvironmentTagsDto: GetEnvironmentTagsDto)
 - getEnvironmentTagsDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(GetEnvironmentTagsDto$Outbound;
}

export function getEnvironmentTagsDtoToJSON(getEnvironmentTagsDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function getEnvironmentTagsDtoToJSON
- export function getEnvironmentTagsDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/getlayoutusageresponsedto.ts
Tamaño: 2314 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  WorkflowInfoDto,
  WorkflowInfoDto$inboundSchema,
  WorkflowInfoDto$Outbound,
  WorkflowInfoDto$outboundSchema,
} from './workflowinfodto.js';

export type GetLayoutUsageResponseDto = {
  /**
   * Array of workflows that use this layout
   */
  workflows: Array<WorkflowInfoDto>;
};

/** @internal */
export const GetLayoutUsageResponseDto$inboundSchema: z.ZodType<GetLayoutUsageResponseDto, z.ZodTypeDef, unknown> =
  z.object({
    workflows: z.array(WorkflowInfoDto$inboundSchema),
  });

/** @internal */
export type GetLayoutUsageResponseDto$Outbound = {
  workflows: Array<WorkflowInfoDto$Outbound>;
};

/** @internal */
export const GetLayoutUsageResponseDto$outboundSchema: z.ZodType<
  GetLayoutUsageResponseDto$Outbound,
  z.ZodTypeDef,
  GetLayoutUsageResponseDto
> = z.object({
  workflows: z.array(WorkflowInfoDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLayoutUsageResponseDto$ {
  /** @deprecated use `GetLayoutUsageResponseDto$inboundSchema` instead. */
  export const inboundSchema = GetLayoutUsageResponseDto$inboundSchema;
  /** @deprecated use `GetLayoutUsageResponseDto$outboundSchema` instead. */
  export const outboundSchema = GetLayoutUsageResponseDto$outboundSchema;
  /** @deprecated use `GetLayoutUsageResponseDto$Outbound` instead. */
  export type Outbound = GetLayoutUsageResponseDto$Outbound;
}

export function getLayoutUsageResponseDtoToJSON(getLayoutUsageResponseDto: GetLayoutUsageResponseDto): string {
  return JSON.stringify(GetLayoutUsageResponseDto$outboundSchema.parse(getLayoutUsageResponseDto));
}

export function getLayoutUsageResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<GetLayoutUsageResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLayoutUsageResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLayoutUsageResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getLayoutUsageResponseDtoToJSON(getLayoutUsageResponseDto: GetLayoutUsageResponseDto)
 - getLayoutUsageResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(GetLayoutUsageResponseDto$Outbound;
}

export function getLayoutUsageResponseDtoToJSON(getLayoutUsag...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function getLayoutUsageResponseDtoToJSON
- export function getLayoutUsageResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/getmasterjsonresponsedto.ts
Tamaño: 4942 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * All translations for given locale organized by workflow identifier
 */
export type Workflows = {};

/**
 * All translations for given locale organized by layout identifier
 */
export type Layouts = {};

export type GetMasterJsonResponseDto = {
  /**
   * All translations for given locale organized by workflow identifier
   */
  workflows: Workflows;
  /**
   * All translations for given locale organized by layout identifier
   */
  layouts: Layouts;
};

/** @internal */
export const Workflows$inboundSchema: z.ZodType<Workflows, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Workflows$Outbound = {};

/** @internal */
export const Workflows$outboundSchema: z.ZodType<Workflows$Outbound, z.ZodTypeDef, Workflows> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Workflows$ {
  /** @deprecated use `Workflows$inboundSchema` instead. */
  export const inboundSchema = Workflows$inboundSchema;
  /** @deprecated use `Workflows$outboundSchema` instead. */
  export const outboundSchema = Workflows$outboundSchema;
  /** @deprecated use `Workflows$Outbound` instead. */
  export type Outbound = Workflows$Outbound;
}

export function workflowsToJSON(workflows: Workflows): string {
  return JSON.stringify(Workflows$outboundSchema.parse(workflows));
}

export function workflowsFromJSON(jsonString: string): SafeParseResult<Workflows, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Workflows$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Workflows' from JSON`
  );
}

/** @internal */
export const Layouts$inboundSchema: z.ZodType<Layouts, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Layouts$Outbound = {};

/** @internal */
export const Layouts$outboundSchema: z.ZodType<Layouts$Outbound, z.ZodTypeDef, Layouts> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Layouts$ {
  /** @deprecated use `Layouts$inboundSchema` instead. */
  export const inboundSchema = Layouts$inboundSchema;
  /** @deprecated use `Layouts$outboundSchema` instead. */
  export const outboundSchema = Layouts$outboundSchema;
  /** @deprecated use `Layouts$Outbound` instead. */
  export type Outbound = Layouts$Outbound;
}

export function layoutsToJSON(layouts: Layouts): string {
  return JSON.stringify(Layouts$outboundSchema.parse(layouts));
}

export function layoutsFromJSON(jsonString: string): SafeParseResult<Layouts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Layouts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Layouts' from JSON`
  );
}

/** @internal */
export const GetMasterJsonResponseDto$inboundSchema: z.ZodType<GetMasterJsonResponseDto, z.ZodTypeDef, unknown> =
  z.object({
    workflows: z.lazy(() => Workflows$inboundSchema),
    layouts: z.lazy(() => Layouts$inboundSchema),
  });

/** @internal */
export type GetMasterJsonResponseDto$Outbound = {
  workflows: Workflows$Outbound;
  layouts: Layouts$Outbound;
};

/** @internal */
export const GetMasterJsonResponseDto$outboundSchema: z.ZodType<
  GetMasterJsonResponseDto$Outbound,
  z.ZodTypeDef,
  GetMasterJsonResponseDto
> = z.object({
  workflows: z.lazy(() => Workflows$outboundSchema),
  layouts: z.lazy(() => Layouts$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMasterJsonResponseDto$ {
  /** @deprecated use `GetMasterJsonResponseDto$inboundSchema` instead. */
  export const inboundSchema = GetMasterJsonResponseDto$inboundSchema;
  /** @deprecated use `GetMasterJsonResponseDto$outboundSchema` instead. */
  export const outboundSchema = GetMasterJsonResponseDto$outboundSchema;
  /** @deprecated use `GetMasterJsonResponseDto$Outbound` instead. */
  export type Outbound = GetMasterJsonResponseDto$Outbound;
}

export function getMasterJsonResponseDtoToJSON(getMasterJsonResponseDto: GetMasterJsonResponseDto): string {
  return JSON.stringify(GetMasterJsonResponseDto$outboundSchema.parse(getMasterJsonResponseDto));
}

export function getMasterJsonResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<GetMasterJsonResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMasterJsonResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMasterJsonResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowsToJSON(workflows: Workflows)
 - workflowsFromJSON(jsonString: string)
 - layoutsToJSON(layouts: Layouts)
 - layoutsFromJSON(jsonString: string)
 - getMasterJsonResponseDtoToJSON(getMasterJsonResponseDto: GetMasterJsonResponseDto)
 - getMasterJsonResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Workflows$Outbound;
}

export function workflowsToJSON(workflows: Workflows): string {
  return JSON...)
 - Outbound(Layouts$Outbound;
}

export function layoutsToJSON(layouts: Layouts): string {
  return JSON.stringi...)
 - Outbound(GetMasterJsonResponseDto$Outbound;
}

export function getMasterJsonResponseDtoToJSON(getMasterJsonRe...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowsToJSON
- export function workflowsFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsToJSON
- export function layoutsFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function getMasterJsonResponseDtoToJSON
- export function getMasterJsonResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/getpreferencesresponsedto.ts
Tamaño: 7649 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  PreferenceLevelEnum,
  PreferenceLevelEnum$inboundSchema,
  PreferenceLevelEnum$outboundSchema,
} from './preferencelevelenum.js';
import {
  SeverityLevelEnum,
  SeverityLevelEnum$inboundSchema,
  SeverityLevelEnum$outboundSchema,
} from './severitylevelenum.js';
import {
  SubscriberPreferenceChannels,
  SubscriberPreferenceChannels$inboundSchema,
  SubscriberPreferenceChannels$Outbound,
  SubscriberPreferenceChannels$outboundSchema,
} from './subscriberpreferencechannels.js';

/**
 * Custom data associated with the workflow
 */
export type GetPreferencesResponseDtoData = {};

/**
 * Workflow information if this is a template-level preference
 */
export type Workflow = {
  /**
   * Unique identifier of the workflow
   */
  id: string;
  /**
   * Workflow identifier used for triggering
   */
  identifier: string;
  /**
   * Human-readable name of the workflow
   */
  name: string;
  /**
   * Whether this workflow is marked as critical
   */
  critical: boolean;
  /**
   * Tags associated with the workflow
   */
  tags?: Array<string> | undefined;
  /**
   * Custom data associated with the workflow
   */
  data?: GetPreferencesResponseDtoData | undefined;
  /**
   * Severity of the workflow
   */
  severity: SeverityLevelEnum;
};

export type GetPreferencesResponseDto = {
  /**
   * The level of the preference (global or template)
   */
  level: PreferenceLevelEnum;
  /**
   * Workflow information if this is a template-level preference
   */
  workflow?: Workflow | null | undefined;
  /**
   * Whether the preference is enabled
   */
  enabled: boolean;
  /**
   * Channel-specific preference settings
   */
  channels: SubscriberPreferenceChannels;
};

/** @internal */
export const GetPreferencesResponseDtoData$inboundSchema: z.ZodType<
  GetPreferencesResponseDtoData,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type GetPreferencesResponseDtoData$Outbound = {};

/** @internal */
export const GetPreferencesResponseDtoData$outboundSchema: z.ZodType<
  GetPreferencesResponseDtoData$Outbound,
  z.ZodTypeDef,
  GetPreferencesResponseDtoData
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPreferencesResponseDtoData$ {
  /** @deprecated use `GetPreferencesResponseDtoData$inboundSchema` instead. */
  export const inboundSchema = GetPreferencesResponseDtoData$inboundSchema;
  /** @deprecated use `GetPreferencesResponseDtoData$outboundSchema` instead. */
  export const outboundSchema = GetPreferencesResponseDtoData$outboundSchema;
  /** @deprecated use `GetPreferencesResponseDtoData$Outbound` instead. */
  export type Outbound = GetPreferencesResponseDtoData$Outbound;
}

export function getPreferencesResponseDtoDataToJSON(
  getPreferencesResponseDtoData: GetPreferencesResponseDtoData
): string {
  return JSON.stringify(GetPreferencesResponseDtoData$outboundSchema.parse(getPreferencesResponseDtoData));
}

export function getPreferencesResponseDtoDataFromJSON(
  jsonString: string
): SafeParseResult<GetPreferencesResponseDtoData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPreferencesResponseDtoData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPreferencesResponseDtoData' from JSON`
  );
}

/** @internal */
export const Workflow$inboundSchema: z.ZodType<Workflow, z.ZodTypeDef, unknown> = z.object({
  id: z.string(),
  identifier: z.string(),
  name: z.string(),
  critical: z.boolean(),
  tags: z.array(z.string()).optional(),
  data: z.lazy(() => GetPreferencesResponseDtoData$inboundSchema).optional(),
  severity: SeverityLevelEnum$inboundSchema,
});

/** @internal */
export type Workflow$Outbound = {
  id: string;
  identifier: string;
  name: string;
  critical: boolean;
  tags?: Array<string> | undefined;
  data?: GetPreferencesResponseDtoData$Outbound | undefined;
  severity: string;
};

/** @internal */
export const Workflow$outboundSchema: z.ZodType<Workflow$Outbound, z.ZodTypeDef, Workflow> = z.object({
  id: z.string(),
  identifier: z.string(),
  name: z.string(),
  critical: z.boolean(),
  tags: z.array(z.string()).optional(),
  data: z.lazy(() => GetPreferencesResponseDtoData$outboundSchema).optional(),
  severity: SeverityLevelEnum$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Workflow$ {
  /** @deprecated use `Workflow$inboundSchema` instead. */
  export const inboundSchema = Workflow$inboundSchema;
  /** @deprecated use `Workflow$outboundSchema` instead. */
  export const outboundSchema = Workflow$outboundSchema;
  /** @deprecated use `Workflow$Outbound` instead. */
  export type Outbound = Workflow$Outbound;
}

export function workflowToJSON(workflow: Workflow): string {
  return JSON.stringify(Workflow$outboundSchema.parse(workflow));
}

export function workflowFromJSON(jsonString: string): SafeParseResult<Workflow, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Workflow$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Workflow' from JSON`
  );
}

/** @internal */
export const GetPreferencesResponseDto$inboundSchema: z.ZodType<GetPreferencesResponseDto, z.ZodTypeDef, unknown> =
  z.object({
    level: PreferenceLevelEnum$inboundSchema,
    workflow: z.nullable(z.lazy(() => Workflow$inboundSchema)).optional(),
    enabled: z.boolean(),
    channels: SubscriberPreferenceChannels$inboundSchema,
  });

/** @internal */
export type GetPreferencesResponseDto$Outbound = {
  level: string;
  workflow?: Workflow$Outbound | null | undefined;
  enabled: boolean;
  channels: SubscriberPreferenceChannels$Outbound;
};

/** @internal */
export const GetPreferencesResponseDto$outboundSchema: z.ZodType<
  GetPreferencesResponseDto$Outbound,
  z.ZodTypeDef,
  GetPreferencesResponseDto
> = z.object({
  level: PreferenceLevelEnum$outboundSchema,
  workflow: z.nullable(z.lazy(() => Workflow$outboundSchema)).optional(),
  enabled: z.boolean(),
  channels: SubscriberPreferenceChannels$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetPreferencesResponseDto$ {
  /** @deprecated use `GetPreferencesResponseDto$inboundSchema` instead. */
  export const inboundSchema = GetPreferencesResponseDto$inboundSchema;
  /** @deprecated use `GetPreferencesResponseDto$outboundSchema` instead. */
  export const outboundSchema = GetPreferencesResponseDto$outboundSchema;
  /** @deprecated use `GetPreferencesResponseDto$Outbound` instead. */
  export type Outbound = GetPreferencesResponseDto$Outbound;
}

export function getPreferencesResponseDtoToJSON(getPreferencesResponseDto: GetPreferencesResponseDto): string {
  return JSON.stringify(GetPreferencesResponseDto$outboundSchema.parse(getPreferencesResponseDto));
}

export function getPreferencesResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<GetPreferencesResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetPreferencesResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetPreferencesResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getPreferencesResponseDtoDataToJSON(getPreferencesResponseDtoData: GetPreferencesResponseDtoData)
 - getPreferencesResponseDtoDataFromJSON(jsonString: string)
 - workflowToJSON(workflow: Workflow)
 - workflowFromJSON(jsonString: string)
 - getPreferencesResponseDtoToJSON(getPreferencesResponseDto: GetPreferencesResponseDto)
 - getPreferencesResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(GetPreferencesResponseDtoData$Outbound;
}

export function getPreferencesResponseDtoDataToJSON(
  ge...)
 - Outbound(Workflow$Outbound;
}

export function workflowToJSON(workflow: Workflow): string {
  return JSON.str...)
 - Outbound(GetPreferencesResponseDto$Outbound;
}

export function getPreferencesResponseDtoToJSON(getPreference...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function getPreferencesResponseDtoDataToJSON
- export function getPreferencesResponseDtoDataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowToJSON
- export function workflowFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function getPreferencesResponseDtoToJSON
- export function getPreferencesResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/getrequestresponsedto.ts
Tamaño: 2582 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  RequestLogResponseDto,
  RequestLogResponseDto$inboundSchema,
  RequestLogResponseDto$Outbound,
  RequestLogResponseDto$outboundSchema,
} from './requestlogresponsedto.js';
import {
  TraceResponseDto,
  TraceResponseDto$inboundSchema,
  TraceResponseDto$Outbound,
  TraceResponseDto$outboundSchema,
} from './traceresponsedto.js';

export type GetRequestResponseDto = {
  /**
   * Request details
   */
  request: RequestLogResponseDto;
  /**
   * Associated traces
   */
  traces: Array<TraceResponseDto>;
};

/** @internal */
export const GetRequestResponseDto$inboundSchema: z.ZodType<GetRequestResponseDto, z.ZodTypeDef, unknown> = z.object({
  request: RequestLogResponseDto$inboundSchema,
  traces: z.array(TraceResponseDto$inboundSchema),
});

/** @internal */
export type GetRequestResponseDto$Outbound = {
  request: RequestLogResponseDto$Outbound;
  traces: Array<TraceResponseDto$Outbound>;
};

/** @internal */
export const GetRequestResponseDto$outboundSchema: z.ZodType<
  GetRequestResponseDto$Outbound,
  z.ZodTypeDef,
  GetRequestResponseDto
> = z.object({
  request: RequestLogResponseDto$outboundSchema,
  traces: z.array(TraceResponseDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRequestResponseDto$ {
  /** @deprecated use `GetRequestResponseDto$inboundSchema` instead. */
  export const inboundSchema = GetRequestResponseDto$inboundSchema;
  /** @deprecated use `GetRequestResponseDto$outboundSchema` instead. */
  export const outboundSchema = GetRequestResponseDto$outboundSchema;
  /** @deprecated use `GetRequestResponseDto$Outbound` instead. */
  export type Outbound = GetRequestResponseDto$Outbound;
}

export function getRequestResponseDtoToJSON(getRequestResponseDto: GetRequestResponseDto): string {
  return JSON.stringify(GetRequestResponseDto$outboundSchema.parse(getRequestResponseDto));
}

export function getRequestResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<GetRequestResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRequestResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRequestResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getRequestResponseDtoToJSON(getRequestResponseDto: GetRequestResponseDto)
 - getRequestResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(GetRequestResponseDto$Outbound;
}

export function getRequestResponseDtoToJSON(getRequestResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function getRequestResponseDtoToJSON
- export function getRequestResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/getrequestsresponsedto.ts
Tamaño: 2688 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  RequestLogResponseDto,
  RequestLogResponseDto$inboundSchema,
  RequestLogResponseDto$Outbound,
  RequestLogResponseDto$outboundSchema,
} from './requestlogresponsedto.js';

export type GetRequestsResponseDto = {
  /**
   * Request log data
   */
  data: Array<RequestLogResponseDto>;
  /**
   * Total number of requests
   */
  total: number;
  /**
   * Page size
   */
  pageSize?: number | undefined;
  /**
   * Current page number
   */
  page?: number | undefined;
};

/** @internal */
export const GetRequestsResponseDto$inboundSchema: z.ZodType<GetRequestsResponseDto, z.ZodTypeDef, unknown> = z.object({
  data: z.array(RequestLogResponseDto$inboundSchema),
  total: z.number(),
  pageSize: z.number().optional(),
  page: z.number().optional(),
});

/** @internal */
export type GetRequestsResponseDto$Outbound = {
  data: Array<RequestLogResponseDto$Outbound>;
  total: number;
  pageSize?: number | undefined;
  page?: number | undefined;
};

/** @internal */
export const GetRequestsResponseDto$outboundSchema: z.ZodType<
  GetRequestsResponseDto$Outbound,
  z.ZodTypeDef,
  GetRequestsResponseDto
> = z.object({
  data: z.array(RequestLogResponseDto$outboundSchema),
  total: z.number(),
  pageSize: z.number().optional(),
  page: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRequestsResponseDto$ {
  /** @deprecated use `GetRequestsResponseDto$inboundSchema` instead. */
  export const inboundSchema = GetRequestsResponseDto$inboundSchema;
  /** @deprecated use `GetRequestsResponseDto$outboundSchema` instead. */
  export const outboundSchema = GetRequestsResponseDto$outboundSchema;
  /** @deprecated use `GetRequestsResponseDto$Outbound` instead. */
  export type Outbound = GetRequestsResponseDto$Outbound;
}

export function getRequestsResponseDtoToJSON(getRequestsResponseDto: GetRequestsResponseDto): string {
  return JSON.stringify(GetRequestsResponseDto$outboundSchema.parse(getRequestsResponseDto));
}

export function getRequestsResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<GetRequestsResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRequestsResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRequestsResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getRequestsResponseDtoToJSON(getRequestsResponseDto: GetRequestsResponseDto)
 - getRequestsResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(GetRequestsResponseDto$Outbound;
}

export function getRequestsResponseDtoToJSON(getRequestsResponse...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function getRequestsResponseDtoToJSON
- export function getRequestsResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/getsubscriberpreferencesdto.ts
Tamaño: 2974 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  SubscriberGlobalPreferenceDto,
  SubscriberGlobalPreferenceDto$inboundSchema,
  SubscriberGlobalPreferenceDto$Outbound,
  SubscriberGlobalPreferenceDto$outboundSchema,
} from './subscriberglobalpreferencedto.js';
import {
  SubscriberWorkflowPreferenceDto,
  SubscriberWorkflowPreferenceDto$inboundSchema,
  SubscriberWorkflowPreferenceDto$Outbound,
  SubscriberWorkflowPreferenceDto$outboundSchema,
} from './subscriberworkflowpreferencedto.js';

export type GetSubscriberPreferencesDto = {
  /**
   * Global preference settings
   */
  global: SubscriberGlobalPreferenceDto;
  /**
   * Workflow-specific preference settings
   */
  workflows: Array<SubscriberWorkflowPreferenceDto>;
};

/** @internal */
export const GetSubscriberPreferencesDto$inboundSchema: z.ZodType<GetSubscriberPreferencesDto, z.ZodTypeDef, unknown> =
  z.object({
    global: SubscriberGlobalPreferenceDto$inboundSchema,
    workflows: z.array(SubscriberWorkflowPreferenceDto$inboundSchema),
  });

/** @internal */
export type GetSubscriberPreferencesDto$Outbound = {
  global: SubscriberGlobalPreferenceDto$Outbound;
  workflows: Array<SubscriberWorkflowPreferenceDto$Outbound>;
};

/** @internal */
export const GetSubscriberPreferencesDto$outboundSchema: z.ZodType<
  GetSubscriberPreferencesDto$Outbound,
  z.ZodTypeDef,
  GetSubscriberPreferencesDto
> = z.object({
  global: SubscriberGlobalPreferenceDto$outboundSchema,
  workflows: z.array(SubscriberWorkflowPreferenceDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetSubscriberPreferencesDto$ {
  /** @deprecated use `GetSubscriberPreferencesDto$inboundSchema` instead. */
  export const inboundSchema = GetSubscriberPreferencesDto$inboundSchema;
  /** @deprecated use `GetSubscriberPreferencesDto$outboundSchema` instead. */
  export const outboundSchema = GetSubscriberPreferencesDto$outboundSchema;
  /** @deprecated use `GetSubscriberPreferencesDto$Outbound` instead. */
  export type Outbound = GetSubscriberPreferencesDto$Outbound;
}

export function getSubscriberPreferencesDtoToJSON(getSubscriberPreferencesDto: GetSubscriberPreferencesDto): string {
  return JSON.stringify(GetSubscriberPreferencesDto$outboundSchema.parse(getSubscriberPreferencesDto));
}

export function getSubscriberPreferencesDtoFromJSON(
  jsonString: string
): SafeParseResult<GetSubscriberPreferencesDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetSubscriberPreferencesDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetSubscriberPreferencesDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getSubscriberPreferencesDtoToJSON(getSubscriberPreferencesDto: GetSubscriberPreferencesDto)
 - getSubscriberPreferencesDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(GetSubscriberPreferencesDto$Outbound;
}

export function getSubscriberPreferencesDtoToJSON(getSubscr...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function getSubscriberPreferencesDtoToJSON
- export function getSubscriberPreferencesDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/getworkflowrunresponsedto.ts
Tamaño: 10447 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { StepRunDto, StepRunDto$inboundSchema, StepRunDto$Outbound, StepRunDto$outboundSchema } from './steprundto.js';

/**
 * Workflow run status
 */
export const GetWorkflowRunResponseDtoStatus = {
  Processing: 'processing',
  Completed: 'completed',
  Error: 'error',
} as const;
/**
 * Workflow run status
 */
export type GetWorkflowRunResponseDtoStatus = ClosedEnum<typeof GetWorkflowRunResponseDtoStatus>;

/**
 * Workflow run delivery lifecycle status
 */
export const GetWorkflowRunResponseDtoDeliveryLifecycleStatus = {
  Pending: 'pending',
  Sent: 'sent',
  Errored: 'errored',
  Skipped: 'skipped',
  Canceled: 'canceled',
  Merged: 'merged',
  Delivered: 'delivered',
  Interacted: 'interacted',
} as const;
/**
 * Workflow run delivery lifecycle status
 */
export type GetWorkflowRunResponseDtoDeliveryLifecycleStatus = ClosedEnum<
  typeof GetWorkflowRunResponseDtoDeliveryLifecycleStatus
>;

/**
 * Severity
 */
export const GetWorkflowRunResponseDtoSeverity = {
  High: 'high',
  Medium: 'medium',
  Low: 'low',
  None: 'none',
} as const;
/**
 * Severity
 */
export type GetWorkflowRunResponseDtoSeverity = ClosedEnum<typeof GetWorkflowRunResponseDtoSeverity>;

/**
 * Trigger payload
 */
export type Payload = {};

export type GetWorkflowRunResponseDto = {
  /**
   * Workflow run id
   */
  id: string;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow name
   */
  workflowName: string;
  /**
   * Organization identifier
   */
  organizationId: string;
  /**
   * Environment identifier
   */
  environmentId: string;
  /**
   * Internal subscriber identifier
   */
  internalSubscriberId: string;
  /**
   * External subscriber identifier
   */
  subscriberId?: string | undefined;
  /**
   * Workflow run status
   */
  status: GetWorkflowRunResponseDtoStatus;
  /**
   * Workflow run delivery lifecycle status
   */
  deliveryLifecycleStatus: GetWorkflowRunResponseDtoDeliveryLifecycleStatus;
  /**
   * Trigger identifier
   */
  triggerIdentifier: string;
  /**
   * Transaction identifier
   */
  transactionId: string;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * Update timestamp
   */
  updatedAt: string;
  /**
   * Severity
   */
  severity: GetWorkflowRunResponseDtoSeverity;
  /**
   * Critical flag
   */
  critical: boolean;
  /**
   * Contexts (keys) in which the workflow run was executed
   */
  contextKeys?: Array<string> | undefined;
  /**
   * Step runs
   */
  steps: Array<StepRunDto>;
  /**
   * Trigger payload
   */
  payload: Payload;
};

/** @internal */
export const GetWorkflowRunResponseDtoStatus$inboundSchema: z.ZodNativeEnum<typeof GetWorkflowRunResponseDtoStatus> =
  z.nativeEnum(GetWorkflowRunResponseDtoStatus);

/** @internal */
export const GetWorkflowRunResponseDtoStatus$outboundSchema: z.ZodNativeEnum<typeof GetWorkflowRunResponseDtoStatus> =
  GetWorkflowRunResponseDtoStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetWorkflowRunResponseDtoStatus$ {
  /** @deprecated use `GetWorkflowRunResponseDtoStatus$inboundSchema` instead. */
  export const inboundSchema = GetWorkflowRunResponseDtoStatus$inboundSchema;
  /** @deprecated use `GetWorkflowRunResponseDtoStatus$outboundSchema` instead. */
  export const outboundSchema = GetWorkflowRunResponseDtoStatus$outboundSchema;
}

/** @internal */
export const GetWorkflowRunResponseDtoDeliveryLifecycleStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetWorkflowRunResponseDtoDeliveryLifecycleStatus
> = z.nativeEnum(GetWorkflowRunResponseDtoDeliveryLifecycleStatus);

/** @internal */
export const GetWorkflowRunResponseDtoDeliveryLifecycleStatus$outboundSchema: z.ZodNativeEnum<
  typeof GetWorkflowRunResponseDtoDeliveryLifecycleStatus
> = GetWorkflowRunResponseDtoDeliveryLifecycleStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetWorkflowRunResponseDtoDeliveryLifecycleStatus$ {
  /** @deprecated use `GetWorkflowRunResponseDtoDeliveryLifecycleStatus$inboundSchema` instead. */
  export const inboundSchema = GetWorkflowRunResponseDtoDeliveryLifecycleStatus$inboundSchema;
  /** @deprecated use `GetWorkflowRunResponseDtoDeliveryLifecycleStatus$outboundSchema` instead. */
  export const outboundSchema = GetWorkflowRunResponseDtoDeliveryLifecycleStatus$outboundSchema;
}

/** @internal */
export const GetWorkflowRunResponseDtoSeverity$inboundSchema: z.ZodNativeEnum<
  typeof GetWorkflowRunResponseDtoSeverity
> = z.nativeEnum(GetWorkflowRunResponseDtoSeverity);

/** @internal */
export const GetWorkflowRunResponseDtoSeverity$outboundSchema: z.ZodNativeEnum<
  typeof GetWorkflowRunResponseDtoSeverity
> = GetWorkflowRunResponseDtoSeverity$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetWorkflowRunResponseDtoSeverity$ {
  /** @deprecated use `GetWorkflowRunResponseDtoSeverity$inboundSchema` instead. */
  export const inboundSchema = GetWorkflowRunResponseDtoSeverity$inboundSchema;
  /** @deprecated use `GetWorkflowRunResponseDtoSeverity$outboundSchema` instead. */
  export const outboundSchema = GetWorkflowRunResponseDtoSeverity$outboundSchema;
}

/** @internal */
export const Payload$inboundSchema: z.ZodType<Payload, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Payload$Outbound = {};

/** @internal */
export const Payload$outboundSchema: z.ZodType<Payload$Outbound, z.ZodTypeDef, Payload> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Payload$ {
  /** @deprecated use `Payload$inboundSchema` instead. */
  export const inboundSchema = Payload$inboundSchema;
  /** @deprecated use `Payload$outboundSchema` instead. */
  export const outboundSchema = Payload$outboundSchema;
  /** @deprecated use `Payload$Outbound` instead. */
  export type Outbound = Payload$Outbound;
}

export function payloadToJSON(payload: Payload): string {
  return JSON.stringify(Payload$outboundSchema.parse(payload));
}

export function payloadFromJSON(jsonString: string): SafeParseResult<Payload, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Payload$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Payload' from JSON`
  );
}

/** @internal */
export const GetWorkflowRunResponseDto$inboundSchema: z.ZodType<GetWorkflowRunResponseDto, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    workflowId: z.string(),
    workflowName: z.string(),
    organizationId: z.string(),
    environmentId: z.string(),
    internalSubscriberId: z.string(),
    subscriberId: z.string().optional(),
    status: GetWorkflowRunResponseDtoStatus$inboundSchema,
    deliveryLifecycleStatus: GetWorkflowRunResponseDtoDeliveryLifecycleStatus$inboundSchema,
    triggerIdentifier: z.string(),
    transactionId: z.string(),
    createdAt: z.string(),
    updatedAt: z.string(),
    severity: GetWorkflowRunResponseDtoSeverity$inboundSchema,
    critical: z.boolean(),
    contextKeys: z.array(z.string()).optional(),
    steps: z.array(StepRunDto$inboundSchema),
    payload: z.lazy(() => Payload$inboundSchema),
  });

/** @internal */
export type GetWorkflowRunResponseDto$Outbound = {
  id: string;
  workflowId: string;
  workflowName: string;
  organizationId: string;
  environmentId: string;
  internalSubscriberId: string;
  subscriberId?: string | undefined;
  status: string;
  deliveryLifecycleStatus: string;
  triggerIdentifier: string;
  transactionId: string;
  createdAt: string;
  updatedAt: string;
  severity: string;
  critical: boolean;
  contextKeys?: Array<string> | undefined;
  steps: Array<StepRunDto$Outbound>;
  payload: Payload$Outbound;
};

/** @internal */
export const GetWorkflowRunResponseDto$outboundSchema: z.ZodType<
  GetWorkflowRunResponseDto$Outbound,
  z.ZodTypeDef,
  GetWorkflowRunResponseDto
> = z.object({
  id: z.string(),
  workflowId: z.string(),
  workflowName: z.string(),
  organizationId: z.string(),
  environmentId: z.string(),
  internalSubscriberId: z.string(),
  subscriberId: z.string().optional(),
  status: GetWorkflowRunResponseDtoStatus$outboundSchema,
  deliveryLifecycleStatus: GetWorkflowRunResponseDtoDeliveryLifecycleStatus$outboundSchema,
  triggerIdentifier: z.string(),
  transactionId: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
  severity: GetWorkflowRunResponseDtoSeverity$outboundSchema,
  critical: z.boolean(),
  contextKeys: z.array(z.string()).optional(),
  steps: z.array(StepRunDto$outboundSchema),
  payload: z.lazy(() => Payload$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetWorkflowRunResponseDto$ {
  /** @deprecated use `GetWorkflowRunResponseDto$inboundSchema` instead. */
  export const inboundSchema = GetWorkflowRunResponseDto$inboundSchema;
  /** @deprecated use `GetWorkflowRunResponseDto$outboundSchema` instead. */
  export const outboundSchema = GetWorkflowRunResponseDto$outboundSchema;
  /** @deprecated use `GetWorkflowRunResponseDto$Outbound` instead. */
  export type Outbound = GetWorkflowRunResponseDto$Outbound;
}

export function getWorkflowRunResponseDtoToJSON(getWorkflowRunResponseDto: GetWorkflowRunResponseDto): string {
  return JSON.stringify(GetWorkflowRunResponseDto$outboundSchema.parse(getWorkflowRunResponseDto));
}

export function getWorkflowRunResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<GetWorkflowRunResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetWorkflowRunResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetWorkflowRunResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - payloadToJSON(payload: Payload)
 - payloadFromJSON(jsonString: string)
 - getWorkflowRunResponseDtoToJSON(getWorkflowRunResponseDto: GetWorkflowRunResponseDto)
 - getWorkflowRunResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Payload$Outbound;
}

export function payloadToJSON(payload: Payload): string {
  return JSON.stringi...)
 - Outbound(GetWorkflowRunResponseDto$Outbound;
}

export function getWorkflowRunResponseDtoToJSON(getWorkflowRu...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function payloadToJSON
- export function payloadFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function getWorkflowRunResponseDtoToJSON
- export function getWorkflowRunResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/getworkflowrunsdto.ts
Tamaño: 8029 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  WorkflowRunStepsDetailsDto,
  WorkflowRunStepsDetailsDto$inboundSchema,
  WorkflowRunStepsDetailsDto$Outbound,
  WorkflowRunStepsDetailsDto$outboundSchema,
} from './workflowrunstepsdetailsdto.js';

/**
 * Workflow run status
 */
export const GetWorkflowRunsDtoStatus = {
  Processing: 'processing',
  Completed: 'completed',
  Error: 'error',
} as const;
/**
 * Workflow run status
 */
export type GetWorkflowRunsDtoStatus = ClosedEnum<typeof GetWorkflowRunsDtoStatus>;

/**
 * Workflow run delivery lifecycle status
 */
export const DeliveryLifecycleStatus = {
  Pending: 'pending',
  Sent: 'sent',
  Errored: 'errored',
  Skipped: 'skipped',
  Canceled: 'canceled',
  Merged: 'merged',
  Delivered: 'delivered',
  Interacted: 'interacted',
} as const;
/**
 * Workflow run delivery lifecycle status
 */
export type DeliveryLifecycleStatus = ClosedEnum<typeof DeliveryLifecycleStatus>;

/**
 * Severity
 */
export const Severity = {
  High: 'high',
  Medium: 'medium',
  Low: 'low',
  None: 'none',
} as const;
/**
 * Severity
 */
export type Severity = ClosedEnum<typeof Severity>;

export type GetWorkflowRunsDto = {
  /**
   * Workflow run id
   */
  id: string;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow name
   */
  workflowName: string;
  /**
   * Organization identifier
   */
  organizationId: string;
  /**
   * Environment identifier
   */
  environmentId: string;
  /**
   * Internal subscriber identifier
   */
  internalSubscriberId: string;
  /**
   * External subscriber identifier
   */
  subscriberId?: string | undefined;
  /**
   * Workflow run status
   */
  status: GetWorkflowRunsDtoStatus;
  /**
   * Workflow run delivery lifecycle status
   */
  deliveryLifecycleStatus: DeliveryLifecycleStatus;
  /**
   * Trigger identifier
   */
  triggerIdentifier: string;
  /**
   * Transaction identifier
   */
  transactionId: string;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * Update timestamp
   */
  updatedAt: string;
  /**
   * Severity
   */
  severity: Severity;
  /**
   * Critical flag
   */
  critical: boolean;
  /**
   * Contexts (keys) in which the workflow run was executed
   */
  contextKeys?: Array<string> | undefined;
  /**
   * Workflow run steps
   */
  steps: Array<WorkflowRunStepsDetailsDto>;
};

/** @internal */
export const GetWorkflowRunsDtoStatus$inboundSchema: z.ZodNativeEnum<typeof GetWorkflowRunsDtoStatus> =
  z.nativeEnum(GetWorkflowRunsDtoStatus);

/** @internal */
export const GetWorkflowRunsDtoStatus$outboundSchema: z.ZodNativeEnum<typeof GetWorkflowRunsDtoStatus> =
  GetWorkflowRunsDtoStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetWorkflowRunsDtoStatus$ {
  /** @deprecated use `GetWorkflowRunsDtoStatus$inboundSchema` instead. */
  export const inboundSchema = GetWorkflowRunsDtoStatus$inboundSchema;
  /** @deprecated use `GetWorkflowRunsDtoStatus$outboundSchema` instead. */
  export const outboundSchema = GetWorkflowRunsDtoStatus$outboundSchema;
}

/** @internal */
export const DeliveryLifecycleStatus$inboundSchema: z.ZodNativeEnum<typeof DeliveryLifecycleStatus> =
  z.nativeEnum(DeliveryLifecycleStatus);

/** @internal */
export const DeliveryLifecycleStatus$outboundSchema: z.ZodNativeEnum<typeof DeliveryLifecycleStatus> =
  DeliveryLifecycleStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeliveryLifecycleStatus$ {
  /** @deprecated use `DeliveryLifecycleStatus$inboundSchema` instead. */
  export const inboundSchema = DeliveryLifecycleStatus$inboundSchema;
  /** @deprecated use `DeliveryLifecycleStatus$outboundSchema` instead. */
  export const outboundSchema = DeliveryLifecycleStatus$outboundSchema;
}

/** @internal */
export const Severity$inboundSchema: z.ZodNativeEnum<typeof Severity> = z.nativeEnum(Severity);

/** @internal */
export const Severity$outboundSchema: z.ZodNativeEnum<typeof Severity> = Severity$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Severity$ {
  /** @deprecated use `Severity$inboundSchema` instead. */
  export const inboundSchema = Severity$inboundSchema;
  /** @deprecated use `Severity$outboundSchema` instead. */
  export const outboundSchema = Severity$outboundSchema;
}

/** @internal */
export const GetWorkflowRunsDto$inboundSchema: z.ZodType<GetWorkflowRunsDto, z.ZodTypeDef, unknown> = z.object({
  id: z.string(),
  workflowId: z.string(),
  workflowName: z.string(),
  organizationId: z.string(),
  environmentId: z.string(),
  internalSubscriberId: z.string(),
  subscriberId: z.string().optional(),
  status: GetWorkflowRunsDtoStatus$inboundSchema,
  deliveryLifecycleStatus: DeliveryLifecycleStatus$inboundSchema,
  triggerIdentifier: z.string(),
  transactionId: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
  severity: Severity$inboundSchema,
  critical: z.boolean(),
  contextKeys: z.array(z.string()).optional(),
  steps: z.array(WorkflowRunStepsDetailsDto$inboundSchema),
});

/** @internal */
export type GetWorkflowRunsDto$Outbound = {
  id: string;
  workflowId: string;
  workflowName: string;
  organizationId: string;
  environmentId: string;
  internalSubscriberId: string;
  subscriberId?: string | undefined;
  status: string;
  deliveryLifecycleStatus: string;
  triggerIdentifier: string;
  transactionId: string;
  createdAt: string;
  updatedAt: string;
  severity: string;
  critical: boolean;
  contextKeys?: Array<string> | undefined;
  steps: Array<WorkflowRunStepsDetailsDto$Outbound>;
};

/** @internal */
export const GetWorkflowRunsDto$outboundSchema: z.ZodType<
  GetWorkflowRunsDto$Outbound,
  z.ZodTypeDef,
  GetWorkflowRunsDto
> = z.object({
  id: z.string(),
  workflowId: z.string(),
  workflowName: z.string(),
  organizationId: z.string(),
  environmentId: z.string(),
  internalSubscriberId: z.string(),
  subscriberId: z.string().optional(),
  status: GetWorkflowRunsDtoStatus$outboundSchema,
  deliveryLifecycleStatus: DeliveryLifecycleStatus$outboundSchema,
  triggerIdentifier: z.string(),
  transactionId: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
  severity: Severity$outboundSchema,
  critical: z.boolean(),
  contextKeys: z.array(z.string()).optional(),
  steps: z.array(WorkflowRunStepsDetailsDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetWorkflowRunsDto$ {
  /** @deprecated use `GetWorkflowRunsDto$inboundSchema` instead. */
  export const inboundSchema = GetWorkflowRunsDto$inboundSchema;
  /** @deprecated use `GetWorkflowRunsDto$outboundSchema` instead. */
  export const outboundSchema = GetWorkflowRunsDto$outboundSchema;
  /** @deprecated use `GetWorkflowRunsDto$Outbound` instead. */
  export type Outbound = GetWorkflowRunsDto$Outbound;
}

export function getWorkflowRunsDtoToJSON(getWorkflowRunsDto: GetWorkflowRunsDto): string {
  return JSON.stringify(GetWorkflowRunsDto$outboundSchema.parse(getWorkflowRunsDto));
}

export function getWorkflowRunsDtoFromJSON(
  jsonString: string
): SafeParseResult<GetWorkflowRunsDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetWorkflowRunsDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetWorkflowRunsDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getWorkflowRunsDtoToJSON(getWorkflowRunsDto: GetWorkflowRunsDto)
 - getWorkflowRunsDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(GetWorkflowRunsDto$Outbound;
}

export function getWorkflowRunsDtoToJSON(getWorkflowRunsDto: GetWork...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function getWorkflowRunsDtoToJSON
- export function getWorkflowRunsDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/getworkflowrunsresponsedto.ts
Tamaño: 5261 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  GetWorkflowRunsDto,
  GetWorkflowRunsDto$inboundSchema,
  GetWorkflowRunsDto$Outbound,
  GetWorkflowRunsDto$outboundSchema,
} from './getworkflowrunsdto.js';

/**
 * Next cursor for pagination
 */
export type Next = {};

/**
 * Previous cursor for pagination
 */
export type Previous = {};

export type GetWorkflowRunsResponseDto = {
  /**
   * Workflow runs data
   */
  data: Array<GetWorkflowRunsDto>;
  /**
   * Next cursor for pagination
   */
  next?: Next | null | undefined;
  /**
   * Previous cursor for pagination
   */
  previous?: Previous | null | undefined;
};

/** @internal */
export const Next$inboundSchema: z.ZodType<Next, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Next$Outbound = {};

/** @internal */
export const Next$outboundSchema: z.ZodType<Next$Outbound, z.ZodTypeDef, Next> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Next$ {
  /** @deprecated use `Next$inboundSchema` instead. */
  export const inboundSchema = Next$inboundSchema;
  /** @deprecated use `Next$outboundSchema` instead. */
  export const outboundSchema = Next$outboundSchema;
  /** @deprecated use `Next$Outbound` instead. */
  export type Outbound = Next$Outbound;
}

export function nextToJSON(next: Next): string {
  return JSON.stringify(Next$outboundSchema.parse(next));
}

export function nextFromJSON(jsonString: string): SafeParseResult<Next, SDKValidationError> {
  return safeParse(jsonString, (x) => Next$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Next' from JSON`);
}

/** @internal */
export const Previous$inboundSchema: z.ZodType<Previous, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Previous$Outbound = {};

/** @internal */
export const Previous$outboundSchema: z.ZodType<Previous$Outbound, z.ZodTypeDef, Previous> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Previous$ {
  /** @deprecated use `Previous$inboundSchema` instead. */
  export const inboundSchema = Previous$inboundSchema;
  /** @deprecated use `Previous$outboundSchema` instead. */
  export const outboundSchema = Previous$outboundSchema;
  /** @deprecated use `Previous$Outbound` instead. */
  export type Outbound = Previous$Outbound;
}

export function previousToJSON(previous: Previous): string {
  return JSON.stringify(Previous$outboundSchema.parse(previous));
}

export function previousFromJSON(jsonString: string): SafeParseResult<Previous, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Previous$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Previous' from JSON`
  );
}

/** @internal */
export const GetWorkflowRunsResponseDto$inboundSchema: z.ZodType<GetWorkflowRunsResponseDto, z.ZodTypeDef, unknown> =
  z.object({
    data: z.array(GetWorkflowRunsDto$inboundSchema),
    next: z.nullable(z.lazy(() => Next$inboundSchema)).optional(),
    previous: z.nullable(z.lazy(() => Previous$inboundSchema)).optional(),
  });

/** @internal */
export type GetWorkflowRunsResponseDto$Outbound = {
  data: Array<GetWorkflowRunsDto$Outbound>;
  next?: Next$Outbound | null | undefined;
  previous?: Previous$Outbound | null | undefined;
};

/** @internal */
export const GetWorkflowRunsResponseDto$outboundSchema: z.ZodType<
  GetWorkflowRunsResponseDto$Outbound,
  z.ZodTypeDef,
  GetWorkflowRunsResponseDto
> = z.object({
  data: z.array(GetWorkflowRunsDto$outboundSchema),
  next: z.nullable(z.lazy(() => Next$outboundSchema)).optional(),
  previous: z.nullable(z.lazy(() => Previous$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetWorkflowRunsResponseDto$ {
  /** @deprecated use `GetWorkflowRunsResponseDto$inboundSchema` instead. */
  export const inboundSchema = GetWorkflowRunsResponseDto$inboundSchema;
  /** @deprecated use `GetWorkflowRunsResponseDto$outboundSchema` instead. */
  export const outboundSchema = GetWorkflowRunsResponseDto$outboundSchema;
  /** @deprecated use `GetWorkflowRunsResponseDto$Outbound` instead. */
  export type Outbound = GetWorkflowRunsResponseDto$Outbound;
}

export function getWorkflowRunsResponseDtoToJSON(getWorkflowRunsResponseDto: GetWorkflowRunsResponseDto): string {
  return JSON.stringify(GetWorkflowRunsResponseDto$outboundSchema.parse(getWorkflowRunsResponseDto));
}

export function getWorkflowRunsResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<GetWorkflowRunsResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetWorkflowRunsResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetWorkflowRunsResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - nextToJSON(next: Next)
 - nextFromJSON(jsonString: string)
 - previousToJSON(previous: Previous)
 - previousFromJSON(jsonString: string)
 - getWorkflowRunsResponseDtoToJSON(getWorkflowRunsResponseDto: GetWorkflowRunsResponseDto)
 - getWorkflowRunsResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Next$Outbound;
}

export function nextToJSON(next: Next): string {
  return JSON.stringify(Next$outb...)
 - Outbound(Previous$Outbound;
}

export function previousToJSON(previous: Previous): string {
  return JSON.str...)
 - Outbound(GetWorkflowRunsResponseDto$Outbound;
}

export function getWorkflowRunsResponseDtoToJSON(getWorkflow...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function nextToJSON
- export function nextFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function previousToJSON
- export function previousFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function getWorkflowRunsResponseDtoToJSON
- export function getWorkflowRunsResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/importmasterjsonrequestdto.ts
Tamaño: 3703 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Master JSON object containing all translations organized by workflow identifier
 */
export type MasterJson = {};

export type ImportMasterJsonRequestDto = {
  /**
   * The locale for which translations are being imported
   */
  locale: string;
  /**
   * Master JSON object containing all translations organized by workflow identifier
   */
  masterJson: MasterJson;
};

/** @internal */
export const MasterJson$inboundSchema: z.ZodType<MasterJson, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type MasterJson$Outbound = {};

/** @internal */
export const MasterJson$outboundSchema: z.ZodType<MasterJson$Outbound, z.ZodTypeDef, MasterJson> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MasterJson$ {
  /** @deprecated use `MasterJson$inboundSchema` instead. */
  export const inboundSchema = MasterJson$inboundSchema;
  /** @deprecated use `MasterJson$outboundSchema` instead. */
  export const outboundSchema = MasterJson$outboundSchema;
  /** @deprecated use `MasterJson$Outbound` instead. */
  export type Outbound = MasterJson$Outbound;
}

export function masterJsonToJSON(masterJson: MasterJson): string {
  return JSON.stringify(MasterJson$outboundSchema.parse(masterJson));
}

export function masterJsonFromJSON(jsonString: string): SafeParseResult<MasterJson, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MasterJson$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MasterJson' from JSON`
  );
}

/** @internal */
export const ImportMasterJsonRequestDto$inboundSchema: z.ZodType<ImportMasterJsonRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    locale: z.string(),
    masterJson: z.lazy(() => MasterJson$inboundSchema),
  });

/** @internal */
export type ImportMasterJsonRequestDto$Outbound = {
  locale: string;
  masterJson: MasterJson$Outbound;
};

/** @internal */
export const ImportMasterJsonRequestDto$outboundSchema: z.ZodType<
  ImportMasterJsonRequestDto$Outbound,
  z.ZodTypeDef,
  ImportMasterJsonRequestDto
> = z.object({
  locale: z.string(),
  masterJson: z.lazy(() => MasterJson$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ImportMasterJsonRequestDto$ {
  /** @deprecated use `ImportMasterJsonRequestDto$inboundSchema` instead. */
  export const inboundSchema = ImportMasterJsonRequestDto$inboundSchema;
  /** @deprecated use `ImportMasterJsonRequestDto$outboundSchema` instead. */
  export const outboundSchema = ImportMasterJsonRequestDto$outboundSchema;
  /** @deprecated use `ImportMasterJsonRequestDto$Outbound` instead. */
  export type Outbound = ImportMasterJsonRequestDto$Outbound;
}

export function importMasterJsonRequestDtoToJSON(importMasterJsonRequestDto: ImportMasterJsonRequestDto): string {
  return JSON.stringify(ImportMasterJsonRequestDto$outboundSchema.parse(importMasterJsonRequestDto));
}

export function importMasterJsonRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<ImportMasterJsonRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ImportMasterJsonRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ImportMasterJsonRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - masterJsonToJSON(masterJson: MasterJson)
 - masterJsonFromJSON(jsonString: string)
 - importMasterJsonRequestDtoToJSON(importMasterJsonRequestDto: ImportMasterJsonRequestDto)
 - importMasterJsonRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MasterJson$Outbound;
}

export function masterJsonToJSON(masterJson: MasterJson): string {
  return ...)
 - Outbound(ImportMasterJsonRequestDto$Outbound;
}

export function importMasterJsonRequestDtoToJSON(importMaste...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function masterJsonToJSON
- export function masterJsonFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function importMasterJsonRequestDtoToJSON
- export function importMasterJsonRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/importmasterjsonresponsedto.ts
Tamaño: 2736 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ImportMasterJsonResponseDto = {
  /**
   * Overall success status of the import operation
   */
  success: boolean;
  /**
   * Human-readable message describing the import result
   */
  message: string;
  /**
   * List of resource IDs that were successfully imported
   */
  successful?: Array<string> | undefined;
  /**
   * List of resource IDs that failed to import
   */
  failed?: Array<string> | undefined;
};

/** @internal */
export const ImportMasterJsonResponseDto$inboundSchema: z.ZodType<ImportMasterJsonResponseDto, z.ZodTypeDef, unknown> =
  z.object({
    success: z.boolean(),
    message: z.string(),
    successful: z.array(z.string()).optional(),
    failed: z.array(z.string()).optional(),
  });

/** @internal */
export type ImportMasterJsonResponseDto$Outbound = {
  success: boolean;
  message: string;
  successful?: Array<string> | undefined;
  failed?: Array<string> | undefined;
};

/** @internal */
export const ImportMasterJsonResponseDto$outboundSchema: z.ZodType<
  ImportMasterJsonResponseDto$Outbound,
  z.ZodTypeDef,
  ImportMasterJsonResponseDto
> = z.object({
  success: z.boolean(),
  message: z.string(),
  successful: z.array(z.string()).optional(),
  failed: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ImportMasterJsonResponseDto$ {
  /** @deprecated use `ImportMasterJsonResponseDto$inboundSchema` instead. */
  export const inboundSchema = ImportMasterJsonResponseDto$inboundSchema;
  /** @deprecated use `ImportMasterJsonResponseDto$outboundSchema` instead. */
  export const outboundSchema = ImportMasterJsonResponseDto$outboundSchema;
  /** @deprecated use `ImportMasterJsonResponseDto$Outbound` instead. */
  export type Outbound = ImportMasterJsonResponseDto$Outbound;
}

export function importMasterJsonResponseDtoToJSON(importMasterJsonResponseDto: ImportMasterJsonResponseDto): string {
  return JSON.stringify(ImportMasterJsonResponseDto$outboundSchema.parse(importMasterJsonResponseDto));
}

export function importMasterJsonResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ImportMasterJsonResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ImportMasterJsonResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ImportMasterJsonResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - importMasterJsonResponseDtoToJSON(importMasterJsonResponseDto: ImportMasterJsonResponseDto)
 - importMasterJsonResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ImportMasterJsonResponseDto$Outbound;
}

export function importMasterJsonResponseDtoToJSON(importMas...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function importMasterJsonResponseDtoToJSON
- export function importMasterJsonResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/inappcontroldto.ts
Tamaño: 4236 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { ActionDto, ActionDto$inboundSchema, ActionDto$Outbound, ActionDto$outboundSchema } from './actiondto.js';
import {
  RedirectDto,
  RedirectDto$inboundSchema,
  RedirectDto$Outbound,
  RedirectDto$outboundSchema,
} from './redirectdto.js';

export type InAppControlDto = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * Content/body of the in-app message. Required if subject is empty.
   */
  body?: string | undefined;
  /**
   * Subject/title of the in-app message. Required if body is empty.
   */
  subject?: string | undefined;
  /**
   * URL for an avatar image. Must be a valid URL or start with / or {{"{{"}} variable }}.
   */
  avatar?: string | undefined;
  /**
   * Primary action button details.
   */
  primaryAction?: ActionDto | undefined;
  /**
   * Secondary action button details.
   */
  secondaryAction?: ActionDto | undefined;
  /**
   * Redirection URL configuration for the main content click (if no actions defined/clicked)..
   */
  redirect?: RedirectDto | undefined;
  /**
   * Disable sanitization of the output.
   */
  disableOutputSanitization?: boolean | undefined;
  /**
   * Additional data payload for the step.
   */
  data?: { [k: string]: any } | undefined;
};

/** @internal */
export const InAppControlDto$inboundSchema: z.ZodType<InAppControlDto, z.ZodTypeDef, unknown> = z.object({
  skip: z.record(z.any()).optional(),
  body: z.string().optional(),
  subject: z.string().optional(),
  avatar: z.string().optional(),
  primaryAction: ActionDto$inboundSchema.optional(),
  secondaryAction: ActionDto$inboundSchema.optional(),
  redirect: RedirectDto$inboundSchema.optional(),
  disableOutputSanitization: z.boolean().default(false),
  data: z.record(z.any()).optional(),
});

/** @internal */
export type InAppControlDto$Outbound = {
  skip?: { [k: string]: any } | undefined;
  body?: string | undefined;
  subject?: string | undefined;
  avatar?: string | undefined;
  primaryAction?: ActionDto$Outbound | undefined;
  secondaryAction?: ActionDto$Outbound | undefined;
  redirect?: RedirectDto$Outbound | undefined;
  disableOutputSanitization: boolean;
  data?: { [k: string]: any } | undefined;
};

/** @internal */
export const InAppControlDto$outboundSchema: z.ZodType<InAppControlDto$Outbound, z.ZodTypeDef, InAppControlDto> =
  z.object({
    skip: z.record(z.any()).optional(),
    body: z.string().optional(),
    subject: z.string().optional(),
    avatar: z.string().optional(),
    primaryAction: ActionDto$outboundSchema.optional(),
    secondaryAction: ActionDto$outboundSchema.optional(),
    redirect: RedirectDto$outboundSchema.optional(),
    disableOutputSanitization: z.boolean().default(false),
    data: z.record(z.any()).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InAppControlDto$ {
  /** @deprecated use `InAppControlDto$inboundSchema` instead. */
  export const inboundSchema = InAppControlDto$inboundSchema;
  /** @deprecated use `InAppControlDto$outboundSchema` instead. */
  export const outboundSchema = InAppControlDto$outboundSchema;
  /** @deprecated use `InAppControlDto$Outbound` instead. */
  export type Outbound = InAppControlDto$Outbound;
}

export function inAppControlDtoToJSON(inAppControlDto: InAppControlDto): string {
  return JSON.stringify(InAppControlDto$outboundSchema.parse(inAppControlDto));
}

export function inAppControlDtoFromJSON(jsonString: string): SafeParseResult<InAppControlDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InAppControlDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InAppControlDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - inAppControlDtoToJSON(inAppControlDto: InAppControlDto)
 - inAppControlDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(InAppControlDto$Outbound;
}

export function inAppControlDtoToJSON(inAppControlDto: InAppControlDto)...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function inAppControlDtoToJSON
- export function inAppControlDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/inappcontrolsmetadataresponsedto.ts
Tamaño: 2980 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  InAppControlDto,
  InAppControlDto$inboundSchema,
  InAppControlDto$Outbound,
  InAppControlDto$outboundSchema,
} from './inappcontroldto.js';
import { UiSchema, UiSchema$inboundSchema, UiSchema$Outbound, UiSchema$outboundSchema } from './uischema.js';

export type InAppControlsMetadataResponseDto = {
  /**
   * JSON Schema for data
   */
  dataSchema?: { [k: string]: any } | undefined;
  /**
   * UI Schema for rendering
   */
  uiSchema?: UiSchema | undefined;
  /**
   * Control values specific to In-App
   */
  values: InAppControlDto;
};

/** @internal */
export const InAppControlsMetadataResponseDto$inboundSchema: z.ZodType<
  InAppControlsMetadataResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$inboundSchema.optional(),
  values: InAppControlDto$inboundSchema,
});

/** @internal */
export type InAppControlsMetadataResponseDto$Outbound = {
  dataSchema?: { [k: string]: any } | undefined;
  uiSchema?: UiSchema$Outbound | undefined;
  values: InAppControlDto$Outbound;
};

/** @internal */
export const InAppControlsMetadataResponseDto$outboundSchema: z.ZodType<
  InAppControlsMetadataResponseDto$Outbound,
  z.ZodTypeDef,
  InAppControlsMetadataResponseDto
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$outboundSchema.optional(),
  values: InAppControlDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InAppControlsMetadataResponseDto$ {
  /** @deprecated use `InAppControlsMetadataResponseDto$inboundSchema` instead. */
  export const inboundSchema = InAppControlsMetadataResponseDto$inboundSchema;
  /** @deprecated use `InAppControlsMetadataResponseDto$outboundSchema` instead. */
  export const outboundSchema = InAppControlsMetadataResponseDto$outboundSchema;
  /** @deprecated use `InAppControlsMetadataResponseDto$Outbound` instead. */
  export type Outbound = InAppControlsMetadataResponseDto$Outbound;
}

export function inAppControlsMetadataResponseDtoToJSON(
  inAppControlsMetadataResponseDto: InAppControlsMetadataResponseDto
): string {
  return JSON.stringify(InAppControlsMetadataResponseDto$outboundSchema.parse(inAppControlsMetadataResponseDto));
}

export function inAppControlsMetadataResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<InAppControlsMetadataResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InAppControlsMetadataResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InAppControlsMetadataResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - inAppControlsMetadataResponseDtoToJSON(inAppControlsMetadataResponseDto: InAppControlsMetadataResponseDto)
 - inAppControlsMetadataResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(InAppControlsMetadataResponseDto$Outbound;
}

export function inAppControlsMetadataResponseDtoToJSON...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function inAppControlsMetadataResponseDtoToJSON
- export function inAppControlsMetadataResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/inapprenderoutput.ts
Tamaño: 3364 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { ActionDto, ActionDto$inboundSchema, ActionDto$Outbound, ActionDto$outboundSchema } from './actiondto.js';
import {
  RedirectDto,
  RedirectDto$inboundSchema,
  RedirectDto$Outbound,
  RedirectDto$outboundSchema,
} from './redirectdto.js';

export type InAppRenderOutput = {
  /**
   * Subject of the in-app notification
   */
  subject?: string | undefined;
  /**
   * Body of the in-app notification
   */
  body: string;
  /**
   * Avatar for the in-app notification
   */
  avatar?: string | undefined;
  /**
   * Primary action details
   */
  primaryAction?: ActionDto | undefined;
  /**
   * Secondary action details
   */
  secondaryAction?: ActionDto | undefined;
  /**
   * Additional data
   */
  data?: { [k: string]: any } | undefined;
  /**
   * Redirect details
   */
  redirect?: RedirectDto | undefined;
};

/** @internal */
export const InAppRenderOutput$inboundSchema: z.ZodType<InAppRenderOutput, z.ZodTypeDef, unknown> = z.object({
  subject: z.string().optional(),
  body: z.string(),
  avatar: z.string().optional(),
  primaryAction: ActionDto$inboundSchema.optional(),
  secondaryAction: ActionDto$inboundSchema.optional(),
  data: z.record(z.any()).optional(),
  redirect: RedirectDto$inboundSchema.optional(),
});

/** @internal */
export type InAppRenderOutput$Outbound = {
  subject?: string | undefined;
  body: string;
  avatar?: string | undefined;
  primaryAction?: ActionDto$Outbound | undefined;
  secondaryAction?: ActionDto$Outbound | undefined;
  data?: { [k: string]: any } | undefined;
  redirect?: RedirectDto$Outbound | undefined;
};

/** @internal */
export const InAppRenderOutput$outboundSchema: z.ZodType<InAppRenderOutput$Outbound, z.ZodTypeDef, InAppRenderOutput> =
  z.object({
    subject: z.string().optional(),
    body: z.string(),
    avatar: z.string().optional(),
    primaryAction: ActionDto$outboundSchema.optional(),
    secondaryAction: ActionDto$outboundSchema.optional(),
    data: z.record(z.any()).optional(),
    redirect: RedirectDto$outboundSchema.optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InAppRenderOutput$ {
  /** @deprecated use `InAppRenderOutput$inboundSchema` instead. */
  export const inboundSchema = InAppRenderOutput$inboundSchema;
  /** @deprecated use `InAppRenderOutput$outboundSchema` instead. */
  export const outboundSchema = InAppRenderOutput$outboundSchema;
  /** @deprecated use `InAppRenderOutput$Outbound` instead. */
  export type Outbound = InAppRenderOutput$Outbound;
}

export function inAppRenderOutputToJSON(inAppRenderOutput: InAppRenderOutput): string {
  return JSON.stringify(InAppRenderOutput$outboundSchema.parse(inAppRenderOutput));
}

export function inAppRenderOutputFromJSON(jsonString: string): SafeParseResult<InAppRenderOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InAppRenderOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InAppRenderOutput' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - inAppRenderOutputToJSON(inAppRenderOutput: InAppRenderOutput)
 - inAppRenderOutputFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(InAppRenderOutput$Outbound;
}

export function inAppRenderOutputToJSON(inAppRenderOutput: InAppRende...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function inAppRenderOutputToJSON
- export function inAppRenderOutputFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/inappstepresponsedto.ts
Tamaño: 9766 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { collectExtraKeys as collectExtraKeys$, safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { ActionDto, ActionDto$inboundSchema, ActionDto$Outbound, ActionDto$outboundSchema } from './actiondto.js';
import {
  InAppControlsMetadataResponseDto,
  InAppControlsMetadataResponseDto$inboundSchema,
  InAppControlsMetadataResponseDto$Outbound,
  InAppControlsMetadataResponseDto$outboundSchema,
} from './inappcontrolsmetadataresponsedto.js';
import {
  RedirectDto,
  RedirectDto$inboundSchema,
  RedirectDto$Outbound,
  RedirectDto$outboundSchema,
} from './redirectdto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  StepIssuesDto,
  StepIssuesDto$inboundSchema,
  StepIssuesDto$Outbound,
  StepIssuesDto$outboundSchema,
} from './stepissuesdto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the in-app step
 */
export type InAppStepResponseDtoControlValues = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * Content/body of the in-app message. Required if subject is empty.
   */
  body?: string | undefined;
  /**
   * Subject/title of the in-app message. Required if body is empty.
   */
  subject?: string | undefined;
  /**
   * URL for an avatar image. Must be a valid URL or start with / or {{"{{"}} variable }}.
   */
  avatar?: string | undefined;
  /**
   * Primary action button details.
   */
  primaryAction?: ActionDto | undefined;
  /**
   * Secondary action button details.
   */
  secondaryAction?: ActionDto | undefined;
  /**
   * Redirection URL configuration for the main content click (if no actions defined/clicked)..
   */
  redirect?: RedirectDto | undefined;
  /**
   * Disable sanitization of the output.
   */
  disableOutputSanitization?: boolean | undefined;
  /**
   * Additional data payload for the step.
   */
  data?: { [k: string]: any } | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type InAppStepResponseDto = {
  /**
   * Controls metadata for the in-app step
   */
  controls: InAppControlsMetadataResponseDto;
  /**
   * Control values for the in-app step
   */
  controlValues?: InAppStepResponseDtoControlValues | undefined;
  /**
   * JSON Schema for variables, follows the JSON Schema standard
   */
  variables: { [k: string]: any };
  /**
   * Unique identifier of the step
   */
  stepId: string;
  /**
   * Database identifier of the step
   */
  id: string;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Slug of the step
   */
  slug: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow database identifier
   */
  workflowDatabaseId: string;
  /**
   * Issues associated with the step
   */
  issues?: StepIssuesDto | undefined;
};

/** @internal */
export const InAppStepResponseDtoControlValues$inboundSchema: z.ZodType<
  InAppStepResponseDtoControlValues,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z
    .object({
      skip: z.record(z.any()).optional(),
      body: z.string().optional(),
      subject: z.string().optional(),
      avatar: z.string().optional(),
      primaryAction: ActionDto$inboundSchema.optional(),
      secondaryAction: ActionDto$inboundSchema.optional(),
      redirect: RedirectDto$inboundSchema.optional(),
      disableOutputSanitization: z.boolean().default(false),
      data: z.record(z.any()).optional(),
    })
    .catchall(z.any()),
  'additionalProperties',
  true
);

/** @internal */
export type InAppStepResponseDtoControlValues$Outbound = {
  skip?: { [k: string]: any } | undefined;
  body?: string | undefined;
  subject?: string | undefined;
  avatar?: string | undefined;
  primaryAction?: ActionDto$Outbound | undefined;
  secondaryAction?: ActionDto$Outbound | undefined;
  redirect?: RedirectDto$Outbound | undefined;
  disableOutputSanitization: boolean;
  data?: { [k: string]: any } | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const InAppStepResponseDtoControlValues$outboundSchema: z.ZodType<
  InAppStepResponseDtoControlValues$Outbound,
  z.ZodTypeDef,
  InAppStepResponseDtoControlValues
> = z
  .object({
    skip: z.record(z.any()).optional(),
    body: z.string().optional(),
    subject: z.string().optional(),
    avatar: z.string().optional(),
    primaryAction: ActionDto$outboundSchema.optional(),
    secondaryAction: ActionDto$outboundSchema.optional(),
    redirect: RedirectDto$outboundSchema.optional(),
    disableOutputSanitization: z.boolean().default(false),
    data: z.record(z.any()).optional(),
    additionalProperties: z.record(z.any()).optional(),
  })
  .transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InAppStepResponseDtoControlValues$ {
  /** @deprecated use `InAppStepResponseDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = InAppStepResponseDtoControlValues$inboundSchema;
  /** @deprecated use `InAppStepResponseDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = InAppStepResponseDtoControlValues$outboundSchema;
  /** @deprecated use `InAppStepResponseDtoControlValues$Outbound` instead. */
  export type Outbound = InAppStepResponseDtoControlValues$Outbound;
}

export function inAppStepResponseDtoControlValuesToJSON(
  inAppStepResponseDtoControlValues: InAppStepResponseDtoControlValues
): string {
  return JSON.stringify(InAppStepResponseDtoControlValues$outboundSchema.parse(inAppStepResponseDtoControlValues));
}

export function inAppStepResponseDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<InAppStepResponseDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InAppStepResponseDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InAppStepResponseDtoControlValues' from JSON`
  );
}

/** @internal */
export const InAppStepResponseDto$inboundSchema: z.ZodType<InAppStepResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    controls: InAppControlsMetadataResponseDto$inboundSchema,
    controlValues: z.lazy(() => InAppStepResponseDtoControlValues$inboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    _id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$inboundSchema,
    origin: ResourceOriginEnum$inboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type InAppStepResponseDto$Outbound = {
  controls: InAppControlsMetadataResponseDto$Outbound;
  controlValues?: InAppStepResponseDtoControlValues$Outbound | undefined;
  variables: { [k: string]: any };
  stepId: string;
  _id: string;
  name: string;
  slug: string;
  type: string;
  origin: string;
  workflowId: string;
  workflowDatabaseId: string;
  issues?: StepIssuesDto$Outbound | undefined;
};

/** @internal */
export const InAppStepResponseDto$outboundSchema: z.ZodType<
  InAppStepResponseDto$Outbound,
  z.ZodTypeDef,
  InAppStepResponseDto
> = z
  .object({
    controls: InAppControlsMetadataResponseDto$outboundSchema,
    controlValues: z.lazy(() => InAppStepResponseDtoControlValues$outboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$outboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InAppStepResponseDto$ {
  /** @deprecated use `InAppStepResponseDto$inboundSchema` instead. */
  export const inboundSchema = InAppStepResponseDto$inboundSchema;
  /** @deprecated use `InAppStepResponseDto$outboundSchema` instead. */
  export const outboundSchema = InAppStepResponseDto$outboundSchema;
  /** @deprecated use `InAppStepResponseDto$Outbound` instead. */
  export type Outbound = InAppStepResponseDto$Outbound;
}

export function inAppStepResponseDtoToJSON(inAppStepResponseDto: InAppStepResponseDto): string {
  return JSON.stringify(InAppStepResponseDto$outboundSchema.parse(inAppStepResponseDto));
}

export function inAppStepResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<InAppStepResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InAppStepResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InAppStepResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - inAppStepResponseDtoControlValuesToJSON(inAppStepResponseDtoControlValues: InAppStepResponseDtoControlValues)
 - inAppStepResponseDtoControlValuesFromJSON(jsonString: string)
 - inAppStepResponseDtoToJSON(inAppStepResponseDto: InAppStepResponseDto)
 - inAppStepResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(InAppStepResponseDtoControlValues$Outbound;
}

export function inAppStepResponseDtoControlValuesToJS...)
 - Outbound(InAppStepResponseDto$Outbound;
}

export function inAppStepResponseDtoToJSON(inAppStepResponseDto: I...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function inAppStepResponseDtoControlValuesToJSON
- export function inAppStepResponseDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function inAppStepResponseDtoToJSON
- export function inAppStepResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/inappstepupsertdto.ts
Tamaño: 5250 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  InAppControlDto,
  InAppControlDto$inboundSchema,
  InAppControlDto$Outbound,
  InAppControlDto$outboundSchema,
} from './inappcontroldto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the In-App step.
 */
export type InAppStepUpsertDtoControlValues =
  | InAppControlDto
  | {
      [k: string]: any;
    };

export type InAppStepUpsertDto = {
  /**
   * Database identifier of the step. Used for updating the step.
   */
  id?: string | undefined;
  /**
   * Unique identifier for the step
   */
  stepId?: string | undefined;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Control values for the In-App step.
   */
  controlValues?: InAppControlDto | { [k: string]: any } | undefined;
};

/** @internal */
export const InAppStepUpsertDtoControlValues$inboundSchema: z.ZodType<
  InAppStepUpsertDtoControlValues,
  z.ZodTypeDef,
  unknown
> = z.union([InAppControlDto$inboundSchema, z.record(z.any())]);

/** @internal */
export type InAppStepUpsertDtoControlValues$Outbound = InAppControlDto$Outbound | { [k: string]: any };

/** @internal */
export const InAppStepUpsertDtoControlValues$outboundSchema: z.ZodType<
  InAppStepUpsertDtoControlValues$Outbound,
  z.ZodTypeDef,
  InAppStepUpsertDtoControlValues
> = z.union([InAppControlDto$outboundSchema, z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InAppStepUpsertDtoControlValues$ {
  /** @deprecated use `InAppStepUpsertDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = InAppStepUpsertDtoControlValues$inboundSchema;
  /** @deprecated use `InAppStepUpsertDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = InAppStepUpsertDtoControlValues$outboundSchema;
  /** @deprecated use `InAppStepUpsertDtoControlValues$Outbound` instead. */
  export type Outbound = InAppStepUpsertDtoControlValues$Outbound;
}

export function inAppStepUpsertDtoControlValuesToJSON(
  inAppStepUpsertDtoControlValues: InAppStepUpsertDtoControlValues
): string {
  return JSON.stringify(InAppStepUpsertDtoControlValues$outboundSchema.parse(inAppStepUpsertDtoControlValues));
}

export function inAppStepUpsertDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<InAppStepUpsertDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InAppStepUpsertDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InAppStepUpsertDtoControlValues' from JSON`
  );
}

/** @internal */
export const InAppStepUpsertDto$inboundSchema: z.ZodType<InAppStepUpsertDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$inboundSchema,
    controlValues: z.union([InAppControlDto$inboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type InAppStepUpsertDto$Outbound = {
  _id?: string | undefined;
  stepId?: string | undefined;
  name: string;
  type: string;
  controlValues?: InAppControlDto$Outbound | { [k: string]: any } | undefined;
};

/** @internal */
export const InAppStepUpsertDto$outboundSchema: z.ZodType<
  InAppStepUpsertDto$Outbound,
  z.ZodTypeDef,
  InAppStepUpsertDto
> = z
  .object({
    id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$outboundSchema,
    controlValues: z.union([InAppControlDto$outboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InAppStepUpsertDto$ {
  /** @deprecated use `InAppStepUpsertDto$inboundSchema` instead. */
  export const inboundSchema = InAppStepUpsertDto$inboundSchema;
  /** @deprecated use `InAppStepUpsertDto$outboundSchema` instead. */
  export const outboundSchema = InAppStepUpsertDto$outboundSchema;
  /** @deprecated use `InAppStepUpsertDto$Outbound` instead. */
  export type Outbound = InAppStepUpsertDto$Outbound;
}

export function inAppStepUpsertDtoToJSON(inAppStepUpsertDto: InAppStepUpsertDto): string {
  return JSON.stringify(InAppStepUpsertDto$outboundSchema.parse(inAppStepUpsertDto));
}

export function inAppStepUpsertDtoFromJSON(
  jsonString: string
): SafeParseResult<InAppStepUpsertDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InAppStepUpsertDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InAppStepUpsertDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - inAppStepUpsertDtoControlValuesToJSON(inAppStepUpsertDtoControlValues: InAppStepUpsertDtoControlValues)
 - inAppStepUpsertDtoControlValuesFromJSON(jsonString: string)
 - inAppStepUpsertDtoToJSON(inAppStepUpsertDto: InAppStepUpsertDto)
 - inAppStepUpsertDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(InAppStepUpsertDtoControlValues$Outbound;
}

export function inAppStepUpsertDtoControlValuesToJSON(
...)
 - Outbound(InAppStepUpsertDto$Outbound;
}

export function inAppStepUpsertDtoToJSON(inAppStepUpsertDto: InAppSt...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function inAppStepUpsertDtoControlValuesToJSON
- export function inAppStepUpsertDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function inAppStepUpsertDtoToJSON
- export function inAppStepUpsertDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/inboundparsedomaindto.ts
Tamaño: 1991 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type InBoundParseDomainDto = {
  inboundParseDomain?: string | undefined;
};

/** @internal */
export const InBoundParseDomainDto$inboundSchema: z.ZodType<InBoundParseDomainDto, z.ZodTypeDef, unknown> = z.object({
  inboundParseDomain: z.string().optional(),
});

/** @internal */
export type InBoundParseDomainDto$Outbound = {
  inboundParseDomain?: string | undefined;
};

/** @internal */
export const InBoundParseDomainDto$outboundSchema: z.ZodType<
  InBoundParseDomainDto$Outbound,
  z.ZodTypeDef,
  InBoundParseDomainDto
> = z.object({
  inboundParseDomain: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InBoundParseDomainDto$ {
  /** @deprecated use `InBoundParseDomainDto$inboundSchema` instead. */
  export const inboundSchema = InBoundParseDomainDto$inboundSchema;
  /** @deprecated use `InBoundParseDomainDto$outboundSchema` instead. */
  export const outboundSchema = InBoundParseDomainDto$outboundSchema;
  /** @deprecated use `InBoundParseDomainDto$Outbound` instead. */
  export type Outbound = InBoundParseDomainDto$Outbound;
}

export function inBoundParseDomainDtoToJSON(inBoundParseDomainDto: InBoundParseDomainDto): string {
  return JSON.stringify(InBoundParseDomainDto$outboundSchema.parse(inBoundParseDomainDto));
}

export function inBoundParseDomainDtoFromJSON(
  jsonString: string
): SafeParseResult<InBoundParseDomainDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InBoundParseDomainDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InBoundParseDomainDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - inBoundParseDomainDtoToJSON(inBoundParseDomainDto: InBoundParseDomainDto)
 - inBoundParseDomainDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(InBoundParseDomainDto$Outbound;
}

export function inBoundParseDomainDtoToJSON(inBoundParseDomainDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function inBoundParseDomainDtoToJSON
- export function inBoundParseDomainDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/index.ts
Tamaño: 11633 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export * from "./actiondto.js";
export * from "./activitiesresponsedto.js";
export * from "./activitynotificationexecutiondetailresponsedto.js";
export * from "./activitynotificationjobresponsedto.js";
export * from "./activitynotificationresponsedto.js";
export * from "./activitynotificationstepresponsedto.js";
export * from "./activitynotificationsubscriberresponsedto.js";
export * from "./activitynotificationtemplateresponsedto.js";
export * from "./activitytopicdto.js";
export * from "./actorfeeditemdto.js";
export * from "./actortypeenum.js";
export * from "./apikeydto.js";
export * from "./autoconfigureintegrationresponsedto.js";
export * from "./bridgeconfigurationdto.js";
export * from "./builderfieldtypeenum.js";
export * from "./bulkcreatesubscriberresponsedto.js";
export * from "./bulksubscribercreatedto.js";
export * from "./bulktriggereventdto.js";
export * from "./bulkupdatesubscriberpreferenceitemdto.js";
export * from "./bulkupdatesubscriberpreferencesdto.js";
export * from "./buttontypeenum.js";
export * from "./channelcredentials.js";
export * from "./channelcredentialsdto.js";
export * from "./channelctatypeenum.js";
export * from "./channelpreferencedto.js";
export * from "./channelsettingsdto.js";
export * from "./channeltypeenum.js";
export * from "./chatcontroldto.js";
export * from "./chatcontrolsmetadataresponsedto.js";
export * from "./chatorpushproviderenum.js";
export * from "./chatrenderoutput.js";
export * from "./chatstepresponsedto.js";
export * from "./chatstepupsertdto.js";
export * from "./configurationsdto.js";
export * from "./constraintvalidation.js";
export * from "./contentissueenum.js";
export * from "./controlsmetadatadto.js";
export * from "./createcontextrequestdto.js";
export * from "./createdsubscriberdto.js";
export * from "./createenvironmentrequestdto.js";
export * from "./createintegrationrequestdto.js";
export * from "./createlayoutdto.js";
export * from "./createsubscriberrequestdto.js";
export * from "./createtopicsubscriptionsrequestdto.js";
export * from "./createtopicsubscriptionsresponsedto.js";
export * from "./createtranslationrequestdto.js";
export * from "./createupdatetopicrequestdto.js";
export * from "./createworkflowdto.js";
export * from "./credentialsdto.js";
export * from "./customcontroldto.js";
export * from "./customcontrolsmetadataresponsedto.js";
export * from "./customstepresponsedto.js";
export * from "./customstepupsertdto.js";
export * from "./delaycontroldto.js";
export * from "./delaycontrolsmetadataresponsedto.js";
export * from "./delayregularmetadata.js";
export * from "./delayscheduledmetadata.js";
export * from "./delaystepresponsedto.js";
export * from "./delaystepupsertdto.js";
export * from "./deletemessageresponsedto.js";
export * from "./deletetopicresponsedto.js";
export * from "./deletetopicsubscriptionsrequestdto.js";
export * from "./deletetopicsubscriptionsresponsedto.js";
export * from "./digestcontroldto.js";
export * from "./digestcontrolsmetadataresponsedto.js";
export * from "./digestmetadatadto.js";
export * from "./digestregularmetadata.js";
export * from "./digestregularoutput.js";
export * from "./digeststepresponsedto.js";
export * from "./digeststepupsertdto.js";
export * from "./digesttimedconfigdto.js";
export * from "./digesttimedmetadata.js";
export * from "./digesttypeenum.js";
export * from "./digestunitenum.js";
export * from "./directionenum.js";
export * from "./duplicatelayoutdto.js";
export * from "./duplicateworkflowdto.js";
export * from "./emailblock.js";
export * from "./emailblockstyles.js";
export * from "./emailblocktypeenum.js";
export * from "./emailchanneloverrides.js";
export * from "./emailcontroldto.js";
export * from "./emailcontrolsdto.js";
export * from "./emailcontrolsmetadataresponsedto.js";
export * from "./emaillayoutrenderoutput.js";
export * from "./emailrenderoutput.js";
export * from "./emailstepresponsedto.js";
export * from "./emailstepupsertdto.js";
export * from "./environmentresponsedto.js";
export * from "./eventbody.js";
export * from "./executiondetailssourceenum.js";
export * from "./executiondetailsstatusenum.js";
export * from "./failedoperationdto.js";
export * from "./feedresponsedto.js";
export * from "./fieldfilterpartdto.js";
export * from "./generatelayoutpreviewresponsedto.js";
export * from "./generatepreviewrequestdto.js";
export * from "./generatepreviewresponsedto.js";
export * from "./getchartsresponsedto.js";
export * from "./getcontextresponsedto.js";
export * from "./getenvironmenttagsdto.js";
export * from "./getlayoutusageresponsedto.js";
export * from "./getmasterjsonresponsedto.js";
export * from "./getpreferencesresponsedto.js";
export * from "./getrequestresponsedto.js";
export * from "./getrequestsresponsedto.js";
export * from "./getsubscriberpreferencesdto.js";
export * from "./getworkflowrunresponsedto.js";
export * from "./getworkflowrunsdto.js";
export * from "./getworkflowrunsresponsedto.js";
export * from "./importmasterjsonrequestdto.js";
export * from "./importmasterjsonresponsedto.js";
export * from "./inappcontroldto.js";
export * from "./inappcontrolsmetadataresponsedto.js";
export * from "./inapprenderoutput.js";
export * from "./inappstepresponsedto.js";
export * from "./inappstepupsertdto.js";
export * from "./inboundparsedomaindto.js";
export * from "./integrationissueenum.js";
export * from "./integrationresponsedto.js";
export * from "./layoutcontrolsdto.js";
export * from "./layoutcontrolvaluesdto.js";
export * from "./layoutcreationsourceenum.js";
export * from "./layoutpreviewpayloaddto.js";
export * from "./layoutpreviewrequestdto.js";
export * from "./layoutresponsedto.js";
export * from "./layoutresponsedtosortfield.js";
export * from "./listcontextsresponsedto.js";
export * from "./listlayoutresponsedto.js";
export * from "./listsubscribersresponsedto.js";
export * from "./listtopicsresponsedto.js";
export * from "./listtopicsubscriptionsresponsedto.js";
export * from "./listworkflowresponse.js";
export * from "./lookbackwindowdto.js";
export * from "./markallmessageasrequestdto.js";
export * from "./markmessageactionasseendto.js";
export * from "./messageaction.js";
export * from "./messageactionresult.js";
export * from "./messageactionstatusenum.js";
export * from "./messagebutton.js";
export * from "./messagecta.js";
export * from "./messagectadata.js";
export * from "./messagemarkasrequestdto.js";
export * from "./messageresponsedto.js";
export * from "./messagesresponsedto.js";
export * from "./messagestatusenum.js";
export * from "./messagetemplate.js";
export * from "./messagetemplatedto.js";
export * from "./metadto.js";
export * from "./monthlytypeenum.js";
export * from "./notificationfeeditemdto.js";
export * from "./notificationgroup.js";
export * from "./notificationstepdata.js";
export * from "./notificationstepdto.js";
export * from "./notificationtrigger.js";
export * from "./notificationtriggerdto.js";
export * from "./notificationtriggervariable.js";
export * from "./ordinalenum.js";
export * from "./ordinalvalueenum.js";
export * from "./patchpreferencechannelsdto.js";
export * from "./patchsubscriberpreferencesdto.js";
export * from "./patchsubscriberrequestdto.js";
export * from "./patchworkflowdto.js";
export * from "./payloadvalidationerrordto.js";
export * from "./preferencelevelenum.js";
export * from "./preferenceoverridesourceenum.js";
export * from "./preferencesrequestdto.js";
export * from "./previewpayloaddto.js";
export * from "./providersidenum.js";
export * from "./pushcontroldto.js";
export * from "./pushcontrolsmetadataresponsedto.js";
export * from "./pushrenderoutput.js";
export * from "./pushstepresponsedto.js";
export * from "./pushstepupsertdto.js";
export * from "./redirectdto.js";
export * from "./removesubscriberresponsedto.js";
export * from "./replycallback.js";
export * from "./requestlogresponsedto.js";
export * from "./resourceoriginenum.js";
export * from "./resourcetypeenum.js";
export * from "./runtimeissuedto.js";
export * from "./scheduledto.js";
export * from "./security.js";
export * from "./severitylevelenum.js";
export * from "./smscontroldto.js";
export * from "./smscontrolsmetadataresponsedto.js";
export * from "./smsrenderoutput.js";
export * from "./smsstepresponsedto.js";
export * from "./smsstepupsertdto.js";
export * from "./stepcontentissuedto.js";
export * from "./stepexecutiondetaildto.js";
export * from "./stepfilterdto.js";
export * from "./stepintegrationissue.js";
export * from "./stepissuesdto.js";
export * from "./steplistresponsedto.js";
export * from "./stepresponsedto.js";
export * from "./steprundto.js";
export * from "./stepsoverrides.js";
export * from "./steptypeenum.js";
export * from "./subscriberchanneldto.js";
export * from "./subscriberdto.js";
export * from "./subscriberfeedresponsedto.js";
export * from "./subscriberglobalpreferencedto.js";
export * from "./subscriberpayloaddto.js";
export * from "./subscriberpreferencechannels.js";
export * from "./subscriberpreferenceoverridedto.js";
export * from "./subscriberpreferencesworkflowinfodto.js";
export * from "./subscriberresponsedto.js";
export * from "./subscriberresponsedtooptional.js";
export * from "./subscriberworkflowpreferencedto.js";
export * from "./subscriptiondto.js";
export * from "./subscriptionerrordto.js";
export * from "./subscriptionsdeleteerrordto.js";
export * from "./syncworkflowdto.js";
export * from "./tenantpayloaddto.js";
export * from "./textalignenum.js";
export * from "./throttlecontroldto.js";
export * from "./throttlecontrolsmetadataresponsedto.js";
export * from "./throttlestepresponsedto.js";
export * from "./throttlestepupsertdto.js";
export * from "./timedconfig.js";
export * from "./timerangedto.js";
export * from "./timeunitenum.js";
export * from "./topicdto.js";
export * from "./topicpayloaddto.js";
export * from "./topicresponsedto.js";
export * from "./topicsubscriberdto.js";
export * from "./topicsubscriptionresponsedto.js";
export * from "./traceresponsedto.js";
export * from "./translationgroupdto.js";
export * from "./translationresponsedto.js";
export * from "./triggereventrequestdto.js";
export * from "./triggereventresponsedto.js";
export * from "./triggereventtoallrequestdto.js";
export * from "./triggerrecipientstypeenum.js";
export * from "./uicomponentenum.js";
export * from "./uischema.js";
export * from "./uischemagroupenum.js";
export * from "./uischemaproperty.js";
export * from "./unseencountresponse.js";
export * from "./updatecontextrequestdto.js";
export * from "./updatedsubscriberdto.js";
export * from "./updateenvironmentrequestdto.js";
export * from "./updateintegrationrequestdto.js";
export * from "./updatelayoutdto.js";
export * from "./updatesubscriberchannelrequestdto.js";
export * from "./updatesubscriberonlineflagrequestdto.js";
export * from "./updatetopicrequestdto.js";
export * from "./updateworkflowdto.js";
export * from "./uploadtranslationsrequestdto.js";
export * from "./uploadtranslationsresponsedto.js";
export * from "./webhookresultdto.js";
export * from "./workflowcreationsourceenum.js";
export * from "./workflowinfodto.js";
export * from "./workflowlistresponsedto.js";
export * from "./workflowpreferencedto.js";
export * from "./workflowpreferencesdto.js";
export * from "./workflowpreferencesresponsedto.js";
export * from "./workflowresponse.js";
export * from "./workflowresponsedto.js";
export * from "./workflowresponsedtosortfield.js";
export * from "./workflowrunstepsdetailsdto.js";
export * from "./workflowstatusenum.js";


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/integrationissueenum.ts
Tamaño: 1229 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Type of integration issue
 */
export const IntegrationIssueEnum = {
  MissingIntegration: 'MISSING_INTEGRATION',
  InboxNotConnected: 'INBOX_NOT_CONNECTED',
} as const;
/**
 * Type of integration issue
 */
export type IntegrationIssueEnum = ClosedEnum<typeof IntegrationIssueEnum>;

/** @internal */
export const IntegrationIssueEnum$inboundSchema: z.ZodNativeEnum<typeof IntegrationIssueEnum> =
  z.nativeEnum(IntegrationIssueEnum);

/** @internal */
export const IntegrationIssueEnum$outboundSchema: z.ZodNativeEnum<typeof IntegrationIssueEnum> =
  IntegrationIssueEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationIssueEnum$ {
  /** @deprecated use `IntegrationIssueEnum$inboundSchema` instead. */
  export const inboundSchema = IntegrationIssueEnum$inboundSchema;
  /** @deprecated use `IntegrationIssueEnum$outboundSchema` instead. */
  export const outboundSchema = IntegrationIssueEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/integrationresponsedto.ts
Tamaño: 7479 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ConfigurationsDto,
  ConfigurationsDto$inboundSchema,
  ConfigurationsDto$Outbound,
  ConfigurationsDto$outboundSchema,
} from './configurationsdto.js';
import {
  CredentialsDto,
  CredentialsDto$inboundSchema,
  CredentialsDto$Outbound,
  CredentialsDto$outboundSchema,
} from './credentialsdto.js';
import {
  StepFilterDto,
  StepFilterDto$inboundSchema,
  StepFilterDto$Outbound,
  StepFilterDto$outboundSchema,
} from './stepfilterdto.js';

/**
 * The channel type for the integration, which defines how the integration communicates (e.g., email, SMS).
 */
export const Channel = {
  InApp: 'in_app',
  Email: 'email',
  Sms: 'sms',
  Chat: 'chat',
  Push: 'push',
} as const;
/**
 * The channel type for the integration, which defines how the integration communicates (e.g., email, SMS).
 */
export type Channel = ClosedEnum<typeof Channel>;

export type IntegrationResponseDto = {
  /**
   * The unique identifier of the integration record in the database. This is automatically generated.
   */
  id?: string | undefined;
  /**
   * The unique identifier for the environment associated with this integration. This links to the Environment collection.
   */
  environmentId: string;
  /**
   * The unique identifier for the organization that owns this integration. This links to the Organization collection.
   */
  organizationId: string;
  /**
   * The name of the integration, which is used to identify it in the user interface.
   */
  name: string;
  /**
   * A unique string identifier for the integration, often used for API calls or internal references.
   */
  identifier: string;
  /**
   * The identifier for the provider of the integration (e.g., "mailgun", "twilio").
   */
  providerId: string;
  /**
   * The channel type for the integration, which defines how the integration communicates (e.g., email, SMS).
   */
  channel: Channel;
  /**
   * The credentials required for the integration to function, including API keys and other sensitive information.
   */
  credentials: CredentialsDto;
  /**
   * The configurations required for enabling the additional configurations of the integration.
   */
  configurations?: ConfigurationsDto | undefined;
  /**
   * Indicates whether the integration is currently active. An active integration will process events and messages.
   */
  active: boolean;
  /**
   * Indicates whether the integration has been marked as deleted (soft delete).
   */
  deleted: boolean;
  /**
   * The timestamp indicating when the integration was deleted. This is set when the integration is soft deleted.
   */
  deletedAt?: string | undefined;
  /**
   * The identifier of the user who performed the deletion of this integration. Useful for audit trails.
   */
  deletedBy?: string | undefined;
  /**
   * Indicates whether this integration is marked as primary. A primary integration is often the default choice for processing.
   */
  primary: boolean;
  /**
   * An array of conditions associated with the integration that may influence its behavior or processing logic.
   */
  conditions?: Array<StepFilterDto> | undefined;
};

/** @internal */
export const Channel$inboundSchema: z.ZodNativeEnum<typeof Channel> = z.nativeEnum(Channel);

/** @internal */
export const Channel$outboundSchema: z.ZodNativeEnum<typeof Channel> = Channel$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Channel$ {
  /** @deprecated use `Channel$inboundSchema` instead. */
  export const inboundSchema = Channel$inboundSchema;
  /** @deprecated use `Channel$outboundSchema` instead. */
  export const outboundSchema = Channel$outboundSchema;
}

/** @internal */
export const IntegrationResponseDto$inboundSchema: z.ZodType<IntegrationResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    _environmentId: z.string(),
    _organizationId: z.string(),
    name: z.string(),
    identifier: z.string(),
    providerId: z.string(),
    channel: Channel$inboundSchema,
    credentials: CredentialsDto$inboundSchema,
    configurations: ConfigurationsDto$inboundSchema.optional(),
    active: z.boolean(),
    deleted: z.boolean(),
    deletedAt: z.string().optional(),
    deletedBy: z.string().optional(),
    primary: z.boolean(),
    conditions: z.array(StepFilterDto$inboundSchema).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      _environmentId: 'environmentId',
      _organizationId: 'organizationId',
    });
  });

/** @internal */
export type IntegrationResponseDto$Outbound = {
  _id?: string | undefined;
  _environmentId: string;
  _organizationId: string;
  name: string;
  identifier: string;
  providerId: string;
  channel: string;
  credentials: CredentialsDto$Outbound;
  configurations?: ConfigurationsDto$Outbound | undefined;
  active: boolean;
  deleted: boolean;
  deletedAt?: string | undefined;
  deletedBy?: string | undefined;
  primary: boolean;
  conditions?: Array<StepFilterDto$Outbound> | undefined;
};

/** @internal */
export const IntegrationResponseDto$outboundSchema: z.ZodType<
  IntegrationResponseDto$Outbound,
  z.ZodTypeDef,
  IntegrationResponseDto
> = z
  .object({
    id: z.string().optional(),
    environmentId: z.string(),
    organizationId: z.string(),
    name: z.string(),
    identifier: z.string(),
    providerId: z.string(),
    channel: Channel$outboundSchema,
    credentials: CredentialsDto$outboundSchema,
    configurations: ConfigurationsDto$outboundSchema.optional(),
    active: z.boolean(),
    deleted: z.boolean(),
    deletedAt: z.string().optional(),
    deletedBy: z.string().optional(),
    primary: z.boolean(),
    conditions: z.array(StepFilterDto$outboundSchema).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      environmentId: '_environmentId',
      organizationId: '_organizationId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationResponseDto$ {
  /** @deprecated use `IntegrationResponseDto$inboundSchema` instead. */
  export const inboundSchema = IntegrationResponseDto$inboundSchema;
  /** @deprecated use `IntegrationResponseDto$outboundSchema` instead. */
  export const outboundSchema = IntegrationResponseDto$outboundSchema;
  /** @deprecated use `IntegrationResponseDto$Outbound` instead. */
  export type Outbound = IntegrationResponseDto$Outbound;
}

export function integrationResponseDtoToJSON(integrationResponseDto: IntegrationResponseDto): string {
  return JSON.stringify(IntegrationResponseDto$outboundSchema.parse(integrationResponseDto));
}

export function integrationResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<IntegrationResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationResponseDtoToJSON(integrationResponseDto: IntegrationResponseDto)
 - integrationResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(IntegrationResponseDto$Outbound;
}

export function integrationResponseDtoToJSON(integrationResponse...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationResponseDtoToJSON
- export function integrationResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/layoutcontrolsdto.ts
Tamaño: 2672 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  LayoutControlValuesDto,
  LayoutControlValuesDto$inboundSchema,
  LayoutControlValuesDto$Outbound,
  LayoutControlValuesDto$outboundSchema,
} from './layoutcontrolvaluesdto.js';
import { UiSchema, UiSchema$inboundSchema, UiSchema$Outbound, UiSchema$outboundSchema } from './uischema.js';

export type LayoutControlsDto = {
  /**
   * JSON Schema for data
   */
  dataSchema?: { [k: string]: any } | undefined;
  /**
   * UI Schema for rendering
   */
  uiSchema?: UiSchema | undefined;
  /**
   * Email layout controls
   */
  values: LayoutControlValuesDto;
};

/** @internal */
export const LayoutControlsDto$inboundSchema: z.ZodType<LayoutControlsDto, z.ZodTypeDef, unknown> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$inboundSchema.optional(),
  values: LayoutControlValuesDto$inboundSchema,
});

/** @internal */
export type LayoutControlsDto$Outbound = {
  dataSchema?: { [k: string]: any } | undefined;
  uiSchema?: UiSchema$Outbound | undefined;
  values: LayoutControlValuesDto$Outbound;
};

/** @internal */
export const LayoutControlsDto$outboundSchema: z.ZodType<LayoutControlsDto$Outbound, z.ZodTypeDef, LayoutControlsDto> =
  z.object({
    dataSchema: z.record(z.any()).optional(),
    uiSchema: UiSchema$outboundSchema.optional(),
    values: LayoutControlValuesDto$outboundSchema,
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutControlsDto$ {
  /** @deprecated use `LayoutControlsDto$inboundSchema` instead. */
  export const inboundSchema = LayoutControlsDto$inboundSchema;
  /** @deprecated use `LayoutControlsDto$outboundSchema` instead. */
  export const outboundSchema = LayoutControlsDto$outboundSchema;
  /** @deprecated use `LayoutControlsDto$Outbound` instead. */
  export type Outbound = LayoutControlsDto$Outbound;
}

export function layoutControlsDtoToJSON(layoutControlsDto: LayoutControlsDto): string {
  return JSON.stringify(LayoutControlsDto$outboundSchema.parse(layoutControlsDto));
}

export function layoutControlsDtoFromJSON(jsonString: string): SafeParseResult<LayoutControlsDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutControlsDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutControlsDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutControlsDtoToJSON(layoutControlsDto: LayoutControlsDto)
 - layoutControlsDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutControlsDto$Outbound;
}

export function layoutControlsDtoToJSON(layoutControlsDto: LayoutCont...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutControlsDtoToJSON
- export function layoutControlsDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/layoutcontrolvaluesdto.ts
Tamaño: 2230 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  EmailControlsDto,
  EmailControlsDto$inboundSchema,
  EmailControlsDto$Outbound,
  EmailControlsDto$outboundSchema,
} from './emailcontrolsdto.js';

export type LayoutControlValuesDto = {
  /**
   * Email layout controls
   */
  email?: EmailControlsDto | undefined;
};

/** @internal */
export const LayoutControlValuesDto$inboundSchema: z.ZodType<LayoutControlValuesDto, z.ZodTypeDef, unknown> = z.object({
  email: EmailControlsDto$inboundSchema.optional(),
});

/** @internal */
export type LayoutControlValuesDto$Outbound = {
  email?: EmailControlsDto$Outbound | undefined;
};

/** @internal */
export const LayoutControlValuesDto$outboundSchema: z.ZodType<
  LayoutControlValuesDto$Outbound,
  z.ZodTypeDef,
  LayoutControlValuesDto
> = z.object({
  email: EmailControlsDto$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutControlValuesDto$ {
  /** @deprecated use `LayoutControlValuesDto$inboundSchema` instead. */
  export const inboundSchema = LayoutControlValuesDto$inboundSchema;
  /** @deprecated use `LayoutControlValuesDto$outboundSchema` instead. */
  export const outboundSchema = LayoutControlValuesDto$outboundSchema;
  /** @deprecated use `LayoutControlValuesDto$Outbound` instead. */
  export type Outbound = LayoutControlValuesDto$Outbound;
}

export function layoutControlValuesDtoToJSON(layoutControlValuesDto: LayoutControlValuesDto): string {
  return JSON.stringify(LayoutControlValuesDto$outboundSchema.parse(layoutControlValuesDto));
}

export function layoutControlValuesDtoFromJSON(
  jsonString: string
): SafeParseResult<LayoutControlValuesDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutControlValuesDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutControlValuesDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutControlValuesDtoToJSON(layoutControlValuesDto: LayoutControlValuesDto)
 - layoutControlValuesDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutControlValuesDto$Outbound;
}

export function layoutControlValuesDtoToJSON(layoutControlValues...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutControlValuesDtoToJSON
- export function layoutControlValuesDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/layoutcreationsourceenum.ts
Tamaño: 1222 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Source of layout creation
 */
export const LayoutCreationSourceEnum = {
  Dashboard: 'dashboard',
} as const;
/**
 * Source of layout creation
 */
export type LayoutCreationSourceEnum = ClosedEnum<typeof LayoutCreationSourceEnum>;

/** @internal */
export const LayoutCreationSourceEnum$inboundSchema: z.ZodNativeEnum<typeof LayoutCreationSourceEnum> =
  z.nativeEnum(LayoutCreationSourceEnum);

/** @internal */
export const LayoutCreationSourceEnum$outboundSchema: z.ZodNativeEnum<typeof LayoutCreationSourceEnum> =
  LayoutCreationSourceEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutCreationSourceEnum$ {
  /** @deprecated use `LayoutCreationSourceEnum$inboundSchema` instead. */
  export const inboundSchema = LayoutCreationSourceEnum$inboundSchema;
  /** @deprecated use `LayoutCreationSourceEnum$outboundSchema` instead. */
  export const outboundSchema = LayoutCreationSourceEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/layoutpreviewpayloaddto.ts
Tamaño: 2405 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  SubscriberResponseDtoOptional,
  SubscriberResponseDtoOptional$inboundSchema,
  SubscriberResponseDtoOptional$Outbound,
  SubscriberResponseDtoOptional$outboundSchema,
} from './subscriberresponsedtooptional.js';

export type LayoutPreviewPayloadDto = {
  /**
   * Partial subscriber information
   */
  subscriber?: SubscriberResponseDtoOptional | undefined;
};

/** @internal */
export const LayoutPreviewPayloadDto$inboundSchema: z.ZodType<LayoutPreviewPayloadDto, z.ZodTypeDef, unknown> =
  z.object({
    subscriber: SubscriberResponseDtoOptional$inboundSchema.optional(),
  });

/** @internal */
export type LayoutPreviewPayloadDto$Outbound = {
  subscriber?: SubscriberResponseDtoOptional$Outbound | undefined;
};

/** @internal */
export const LayoutPreviewPayloadDto$outboundSchema: z.ZodType<
  LayoutPreviewPayloadDto$Outbound,
  z.ZodTypeDef,
  LayoutPreviewPayloadDto
> = z.object({
  subscriber: SubscriberResponseDtoOptional$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutPreviewPayloadDto$ {
  /** @deprecated use `LayoutPreviewPayloadDto$inboundSchema` instead. */
  export const inboundSchema = LayoutPreviewPayloadDto$inboundSchema;
  /** @deprecated use `LayoutPreviewPayloadDto$outboundSchema` instead. */
  export const outboundSchema = LayoutPreviewPayloadDto$outboundSchema;
  /** @deprecated use `LayoutPreviewPayloadDto$Outbound` instead. */
  export type Outbound = LayoutPreviewPayloadDto$Outbound;
}

export function layoutPreviewPayloadDtoToJSON(layoutPreviewPayloadDto: LayoutPreviewPayloadDto): string {
  return JSON.stringify(LayoutPreviewPayloadDto$outboundSchema.parse(layoutPreviewPayloadDto));
}

export function layoutPreviewPayloadDtoFromJSON(
  jsonString: string
): SafeParseResult<LayoutPreviewPayloadDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutPreviewPayloadDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutPreviewPayloadDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutPreviewPayloadDtoToJSON(layoutPreviewPayloadDto: LayoutPreviewPayloadDto)
 - layoutPreviewPayloadDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutPreviewPayloadDto$Outbound;
}

export function layoutPreviewPayloadDtoToJSON(layoutPreviewPayl...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutPreviewPayloadDtoToJSON
- export function layoutPreviewPayloadDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/layoutpreviewrequestdto.ts
Tamaño: 2632 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  LayoutPreviewPayloadDto,
  LayoutPreviewPayloadDto$inboundSchema,
  LayoutPreviewPayloadDto$Outbound,
  LayoutPreviewPayloadDto$outboundSchema,
} from './layoutpreviewpayloaddto.js';

export type LayoutPreviewRequestDto = {
  /**
   * Optional control values for layout preview
   */
  controlValues?: { [k: string]: any } | undefined;
  /**
   * Optional payload for layout preview
   */
  previewPayload?: LayoutPreviewPayloadDto | undefined;
};

/** @internal */
export const LayoutPreviewRequestDto$inboundSchema: z.ZodType<LayoutPreviewRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    controlValues: z.record(z.any()).optional(),
    previewPayload: LayoutPreviewPayloadDto$inboundSchema.optional(),
  });

/** @internal */
export type LayoutPreviewRequestDto$Outbound = {
  controlValues?: { [k: string]: any } | undefined;
  previewPayload?: LayoutPreviewPayloadDto$Outbound | undefined;
};

/** @internal */
export const LayoutPreviewRequestDto$outboundSchema: z.ZodType<
  LayoutPreviewRequestDto$Outbound,
  z.ZodTypeDef,
  LayoutPreviewRequestDto
> = z.object({
  controlValues: z.record(z.any()).optional(),
  previewPayload: LayoutPreviewPayloadDto$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutPreviewRequestDto$ {
  /** @deprecated use `LayoutPreviewRequestDto$inboundSchema` instead. */
  export const inboundSchema = LayoutPreviewRequestDto$inboundSchema;
  /** @deprecated use `LayoutPreviewRequestDto$outboundSchema` instead. */
  export const outboundSchema = LayoutPreviewRequestDto$outboundSchema;
  /** @deprecated use `LayoutPreviewRequestDto$Outbound` instead. */
  export type Outbound = LayoutPreviewRequestDto$Outbound;
}

export function layoutPreviewRequestDtoToJSON(layoutPreviewRequestDto: LayoutPreviewRequestDto): string {
  return JSON.stringify(LayoutPreviewRequestDto$outboundSchema.parse(layoutPreviewRequestDto));
}

export function layoutPreviewRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<LayoutPreviewRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutPreviewRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutPreviewRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutPreviewRequestDtoToJSON(layoutPreviewRequestDto: LayoutPreviewRequestDto)
 - layoutPreviewRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutPreviewRequestDto$Outbound;
}

export function layoutPreviewRequestDtoToJSON(layoutPreviewRequ...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutPreviewRequestDtoToJSON
- export function layoutPreviewRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/layoutresponsedto.ts
Tamaño: 6853 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  LayoutControlsDto,
  LayoutControlsDto$inboundSchema,
  LayoutControlsDto$Outbound,
  LayoutControlsDto$outboundSchema,
} from './layoutcontrolsdto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  ResourceTypeEnum,
  ResourceTypeEnum$inboundSchema,
  ResourceTypeEnum$outboundSchema,
} from './resourcetypeenum.js';

/**
 * User who last updated the layout
 */
export type UpdatedBy = {
  /**
   * User ID
   */
  id: string;
  /**
   * User first name
   */
  firstName?: string | null | undefined;
  /**
   * User last name
   */
  lastName?: string | null | undefined;
  /**
   * User external ID
   */
  externalId?: string | null | undefined;
};

export type LayoutResponseDto = {
  /**
   * Unique internal identifier of the layout
   */
  id: string;
  /**
   * Unique identifier for the layout
   */
  layoutId: string;
  /**
   * Slug of the layout
   */
  slug: string;
  /**
   * Name of the layout
   */
  name: string;
  /**
   * Whether the layout is the default layout
   */
  isDefault: boolean;
  /**
   * Whether the layout translations are enabled
   */
  isTranslationEnabled: boolean;
  /**
   * Last updated timestamp
   */
  updatedAt: string;
  /**
   * User who last updated the layout
   */
  updatedBy?: UpdatedBy | null | undefined;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Type of the layout
   */
  type: ResourceTypeEnum;
  /**
   * The variables JSON Schema for the layout
   */
  variables?: { [k: string]: any } | null | undefined;
  /**
   * Controls metadata for the layout
   */
  controls: LayoutControlsDto;
};

/** @internal */
export const UpdatedBy$inboundSchema: z.ZodType<UpdatedBy, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type UpdatedBy$Outbound = {
  _id: string;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  externalId?: string | null | undefined;
};

/** @internal */
export const UpdatedBy$outboundSchema: z.ZodType<UpdatedBy$Outbound, z.ZodTypeDef, UpdatedBy> = z
  .object({
    id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatedBy$ {
  /** @deprecated use `UpdatedBy$inboundSchema` instead. */
  export const inboundSchema = UpdatedBy$inboundSchema;
  /** @deprecated use `UpdatedBy$outboundSchema` instead. */
  export const outboundSchema = UpdatedBy$outboundSchema;
  /** @deprecated use `UpdatedBy$Outbound` instead. */
  export type Outbound = UpdatedBy$Outbound;
}

export function updatedByToJSON(updatedBy: UpdatedBy): string {
  return JSON.stringify(UpdatedBy$outboundSchema.parse(updatedBy));
}

export function updatedByFromJSON(jsonString: string): SafeParseResult<UpdatedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatedBy' from JSON`
  );
}

/** @internal */
export const LayoutResponseDto$inboundSchema: z.ZodType<LayoutResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    layoutId: z.string(),
    slug: z.string(),
    name: z.string(),
    isDefault: z.boolean(),
    isTranslationEnabled: z.boolean(),
    updatedAt: z.string(),
    updatedBy: z.nullable(z.lazy(() => UpdatedBy$inboundSchema)).optional(),
    createdAt: z.string(),
    origin: ResourceOriginEnum$inboundSchema,
    type: ResourceTypeEnum$inboundSchema,
    variables: z.nullable(z.record(z.any())).optional(),
    controls: LayoutControlsDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type LayoutResponseDto$Outbound = {
  _id: string;
  layoutId: string;
  slug: string;
  name: string;
  isDefault: boolean;
  isTranslationEnabled: boolean;
  updatedAt: string;
  updatedBy?: UpdatedBy$Outbound | null | undefined;
  createdAt: string;
  origin: string;
  type: string;
  variables?: { [k: string]: any } | null | undefined;
  controls: LayoutControlsDto$Outbound;
};

/** @internal */
export const LayoutResponseDto$outboundSchema: z.ZodType<LayoutResponseDto$Outbound, z.ZodTypeDef, LayoutResponseDto> =
  z
    .object({
      id: z.string(),
      layoutId: z.string(),
      slug: z.string(),
      name: z.string(),
      isDefault: z.boolean(),
      isTranslationEnabled: z.boolean(),
      updatedAt: z.string(),
      updatedBy: z.nullable(z.lazy(() => UpdatedBy$outboundSchema)).optional(),
      createdAt: z.string(),
      origin: ResourceOriginEnum$outboundSchema,
      type: ResourceTypeEnum$outboundSchema,
      variables: z.nullable(z.record(z.any())).optional(),
      controls: LayoutControlsDto$outboundSchema,
    })
    .transform((v) => {
      return remap$(v, {
        id: '_id',
      });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutResponseDto$ {
  /** @deprecated use `LayoutResponseDto$inboundSchema` instead. */
  export const inboundSchema = LayoutResponseDto$inboundSchema;
  /** @deprecated use `LayoutResponseDto$outboundSchema` instead. */
  export const outboundSchema = LayoutResponseDto$outboundSchema;
  /** @deprecated use `LayoutResponseDto$Outbound` instead. */
  export type Outbound = LayoutResponseDto$Outbound;
}

export function layoutResponseDtoToJSON(layoutResponseDto: LayoutResponseDto): string {
  return JSON.stringify(LayoutResponseDto$outboundSchema.parse(layoutResponseDto));
}

export function layoutResponseDtoFromJSON(jsonString: string): SafeParseResult<LayoutResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updatedByToJSON(updatedBy: UpdatedBy)
 - updatedByFromJSON(jsonString: string)
 - layoutResponseDtoToJSON(layoutResponseDto: LayoutResponseDto)
 - layoutResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdatedBy$Outbound;
}

export function updatedByToJSON(updatedBy: UpdatedBy): string {
  return JSON...)
 - Outbound(LayoutResponseDto$Outbound;
}

export function layoutResponseDtoToJSON(layoutResponseDto: LayoutResp...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updatedByToJSON
- export function updatedByFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutResponseDtoToJSON
- export function layoutResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/layoutresponsedtosortfield.ts
Tamaño: 1218 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

export const LayoutResponseDtoSortField = {
  CreatedAt: 'createdAt',
  UpdatedAt: 'updatedAt',
  Name: 'name',
} as const;
export type LayoutResponseDtoSortField = ClosedEnum<typeof LayoutResponseDtoSortField>;

/** @internal */
export const LayoutResponseDtoSortField$inboundSchema: z.ZodNativeEnum<typeof LayoutResponseDtoSortField> =
  z.nativeEnum(LayoutResponseDtoSortField);

/** @internal */
export const LayoutResponseDtoSortField$outboundSchema: z.ZodNativeEnum<typeof LayoutResponseDtoSortField> =
  LayoutResponseDtoSortField$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutResponseDtoSortField$ {
  /** @deprecated use `LayoutResponseDtoSortField$inboundSchema` instead. */
  export const inboundSchema = LayoutResponseDtoSortField$inboundSchema;
  /** @deprecated use `LayoutResponseDtoSortField$outboundSchema` instead. */
  export const outboundSchema = LayoutResponseDtoSortField$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/listcontextsresponsedto.ts
Tamaño: 3070 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  GetContextResponseDto,
  GetContextResponseDto$inboundSchema,
  GetContextResponseDto$Outbound,
  GetContextResponseDto$outboundSchema,
} from './getcontextresponsedto.js';

export type ListContextsResponseDto = {
  /**
   * List of returned Contexts
   */
  data: Array<GetContextResponseDto>;
  /**
   * The cursor for the next page of results, or null if there are no more pages.
   */
  next: string | null;
  /**
   * The cursor for the previous page of results, or null if this is the first page.
   */
  previous: string | null;
  /**
   * The total count of items (up to 50,000)
   */
  totalCount: number;
  /**
   * Whether there are more than 50,000 results available
   */
  totalCountCapped: boolean;
};

/** @internal */
export const ListContextsResponseDto$inboundSchema: z.ZodType<ListContextsResponseDto, z.ZodTypeDef, unknown> =
  z.object({
    data: z.array(GetContextResponseDto$inboundSchema),
    next: z.nullable(z.string()),
    previous: z.nullable(z.string()),
    totalCount: z.number(),
    totalCountCapped: z.boolean(),
  });

/** @internal */
export type ListContextsResponseDto$Outbound = {
  data: Array<GetContextResponseDto$Outbound>;
  next: string | null;
  previous: string | null;
  totalCount: number;
  totalCountCapped: boolean;
};

/** @internal */
export const ListContextsResponseDto$outboundSchema: z.ZodType<
  ListContextsResponseDto$Outbound,
  z.ZodTypeDef,
  ListContextsResponseDto
> = z.object({
  data: z.array(GetContextResponseDto$outboundSchema),
  next: z.nullable(z.string()),
  previous: z.nullable(z.string()),
  totalCount: z.number(),
  totalCountCapped: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContextsResponseDto$ {
  /** @deprecated use `ListContextsResponseDto$inboundSchema` instead. */
  export const inboundSchema = ListContextsResponseDto$inboundSchema;
  /** @deprecated use `ListContextsResponseDto$outboundSchema` instead. */
  export const outboundSchema = ListContextsResponseDto$outboundSchema;
  /** @deprecated use `ListContextsResponseDto$Outbound` instead. */
  export type Outbound = ListContextsResponseDto$Outbound;
}

export function listContextsResponseDtoToJSON(listContextsResponseDto: ListContextsResponseDto): string {
  return JSON.stringify(ListContextsResponseDto$outboundSchema.parse(listContextsResponseDto));
}

export function listContextsResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ListContextsResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContextsResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContextsResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - listContextsResponseDtoToJSON(listContextsResponseDto: ListContextsResponseDto)
 - listContextsResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ListContextsResponseDto$Outbound;
}

export function listContextsResponseDtoToJSON(listContextsRespo...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function listContextsResponseDtoToJSON
- export function listContextsResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/listlayoutresponsedto.ts
Tamaño: 2339 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  LayoutResponseDto,
  LayoutResponseDto$inboundSchema,
  LayoutResponseDto$Outbound,
  LayoutResponseDto$outboundSchema,
} from './layoutresponsedto.js';

export type ListLayoutResponseDto = {
  /**
   * List of layouts
   */
  layouts: Array<LayoutResponseDto>;
  /**
   * Total number of layouts
   */
  totalCount: number;
};

/** @internal */
export const ListLayoutResponseDto$inboundSchema: z.ZodType<ListLayoutResponseDto, z.ZodTypeDef, unknown> = z.object({
  layouts: z.array(LayoutResponseDto$inboundSchema),
  totalCount: z.number(),
});

/** @internal */
export type ListLayoutResponseDto$Outbound = {
  layouts: Array<LayoutResponseDto$Outbound>;
  totalCount: number;
};

/** @internal */
export const ListLayoutResponseDto$outboundSchema: z.ZodType<
  ListLayoutResponseDto$Outbound,
  z.ZodTypeDef,
  ListLayoutResponseDto
> = z.object({
  layouts: z.array(LayoutResponseDto$outboundSchema),
  totalCount: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListLayoutResponseDto$ {
  /** @deprecated use `ListLayoutResponseDto$inboundSchema` instead. */
  export const inboundSchema = ListLayoutResponseDto$inboundSchema;
  /** @deprecated use `ListLayoutResponseDto$outboundSchema` instead. */
  export const outboundSchema = ListLayoutResponseDto$outboundSchema;
  /** @deprecated use `ListLayoutResponseDto$Outbound` instead. */
  export type Outbound = ListLayoutResponseDto$Outbound;
}

export function listLayoutResponseDtoToJSON(listLayoutResponseDto: ListLayoutResponseDto): string {
  return JSON.stringify(ListLayoutResponseDto$outboundSchema.parse(listLayoutResponseDto));
}

export function listLayoutResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ListLayoutResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListLayoutResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListLayoutResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - listLayoutResponseDtoToJSON(listLayoutResponseDto: ListLayoutResponseDto)
 - listLayoutResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ListLayoutResponseDto$Outbound;
}

export function listLayoutResponseDtoToJSON(listLayoutResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function listLayoutResponseDtoToJSON
- export function listLayoutResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/listsubscribersresponsedto.ts
Tamaño: 3142 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  SubscriberResponseDto,
  SubscriberResponseDto$inboundSchema,
  SubscriberResponseDto$Outbound,
  SubscriberResponseDto$outboundSchema,
} from './subscriberresponsedto.js';

export type ListSubscribersResponseDto = {
  /**
   * List of returned Subscribers
   */
  data: Array<SubscriberResponseDto>;
  /**
   * The cursor for the next page of results, or null if there are no more pages.
   */
  next: string | null;
  /**
   * The cursor for the previous page of results, or null if this is the first page.
   */
  previous: string | null;
  /**
   * The total count of items (up to 50,000)
   */
  totalCount: number;
  /**
   * Whether there are more than 50,000 results available
   */
  totalCountCapped: boolean;
};

/** @internal */
export const ListSubscribersResponseDto$inboundSchema: z.ZodType<ListSubscribersResponseDto, z.ZodTypeDef, unknown> =
  z.object({
    data: z.array(SubscriberResponseDto$inboundSchema),
    next: z.nullable(z.string()),
    previous: z.nullable(z.string()),
    totalCount: z.number(),
    totalCountCapped: z.boolean(),
  });

/** @internal */
export type ListSubscribersResponseDto$Outbound = {
  data: Array<SubscriberResponseDto$Outbound>;
  next: string | null;
  previous: string | null;
  totalCount: number;
  totalCountCapped: boolean;
};

/** @internal */
export const ListSubscribersResponseDto$outboundSchema: z.ZodType<
  ListSubscribersResponseDto$Outbound,
  z.ZodTypeDef,
  ListSubscribersResponseDto
> = z.object({
  data: z.array(SubscriberResponseDto$outboundSchema),
  next: z.nullable(z.string()),
  previous: z.nullable(z.string()),
  totalCount: z.number(),
  totalCountCapped: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscribersResponseDto$ {
  /** @deprecated use `ListSubscribersResponseDto$inboundSchema` instead. */
  export const inboundSchema = ListSubscribersResponseDto$inboundSchema;
  /** @deprecated use `ListSubscribersResponseDto$outboundSchema` instead. */
  export const outboundSchema = ListSubscribersResponseDto$outboundSchema;
  /** @deprecated use `ListSubscribersResponseDto$Outbound` instead. */
  export type Outbound = ListSubscribersResponseDto$Outbound;
}

export function listSubscribersResponseDtoToJSON(listSubscribersResponseDto: ListSubscribersResponseDto): string {
  return JSON.stringify(ListSubscribersResponseDto$outboundSchema.parse(listSubscribersResponseDto));
}

export function listSubscribersResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ListSubscribersResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscribersResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscribersResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - listSubscribersResponseDtoToJSON(listSubscribersResponseDto: ListSubscribersResponseDto)
 - listSubscribersResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ListSubscribersResponseDto$Outbound;
}

export function listSubscribersResponseDtoToJSON(listSubscri...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function listSubscribersResponseDtoToJSON
- export function listSubscribersResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/listtopicsresponsedto.ts
Tamaño: 2963 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  TopicResponseDto,
  TopicResponseDto$inboundSchema,
  TopicResponseDto$Outbound,
  TopicResponseDto$outboundSchema,
} from './topicresponsedto.js';

export type ListTopicsResponseDto = {
  /**
   * List of returned Topics
   */
  data: Array<TopicResponseDto>;
  /**
   * The cursor for the next page of results, or null if there are no more pages.
   */
  next: string | null;
  /**
   * The cursor for the previous page of results, or null if this is the first page.
   */
  previous: string | null;
  /**
   * The total count of items (up to 50,000)
   */
  totalCount: number;
  /**
   * Whether there are more than 50,000 results available
   */
  totalCountCapped: boolean;
};

/** @internal */
export const ListTopicsResponseDto$inboundSchema: z.ZodType<ListTopicsResponseDto, z.ZodTypeDef, unknown> = z.object({
  data: z.array(TopicResponseDto$inboundSchema),
  next: z.nullable(z.string()),
  previous: z.nullable(z.string()),
  totalCount: z.number(),
  totalCountCapped: z.boolean(),
});

/** @internal */
export type ListTopicsResponseDto$Outbound = {
  data: Array<TopicResponseDto$Outbound>;
  next: string | null;
  previous: string | null;
  totalCount: number;
  totalCountCapped: boolean;
};

/** @internal */
export const ListTopicsResponseDto$outboundSchema: z.ZodType<
  ListTopicsResponseDto$Outbound,
  z.ZodTypeDef,
  ListTopicsResponseDto
> = z.object({
  data: z.array(TopicResponseDto$outboundSchema),
  next: z.nullable(z.string()),
  previous: z.nullable(z.string()),
  totalCount: z.number(),
  totalCountCapped: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListTopicsResponseDto$ {
  /** @deprecated use `ListTopicsResponseDto$inboundSchema` instead. */
  export const inboundSchema = ListTopicsResponseDto$inboundSchema;
  /** @deprecated use `ListTopicsResponseDto$outboundSchema` instead. */
  export const outboundSchema = ListTopicsResponseDto$outboundSchema;
  /** @deprecated use `ListTopicsResponseDto$Outbound` instead. */
  export type Outbound = ListTopicsResponseDto$Outbound;
}

export function listTopicsResponseDtoToJSON(listTopicsResponseDto: ListTopicsResponseDto): string {
  return JSON.stringify(ListTopicsResponseDto$outboundSchema.parse(listTopicsResponseDto));
}

export function listTopicsResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ListTopicsResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListTopicsResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListTopicsResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - listTopicsResponseDtoToJSON(listTopicsResponseDto: ListTopicsResponseDto)
 - listTopicsResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ListTopicsResponseDto$Outbound;
}

export function listTopicsResponseDtoToJSON(listTopicsResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function listTopicsResponseDtoToJSON
- export function listTopicsResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/listtopicsubscriptionsresponsedto.ts
Tamaño: 3372 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  TopicSubscriptionResponseDto,
  TopicSubscriptionResponseDto$inboundSchema,
  TopicSubscriptionResponseDto$Outbound,
  TopicSubscriptionResponseDto$outboundSchema,
} from './topicsubscriptionresponsedto.js';

export type ListTopicSubscriptionsResponseDto = {
  /**
   * List of returned Topic Subscriptions
   */
  data: Array<TopicSubscriptionResponseDto>;
  /**
   * The cursor for the next page of results, or null if there are no more pages.
   */
  next: string | null;
  /**
   * The cursor for the previous page of results, or null if this is the first page.
   */
  previous: string | null;
  /**
   * The total count of items (up to 50,000)
   */
  totalCount: number;
  /**
   * Whether there are more than 50,000 results available
   */
  totalCountCapped: boolean;
};

/** @internal */
export const ListTopicSubscriptionsResponseDto$inboundSchema: z.ZodType<
  ListTopicSubscriptionsResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.array(TopicSubscriptionResponseDto$inboundSchema),
  next: z.nullable(z.string()),
  previous: z.nullable(z.string()),
  totalCount: z.number(),
  totalCountCapped: z.boolean(),
});

/** @internal */
export type ListTopicSubscriptionsResponseDto$Outbound = {
  data: Array<TopicSubscriptionResponseDto$Outbound>;
  next: string | null;
  previous: string | null;
  totalCount: number;
  totalCountCapped: boolean;
};

/** @internal */
export const ListTopicSubscriptionsResponseDto$outboundSchema: z.ZodType<
  ListTopicSubscriptionsResponseDto$Outbound,
  z.ZodTypeDef,
  ListTopicSubscriptionsResponseDto
> = z.object({
  data: z.array(TopicSubscriptionResponseDto$outboundSchema),
  next: z.nullable(z.string()),
  previous: z.nullable(z.string()),
  totalCount: z.number(),
  totalCountCapped: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListTopicSubscriptionsResponseDto$ {
  /** @deprecated use `ListTopicSubscriptionsResponseDto$inboundSchema` instead. */
  export const inboundSchema = ListTopicSubscriptionsResponseDto$inboundSchema;
  /** @deprecated use `ListTopicSubscriptionsResponseDto$outboundSchema` instead. */
  export const outboundSchema = ListTopicSubscriptionsResponseDto$outboundSchema;
  /** @deprecated use `ListTopicSubscriptionsResponseDto$Outbound` instead. */
  export type Outbound = ListTopicSubscriptionsResponseDto$Outbound;
}

export function listTopicSubscriptionsResponseDtoToJSON(
  listTopicSubscriptionsResponseDto: ListTopicSubscriptionsResponseDto
): string {
  return JSON.stringify(ListTopicSubscriptionsResponseDto$outboundSchema.parse(listTopicSubscriptionsResponseDto));
}

export function listTopicSubscriptionsResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ListTopicSubscriptionsResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListTopicSubscriptionsResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListTopicSubscriptionsResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - listTopicSubscriptionsResponseDtoToJSON(listTopicSubscriptionsResponseDto: ListTopicSubscriptionsResponseDto)
 - listTopicSubscriptionsResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ListTopicSubscriptionsResponseDto$Outbound;
}

export function listTopicSubscriptionsResponseDtoToJS...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function listTopicSubscriptionsResponseDtoToJSON
- export function listTopicSubscriptionsResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/listworkflowresponse.ts
Tamaño: 2382 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  WorkflowListResponseDto,
  WorkflowListResponseDto$inboundSchema,
  WorkflowListResponseDto$Outbound,
  WorkflowListResponseDto$outboundSchema,
} from './workflowlistresponsedto.js';

export type ListWorkflowResponse = {
  /**
   * List of workflows
   */
  workflows: Array<WorkflowListResponseDto>;
  /**
   * Total number of workflows
   */
  totalCount: number;
};

/** @internal */
export const ListWorkflowResponse$inboundSchema: z.ZodType<ListWorkflowResponse, z.ZodTypeDef, unknown> = z.object({
  workflows: z.array(WorkflowListResponseDto$inboundSchema),
  totalCount: z.number(),
});

/** @internal */
export type ListWorkflowResponse$Outbound = {
  workflows: Array<WorkflowListResponseDto$Outbound>;
  totalCount: number;
};

/** @internal */
export const ListWorkflowResponse$outboundSchema: z.ZodType<
  ListWorkflowResponse$Outbound,
  z.ZodTypeDef,
  ListWorkflowResponse
> = z.object({
  workflows: z.array(WorkflowListResponseDto$outboundSchema),
  totalCount: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListWorkflowResponse$ {
  /** @deprecated use `ListWorkflowResponse$inboundSchema` instead. */
  export const inboundSchema = ListWorkflowResponse$inboundSchema;
  /** @deprecated use `ListWorkflowResponse$outboundSchema` instead. */
  export const outboundSchema = ListWorkflowResponse$outboundSchema;
  /** @deprecated use `ListWorkflowResponse$Outbound` instead. */
  export type Outbound = ListWorkflowResponse$Outbound;
}

export function listWorkflowResponseToJSON(listWorkflowResponse: ListWorkflowResponse): string {
  return JSON.stringify(ListWorkflowResponse$outboundSchema.parse(listWorkflowResponse));
}

export function listWorkflowResponseFromJSON(
  jsonString: string
): SafeParseResult<ListWorkflowResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListWorkflowResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListWorkflowResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - listWorkflowResponseToJSON(listWorkflowResponse: ListWorkflowResponse)
 - listWorkflowResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ListWorkflowResponse$Outbound;
}

export function listWorkflowResponseToJSON(listWorkflowResponse: L...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function listWorkflowResponseToJSON
- export function listWorkflowResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/lookbackwindowdto.ts
Tamaño: 3241 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Unit of time for the look-back window.
 */
export const LookBackWindowDtoUnit = {
  Seconds: 'seconds',
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
  Weeks: 'weeks',
  Months: 'months',
} as const;
/**
 * Unit of time for the look-back window.
 */
export type LookBackWindowDtoUnit = ClosedEnum<typeof LookBackWindowDtoUnit>;

export type LookBackWindowDto = {
  /**
   * Amount of time for the look-back window.
   */
  amount: number;
  /**
   * Unit of time for the look-back window.
   */
  unit: LookBackWindowDtoUnit;
};

/** @internal */
export const LookBackWindowDtoUnit$inboundSchema: z.ZodNativeEnum<typeof LookBackWindowDtoUnit> =
  z.nativeEnum(LookBackWindowDtoUnit);

/** @internal */
export const LookBackWindowDtoUnit$outboundSchema: z.ZodNativeEnum<typeof LookBackWindowDtoUnit> =
  LookBackWindowDtoUnit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LookBackWindowDtoUnit$ {
  /** @deprecated use `LookBackWindowDtoUnit$inboundSchema` instead. */
  export const inboundSchema = LookBackWindowDtoUnit$inboundSchema;
  /** @deprecated use `LookBackWindowDtoUnit$outboundSchema` instead. */
  export const outboundSchema = LookBackWindowDtoUnit$outboundSchema;
}

/** @internal */
export const LookBackWindowDto$inboundSchema: z.ZodType<LookBackWindowDto, z.ZodTypeDef, unknown> = z.object({
  amount: z.number(),
  unit: LookBackWindowDtoUnit$inboundSchema,
});

/** @internal */
export type LookBackWindowDto$Outbound = {
  amount: number;
  unit: string;
};

/** @internal */
export const LookBackWindowDto$outboundSchema: z.ZodType<LookBackWindowDto$Outbound, z.ZodTypeDef, LookBackWindowDto> =
  z.object({
    amount: z.number(),
    unit: LookBackWindowDtoUnit$outboundSchema,
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LookBackWindowDto$ {
  /** @deprecated use `LookBackWindowDto$inboundSchema` instead. */
  export const inboundSchema = LookBackWindowDto$inboundSchema;
  /** @deprecated use `LookBackWindowDto$outboundSchema` instead. */
  export const outboundSchema = LookBackWindowDto$outboundSchema;
  /** @deprecated use `LookBackWindowDto$Outbound` instead. */
  export type Outbound = LookBackWindowDto$Outbound;
}

export function lookBackWindowDtoToJSON(lookBackWindowDto: LookBackWindowDto): string {
  return JSON.stringify(LookBackWindowDto$outboundSchema.parse(lookBackWindowDto));
}

export function lookBackWindowDtoFromJSON(jsonString: string): SafeParseResult<LookBackWindowDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LookBackWindowDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LookBackWindowDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - lookBackWindowDtoToJSON(lookBackWindowDto: LookBackWindowDto)
 - lookBackWindowDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LookBackWindowDto$Outbound;
}

export function lookBackWindowDtoToJSON(lookBackWindowDto: LookBackWi...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function lookBackWindowDtoToJSON
- export function lookBackWindowDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/markallmessageasrequestdto.ts
Tamaño: 4948 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Optional feed identifier or array of feed identifiers
 */
export type FeedIdentifier = string | Array<string>;

/**
 * Mark all subscriber messages as read, unread, seen or unseen
 */
export const MarkAs = {
  Read: 'read',
  Seen: 'seen',
  Unread: 'unread',
  Unseen: 'unseen',
} as const;
/**
 * Mark all subscriber messages as read, unread, seen or unseen
 */
export type MarkAs = ClosedEnum<typeof MarkAs>;

export type MarkAllMessageAsRequestDto = {
  /**
   * Optional feed identifier or array of feed identifiers
   */
  feedIdentifier?: string | Array<string> | undefined;
  /**
   * Mark all subscriber messages as read, unread, seen or unseen
   */
  markAs: MarkAs;
};

/** @internal */
export const FeedIdentifier$inboundSchema: z.ZodType<FeedIdentifier, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type FeedIdentifier$Outbound = string | Array<string>;

/** @internal */
export const FeedIdentifier$outboundSchema: z.ZodType<FeedIdentifier$Outbound, z.ZodTypeDef, FeedIdentifier> = z.union([
  z.string(),
  z.array(z.string()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeedIdentifier$ {
  /** @deprecated use `FeedIdentifier$inboundSchema` instead. */
  export const inboundSchema = FeedIdentifier$inboundSchema;
  /** @deprecated use `FeedIdentifier$outboundSchema` instead. */
  export const outboundSchema = FeedIdentifier$outboundSchema;
  /** @deprecated use `FeedIdentifier$Outbound` instead. */
  export type Outbound = FeedIdentifier$Outbound;
}

export function feedIdentifierToJSON(feedIdentifier: FeedIdentifier): string {
  return JSON.stringify(FeedIdentifier$outboundSchema.parse(feedIdentifier));
}

export function feedIdentifierFromJSON(jsonString: string): SafeParseResult<FeedIdentifier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FeedIdentifier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeedIdentifier' from JSON`
  );
}

/** @internal */
export const MarkAs$inboundSchema: z.ZodNativeEnum<typeof MarkAs> = z.nativeEnum(MarkAs);

/** @internal */
export const MarkAs$outboundSchema: z.ZodNativeEnum<typeof MarkAs> = MarkAs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MarkAs$ {
  /** @deprecated use `MarkAs$inboundSchema` instead. */
  export const inboundSchema = MarkAs$inboundSchema;
  /** @deprecated use `MarkAs$outboundSchema` instead. */
  export const outboundSchema = MarkAs$outboundSchema;
}

/** @internal */
export const MarkAllMessageAsRequestDto$inboundSchema: z.ZodType<MarkAllMessageAsRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    feedIdentifier: z.union([z.string(), z.array(z.string())]).optional(),
    markAs: MarkAs$inboundSchema,
  });

/** @internal */
export type MarkAllMessageAsRequestDto$Outbound = {
  feedIdentifier?: string | Array<string> | undefined;
  markAs: string;
};

/** @internal */
export const MarkAllMessageAsRequestDto$outboundSchema: z.ZodType<
  MarkAllMessageAsRequestDto$Outbound,
  z.ZodTypeDef,
  MarkAllMessageAsRequestDto
> = z.object({
  feedIdentifier: z.union([z.string(), z.array(z.string())]).optional(),
  markAs: MarkAs$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MarkAllMessageAsRequestDto$ {
  /** @deprecated use `MarkAllMessageAsRequestDto$inboundSchema` instead. */
  export const inboundSchema = MarkAllMessageAsRequestDto$inboundSchema;
  /** @deprecated use `MarkAllMessageAsRequestDto$outboundSchema` instead. */
  export const outboundSchema = MarkAllMessageAsRequestDto$outboundSchema;
  /** @deprecated use `MarkAllMessageAsRequestDto$Outbound` instead. */
  export type Outbound = MarkAllMessageAsRequestDto$Outbound;
}

export function markAllMessageAsRequestDtoToJSON(markAllMessageAsRequestDto: MarkAllMessageAsRequestDto): string {
  return JSON.stringify(MarkAllMessageAsRequestDto$outboundSchema.parse(markAllMessageAsRequestDto));
}

export function markAllMessageAsRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<MarkAllMessageAsRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MarkAllMessageAsRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MarkAllMessageAsRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - feedIdentifierToJSON(feedIdentifier: FeedIdentifier)
 - feedIdentifierFromJSON(jsonString: string)
 - markAllMessageAsRequestDtoToJSON(markAllMessageAsRequestDto: MarkAllMessageAsRequestDto)
 - markAllMessageAsRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(FeedIdentifier$Outbound;
}

export function feedIdentifierToJSON(feedIdentifier: FeedIdentifier): st...)
 - Outbound(MarkAllMessageAsRequestDto$Outbound;
}

export function markAllMessageAsRequestDtoToJSON(markAllMess...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function feedIdentifierToJSON
- export function feedIdentifierFromJSON
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function markAllMessageAsRequestDtoToJSON
- export function markAllMessageAsRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/markmessageactionasseendto.ts
Tamaño: 5570 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Message action status
 */
export const MarkMessageActionAsSeenDtoStatus = {
  Pending: 'pending',
  Done: 'done',
} as const;
/**
 * Message action status
 */
export type MarkMessageActionAsSeenDtoStatus = ClosedEnum<typeof MarkMessageActionAsSeenDtoStatus>;

/**
 * Message action payload
 */
export type MarkMessageActionAsSeenDtoPayload = {};

export type MarkMessageActionAsSeenDto = {
  /**
   * Message action status
   */
  status: MarkMessageActionAsSeenDtoStatus;
  /**
   * Message action payload
   */
  payload?: MarkMessageActionAsSeenDtoPayload | undefined;
};

/** @internal */
export const MarkMessageActionAsSeenDtoStatus$inboundSchema: z.ZodNativeEnum<typeof MarkMessageActionAsSeenDtoStatus> =
  z.nativeEnum(MarkMessageActionAsSeenDtoStatus);

/** @internal */
export const MarkMessageActionAsSeenDtoStatus$outboundSchema: z.ZodNativeEnum<typeof MarkMessageActionAsSeenDtoStatus> =
  MarkMessageActionAsSeenDtoStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MarkMessageActionAsSeenDtoStatus$ {
  /** @deprecated use `MarkMessageActionAsSeenDtoStatus$inboundSchema` instead. */
  export const inboundSchema = MarkMessageActionAsSeenDtoStatus$inboundSchema;
  /** @deprecated use `MarkMessageActionAsSeenDtoStatus$outboundSchema` instead. */
  export const outboundSchema = MarkMessageActionAsSeenDtoStatus$outboundSchema;
}

/** @internal */
export const MarkMessageActionAsSeenDtoPayload$inboundSchema: z.ZodType<
  MarkMessageActionAsSeenDtoPayload,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type MarkMessageActionAsSeenDtoPayload$Outbound = {};

/** @internal */
export const MarkMessageActionAsSeenDtoPayload$outboundSchema: z.ZodType<
  MarkMessageActionAsSeenDtoPayload$Outbound,
  z.ZodTypeDef,
  MarkMessageActionAsSeenDtoPayload
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MarkMessageActionAsSeenDtoPayload$ {
  /** @deprecated use `MarkMessageActionAsSeenDtoPayload$inboundSchema` instead. */
  export const inboundSchema = MarkMessageActionAsSeenDtoPayload$inboundSchema;
  /** @deprecated use `MarkMessageActionAsSeenDtoPayload$outboundSchema` instead. */
  export const outboundSchema = MarkMessageActionAsSeenDtoPayload$outboundSchema;
  /** @deprecated use `MarkMessageActionAsSeenDtoPayload$Outbound` instead. */
  export type Outbound = MarkMessageActionAsSeenDtoPayload$Outbound;
}

export function markMessageActionAsSeenDtoPayloadToJSON(
  markMessageActionAsSeenDtoPayload: MarkMessageActionAsSeenDtoPayload
): string {
  return JSON.stringify(MarkMessageActionAsSeenDtoPayload$outboundSchema.parse(markMessageActionAsSeenDtoPayload));
}

export function markMessageActionAsSeenDtoPayloadFromJSON(
  jsonString: string
): SafeParseResult<MarkMessageActionAsSeenDtoPayload, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MarkMessageActionAsSeenDtoPayload$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MarkMessageActionAsSeenDtoPayload' from JSON`
  );
}

/** @internal */
export const MarkMessageActionAsSeenDto$inboundSchema: z.ZodType<MarkMessageActionAsSeenDto, z.ZodTypeDef, unknown> =
  z.object({
    status: MarkMessageActionAsSeenDtoStatus$inboundSchema,
    payload: z.lazy(() => MarkMessageActionAsSeenDtoPayload$inboundSchema).optional(),
  });

/** @internal */
export type MarkMessageActionAsSeenDto$Outbound = {
  status: string;
  payload?: MarkMessageActionAsSeenDtoPayload$Outbound | undefined;
};

/** @internal */
export const MarkMessageActionAsSeenDto$outboundSchema: z.ZodType<
  MarkMessageActionAsSeenDto$Outbound,
  z.ZodTypeDef,
  MarkMessageActionAsSeenDto
> = z.object({
  status: MarkMessageActionAsSeenDtoStatus$outboundSchema,
  payload: z.lazy(() => MarkMessageActionAsSeenDtoPayload$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MarkMessageActionAsSeenDto$ {
  /** @deprecated use `MarkMessageActionAsSeenDto$inboundSchema` instead. */
  export const inboundSchema = MarkMessageActionAsSeenDto$inboundSchema;
  /** @deprecated use `MarkMessageActionAsSeenDto$outboundSchema` instead. */
  export const outboundSchema = MarkMessageActionAsSeenDto$outboundSchema;
  /** @deprecated use `MarkMessageActionAsSeenDto$Outbound` instead. */
  export type Outbound = MarkMessageActionAsSeenDto$Outbound;
}

export function markMessageActionAsSeenDtoToJSON(markMessageActionAsSeenDto: MarkMessageActionAsSeenDto): string {
  return JSON.stringify(MarkMessageActionAsSeenDto$outboundSchema.parse(markMessageActionAsSeenDto));
}

export function markMessageActionAsSeenDtoFromJSON(
  jsonString: string
): SafeParseResult<MarkMessageActionAsSeenDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MarkMessageActionAsSeenDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MarkMessageActionAsSeenDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - markMessageActionAsSeenDtoPayloadToJSON(markMessageActionAsSeenDtoPayload: MarkMessageActionAsSeenDtoPayload)
 - markMessageActionAsSeenDtoPayloadFromJSON(jsonString: string)
 - markMessageActionAsSeenDtoToJSON(markMessageActionAsSeenDto: MarkMessageActionAsSeenDto)
 - markMessageActionAsSeenDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MarkMessageActionAsSeenDtoPayload$Outbound;
}

export function markMessageActionAsSeenDtoPayloadToJS...)
 - Outbound(MarkMessageActionAsSeenDto$Outbound;
}

export function markMessageActionAsSeenDtoToJSON(markMessage...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function markMessageActionAsSeenDtoPayloadToJSON
- export function markMessageActionAsSeenDtoPayloadFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function markMessageActionAsSeenDtoToJSON
- export function markMessageActionAsSeenDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messageaction.ts
Tamaño: 2887 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  MessageActionResult,
  MessageActionResult$inboundSchema,
  MessageActionResult$Outbound,
  MessageActionResult$outboundSchema,
} from './messageactionresult.js';
import {
  MessageActionStatusEnum,
  MessageActionStatusEnum$inboundSchema,
  MessageActionStatusEnum$outboundSchema,
} from './messageactionstatusenum.js';
import {
  MessageButton,
  MessageButton$inboundSchema,
  MessageButton$Outbound,
  MessageButton$outboundSchema,
} from './messagebutton.js';

export type MessageAction = {
  /**
   * Status of the message action
   */
  status?: MessageActionStatusEnum | undefined;
  /**
   * List of buttons associated with the message action
   */
  buttons?: Array<MessageButton> | undefined;
  /**
   * Result of the message action
   */
  result?: MessageActionResult | undefined;
};

/** @internal */
export const MessageAction$inboundSchema: z.ZodType<MessageAction, z.ZodTypeDef, unknown> = z.object({
  status: MessageActionStatusEnum$inboundSchema.optional(),
  buttons: z.array(MessageButton$inboundSchema).optional(),
  result: MessageActionResult$inboundSchema.optional(),
});

/** @internal */
export type MessageAction$Outbound = {
  status?: string | undefined;
  buttons?: Array<MessageButton$Outbound> | undefined;
  result?: MessageActionResult$Outbound | undefined;
};

/** @internal */
export const MessageAction$outboundSchema: z.ZodType<MessageAction$Outbound, z.ZodTypeDef, MessageAction> = z.object({
  status: MessageActionStatusEnum$outboundSchema.optional(),
  buttons: z.array(MessageButton$outboundSchema).optional(),
  result: MessageActionResult$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageAction$ {
  /** @deprecated use `MessageAction$inboundSchema` instead. */
  export const inboundSchema = MessageAction$inboundSchema;
  /** @deprecated use `MessageAction$outboundSchema` instead. */
  export const outboundSchema = MessageAction$outboundSchema;
  /** @deprecated use `MessageAction$Outbound` instead. */
  export type Outbound = MessageAction$Outbound;
}

export function messageActionToJSON(messageAction: MessageAction): string {
  return JSON.stringify(MessageAction$outboundSchema.parse(messageAction));
}

export function messageActionFromJSON(jsonString: string): SafeParseResult<MessageAction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageAction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageAction' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageActionToJSON(messageAction: MessageAction)
 - messageActionFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageAction$Outbound;
}

export function messageActionToJSON(messageAction: MessageAction): string...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageActionToJSON
- export function messageActionFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messageactionresult.ts
Tamaño: 4098 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { ButtonTypeEnum, ButtonTypeEnum$inboundSchema, ButtonTypeEnum$outboundSchema } from './buttontypeenum.js';

/**
 * Payload of the action result
 */
export type MessageActionResultPayload = {};

export type MessageActionResult = {
  /**
   * Payload of the action result
   */
  payload?: MessageActionResultPayload | undefined;
  /**
   * Type of button for the action result
   */
  type?: ButtonTypeEnum | undefined;
};

/** @internal */
export const MessageActionResultPayload$inboundSchema: z.ZodType<MessageActionResultPayload, z.ZodTypeDef, unknown> =
  z.object({});

/** @internal */
export type MessageActionResultPayload$Outbound = {};

/** @internal */
export const MessageActionResultPayload$outboundSchema: z.ZodType<
  MessageActionResultPayload$Outbound,
  z.ZodTypeDef,
  MessageActionResultPayload
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageActionResultPayload$ {
  /** @deprecated use `MessageActionResultPayload$inboundSchema` instead. */
  export const inboundSchema = MessageActionResultPayload$inboundSchema;
  /** @deprecated use `MessageActionResultPayload$outboundSchema` instead. */
  export const outboundSchema = MessageActionResultPayload$outboundSchema;
  /** @deprecated use `MessageActionResultPayload$Outbound` instead. */
  export type Outbound = MessageActionResultPayload$Outbound;
}

export function messageActionResultPayloadToJSON(messageActionResultPayload: MessageActionResultPayload): string {
  return JSON.stringify(MessageActionResultPayload$outboundSchema.parse(messageActionResultPayload));
}

export function messageActionResultPayloadFromJSON(
  jsonString: string
): SafeParseResult<MessageActionResultPayload, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageActionResultPayload$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageActionResultPayload' from JSON`
  );
}

/** @internal */
export const MessageActionResult$inboundSchema: z.ZodType<MessageActionResult, z.ZodTypeDef, unknown> = z.object({
  payload: z.lazy(() => MessageActionResultPayload$inboundSchema).optional(),
  type: ButtonTypeEnum$inboundSchema.optional(),
});

/** @internal */
export type MessageActionResult$Outbound = {
  payload?: MessageActionResultPayload$Outbound | undefined;
  type?: string | undefined;
};

/** @internal */
export const MessageActionResult$outboundSchema: z.ZodType<
  MessageActionResult$Outbound,
  z.ZodTypeDef,
  MessageActionResult
> = z.object({
  payload: z.lazy(() => MessageActionResultPayload$outboundSchema).optional(),
  type: ButtonTypeEnum$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageActionResult$ {
  /** @deprecated use `MessageActionResult$inboundSchema` instead. */
  export const inboundSchema = MessageActionResult$inboundSchema;
  /** @deprecated use `MessageActionResult$outboundSchema` instead. */
  export const outboundSchema = MessageActionResult$outboundSchema;
  /** @deprecated use `MessageActionResult$Outbound` instead. */
  export type Outbound = MessageActionResult$Outbound;
}

export function messageActionResultToJSON(messageActionResult: MessageActionResult): string {
  return JSON.stringify(MessageActionResult$outboundSchema.parse(messageActionResult));
}

export function messageActionResultFromJSON(
  jsonString: string
): SafeParseResult<MessageActionResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageActionResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageActionResult' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageActionResultPayloadToJSON(messageActionResultPayload: MessageActionResultPayload)
 - messageActionResultPayloadFromJSON(jsonString: string)
 - messageActionResultToJSON(messageActionResult: MessageActionResult)
 - messageActionResultFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageActionResultPayload$Outbound;
}

export function messageActionResultPayloadToJSON(messageActi...)
 - Outbound(MessageActionResult$Outbound;
}

export function messageActionResultToJSON(messageActionResult: Mess...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageActionResultPayloadToJSON
- export function messageActionResultPayloadFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageActionResultToJSON
- export function messageActionResultFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messageactionstatusenum.ts
Tamaño: 1226 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Status of the message action
 */
export const MessageActionStatusEnum = {
  Pending: 'pending',
  Done: 'done',
} as const;
/**
 * Status of the message action
 */
export type MessageActionStatusEnum = ClosedEnum<typeof MessageActionStatusEnum>;

/** @internal */
export const MessageActionStatusEnum$inboundSchema: z.ZodNativeEnum<typeof MessageActionStatusEnum> =
  z.nativeEnum(MessageActionStatusEnum);

/** @internal */
export const MessageActionStatusEnum$outboundSchema: z.ZodNativeEnum<typeof MessageActionStatusEnum> =
  MessageActionStatusEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageActionStatusEnum$ {
  /** @deprecated use `MessageActionStatusEnum$inboundSchema` instead. */
  export const inboundSchema = MessageActionStatusEnum$inboundSchema;
  /** @deprecated use `MessageActionStatusEnum$outboundSchema` instead. */
  export const outboundSchema = MessageActionStatusEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messagebutton.ts
Tamaño: 2250 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { ButtonTypeEnum, ButtonTypeEnum$inboundSchema, ButtonTypeEnum$outboundSchema } from './buttontypeenum.js';

export type MessageButton = {
  /**
   * Type of button for the action result
   */
  type: ButtonTypeEnum;
  /**
   * Content of the button
   */
  content: string;
  /**
   * Content of the result when the button is clicked
   */
  resultContent?: string | undefined;
};

/** @internal */
export const MessageButton$inboundSchema: z.ZodType<MessageButton, z.ZodTypeDef, unknown> = z.object({
  type: ButtonTypeEnum$inboundSchema,
  content: z.string(),
  resultContent: z.string().optional(),
});

/** @internal */
export type MessageButton$Outbound = {
  type: string;
  content: string;
  resultContent?: string | undefined;
};

/** @internal */
export const MessageButton$outboundSchema: z.ZodType<MessageButton$Outbound, z.ZodTypeDef, MessageButton> = z.object({
  type: ButtonTypeEnum$outboundSchema,
  content: z.string(),
  resultContent: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageButton$ {
  /** @deprecated use `MessageButton$inboundSchema` instead. */
  export const inboundSchema = MessageButton$inboundSchema;
  /** @deprecated use `MessageButton$outboundSchema` instead. */
  export const outboundSchema = MessageButton$outboundSchema;
  /** @deprecated use `MessageButton$Outbound` instead. */
  export type Outbound = MessageButton$Outbound;
}

export function messageButtonToJSON(messageButton: MessageButton): string {
  return JSON.stringify(MessageButton$outboundSchema.parse(messageButton));
}

export function messageButtonFromJSON(jsonString: string): SafeParseResult<MessageButton, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageButton$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageButton' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageButtonToJSON(messageButton: MessageButton)
 - messageButtonFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageButton$Outbound;
}

export function messageButtonToJSON(messageButton: MessageButton): string...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageButtonToJSON
- export function messageButtonFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messagecta.ts
Tamaño: 2682 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelCTATypeEnum,
  ChannelCTATypeEnum$inboundSchema,
  ChannelCTATypeEnum$outboundSchema,
} from './channelctatypeenum.js';
import {
  MessageAction,
  MessageAction$inboundSchema,
  MessageAction$Outbound,
  MessageAction$outboundSchema,
} from './messageaction.js';
import {
  MessageCTAData,
  MessageCTAData$inboundSchema,
  MessageCTAData$Outbound,
  MessageCTAData$outboundSchema,
} from './messagectadata.js';

export type MessageCTA = {
  /**
   * Type of call to action
   */
  type?: ChannelCTATypeEnum | undefined;
  /**
   * Data associated with the call to action
   */
  data?: MessageCTAData | undefined;
  /**
   * Action associated with the call to action
   */
  action?: MessageAction | undefined;
};

/** @internal */
export const MessageCTA$inboundSchema: z.ZodType<MessageCTA, z.ZodTypeDef, unknown> = z.object({
  type: ChannelCTATypeEnum$inboundSchema.optional(),
  data: MessageCTAData$inboundSchema.optional(),
  action: MessageAction$inboundSchema.optional(),
});

/** @internal */
export type MessageCTA$Outbound = {
  type?: string | undefined;
  data?: MessageCTAData$Outbound | undefined;
  action?: MessageAction$Outbound | undefined;
};

/** @internal */
export const MessageCTA$outboundSchema: z.ZodType<MessageCTA$Outbound, z.ZodTypeDef, MessageCTA> = z.object({
  type: ChannelCTATypeEnum$outboundSchema.optional(),
  data: MessageCTAData$outboundSchema.optional(),
  action: MessageAction$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageCTA$ {
  /** @deprecated use `MessageCTA$inboundSchema` instead. */
  export const inboundSchema = MessageCTA$inboundSchema;
  /** @deprecated use `MessageCTA$outboundSchema` instead. */
  export const outboundSchema = MessageCTA$outboundSchema;
  /** @deprecated use `MessageCTA$Outbound` instead. */
  export type Outbound = MessageCTA$Outbound;
}

export function messageCTAToJSON(messageCTA: MessageCTA): string {
  return JSON.stringify(MessageCTA$outboundSchema.parse(messageCTA));
}

export function messageCTAFromJSON(jsonString: string): SafeParseResult<MessageCTA, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageCTA$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageCTA' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageCTAToJSON(messageCTA: MessageCTA)
 - messageCTAFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageCTA$Outbound;
}

export function messageCTAToJSON(messageCTA: MessageCTA): string {
  return ...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageCTAToJSON
- export function messageCTAFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messagectadata.ts
Tamaño: 1810 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type MessageCTAData = {
  /**
   * URL for the call to action
   */
  url?: string | undefined;
};

/** @internal */
export const MessageCTAData$inboundSchema: z.ZodType<MessageCTAData, z.ZodTypeDef, unknown> = z.object({
  url: z.string().optional(),
});

/** @internal */
export type MessageCTAData$Outbound = {
  url?: string | undefined;
};

/** @internal */
export const MessageCTAData$outboundSchema: z.ZodType<MessageCTAData$Outbound, z.ZodTypeDef, MessageCTAData> = z.object(
  {
    url: z.string().optional(),
  }
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageCTAData$ {
  /** @deprecated use `MessageCTAData$inboundSchema` instead. */
  export const inboundSchema = MessageCTAData$inboundSchema;
  /** @deprecated use `MessageCTAData$outboundSchema` instead. */
  export const outboundSchema = MessageCTAData$outboundSchema;
  /** @deprecated use `MessageCTAData$Outbound` instead. */
  export type Outbound = MessageCTAData$Outbound;
}

export function messageCTADataToJSON(messageCTAData: MessageCTAData): string {
  return JSON.stringify(MessageCTAData$outboundSchema.parse(messageCTAData));
}

export function messageCTADataFromJSON(jsonString: string): SafeParseResult<MessageCTAData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageCTAData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageCTAData' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageCTADataToJSON(messageCTAData: MessageCTAData)
 - messageCTADataFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageCTAData$Outbound;
}

export function messageCTADataToJSON(messageCTAData: MessageCTAData): st...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageCTADataToJSON
- export function messageCTADataFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messagemarkasrequestdto.ts
Tamaño: 4733 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type MessageId = string | Array<string>;

export const MessageMarkAsRequestDtoMarkAs = {
  Read: 'read',
  Seen: 'seen',
  Unread: 'unread',
  Unseen: 'unseen',
} as const;
export type MessageMarkAsRequestDtoMarkAs = ClosedEnum<typeof MessageMarkAsRequestDtoMarkAs>;

export type MessageMarkAsRequestDto = {
  messageId: string | Array<string>;
  markAs: MessageMarkAsRequestDtoMarkAs;
};

/** @internal */
export const MessageId$inboundSchema: z.ZodType<MessageId, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type MessageId$Outbound = string | Array<string>;

/** @internal */
export const MessageId$outboundSchema: z.ZodType<MessageId$Outbound, z.ZodTypeDef, MessageId> = z.union([
  z.string(),
  z.array(z.string()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageId$ {
  /** @deprecated use `MessageId$inboundSchema` instead. */
  export const inboundSchema = MessageId$inboundSchema;
  /** @deprecated use `MessageId$outboundSchema` instead. */
  export const outboundSchema = MessageId$outboundSchema;
  /** @deprecated use `MessageId$Outbound` instead. */
  export type Outbound = MessageId$Outbound;
}

export function messageIdToJSON(messageId: MessageId): string {
  return JSON.stringify(MessageId$outboundSchema.parse(messageId));
}

export function messageIdFromJSON(jsonString: string): SafeParseResult<MessageId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageId' from JSON`
  );
}

/** @internal */
export const MessageMarkAsRequestDtoMarkAs$inboundSchema: z.ZodNativeEnum<typeof MessageMarkAsRequestDtoMarkAs> =
  z.nativeEnum(MessageMarkAsRequestDtoMarkAs);

/** @internal */
export const MessageMarkAsRequestDtoMarkAs$outboundSchema: z.ZodNativeEnum<typeof MessageMarkAsRequestDtoMarkAs> =
  MessageMarkAsRequestDtoMarkAs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageMarkAsRequestDtoMarkAs$ {
  /** @deprecated use `MessageMarkAsRequestDtoMarkAs$inboundSchema` instead. */
  export const inboundSchema = MessageMarkAsRequestDtoMarkAs$inboundSchema;
  /** @deprecated use `MessageMarkAsRequestDtoMarkAs$outboundSchema` instead. */
  export const outboundSchema = MessageMarkAsRequestDtoMarkAs$outboundSchema;
}

/** @internal */
export const MessageMarkAsRequestDto$inboundSchema: z.ZodType<MessageMarkAsRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    messageId: z.union([z.string(), z.array(z.string())]),
    markAs: MessageMarkAsRequestDtoMarkAs$inboundSchema,
  });

/** @internal */
export type MessageMarkAsRequestDto$Outbound = {
  messageId: string | Array<string>;
  markAs: string;
};

/** @internal */
export const MessageMarkAsRequestDto$outboundSchema: z.ZodType<
  MessageMarkAsRequestDto$Outbound,
  z.ZodTypeDef,
  MessageMarkAsRequestDto
> = z.object({
  messageId: z.union([z.string(), z.array(z.string())]),
  markAs: MessageMarkAsRequestDtoMarkAs$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageMarkAsRequestDto$ {
  /** @deprecated use `MessageMarkAsRequestDto$inboundSchema` instead. */
  export const inboundSchema = MessageMarkAsRequestDto$inboundSchema;
  /** @deprecated use `MessageMarkAsRequestDto$outboundSchema` instead. */
  export const outboundSchema = MessageMarkAsRequestDto$outboundSchema;
  /** @deprecated use `MessageMarkAsRequestDto$Outbound` instead. */
  export type Outbound = MessageMarkAsRequestDto$Outbound;
}

export function messageMarkAsRequestDtoToJSON(messageMarkAsRequestDto: MessageMarkAsRequestDto): string {
  return JSON.stringify(MessageMarkAsRequestDto$outboundSchema.parse(messageMarkAsRequestDto));
}

export function messageMarkAsRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<MessageMarkAsRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageMarkAsRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageMarkAsRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageIdToJSON(messageId: MessageId)
 - messageIdFromJSON(jsonString: string)
 - messageMarkAsRequestDtoToJSON(messageMarkAsRequestDto: MessageMarkAsRequestDto)
 - messageMarkAsRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageId$Outbound;
}

export function messageIdToJSON(messageId: MessageId): string {
  return JSON...)
 - Outbound(MessageMarkAsRequestDto$Outbound;
}

export function messageMarkAsRequestDtoToJSON(messageMarkAsRequ...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageIdToJSON
- export function messageIdFromJSON
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageMarkAsRequestDtoToJSON
- export function messageMarkAsRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messageresponsedto.ts
Tamaño: 16343 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { ChannelTypeEnum, ChannelTypeEnum$inboundSchema, ChannelTypeEnum$outboundSchema } from './channeltypeenum.js';
import { EmailBlock, EmailBlock$inboundSchema, EmailBlock$Outbound, EmailBlock$outboundSchema } from './emailblock.js';
import { MessageCTA, MessageCTA$inboundSchema, MessageCTA$Outbound, MessageCTA$outboundSchema } from './messagecta.js';
import {
  MessageStatusEnum,
  MessageStatusEnum$inboundSchema,
  MessageStatusEnum$outboundSchema,
} from './messagestatusenum.js';
import {
  SubscriberResponseDto,
  SubscriberResponseDto$inboundSchema,
  SubscriberResponseDto$Outbound,
  SubscriberResponseDto$outboundSchema,
} from './subscriberresponsedto.js';
import {
  WorkflowResponse,
  WorkflowResponse$inboundSchema,
  WorkflowResponse$Outbound,
  WorkflowResponse$outboundSchema,
} from './workflowresponse.js';

/**
 * Content of the message, can be an email block or a string
 */
export type MessageResponseDtoContent = Array<EmailBlock> | string;

/**
 * The payload that was used to send the notification trigger
 */
export type MessageResponseDtoPayload = {};

/**
 * Provider specific overrides used when triggering the notification
 */
export type MessageResponseDtoOverrides = {};

export type MessageResponseDto = {
  /**
   * Unique identifier for the message
   */
  id?: string | undefined;
  /**
   * Template ID associated with the message
   */
  templateId?: string | null | undefined;
  /**
   * Environment ID where the message is sent
   */
  environmentId: string;
  /**
   * Message template ID
   */
  messageTemplateId?: string | null | undefined;
  /**
   * Organization ID associated with the message
   */
  organizationId: string;
  /**
   * Notification ID associated with the message
   */
  notificationId: string;
  /**
   * Subscriber ID associated with the message
   */
  subscriberId: string;
  /**
   * Subscriber details, if available
   */
  subscriber?: SubscriberResponseDto | undefined;
  /**
   * Workflow template associated with the message
   */
  template?: WorkflowResponse | undefined;
  /**
   * Identifier for the message template
   */
  templateIdentifier?: string | undefined;
  /**
   * Creation date of the message
   */
  createdAt: string;
  /**
   * Array of delivery dates for the message, if the message has multiple delivery dates, for example after being snoozed
   */
  deliveredAt?: Array<string> | undefined;
  /**
   * Last seen date of the message, if available
   */
  lastSeenDate?: string | undefined;
  /**
   * Last read date of the message, if available
   */
  lastReadDate?: string | undefined;
  /**
   * Content of the message, can be an email block or a string
   */
  content?: Array<EmailBlock> | string | null | undefined;
  /**
   * Transaction ID associated with the message
   */
  transactionId: string;
  /**
   * Subject of the message, if applicable
   */
  subject?: string | undefined;
  /**
   * Channel type through which the message is sent
   */
  channel: ChannelTypeEnum;
  /**
   * Indicates if the message has been read
   */
  read: boolean;
  /**
   * Indicates if the message has been seen
   */
  seen: boolean;
  /**
   * Date when the message will be unsnoozed
   */
  snoozedUntil?: string | undefined;
  /**
   * Email address associated with the message, if applicable
   */
  email?: string | undefined;
  /**
   * Phone number associated with the message, if applicable
   */
  phone?: string | undefined;
  /**
   * Direct webhook URL for the message, if applicable
   */
  directWebhookUrl?: string | undefined;
  /**
   * Provider ID associated with the message, if applicable
   */
  providerId?: string | undefined;
  /**
   * Device tokens associated with the message, if applicable
   */
  deviceTokens?: Array<string> | undefined;
  /**
   * Title of the message, if applicable
   */
  title?: string | undefined;
  /**
   * Call to action associated with the message
   */
  cta: MessageCTA;
  /**
   * Feed ID associated with the message, if applicable
   */
  feedId?: string | null | undefined;
  /**
   * Status of the message
   */
  status: MessageStatusEnum;
  /**
   * Error ID if the message has an error
   */
  errorId?: string | undefined;
  /**
   * Error text if the message has an error
   */
  errorText?: string | undefined;
  /**
   * The payload that was used to send the notification trigger
   */
  payload?: MessageResponseDtoPayload | undefined;
  /**
   * Provider specific overrides used when triggering the notification
   */
  overrides?: MessageResponseDtoOverrides | undefined;
  /**
   * Context keys associated with the message (format: "type:id")
   */
  contextKeys?: Array<string> | undefined;
};

/** @internal */
export const MessageResponseDtoContent$inboundSchema: z.ZodType<MessageResponseDtoContent, z.ZodTypeDef, unknown> =
  z.union([z.array(EmailBlock$inboundSchema), z.string()]);

/** @internal */
export type MessageResponseDtoContent$Outbound = Array<EmailBlock$Outbound> | string;

/** @internal */
export const MessageResponseDtoContent$outboundSchema: z.ZodType<
  MessageResponseDtoContent$Outbound,
  z.ZodTypeDef,
  MessageResponseDtoContent
> = z.union([z.array(EmailBlock$outboundSchema), z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageResponseDtoContent$ {
  /** @deprecated use `MessageResponseDtoContent$inboundSchema` instead. */
  export const inboundSchema = MessageResponseDtoContent$inboundSchema;
  /** @deprecated use `MessageResponseDtoContent$outboundSchema` instead. */
  export const outboundSchema = MessageResponseDtoContent$outboundSchema;
  /** @deprecated use `MessageResponseDtoContent$Outbound` instead. */
  export type Outbound = MessageResponseDtoContent$Outbound;
}

export function messageResponseDtoContentToJSON(messageResponseDtoContent: MessageResponseDtoContent): string {
  return JSON.stringify(MessageResponseDtoContent$outboundSchema.parse(messageResponseDtoContent));
}

export function messageResponseDtoContentFromJSON(
  jsonString: string
): SafeParseResult<MessageResponseDtoContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageResponseDtoContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageResponseDtoContent' from JSON`
  );
}

/** @internal */
export const MessageResponseDtoPayload$inboundSchema: z.ZodType<MessageResponseDtoPayload, z.ZodTypeDef, unknown> =
  z.object({});

/** @internal */
export type MessageResponseDtoPayload$Outbound = {};

/** @internal */
export const MessageResponseDtoPayload$outboundSchema: z.ZodType<
  MessageResponseDtoPayload$Outbound,
  z.ZodTypeDef,
  MessageResponseDtoPayload
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageResponseDtoPayload$ {
  /** @deprecated use `MessageResponseDtoPayload$inboundSchema` instead. */
  export const inboundSchema = MessageResponseDtoPayload$inboundSchema;
  /** @deprecated use `MessageResponseDtoPayload$outboundSchema` instead. */
  export const outboundSchema = MessageResponseDtoPayload$outboundSchema;
  /** @deprecated use `MessageResponseDtoPayload$Outbound` instead. */
  export type Outbound = MessageResponseDtoPayload$Outbound;
}

export function messageResponseDtoPayloadToJSON(messageResponseDtoPayload: MessageResponseDtoPayload): string {
  return JSON.stringify(MessageResponseDtoPayload$outboundSchema.parse(messageResponseDtoPayload));
}

export function messageResponseDtoPayloadFromJSON(
  jsonString: string
): SafeParseResult<MessageResponseDtoPayload, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageResponseDtoPayload$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageResponseDtoPayload' from JSON`
  );
}

/** @internal */
export const MessageResponseDtoOverrides$inboundSchema: z.ZodType<MessageResponseDtoOverrides, z.ZodTypeDef, unknown> =
  z.object({});

/** @internal */
export type MessageResponseDtoOverrides$Outbound = {};

/** @internal */
export const MessageResponseDtoOverrides$outboundSchema: z.ZodType<
  MessageResponseDtoOverrides$Outbound,
  z.ZodTypeDef,
  MessageResponseDtoOverrides
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageResponseDtoOverrides$ {
  /** @deprecated use `MessageResponseDtoOverrides$inboundSchema` instead. */
  export const inboundSchema = MessageResponseDtoOverrides$inboundSchema;
  /** @deprecated use `MessageResponseDtoOverrides$outboundSchema` instead. */
  export const outboundSchema = MessageResponseDtoOverrides$outboundSchema;
  /** @deprecated use `MessageResponseDtoOverrides$Outbound` instead. */
  export type Outbound = MessageResponseDtoOverrides$Outbound;
}

export function messageResponseDtoOverridesToJSON(messageResponseDtoOverrides: MessageResponseDtoOverrides): string {
  return JSON.stringify(MessageResponseDtoOverrides$outboundSchema.parse(messageResponseDtoOverrides));
}

export function messageResponseDtoOverridesFromJSON(
  jsonString: string
): SafeParseResult<MessageResponseDtoOverrides, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageResponseDtoOverrides$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageResponseDtoOverrides' from JSON`
  );
}

/** @internal */
export const MessageResponseDto$inboundSchema: z.ZodType<MessageResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    _templateId: z.nullable(z.string()).optional(),
    _environmentId: z.string(),
    _messageTemplateId: z.nullable(z.string()).optional(),
    _organizationId: z.string(),
    _notificationId: z.string(),
    _subscriberId: z.string(),
    subscriber: SubscriberResponseDto$inboundSchema.optional(),
    template: WorkflowResponse$inboundSchema.optional(),
    templateIdentifier: z.string().optional(),
    createdAt: z.string(),
    deliveredAt: z.array(z.string()).optional(),
    lastSeenDate: z.string().optional(),
    lastReadDate: z.string().optional(),
    content: z.nullable(z.union([z.array(EmailBlock$inboundSchema), z.string()])).optional(),
    transactionId: z.string(),
    subject: z.string().optional(),
    channel: ChannelTypeEnum$inboundSchema,
    read: z.boolean(),
    seen: z.boolean(),
    snoozedUntil: z.string().optional(),
    email: z.string().optional(),
    phone: z.string().optional(),
    directWebhookUrl: z.string().optional(),
    providerId: z.string().optional(),
    deviceTokens: z.array(z.string()).optional(),
    title: z.string().optional(),
    cta: MessageCTA$inboundSchema,
    _feedId: z.nullable(z.string()).optional(),
    status: MessageStatusEnum$inboundSchema,
    errorId: z.string().optional(),
    errorText: z.string().optional(),
    payload: z.lazy(() => MessageResponseDtoPayload$inboundSchema).optional(),
    overrides: z.lazy(() => MessageResponseDtoOverrides$inboundSchema).optional(),
    contextKeys: z.array(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      _templateId: 'templateId',
      _environmentId: 'environmentId',
      _messageTemplateId: 'messageTemplateId',
      _organizationId: 'organizationId',
      _notificationId: 'notificationId',
      _subscriberId: 'subscriberId',
      _feedId: 'feedId',
    });
  });

/** @internal */
export type MessageResponseDto$Outbound = {
  _id?: string | undefined;
  _templateId?: string | null | undefined;
  _environmentId: string;
  _messageTemplateId?: string | null | undefined;
  _organizationId: string;
  _notificationId: string;
  _subscriberId: string;
  subscriber?: SubscriberResponseDto$Outbound | undefined;
  template?: WorkflowResponse$Outbound | undefined;
  templateIdentifier?: string | undefined;
  createdAt: string;
  deliveredAt?: Array<string> | undefined;
  lastSeenDate?: string | undefined;
  lastReadDate?: string | undefined;
  content?: Array<EmailBlock$Outbound> | string | null | undefined;
  transactionId: string;
  subject?: string | undefined;
  channel: string;
  read: boolean;
  seen: boolean;
  snoozedUntil?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  directWebhookUrl?: string | undefined;
  providerId?: string | undefined;
  deviceTokens?: Array<string> | undefined;
  title?: string | undefined;
  cta: MessageCTA$Outbound;
  _feedId?: string | null | undefined;
  status: string;
  errorId?: string | undefined;
  errorText?: string | undefined;
  payload?: MessageResponseDtoPayload$Outbound | undefined;
  overrides?: MessageResponseDtoOverrides$Outbound | undefined;
  contextKeys?: Array<string> | undefined;
};

/** @internal */
export const MessageResponseDto$outboundSchema: z.ZodType<
  MessageResponseDto$Outbound,
  z.ZodTypeDef,
  MessageResponseDto
> = z
  .object({
    id: z.string().optional(),
    templateId: z.nullable(z.string()).optional(),
    environmentId: z.string(),
    messageTemplateId: z.nullable(z.string()).optional(),
    organizationId: z.string(),
    notificationId: z.string(),
    subscriberId: z.string(),
    subscriber: SubscriberResponseDto$outboundSchema.optional(),
    template: WorkflowResponse$outboundSchema.optional(),
    templateIdentifier: z.string().optional(),
    createdAt: z.string(),
    deliveredAt: z.array(z.string()).optional(),
    lastSeenDate: z.string().optional(),
    lastReadDate: z.string().optional(),
    content: z.nullable(z.union([z.array(EmailBlock$outboundSchema), z.string()])).optional(),
    transactionId: z.string(),
    subject: z.string().optional(),
    channel: ChannelTypeEnum$outboundSchema,
    read: z.boolean(),
    seen: z.boolean(),
    snoozedUntil: z.string().optional(),
    email: z.string().optional(),
    phone: z.string().optional(),
    directWebhookUrl: z.string().optional(),
    providerId: z.string().optional(),
    deviceTokens: z.array(z.string()).optional(),
    title: z.string().optional(),
    cta: MessageCTA$outboundSchema,
    feedId: z.nullable(z.string()).optional(),
    status: MessageStatusEnum$outboundSchema,
    errorId: z.string().optional(),
    errorText: z.string().optional(),
    payload: z.lazy(() => MessageResponseDtoPayload$outboundSchema).optional(),
    overrides: z.lazy(() => MessageResponseDtoOverrides$outboundSchema).optional(),
    contextKeys: z.array(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      templateId: '_templateId',
      environmentId: '_environmentId',
      messageTemplateId: '_messageTemplateId',
      organizationId: '_organizationId',
      notificationId: '_notificationId',
      subscriberId: '_subscriberId',
      feedId: '_feedId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageResponseDto$ {
  /** @deprecated use `MessageResponseDto$inboundSchema` instead. */
  export const inboundSchema = MessageResponseDto$inboundSchema;
  /** @deprecated use `MessageResponseDto$outboundSchema` instead. */
  export const outboundSchema = MessageResponseDto$outboundSchema;
  /** @deprecated use `MessageResponseDto$Outbound` instead. */
  export type Outbound = MessageResponseDto$Outbound;
}

export function messageResponseDtoToJSON(messageResponseDto: MessageResponseDto): string {
  return JSON.stringify(MessageResponseDto$outboundSchema.parse(messageResponseDto));
}

export function messageResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<MessageResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageResponseDtoContentToJSON(messageResponseDtoContent: MessageResponseDtoContent)
 - messageResponseDtoContentFromJSON(jsonString: string)
 - messageResponseDtoPayloadToJSON(messageResponseDtoPayload: MessageResponseDtoPayload)
 - messageResponseDtoPayloadFromJSON(jsonString: string)
 - messageResponseDtoOverridesToJSON(messageResponseDtoOverrides: MessageResponseDtoOverrides)
 - messageResponseDtoOverridesFromJSON(jsonString: string)
 - messageResponseDtoToJSON(messageResponseDto: MessageResponseDto)
 - messageResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageResponseDtoContent$Outbound;
}

export function messageResponseDtoContentToJSON(messageRespon...)
 - Outbound(MessageResponseDtoPayload$Outbound;
}

export function messageResponseDtoPayloadToJSON(messageRespon...)
 - Outbound(MessageResponseDtoOverrides$Outbound;
}

export function messageResponseDtoOverridesToJSON(messageRe...)
 - Outbound(MessageResponseDto$Outbound;
}

export function messageResponseDtoToJSON(messageResponseDto: Message...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageResponseDtoContentToJSON
- export function messageResponseDtoContentFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageResponseDtoPayloadToJSON
- export function messageResponseDtoPayloadFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageResponseDtoOverridesToJSON
- export function messageResponseDtoOverridesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageResponseDtoToJSON
- export function messageResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messagesresponsedto.ts
Tamaño: 2744 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  MessageResponseDto,
  MessageResponseDto$inboundSchema,
  MessageResponseDto$Outbound,
  MessageResponseDto$outboundSchema,
} from './messageresponsedto.js';

export type MessagesResponseDto = {
  /**
   * Total number of messages available
   */
  totalCount?: number | undefined;
  /**
   * Indicates if there are more messages available
   */
  hasMore: boolean;
  /**
   * List of messages
   */
  data: Array<MessageResponseDto>;
  /**
   * Number of messages per page
   */
  pageSize: number;
  /**
   * Current page number
   */
  page: number;
};

/** @internal */
export const MessagesResponseDto$inboundSchema: z.ZodType<MessagesResponseDto, z.ZodTypeDef, unknown> = z.object({
  totalCount: z.number().optional(),
  hasMore: z.boolean(),
  data: z.array(MessageResponseDto$inboundSchema),
  pageSize: z.number(),
  page: z.number(),
});

/** @internal */
export type MessagesResponseDto$Outbound = {
  totalCount?: number | undefined;
  hasMore: boolean;
  data: Array<MessageResponseDto$Outbound>;
  pageSize: number;
  page: number;
};

/** @internal */
export const MessagesResponseDto$outboundSchema: z.ZodType<
  MessagesResponseDto$Outbound,
  z.ZodTypeDef,
  MessagesResponseDto
> = z.object({
  totalCount: z.number().optional(),
  hasMore: z.boolean(),
  data: z.array(MessageResponseDto$outboundSchema),
  pageSize: z.number(),
  page: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesResponseDto$ {
  /** @deprecated use `MessagesResponseDto$inboundSchema` instead. */
  export const inboundSchema = MessagesResponseDto$inboundSchema;
  /** @deprecated use `MessagesResponseDto$outboundSchema` instead. */
  export const outboundSchema = MessagesResponseDto$outboundSchema;
  /** @deprecated use `MessagesResponseDto$Outbound` instead. */
  export type Outbound = MessagesResponseDto$Outbound;
}

export function messagesResponseDtoToJSON(messagesResponseDto: MessagesResponseDto): string {
  return JSON.stringify(MessagesResponseDto$outboundSchema.parse(messagesResponseDto));
}

export function messagesResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<MessagesResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messagesResponseDtoToJSON(messagesResponseDto: MessagesResponseDto)
 - messagesResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessagesResponseDto$Outbound;
}

export function messagesResponseDtoToJSON(messagesResponseDto: Mess...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagesResponseDtoToJSON
- export function messagesResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messagestatusenum.ts
Tamaño: 1146 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Status of the message
 */
export const MessageStatusEnum = {
  Sent: 'sent',
  Error: 'error',
  Warning: 'warning',
} as const;
/**
 * Status of the message
 */
export type MessageStatusEnum = ClosedEnum<typeof MessageStatusEnum>;

/** @internal */
export const MessageStatusEnum$inboundSchema: z.ZodNativeEnum<typeof MessageStatusEnum> =
  z.nativeEnum(MessageStatusEnum);

/** @internal */
export const MessageStatusEnum$outboundSchema: z.ZodNativeEnum<typeof MessageStatusEnum> =
  MessageStatusEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageStatusEnum$ {
  /** @deprecated use `MessageStatusEnum$inboundSchema` instead. */
  export const inboundSchema = MessageStatusEnum$inboundSchema;
  /** @deprecated use `MessageStatusEnum$outboundSchema` instead. */
  export const outboundSchema = MessageStatusEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messagetemplate.ts
Tamaño: 1663 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type MessageTemplate = {};

/** @internal */
export const MessageTemplate$inboundSchema: z.ZodType<MessageTemplate, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type MessageTemplate$Outbound = {};

/** @internal */
export const MessageTemplate$outboundSchema: z.ZodType<MessageTemplate$Outbound, z.ZodTypeDef, MessageTemplate> =
  z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageTemplate$ {
  /** @deprecated use `MessageTemplate$inboundSchema` instead. */
  export const inboundSchema = MessageTemplate$inboundSchema;
  /** @deprecated use `MessageTemplate$outboundSchema` instead. */
  export const outboundSchema = MessageTemplate$outboundSchema;
  /** @deprecated use `MessageTemplate$Outbound` instead. */
  export type Outbound = MessageTemplate$Outbound;
}

export function messageTemplateToJSON(messageTemplate: MessageTemplate): string {
  return JSON.stringify(MessageTemplate$outboundSchema.parse(messageTemplate));
}

export function messageTemplateFromJSON(jsonString: string): SafeParseResult<MessageTemplate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageTemplate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageTemplate' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageTemplateToJSON(messageTemplate: MessageTemplate)
 - messageTemplateFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageTemplate$Outbound;
}

export function messageTemplateToJSON(messageTemplate: MessageTemplate)...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageTemplateToJSON
- export function messageTemplateFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messagetemplatedto.ts
Tamaño: 1742 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type MessageTemplateDto = {};

/** @internal */
export const MessageTemplateDto$inboundSchema: z.ZodType<MessageTemplateDto, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type MessageTemplateDto$Outbound = {};

/** @internal */
export const MessageTemplateDto$outboundSchema: z.ZodType<
  MessageTemplateDto$Outbound,
  z.ZodTypeDef,
  MessageTemplateDto
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageTemplateDto$ {
  /** @deprecated use `MessageTemplateDto$inboundSchema` instead. */
  export const inboundSchema = MessageTemplateDto$inboundSchema;
  /** @deprecated use `MessageTemplateDto$outboundSchema` instead. */
  export const outboundSchema = MessageTemplateDto$outboundSchema;
  /** @deprecated use `MessageTemplateDto$Outbound` instead. */
  export type Outbound = MessageTemplateDto$Outbound;
}

export function messageTemplateDtoToJSON(messageTemplateDto: MessageTemplateDto): string {
  return JSON.stringify(MessageTemplateDto$outboundSchema.parse(messageTemplateDto));
}

export function messageTemplateDtoFromJSON(
  jsonString: string
): SafeParseResult<MessageTemplateDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageTemplateDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageTemplateDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageTemplateDtoToJSON(messageTemplateDto: MessageTemplateDto)
 - messageTemplateDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageTemplateDto$Outbound;
}

export function messageTemplateDtoToJSON(messageTemplateDto: Message...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageTemplateDtoToJSON
- export function messageTemplateDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/metadto.ts
Tamaño: 1937 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type MetaDto = {
  /**
   * The total count of subscriber IDs provided
   */
  totalCount: number;
  /**
   * The count of successfully created subscriptions
   */
  successful: number;
  /**
   * The count of failed subscription attempts
   */
  failed: number;
};

/** @internal */
export const MetaDto$inboundSchema: z.ZodType<MetaDto, z.ZodTypeDef, unknown> = z.object({
  totalCount: z.number(),
  successful: z.number(),
  failed: z.number(),
});

/** @internal */
export type MetaDto$Outbound = {
  totalCount: number;
  successful: number;
  failed: number;
};

/** @internal */
export const MetaDto$outboundSchema: z.ZodType<MetaDto$Outbound, z.ZodTypeDef, MetaDto> = z.object({
  totalCount: z.number(),
  successful: z.number(),
  failed: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetaDto$ {
  /** @deprecated use `MetaDto$inboundSchema` instead. */
  export const inboundSchema = MetaDto$inboundSchema;
  /** @deprecated use `MetaDto$outboundSchema` instead. */
  export const outboundSchema = MetaDto$outboundSchema;
  /** @deprecated use `MetaDto$Outbound` instead. */
  export type Outbound = MetaDto$Outbound;
}

export function metaDtoToJSON(metaDto: MetaDto): string {
  return JSON.stringify(MetaDto$outboundSchema.parse(metaDto));
}

export function metaDtoFromJSON(jsonString: string): SafeParseResult<MetaDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetaDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetaDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - metaDtoToJSON(metaDto: MetaDto)
 - metaDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MetaDto$Outbound;
}

export function metaDtoToJSON(metaDto: MetaDto): string {
  return JSON.stringi...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function metaDtoToJSON
- export function metaDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/monthlytypeenum.ts
Tamaño: 1092 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Type of monthly schedule
 */
export const MonthlyTypeEnum = {
  Each: 'each',
  On: 'on',
} as const;
/**
 * Type of monthly schedule
 */
export type MonthlyTypeEnum = ClosedEnum<typeof MonthlyTypeEnum>;

/** @internal */
export const MonthlyTypeEnum$inboundSchema: z.ZodNativeEnum<typeof MonthlyTypeEnum> = z.nativeEnum(MonthlyTypeEnum);

/** @internal */
export const MonthlyTypeEnum$outboundSchema: z.ZodNativeEnum<typeof MonthlyTypeEnum> = MonthlyTypeEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MonthlyTypeEnum$ {
  /** @deprecated use `MonthlyTypeEnum$inboundSchema` instead. */
  export const inboundSchema = MonthlyTypeEnum$inboundSchema;
  /** @deprecated use `MonthlyTypeEnum$outboundSchema` instead. */
  export const outboundSchema = MonthlyTypeEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/notificationfeeditemdto.ts
Tamaño: 11060 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ActorFeedItemDto,
  ActorFeedItemDto$inboundSchema,
  ActorFeedItemDto$Outbound,
  ActorFeedItemDto$outboundSchema,
} from './actorfeeditemdto.js';
import { ChannelTypeEnum, ChannelTypeEnum$inboundSchema, ChannelTypeEnum$outboundSchema } from './channeltypeenum.js';
import { MessageCTA, MessageCTA$inboundSchema, MessageCTA$Outbound, MessageCTA$outboundSchema } from './messagecta.js';
import {
  SubscriberFeedResponseDto,
  SubscriberFeedResponseDto$inboundSchema,
  SubscriberFeedResponseDto$Outbound,
  SubscriberFeedResponseDto$outboundSchema,
} from './subscriberfeedresponsedto.js';

/**
 * Current status of the notification.
 */
export const NotificationFeedItemDtoStatus = {
  Sent: 'sent',
  Error: 'error',
  Warning: 'warning',
} as const;
/**
 * Current status of the notification.
 */
export type NotificationFeedItemDtoStatus = ClosedEnum<typeof NotificationFeedItemDtoStatus>;

export type NotificationFeedItemDto = {
  /**
   * Unique identifier for the notification.
   */
  id: string;
  /**
   * Identifier for the template used to generate the notification.
   */
  templateId: string;
  /**
   * Identifier for the environment where the notification is sent.
   */
  environmentId: string;
  /**
   * Identifier for the message template used.
   */
  messageTemplateId?: string | undefined;
  /**
   * Identifier for the organization sending the notification.
   */
  organizationId: string;
  /**
   * Unique identifier for the notification instance.
   */
  notificationId: string;
  /**
   * Unique identifier for the subscriber receiving the notification.
   */
  subscriberId: string;
  /**
   * Identifier for the feed associated with the notification.
   */
  feedId?: string | null | undefined;
  /**
   * Identifier for the job that triggered the notification.
   */
  jobId: string;
  /**
   * Timestamp indicating when the notification was created.
   */
  createdAt?: Date | null | undefined;
  /**
   * Timestamp indicating when the notification was last updated.
   */
  updatedAt?: Date | null | undefined;
  /**
   * Actor details related to the notification, if applicable.
   */
  actor?: ActorFeedItemDto | undefined;
  /**
   * Subscriber details associated with this notification.
   */
  subscriber?: SubscriberFeedResponseDto | undefined;
  /**
   * Unique identifier for the transaction associated with the notification.
   */
  transactionId: string;
  /**
   * Identifier for the template used, if applicable.
   */
  templateIdentifier?: string | null | undefined;
  /**
   * Identifier for the provider that sends the notification.
   */
  providerId?: string | null | undefined;
  /**
   * The main content of the notification.
   */
  content: string;
  /**
   * The subject line for email notifications, if applicable.
   */
  subject?: string | null | undefined;
  /**
   * Channel type through which the message is sent
   */
  channel: ChannelTypeEnum;
  /**
   * Indicates whether the notification has been read by the subscriber.
   */
  read: boolean;
  /**
   * Indicates whether the notification has been seen by the subscriber.
   */
  seen: boolean;
  /**
   * Device tokens for push notifications, if applicable.
   */
  deviceTokens?: Array<string> | null | undefined;
  /**
   * Call-to-action information associated with the notification.
   */
  cta: MessageCTA;
  /**
   * Current status of the notification.
   */
  status: NotificationFeedItemDtoStatus;
  /**
   * The payload that was used to send the notification trigger.
   */
  payload?: { [k: string]: any } | undefined;
  /**
   * The data sent with the notification.
   */
  data?: { [k: string]: any } | null | undefined;
  /**
   * Provider-specific overrides used when triggering the notification.
   */
  overrides?: { [k: string]: any } | undefined;
  /**
   * Tags associated with the workflow that triggered the notification.
   */
  tags?: Array<string> | null | undefined;
};

/** @internal */
export const NotificationFeedItemDtoStatus$inboundSchema: z.ZodNativeEnum<typeof NotificationFeedItemDtoStatus> =
  z.nativeEnum(NotificationFeedItemDtoStatus);

/** @internal */
export const NotificationFeedItemDtoStatus$outboundSchema: z.ZodNativeEnum<typeof NotificationFeedItemDtoStatus> =
  NotificationFeedItemDtoStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationFeedItemDtoStatus$ {
  /** @deprecated use `NotificationFeedItemDtoStatus$inboundSchema` instead. */
  export const inboundSchema = NotificationFeedItemDtoStatus$inboundSchema;
  /** @deprecated use `NotificationFeedItemDtoStatus$outboundSchema` instead. */
  export const outboundSchema = NotificationFeedItemDtoStatus$outboundSchema;
}

/** @internal */
export const NotificationFeedItemDto$inboundSchema: z.ZodType<NotificationFeedItemDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    _templateId: z.string(),
    _environmentId: z.string(),
    _messageTemplateId: z.string().optional(),
    _organizationId: z.string(),
    _notificationId: z.string(),
    _subscriberId: z.string(),
    _feedId: z.nullable(z.string()).optional(),
    _jobId: z.string(),
    createdAt: z
      .nullable(
        z
          .string()
          .datetime({ offset: true })
          .transform((v) => new Date(v))
      )
      .optional(),
    updatedAt: z
      .nullable(
        z
          .string()
          .datetime({ offset: true })
          .transform((v) => new Date(v))
      )
      .optional(),
    actor: ActorFeedItemDto$inboundSchema.optional(),
    subscriber: SubscriberFeedResponseDto$inboundSchema.optional(),
    transactionId: z.string(),
    templateIdentifier: z.nullable(z.string()).optional(),
    providerId: z.nullable(z.string()).optional(),
    content: z.string(),
    subject: z.nullable(z.string()).optional(),
    channel: ChannelTypeEnum$inboundSchema,
    read: z.boolean(),
    seen: z.boolean(),
    deviceTokens: z.nullable(z.array(z.string())).optional(),
    cta: MessageCTA$inboundSchema,
    status: NotificationFeedItemDtoStatus$inboundSchema,
    payload: z.record(z.any()).optional(),
    data: z.nullable(z.record(z.any())).optional(),
    overrides: z.record(z.any()).optional(),
    tags: z.nullable(z.array(z.string())).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      _templateId: 'templateId',
      _environmentId: 'environmentId',
      _messageTemplateId: 'messageTemplateId',
      _organizationId: 'organizationId',
      _notificationId: 'notificationId',
      _subscriberId: 'subscriberId',
      _feedId: 'feedId',
      _jobId: 'jobId',
    });
  });

/** @internal */
export type NotificationFeedItemDto$Outbound = {
  _id: string;
  _templateId: string;
  _environmentId: string;
  _messageTemplateId?: string | undefined;
  _organizationId: string;
  _notificationId: string;
  _subscriberId: string;
  _feedId?: string | null | undefined;
  _jobId: string;
  createdAt?: string | null | undefined;
  updatedAt?: string | null | undefined;
  actor?: ActorFeedItemDto$Outbound | undefined;
  subscriber?: SubscriberFeedResponseDto$Outbound | undefined;
  transactionId: string;
  templateIdentifier?: string | null | undefined;
  providerId?: string | null | undefined;
  content: string;
  subject?: string | null | undefined;
  channel: string;
  read: boolean;
  seen: boolean;
  deviceTokens?: Array<string> | null | undefined;
  cta: MessageCTA$Outbound;
  status: string;
  payload?: { [k: string]: any } | undefined;
  data?: { [k: string]: any } | null | undefined;
  overrides?: { [k: string]: any } | undefined;
  tags?: Array<string> | null | undefined;
};

/** @internal */
export const NotificationFeedItemDto$outboundSchema: z.ZodType<
  NotificationFeedItemDto$Outbound,
  z.ZodTypeDef,
  NotificationFeedItemDto
> = z
  .object({
    id: z.string(),
    templateId: z.string(),
    environmentId: z.string(),
    messageTemplateId: z.string().optional(),
    organizationId: z.string(),
    notificationId: z.string(),
    subscriberId: z.string(),
    feedId: z.nullable(z.string()).optional(),
    jobId: z.string(),
    createdAt: z.nullable(z.date().transform((v) => v.toISOString())).optional(),
    updatedAt: z.nullable(z.date().transform((v) => v.toISOString())).optional(),
    actor: ActorFeedItemDto$outboundSchema.optional(),
    subscriber: SubscriberFeedResponseDto$outboundSchema.optional(),
    transactionId: z.string(),
    templateIdentifier: z.nullable(z.string()).optional(),
    providerId: z.nullable(z.string()).optional(),
    content: z.string(),
    subject: z.nullable(z.string()).optional(),
    channel: ChannelTypeEnum$outboundSchema,
    read: z.boolean(),
    seen: z.boolean(),
    deviceTokens: z.nullable(z.array(z.string())).optional(),
    cta: MessageCTA$outboundSchema,
    status: NotificationFeedItemDtoStatus$outboundSchema,
    payload: z.record(z.any()).optional(),
    data: z.nullable(z.record(z.any())).optional(),
    overrides: z.record(z.any()).optional(),
    tags: z.nullable(z.array(z.string())).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      templateId: '_templateId',
      environmentId: '_environmentId',
      messageTemplateId: '_messageTemplateId',
      organizationId: '_organizationId',
      notificationId: '_notificationId',
      subscriberId: '_subscriberId',
      feedId: '_feedId',
      jobId: '_jobId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationFeedItemDto$ {
  /** @deprecated use `NotificationFeedItemDto$inboundSchema` instead. */
  export const inboundSchema = NotificationFeedItemDto$inboundSchema;
  /** @deprecated use `NotificationFeedItemDto$outboundSchema` instead. */
  export const outboundSchema = NotificationFeedItemDto$outboundSchema;
  /** @deprecated use `NotificationFeedItemDto$Outbound` instead. */
  export type Outbound = NotificationFeedItemDto$Outbound;
}

export function notificationFeedItemDtoToJSON(notificationFeedItemDto: NotificationFeedItemDto): string {
  return JSON.stringify(NotificationFeedItemDto$outboundSchema.parse(notificationFeedItemDto));
}

export function notificationFeedItemDtoFromJSON(
  jsonString: string
): SafeParseResult<NotificationFeedItemDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationFeedItemDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationFeedItemDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationFeedItemDtoToJSON(notificationFeedItemDto: NotificationFeedItemDto)
 - notificationFeedItemDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(NotificationFeedItemDto$Outbound;
}

export function notificationFeedItemDtoToJSON(notificationFeedI...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationFeedItemDtoToJSON
- export function notificationFeedItemDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/notificationgroup.ts
Tamaño: 2748 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type NotificationGroup = {
  id?: string | undefined;
  name: string;
  environmentId: string;
  organizationId: string;
  parentId?: string | undefined;
};

/** @internal */
export const NotificationGroup$inboundSchema: z.ZodType<NotificationGroup, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    name: z.string(),
    _environmentId: z.string(),
    _organizationId: z.string(),
    _parentId: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      _environmentId: 'environmentId',
      _organizationId: 'organizationId',
      _parentId: 'parentId',
    });
  });

/** @internal */
export type NotificationGroup$Outbound = {
  _id?: string | undefined;
  name: string;
  _environmentId: string;
  _organizationId: string;
  _parentId?: string | undefined;
};

/** @internal */
export const NotificationGroup$outboundSchema: z.ZodType<NotificationGroup$Outbound, z.ZodTypeDef, NotificationGroup> =
  z
    .object({
      id: z.string().optional(),
      name: z.string(),
      environmentId: z.string(),
      organizationId: z.string(),
      parentId: z.string().optional(),
    })
    .transform((v) => {
      return remap$(v, {
        id: '_id',
        environmentId: '_environmentId',
        organizationId: '_organizationId',
        parentId: '_parentId',
      });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationGroup$ {
  /** @deprecated use `NotificationGroup$inboundSchema` instead. */
  export const inboundSchema = NotificationGroup$inboundSchema;
  /** @deprecated use `NotificationGroup$outboundSchema` instead. */
  export const outboundSchema = NotificationGroup$outboundSchema;
  /** @deprecated use `NotificationGroup$Outbound` instead. */
  export type Outbound = NotificationGroup$Outbound;
}

export function notificationGroupToJSON(notificationGroup: NotificationGroup): string {
  return JSON.stringify(NotificationGroup$outboundSchema.parse(notificationGroup));
}

export function notificationGroupFromJSON(jsonString: string): SafeParseResult<NotificationGroup, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationGroup$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationGroup' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationGroupToJSON(notificationGroup: NotificationGroup)
 - notificationGroupFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(NotificationGroup$Outbound;
}

export function notificationGroupToJSON(notificationGroup: Notificati...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationGroupToJSON
- export function notificationGroupFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/notificationstepdata.ts
Tamaño: 8813 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  DelayRegularMetadata,
  DelayRegularMetadata$inboundSchema,
  DelayRegularMetadata$Outbound,
  DelayRegularMetadata$outboundSchema,
} from './delayregularmetadata.js';
import {
  DelayScheduledMetadata,
  DelayScheduledMetadata$inboundSchema,
  DelayScheduledMetadata$Outbound,
  DelayScheduledMetadata$outboundSchema,
} from './delayscheduledmetadata.js';
import {
  DigestRegularMetadata,
  DigestRegularMetadata$inboundSchema,
  DigestRegularMetadata$Outbound,
  DigestRegularMetadata$outboundSchema,
} from './digestregularmetadata.js';
import {
  DigestTimedMetadata,
  DigestTimedMetadata$inboundSchema,
  DigestTimedMetadata$Outbound,
  DigestTimedMetadata$outboundSchema,
} from './digesttimedmetadata.js';
import {
  MessageTemplate,
  MessageTemplate$inboundSchema,
  MessageTemplate$Outbound,
  MessageTemplate$outboundSchema,
} from './messagetemplate.js';
import {
  ReplyCallback,
  ReplyCallback$inboundSchema,
  ReplyCallback$Outbound,
  ReplyCallback$outboundSchema,
} from './replycallback.js';
import {
  StepFilterDto,
  StepFilterDto$inboundSchema,
  StepFilterDto$Outbound,
  StepFilterDto$outboundSchema,
} from './stepfilterdto.js';

/**
 * Metadata associated with the workflow step. Can vary based on the type of step.
 */
export type NotificationStepDataMetadata =
  | DelayScheduledMetadata
  | DigestRegularMetadata
  | DigestTimedMetadata
  | DelayRegularMetadata;

export type NotificationStepData = {
  /**
   * Unique identifier for the notification step.
   */
  id?: string | undefined;
  /**
   * Universally unique identifier for the notification step.
   */
  uuid?: string | undefined;
  /**
   * Name of the notification step.
   */
  name?: string | undefined;
  /**
   * ID of the template associated with this notification step.
   */
  templateId?: string | undefined;
  /**
   * Indicates whether the notification step is active.
   */
  active?: boolean | undefined;
  /**
   * Determines if the process should stop on failure.
   */
  shouldStopOnFail?: boolean | undefined;
  /**
   * Message template used in this notification step.
   */
  template?: MessageTemplate | undefined;
  /**
   * Filters applied to this notification step.
   */
  filters?: Array<StepFilterDto> | undefined;
  /**
   * ID of the parent notification step, if applicable.
   */
  parentId?: string | undefined;
  /**
   * Metadata associated with the workflow step. Can vary based on the type of step.
   */
  metadata?: DelayScheduledMetadata | DigestRegularMetadata | DigestTimedMetadata | DelayRegularMetadata | undefined;
  /**
   * Callback information for replies, including whether it is active and the callback URL.
   */
  replyCallback?: ReplyCallback | undefined;
};

/** @internal */
export const NotificationStepDataMetadata$inboundSchema: z.ZodType<
  NotificationStepDataMetadata,
  z.ZodTypeDef,
  unknown
> = z.union([
  DelayScheduledMetadata$inboundSchema,
  DigestRegularMetadata$inboundSchema,
  DigestTimedMetadata$inboundSchema,
  DelayRegularMetadata$inboundSchema,
]);

/** @internal */
export type NotificationStepDataMetadata$Outbound =
  | DelayScheduledMetadata$Outbound
  | DigestRegularMetadata$Outbound
  | DigestTimedMetadata$Outbound
  | DelayRegularMetadata$Outbound;

/** @internal */
export const NotificationStepDataMetadata$outboundSchema: z.ZodType<
  NotificationStepDataMetadata$Outbound,
  z.ZodTypeDef,
  NotificationStepDataMetadata
> = z.union([
  DelayScheduledMetadata$outboundSchema,
  DigestRegularMetadata$outboundSchema,
  DigestTimedMetadata$outboundSchema,
  DelayRegularMetadata$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationStepDataMetadata$ {
  /** @deprecated use `NotificationStepDataMetadata$inboundSchema` instead. */
  export const inboundSchema = NotificationStepDataMetadata$inboundSchema;
  /** @deprecated use `NotificationStepDataMetadata$outboundSchema` instead. */
  export const outboundSchema = NotificationStepDataMetadata$outboundSchema;
  /** @deprecated use `NotificationStepDataMetadata$Outbound` instead. */
  export type Outbound = NotificationStepDataMetadata$Outbound;
}

export function notificationStepDataMetadataToJSON(notificationStepDataMetadata: NotificationStepDataMetadata): string {
  return JSON.stringify(NotificationStepDataMetadata$outboundSchema.parse(notificationStepDataMetadata));
}

export function notificationStepDataMetadataFromJSON(
  jsonString: string
): SafeParseResult<NotificationStepDataMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationStepDataMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationStepDataMetadata' from JSON`
  );
}

/** @internal */
export const NotificationStepData$inboundSchema: z.ZodType<NotificationStepData, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    uuid: z.string().optional(),
    name: z.string().optional(),
    _templateId: z.string().optional(),
    active: z.boolean().optional(),
    shouldStopOnFail: z.boolean().optional(),
    template: MessageTemplate$inboundSchema.optional(),
    filters: z.array(StepFilterDto$inboundSchema).optional(),
    _parentId: z.string().optional(),
    metadata: z
      .union([
        DelayScheduledMetadata$inboundSchema,
        DigestRegularMetadata$inboundSchema,
        DigestTimedMetadata$inboundSchema,
        DelayRegularMetadata$inboundSchema,
      ])
      .optional(),
    replyCallback: ReplyCallback$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      _templateId: 'templateId',
      _parentId: 'parentId',
    });
  });

/** @internal */
export type NotificationStepData$Outbound = {
  _id?: string | undefined;
  uuid?: string | undefined;
  name?: string | undefined;
  _templateId?: string | undefined;
  active?: boolean | undefined;
  shouldStopOnFail?: boolean | undefined;
  template?: MessageTemplate$Outbound | undefined;
  filters?: Array<StepFilterDto$Outbound> | undefined;
  _parentId?: string | undefined;
  metadata?:
    | DelayScheduledMetadata$Outbound
    | DigestRegularMetadata$Outbound
    | DigestTimedMetadata$Outbound
    | DelayRegularMetadata$Outbound
    | undefined;
  replyCallback?: ReplyCallback$Outbound | undefined;
};

/** @internal */
export const NotificationStepData$outboundSchema: z.ZodType<
  NotificationStepData$Outbound,
  z.ZodTypeDef,
  NotificationStepData
> = z
  .object({
    id: z.string().optional(),
    uuid: z.string().optional(),
    name: z.string().optional(),
    templateId: z.string().optional(),
    active: z.boolean().optional(),
    shouldStopOnFail: z.boolean().optional(),
    template: MessageTemplate$outboundSchema.optional(),
    filters: z.array(StepFilterDto$outboundSchema).optional(),
    parentId: z.string().optional(),
    metadata: z
      .union([
        DelayScheduledMetadata$outboundSchema,
        DigestRegularMetadata$outboundSchema,
        DigestTimedMetadata$outboundSchema,
        DelayRegularMetadata$outboundSchema,
      ])
      .optional(),
    replyCallback: ReplyCallback$outboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      templateId: '_templateId',
      parentId: '_parentId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationStepData$ {
  /** @deprecated use `NotificationStepData$inboundSchema` instead. */
  export const inboundSchema = NotificationStepData$inboundSchema;
  /** @deprecated use `NotificationStepData$outboundSchema` instead. */
  export const outboundSchema = NotificationStepData$outboundSchema;
  /** @deprecated use `NotificationStepData$Outbound` instead. */
  export type Outbound = NotificationStepData$Outbound;
}

export function notificationStepDataToJSON(notificationStepData: NotificationStepData): string {
  return JSON.stringify(NotificationStepData$outboundSchema.parse(notificationStepData));
}

export function notificationStepDataFromJSON(
  jsonString: string
): SafeParseResult<NotificationStepData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationStepData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationStepData' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationStepDataMetadataToJSON(notificationStepDataMetadata: NotificationStepDataMetadata)
 - notificationStepDataMetadataFromJSON(jsonString: string)
 - notificationStepDataToJSON(notificationStepData: NotificationStepData)
 - notificationStepDataFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(NotificationStepDataMetadata$Outbound;
}

export function notificationStepDataMetadataToJSON(notific...)
 - Outbound(NotificationStepData$Outbound;
}

export function notificationStepDataToJSON(notificationStepData: N...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationStepDataMetadataToJSON
- export function notificationStepDataMetadataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationStepDataToJSON
- export function notificationStepDataFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/notificationstepdto.ts
Tamaño: 8737 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  DelayRegularMetadata,
  DelayRegularMetadata$inboundSchema,
  DelayRegularMetadata$Outbound,
  DelayRegularMetadata$outboundSchema,
} from './delayregularmetadata.js';
import {
  DelayScheduledMetadata,
  DelayScheduledMetadata$inboundSchema,
  DelayScheduledMetadata$Outbound,
  DelayScheduledMetadata$outboundSchema,
} from './delayscheduledmetadata.js';
import {
  DigestRegularMetadata,
  DigestRegularMetadata$inboundSchema,
  DigestRegularMetadata$Outbound,
  DigestRegularMetadata$outboundSchema,
} from './digestregularmetadata.js';
import {
  DigestTimedMetadata,
  DigestTimedMetadata$inboundSchema,
  DigestTimedMetadata$Outbound,
  DigestTimedMetadata$outboundSchema,
} from './digesttimedmetadata.js';
import {
  MessageTemplate,
  MessageTemplate$inboundSchema,
  MessageTemplate$Outbound,
  MessageTemplate$outboundSchema,
} from './messagetemplate.js';
import {
  NotificationStepData,
  NotificationStepData$inboundSchema,
  NotificationStepData$Outbound,
  NotificationStepData$outboundSchema,
} from './notificationstepdata.js';
import {
  ReplyCallback,
  ReplyCallback$inboundSchema,
  ReplyCallback$Outbound,
  ReplyCallback$outboundSchema,
} from './replycallback.js';
import {
  StepFilterDto,
  StepFilterDto$inboundSchema,
  StepFilterDto$Outbound,
  StepFilterDto$outboundSchema,
} from './stepfilterdto.js';

/**
 * Metadata associated with the workflow step. Can vary based on the type of step.
 */
export type Metadata = DelayScheduledMetadata | DigestRegularMetadata | DigestTimedMetadata | DelayRegularMetadata;

export type NotificationStepDto = {
  /**
   * Unique identifier for the notification step.
   */
  id?: string | undefined;
  /**
   * Universally unique identifier for the notification step.
   */
  uuid?: string | undefined;
  /**
   * Name of the notification step.
   */
  name?: string | undefined;
  /**
   * ID of the template associated with this notification step.
   */
  templateId?: string | undefined;
  /**
   * Indicates whether the notification step is active.
   */
  active?: boolean | undefined;
  /**
   * Determines if the process should stop on failure.
   */
  shouldStopOnFail?: boolean | undefined;
  /**
   * Message template used in this notification step.
   */
  template?: MessageTemplate | undefined;
  /**
   * Filters applied to this notification step.
   */
  filters?: Array<StepFilterDto> | undefined;
  /**
   * ID of the parent notification step, if applicable.
   */
  parentId?: string | undefined;
  /**
   * Metadata associated with the workflow step. Can vary based on the type of step.
   */
  metadata?: DelayScheduledMetadata | DigestRegularMetadata | DigestTimedMetadata | DelayRegularMetadata | undefined;
  /**
   * Callback information for replies, including whether it is active and the callback URL.
   */
  replyCallback?: ReplyCallback | undefined;
  variants?: Array<NotificationStepData> | undefined;
};

/** @internal */
export const Metadata$inboundSchema: z.ZodType<Metadata, z.ZodTypeDef, unknown> = z.union([
  DelayScheduledMetadata$inboundSchema,
  DigestRegularMetadata$inboundSchema,
  DigestTimedMetadata$inboundSchema,
  DelayRegularMetadata$inboundSchema,
]);

/** @internal */
export type Metadata$Outbound =
  | DelayScheduledMetadata$Outbound
  | DigestRegularMetadata$Outbound
  | DigestTimedMetadata$Outbound
  | DelayRegularMetadata$Outbound;

/** @internal */
export const Metadata$outboundSchema: z.ZodType<Metadata$Outbound, z.ZodTypeDef, Metadata> = z.union([
  DelayScheduledMetadata$outboundSchema,
  DigestRegularMetadata$outboundSchema,
  DigestTimedMetadata$outboundSchema,
  DelayRegularMetadata$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Metadata$ {
  /** @deprecated use `Metadata$inboundSchema` instead. */
  export const inboundSchema = Metadata$inboundSchema;
  /** @deprecated use `Metadata$outboundSchema` instead. */
  export const outboundSchema = Metadata$outboundSchema;
  /** @deprecated use `Metadata$Outbound` instead. */
  export type Outbound = Metadata$Outbound;
}

export function metadataToJSON(metadata: Metadata): string {
  return JSON.stringify(Metadata$outboundSchema.parse(metadata));
}

export function metadataFromJSON(jsonString: string): SafeParseResult<Metadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Metadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Metadata' from JSON`
  );
}

/** @internal */
export const NotificationStepDto$inboundSchema: z.ZodType<NotificationStepDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    uuid: z.string().optional(),
    name: z.string().optional(),
    _templateId: z.string().optional(),
    active: z.boolean().optional(),
    shouldStopOnFail: z.boolean().optional(),
    template: MessageTemplate$inboundSchema.optional(),
    filters: z.array(StepFilterDto$inboundSchema).optional(),
    _parentId: z.string().optional(),
    metadata: z
      .union([
        DelayScheduledMetadata$inboundSchema,
        DigestRegularMetadata$inboundSchema,
        DigestTimedMetadata$inboundSchema,
        DelayRegularMetadata$inboundSchema,
      ])
      .optional(),
    replyCallback: ReplyCallback$inboundSchema.optional(),
    variants: z.array(NotificationStepData$inboundSchema).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      _templateId: 'templateId',
      _parentId: 'parentId',
    });
  });

/** @internal */
export type NotificationStepDto$Outbound = {
  _id?: string | undefined;
  uuid?: string | undefined;
  name?: string | undefined;
  _templateId?: string | undefined;
  active?: boolean | undefined;
  shouldStopOnFail?: boolean | undefined;
  template?: MessageTemplate$Outbound | undefined;
  filters?: Array<StepFilterDto$Outbound> | undefined;
  _parentId?: string | undefined;
  metadata?:
    | DelayScheduledMetadata$Outbound
    | DigestRegularMetadata$Outbound
    | DigestTimedMetadata$Outbound
    | DelayRegularMetadata$Outbound
    | undefined;
  replyCallback?: ReplyCallback$Outbound | undefined;
  variants?: Array<NotificationStepData$Outbound> | undefined;
};

/** @internal */
export const NotificationStepDto$outboundSchema: z.ZodType<
  NotificationStepDto$Outbound,
  z.ZodTypeDef,
  NotificationStepDto
> = z
  .object({
    id: z.string().optional(),
    uuid: z.string().optional(),
    name: z.string().optional(),
    templateId: z.string().optional(),
    active: z.boolean().optional(),
    shouldStopOnFail: z.boolean().optional(),
    template: MessageTemplate$outboundSchema.optional(),
    filters: z.array(StepFilterDto$outboundSchema).optional(),
    parentId: z.string().optional(),
    metadata: z
      .union([
        DelayScheduledMetadata$outboundSchema,
        DigestRegularMetadata$outboundSchema,
        DigestTimedMetadata$outboundSchema,
        DelayRegularMetadata$outboundSchema,
      ])
      .optional(),
    replyCallback: ReplyCallback$outboundSchema.optional(),
    variants: z.array(NotificationStepData$outboundSchema).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      templateId: '_templateId',
      parentId: '_parentId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationStepDto$ {
  /** @deprecated use `NotificationStepDto$inboundSchema` instead. */
  export const inboundSchema = NotificationStepDto$inboundSchema;
  /** @deprecated use `NotificationStepDto$outboundSchema` instead. */
  export const outboundSchema = NotificationStepDto$outboundSchema;
  /** @deprecated use `NotificationStepDto$Outbound` instead. */
  export type Outbound = NotificationStepDto$Outbound;
}

export function notificationStepDtoToJSON(notificationStepDto: NotificationStepDto): string {
  return JSON.stringify(NotificationStepDto$outboundSchema.parse(notificationStepDto));
}

export function notificationStepDtoFromJSON(
  jsonString: string
): SafeParseResult<NotificationStepDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationStepDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationStepDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - metadataToJSON(metadata: Metadata)
 - metadataFromJSON(jsonString: string)
 - notificationStepDtoToJSON(notificationStepDto: NotificationStepDto)
 - notificationStepDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Metadata$Outbound;
}

export function metadataToJSON(metadata: Metadata): string {
  return JSON.str...)
 - Outbound(NotificationStepDto$Outbound;
}

export function notificationStepDtoToJSON(notificationStepDto: Noti...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function metadataToJSON
- export function metadataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationStepDtoToJSON
- export function notificationStepDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/notificationtrigger.ts
Tamaño: 3807 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  NotificationTriggerVariable,
  NotificationTriggerVariable$inboundSchema,
  NotificationTriggerVariable$Outbound,
  NotificationTriggerVariable$outboundSchema,
} from './notificationtriggervariable.js';

export const NotificationTriggerType = {
  Event: 'event',
} as const;
export type NotificationTriggerType = ClosedEnum<typeof NotificationTriggerType>;

export type NotificationTrigger = {
  type: NotificationTriggerType;
  identifier: string;
  variables: Array<NotificationTriggerVariable>;
  subscriberVariables?: Array<NotificationTriggerVariable> | undefined;
};

/** @internal */
export const NotificationTriggerType$inboundSchema: z.ZodNativeEnum<typeof NotificationTriggerType> =
  z.nativeEnum(NotificationTriggerType);

/** @internal */
export const NotificationTriggerType$outboundSchema: z.ZodNativeEnum<typeof NotificationTriggerType> =
  NotificationTriggerType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationTriggerType$ {
  /** @deprecated use `NotificationTriggerType$inboundSchema` instead. */
  export const inboundSchema = NotificationTriggerType$inboundSchema;
  /** @deprecated use `NotificationTriggerType$outboundSchema` instead. */
  export const outboundSchema = NotificationTriggerType$outboundSchema;
}

/** @internal */
export const NotificationTrigger$inboundSchema: z.ZodType<NotificationTrigger, z.ZodTypeDef, unknown> = z.object({
  type: NotificationTriggerType$inboundSchema,
  identifier: z.string(),
  variables: z.array(NotificationTriggerVariable$inboundSchema),
  subscriberVariables: z.array(NotificationTriggerVariable$inboundSchema).optional(),
});

/** @internal */
export type NotificationTrigger$Outbound = {
  type: string;
  identifier: string;
  variables: Array<NotificationTriggerVariable$Outbound>;
  subscriberVariables?: Array<NotificationTriggerVariable$Outbound> | undefined;
};

/** @internal */
export const NotificationTrigger$outboundSchema: z.ZodType<
  NotificationTrigger$Outbound,
  z.ZodTypeDef,
  NotificationTrigger
> = z.object({
  type: NotificationTriggerType$outboundSchema,
  identifier: z.string(),
  variables: z.array(NotificationTriggerVariable$outboundSchema),
  subscriberVariables: z.array(NotificationTriggerVariable$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationTrigger$ {
  /** @deprecated use `NotificationTrigger$inboundSchema` instead. */
  export const inboundSchema = NotificationTrigger$inboundSchema;
  /** @deprecated use `NotificationTrigger$outboundSchema` instead. */
  export const outboundSchema = NotificationTrigger$outboundSchema;
  /** @deprecated use `NotificationTrigger$Outbound` instead. */
  export type Outbound = NotificationTrigger$Outbound;
}

export function notificationTriggerToJSON(notificationTrigger: NotificationTrigger): string {
  return JSON.stringify(NotificationTrigger$outboundSchema.parse(notificationTrigger));
}

export function notificationTriggerFromJSON(
  jsonString: string
): SafeParseResult<NotificationTrigger, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationTrigger$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationTrigger' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationTriggerToJSON(notificationTrigger: NotificationTrigger)
 - notificationTriggerFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(NotificationTrigger$Outbound;
}

export function notificationTriggerToJSON(notificationTrigger: Noti...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationTriggerToJSON
- export function notificationTriggerFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/notificationtriggerdto.ts
Tamaño: 4164 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  NotificationTriggerVariable,
  NotificationTriggerVariable$inboundSchema,
  NotificationTriggerVariable$Outbound,
  NotificationTriggerVariable$outboundSchema,
} from './notificationtriggervariable.js';

/**
 * Type of the trigger
 */
export const NotificationTriggerDtoType = {
  Event: 'event',
} as const;
/**
 * Type of the trigger
 */
export type NotificationTriggerDtoType = ClosedEnum<typeof NotificationTriggerDtoType>;

export type NotificationTriggerDto = {
  /**
   * Type of the trigger
   */
  type: NotificationTriggerDtoType;
  /**
   * Identifier of the trigger
   */
  identifier: string;
  /**
   * Variables of the trigger
   */
  variables: Array<NotificationTriggerVariable>;
  /**
   * Subscriber variables of the trigger
   */
  subscriberVariables?: Array<NotificationTriggerVariable> | undefined;
};

/** @internal */
export const NotificationTriggerDtoType$inboundSchema: z.ZodNativeEnum<typeof NotificationTriggerDtoType> =
  z.nativeEnum(NotificationTriggerDtoType);

/** @internal */
export const NotificationTriggerDtoType$outboundSchema: z.ZodNativeEnum<typeof NotificationTriggerDtoType> =
  NotificationTriggerDtoType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationTriggerDtoType$ {
  /** @deprecated use `NotificationTriggerDtoType$inboundSchema` instead. */
  export const inboundSchema = NotificationTriggerDtoType$inboundSchema;
  /** @deprecated use `NotificationTriggerDtoType$outboundSchema` instead. */
  export const outboundSchema = NotificationTriggerDtoType$outboundSchema;
}

/** @internal */
export const NotificationTriggerDto$inboundSchema: z.ZodType<NotificationTriggerDto, z.ZodTypeDef, unknown> = z.object({
  type: NotificationTriggerDtoType$inboundSchema,
  identifier: z.string(),
  variables: z.array(NotificationTriggerVariable$inboundSchema),
  subscriberVariables: z.array(NotificationTriggerVariable$inboundSchema).optional(),
});

/** @internal */
export type NotificationTriggerDto$Outbound = {
  type: string;
  identifier: string;
  variables: Array<NotificationTriggerVariable$Outbound>;
  subscriberVariables?: Array<NotificationTriggerVariable$Outbound> | undefined;
};

/** @internal */
export const NotificationTriggerDto$outboundSchema: z.ZodType<
  NotificationTriggerDto$Outbound,
  z.ZodTypeDef,
  NotificationTriggerDto
> = z.object({
  type: NotificationTriggerDtoType$outboundSchema,
  identifier: z.string(),
  variables: z.array(NotificationTriggerVariable$outboundSchema),
  subscriberVariables: z.array(NotificationTriggerVariable$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationTriggerDto$ {
  /** @deprecated use `NotificationTriggerDto$inboundSchema` instead. */
  export const inboundSchema = NotificationTriggerDto$inboundSchema;
  /** @deprecated use `NotificationTriggerDto$outboundSchema` instead. */
  export const outboundSchema = NotificationTriggerDto$outboundSchema;
  /** @deprecated use `NotificationTriggerDto$Outbound` instead. */
  export type Outbound = NotificationTriggerDto$Outbound;
}

export function notificationTriggerDtoToJSON(notificationTriggerDto: NotificationTriggerDto): string {
  return JSON.stringify(NotificationTriggerDto$outboundSchema.parse(notificationTriggerDto));
}

export function notificationTriggerDtoFromJSON(
  jsonString: string
): SafeParseResult<NotificationTriggerDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationTriggerDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationTriggerDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationTriggerDtoToJSON(notificationTriggerDto: NotificationTriggerDto)
 - notificationTriggerDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(NotificationTriggerDto$Outbound;
}

export function notificationTriggerDtoToJSON(notificationTrigger...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationTriggerDtoToJSON
- export function notificationTriggerDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/notificationtriggervariable.ts
Tamaño: 2069 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type NotificationTriggerVariable = {
  /**
   * Name of the variable
   */
  name: string;
};

/** @internal */
export const NotificationTriggerVariable$inboundSchema: z.ZodType<NotificationTriggerVariable, z.ZodTypeDef, unknown> =
  z.object({
    name: z.string(),
  });

/** @internal */
export type NotificationTriggerVariable$Outbound = {
  name: string;
};

/** @internal */
export const NotificationTriggerVariable$outboundSchema: z.ZodType<
  NotificationTriggerVariable$Outbound,
  z.ZodTypeDef,
  NotificationTriggerVariable
> = z.object({
  name: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationTriggerVariable$ {
  /** @deprecated use `NotificationTriggerVariable$inboundSchema` instead. */
  export const inboundSchema = NotificationTriggerVariable$inboundSchema;
  /** @deprecated use `NotificationTriggerVariable$outboundSchema` instead. */
  export const outboundSchema = NotificationTriggerVariable$outboundSchema;
  /** @deprecated use `NotificationTriggerVariable$Outbound` instead. */
  export type Outbound = NotificationTriggerVariable$Outbound;
}

export function notificationTriggerVariableToJSON(notificationTriggerVariable: NotificationTriggerVariable): string {
  return JSON.stringify(NotificationTriggerVariable$outboundSchema.parse(notificationTriggerVariable));
}

export function notificationTriggerVariableFromJSON(
  jsonString: string
): SafeParseResult<NotificationTriggerVariable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationTriggerVariable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationTriggerVariable' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationTriggerVariableToJSON(notificationTriggerVariable: NotificationTriggerVariable)
 - notificationTriggerVariableFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(NotificationTriggerVariable$Outbound;
}

export function notificationTriggerVariableToJSON(notificat...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationTriggerVariableToJSON
- export function notificationTriggerVariableFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/ordinalenum.ts
Tamaño: 1102 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Ordinal position for the digest
 */
export const OrdinalEnum = {
  One: '1',
  Two: '2',
  Three: '3',
  Four: '4',
  Five: '5',
  Last: 'last',
} as const;
/**
 * Ordinal position for the digest
 */
export type OrdinalEnum = ClosedEnum<typeof OrdinalEnum>;

/** @internal */
export const OrdinalEnum$inboundSchema: z.ZodNativeEnum<typeof OrdinalEnum> = z.nativeEnum(OrdinalEnum);

/** @internal */
export const OrdinalEnum$outboundSchema: z.ZodNativeEnum<typeof OrdinalEnum> = OrdinalEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrdinalEnum$ {
  /** @deprecated use `OrdinalEnum$inboundSchema` instead. */
  export const inboundSchema = OrdinalEnum$inboundSchema;
  /** @deprecated use `OrdinalEnum$outboundSchema` instead. */
  export const outboundSchema = OrdinalEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/ordinalvalueenum.ts
Tamaño: 1284 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Value of the ordinal
 */
export const OrdinalValueEnum = {
  Day: 'day',
  Weekday: 'weekday',
  Weekend: 'weekend',
  Sunday: 'sunday',
  Monday: 'monday',
  Tuesday: 'tuesday',
  Wednesday: 'wednesday',
  Thursday: 'thursday',
  Friday: 'friday',
  Saturday: 'saturday',
} as const;
/**
 * Value of the ordinal
 */
export type OrdinalValueEnum = ClosedEnum<typeof OrdinalValueEnum>;

/** @internal */
export const OrdinalValueEnum$inboundSchema: z.ZodNativeEnum<typeof OrdinalValueEnum> = z.nativeEnum(OrdinalValueEnum);

/** @internal */
export const OrdinalValueEnum$outboundSchema: z.ZodNativeEnum<typeof OrdinalValueEnum> = OrdinalValueEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrdinalValueEnum$ {
  /** @deprecated use `OrdinalValueEnum$inboundSchema` instead. */
  export const inboundSchema = OrdinalValueEnum$inboundSchema;
  /** @deprecated use `OrdinalValueEnum$outboundSchema` instead. */
  export const outboundSchema = OrdinalValueEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/patchpreferencechannelsdto.ts
Tamaño: 3014 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type PatchPreferenceChannelsDto = {
  /**
   * Email channel preference
   */
  email?: boolean | undefined;
  /**
   * SMS channel preference
   */
  sms?: boolean | undefined;
  /**
   * In-app channel preference
   */
  inApp?: boolean | undefined;
  /**
   * Push channel preference
   */
  push?: boolean | undefined;
  /**
   * Chat channel preference
   */
  chat?: boolean | undefined;
};

/** @internal */
export const PatchPreferenceChannelsDto$inboundSchema: z.ZodType<PatchPreferenceChannelsDto, z.ZodTypeDef, unknown> = z
  .object({
    email: z.boolean().optional(),
    sms: z.boolean().optional(),
    in_app: z.boolean().optional(),
    push: z.boolean().optional(),
    chat: z.boolean().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      in_app: 'inApp',
    });
  });

/** @internal */
export type PatchPreferenceChannelsDto$Outbound = {
  email?: boolean | undefined;
  sms?: boolean | undefined;
  in_app?: boolean | undefined;
  push?: boolean | undefined;
  chat?: boolean | undefined;
};

/** @internal */
export const PatchPreferenceChannelsDto$outboundSchema: z.ZodType<
  PatchPreferenceChannelsDto$Outbound,
  z.ZodTypeDef,
  PatchPreferenceChannelsDto
> = z
  .object({
    email: z.boolean().optional(),
    sms: z.boolean().optional(),
    inApp: z.boolean().optional(),
    push: z.boolean().optional(),
    chat: z.boolean().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      inApp: 'in_app',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PatchPreferenceChannelsDto$ {
  /** @deprecated use `PatchPreferenceChannelsDto$inboundSchema` instead. */
  export const inboundSchema = PatchPreferenceChannelsDto$inboundSchema;
  /** @deprecated use `PatchPreferenceChannelsDto$outboundSchema` instead. */
  export const outboundSchema = PatchPreferenceChannelsDto$outboundSchema;
  /** @deprecated use `PatchPreferenceChannelsDto$Outbound` instead. */
  export type Outbound = PatchPreferenceChannelsDto$Outbound;
}

export function patchPreferenceChannelsDtoToJSON(patchPreferenceChannelsDto: PatchPreferenceChannelsDto): string {
  return JSON.stringify(PatchPreferenceChannelsDto$outboundSchema.parse(patchPreferenceChannelsDto));
}

export function patchPreferenceChannelsDtoFromJSON(
  jsonString: string
): SafeParseResult<PatchPreferenceChannelsDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PatchPreferenceChannelsDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PatchPreferenceChannelsDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - patchPreferenceChannelsDtoToJSON(patchPreferenceChannelsDto: PatchPreferenceChannelsDto)
 - patchPreferenceChannelsDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PatchPreferenceChannelsDto$Outbound;
}

export function patchPreferenceChannelsDtoToJSON(patchPrefer...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function patchPreferenceChannelsDtoToJSON
- export function patchPreferenceChannelsDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/patchsubscriberpreferencesdto.ts
Tamaño: 3168 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  PatchPreferenceChannelsDto,
  PatchPreferenceChannelsDto$inboundSchema,
  PatchPreferenceChannelsDto$Outbound,
  PatchPreferenceChannelsDto$outboundSchema,
} from './patchpreferencechannelsdto.js';
import {
  ScheduleDto,
  ScheduleDto$inboundSchema,
  ScheduleDto$Outbound,
  ScheduleDto$outboundSchema,
} from './scheduledto.js';

export type PatchSubscriberPreferencesDto = {
  /**
   * Channel-specific preference settings
   */
  channels?: PatchPreferenceChannelsDto | undefined;
  /**
   * Workflow internal _id, identifier or slug. If provided, update workflow specific preferences, otherwise update global preferences
   */
  workflowId?: string | undefined;
  /**
   * Subscriber schedule
   */
  schedule?: ScheduleDto | undefined;
};

/** @internal */
export const PatchSubscriberPreferencesDto$inboundSchema: z.ZodType<
  PatchSubscriberPreferencesDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  channels: PatchPreferenceChannelsDto$inboundSchema.optional(),
  workflowId: z.string().optional(),
  schedule: ScheduleDto$inboundSchema.optional(),
});

/** @internal */
export type PatchSubscriberPreferencesDto$Outbound = {
  channels?: PatchPreferenceChannelsDto$Outbound | undefined;
  workflowId?: string | undefined;
  schedule?: ScheduleDto$Outbound | undefined;
};

/** @internal */
export const PatchSubscriberPreferencesDto$outboundSchema: z.ZodType<
  PatchSubscriberPreferencesDto$Outbound,
  z.ZodTypeDef,
  PatchSubscriberPreferencesDto
> = z.object({
  channels: PatchPreferenceChannelsDto$outboundSchema.optional(),
  workflowId: z.string().optional(),
  schedule: ScheduleDto$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PatchSubscriberPreferencesDto$ {
  /** @deprecated use `PatchSubscriberPreferencesDto$inboundSchema` instead. */
  export const inboundSchema = PatchSubscriberPreferencesDto$inboundSchema;
  /** @deprecated use `PatchSubscriberPreferencesDto$outboundSchema` instead. */
  export const outboundSchema = PatchSubscriberPreferencesDto$outboundSchema;
  /** @deprecated use `PatchSubscriberPreferencesDto$Outbound` instead. */
  export type Outbound = PatchSubscriberPreferencesDto$Outbound;
}

export function patchSubscriberPreferencesDtoToJSON(
  patchSubscriberPreferencesDto: PatchSubscriberPreferencesDto
): string {
  return JSON.stringify(PatchSubscriberPreferencesDto$outboundSchema.parse(patchSubscriberPreferencesDto));
}

export function patchSubscriberPreferencesDtoFromJSON(
  jsonString: string
): SafeParseResult<PatchSubscriberPreferencesDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PatchSubscriberPreferencesDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PatchSubscriberPreferencesDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - patchSubscriberPreferencesDtoToJSON(patchSubscriberPreferencesDto: PatchSubscriberPreferencesDto)
 - patchSubscriberPreferencesDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PatchSubscriberPreferencesDto$Outbound;
}

export function patchSubscriberPreferencesDtoToJSON(
  pa...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function patchSubscriberPreferencesDtoToJSON
- export function patchSubscriberPreferencesDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/patchsubscriberrequestdto.ts
Tamaño: 3684 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type PatchSubscriberRequestDto = {
  /**
   * First name of the subscriber
   */
  firstName?: string | null | undefined;
  /**
   * Last name of the subscriber
   */
  lastName?: string | null | undefined;
  /**
   * Email address of the subscriber
   */
  email?: string | null | undefined;
  /**
   * Phone number of the subscriber
   */
  phone?: string | null | undefined;
  /**
   * Avatar URL or identifier
   */
  avatar?: string | null | undefined;
  /**
   * Timezone of the subscriber
   */
  timezone?: string | null | undefined;
  /**
   * Locale of the subscriber
   */
  locale?: string | null | undefined;
  /**
   * Additional custom data for the subscriber
   */
  data?: { [k: string]: any } | null | undefined;
};

/** @internal */
export const PatchSubscriberRequestDto$inboundSchema: z.ZodType<PatchSubscriberRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
    phone: z.nullable(z.string()).optional(),
    avatar: z.nullable(z.string()).optional(),
    timezone: z.nullable(z.string()).optional(),
    locale: z.nullable(z.string()).optional(),
    data: z.nullable(z.record(z.any())).optional(),
  });

/** @internal */
export type PatchSubscriberRequestDto$Outbound = {
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  email?: string | null | undefined;
  phone?: string | null | undefined;
  avatar?: string | null | undefined;
  timezone?: string | null | undefined;
  locale?: string | null | undefined;
  data?: { [k: string]: any } | null | undefined;
};

/** @internal */
export const PatchSubscriberRequestDto$outboundSchema: z.ZodType<
  PatchSubscriberRequestDto$Outbound,
  z.ZodTypeDef,
  PatchSubscriberRequestDto
> = z.object({
  firstName: z.nullable(z.string()).optional(),
  lastName: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  phone: z.nullable(z.string()).optional(),
  avatar: z.nullable(z.string()).optional(),
  timezone: z.nullable(z.string()).optional(),
  locale: z.nullable(z.string()).optional(),
  data: z.nullable(z.record(z.any())).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PatchSubscriberRequestDto$ {
  /** @deprecated use `PatchSubscriberRequestDto$inboundSchema` instead. */
  export const inboundSchema = PatchSubscriberRequestDto$inboundSchema;
  /** @deprecated use `PatchSubscriberRequestDto$outboundSchema` instead. */
  export const outboundSchema = PatchSubscriberRequestDto$outboundSchema;
  /** @deprecated use `PatchSubscriberRequestDto$Outbound` instead. */
  export type Outbound = PatchSubscriberRequestDto$Outbound;
}

export function patchSubscriberRequestDtoToJSON(patchSubscriberRequestDto: PatchSubscriberRequestDto): string {
  return JSON.stringify(PatchSubscriberRequestDto$outboundSchema.parse(patchSubscriberRequestDto));
}

export function patchSubscriberRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<PatchSubscriberRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PatchSubscriberRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PatchSubscriberRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - patchSubscriberRequestDtoToJSON(patchSubscriberRequestDto: PatchSubscriberRequestDto)
 - patchSubscriberRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PatchSubscriberRequestDto$Outbound;
}

export function patchSubscriberRequestDtoToJSON(patchSubscrib...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function patchSubscriberRequestDtoToJSON
- export function patchSubscriberRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/patchworkflowdto.ts
Tamaño: 3235 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type PatchWorkflowDto = {
  /**
   * Activate or deactivate the workflow
   */
  active?: boolean | undefined;
  /**
   * New name for the workflow
   */
  name?: string | undefined;
  /**
   * Updated description of the workflow
   */
  description?: string | undefined;
  /**
   * Tags associated with the workflow
   */
  tags?: Array<string> | undefined;
  /**
   * The payload JSON Schema for the workflow
   */
  payloadSchema?: { [k: string]: any } | null | undefined;
  /**
   * Enable or disable payload schema validation
   */
  validatePayload?: boolean | undefined;
  /**
   * Enable or disable translations for this workflow
   */
  isTranslationEnabled?: boolean | undefined;
};

/** @internal */
export const PatchWorkflowDto$inboundSchema: z.ZodType<PatchWorkflowDto, z.ZodTypeDef, unknown> = z.object({
  active: z.boolean().optional(),
  name: z.string().optional(),
  description: z.string().optional(),
  tags: z.array(z.string()).optional(),
  payloadSchema: z.nullable(z.record(z.any())).optional(),
  validatePayload: z.boolean().optional(),
  isTranslationEnabled: z.boolean().optional(),
});

/** @internal */
export type PatchWorkflowDto$Outbound = {
  active?: boolean | undefined;
  name?: string | undefined;
  description?: string | undefined;
  tags?: Array<string> | undefined;
  payloadSchema?: { [k: string]: any } | null | undefined;
  validatePayload?: boolean | undefined;
  isTranslationEnabled?: boolean | undefined;
};

/** @internal */
export const PatchWorkflowDto$outboundSchema: z.ZodType<PatchWorkflowDto$Outbound, z.ZodTypeDef, PatchWorkflowDto> =
  z.object({
    active: z.boolean().optional(),
    name: z.string().optional(),
    description: z.string().optional(),
    tags: z.array(z.string()).optional(),
    payloadSchema: z.nullable(z.record(z.any())).optional(),
    validatePayload: z.boolean().optional(),
    isTranslationEnabled: z.boolean().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PatchWorkflowDto$ {
  /** @deprecated use `PatchWorkflowDto$inboundSchema` instead. */
  export const inboundSchema = PatchWorkflowDto$inboundSchema;
  /** @deprecated use `PatchWorkflowDto$outboundSchema` instead. */
  export const outboundSchema = PatchWorkflowDto$outboundSchema;
  /** @deprecated use `PatchWorkflowDto$Outbound` instead. */
  export type Outbound = PatchWorkflowDto$Outbound;
}

export function patchWorkflowDtoToJSON(patchWorkflowDto: PatchWorkflowDto): string {
  return JSON.stringify(PatchWorkflowDto$outboundSchema.parse(patchWorkflowDto));
}

export function patchWorkflowDtoFromJSON(jsonString: string): SafeParseResult<PatchWorkflowDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PatchWorkflowDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PatchWorkflowDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - patchWorkflowDtoToJSON(patchWorkflowDto: PatchWorkflowDto)
 - patchWorkflowDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PatchWorkflowDto$Outbound;
}

export function patchWorkflowDtoToJSON(patchWorkflowDto: PatchWorkflow...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function patchWorkflowDtoToJSON
- export function patchWorkflowDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/payloadvalidationerrordto.ts
Tamaño: 8215 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type Value5 = string | number | boolean | { [k: string]: any };

export type Value4 = {};

/**
 * The actual value that failed validation
 */
export type PayloadValidationErrorDtoValue =
  | string
  | number
  | boolean
  | Value4
  | Array<string | number | boolean | { [k: string]: any } | null>;

export type PayloadValidationErrorDto = {
  /**
   * Field path that failed validation
   */
  field: string;
  /**
   * Validation error message
   */
  message: string;
  /**
   * The actual value that failed validation
   */
  value?:
    | string
    | number
    | boolean
    | Value4
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
  /**
   * JSON Schema path where the validation failed
   */
  schemaPath?: string | undefined;
};

/** @internal */
export const Value5$inboundSchema: z.ZodType<Value5, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/** @internal */
export type Value5$Outbound = string | number | boolean | { [k: string]: any };

/** @internal */
export const Value5$outboundSchema: z.ZodType<Value5$Outbound, z.ZodTypeDef, Value5> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Value5$ {
  /** @deprecated use `Value5$inboundSchema` instead. */
  export const inboundSchema = Value5$inboundSchema;
  /** @deprecated use `Value5$outboundSchema` instead. */
  export const outboundSchema = Value5$outboundSchema;
  /** @deprecated use `Value5$Outbound` instead. */
  export type Outbound = Value5$Outbound;
}

export function value5ToJSON(value5: Value5): string {
  return JSON.stringify(Value5$outboundSchema.parse(value5));
}

export function value5FromJSON(jsonString: string): SafeParseResult<Value5, SDKValidationError> {
  return safeParse(jsonString, (x) => Value5$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Value5' from JSON`);
}

/** @internal */
export const Value4$inboundSchema: z.ZodType<Value4, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Value4$Outbound = {};

/** @internal */
export const Value4$outboundSchema: z.ZodType<Value4$Outbound, z.ZodTypeDef, Value4> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Value4$ {
  /** @deprecated use `Value4$inboundSchema` instead. */
  export const inboundSchema = Value4$inboundSchema;
  /** @deprecated use `Value4$outboundSchema` instead. */
  export const outboundSchema = Value4$outboundSchema;
  /** @deprecated use `Value4$Outbound` instead. */
  export type Outbound = Value4$Outbound;
}

export function value4ToJSON(value4: Value4): string {
  return JSON.stringify(Value4$outboundSchema.parse(value4));
}

export function value4FromJSON(jsonString: string): SafeParseResult<Value4, SDKValidationError> {
  return safeParse(jsonString, (x) => Value4$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Value4' from JSON`);
}

/** @internal */
export const PayloadValidationErrorDtoValue$inboundSchema: z.ZodType<
  PayloadValidationErrorDtoValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => Value4$inboundSchema),
  z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
]);

/** @internal */
export type PayloadValidationErrorDtoValue$Outbound =
  | string
  | number
  | boolean
  | Value4$Outbound
  | Array<string | number | boolean | { [k: string]: any } | null>;

/** @internal */
export const PayloadValidationErrorDtoValue$outboundSchema: z.ZodType<
  PayloadValidationErrorDtoValue$Outbound,
  z.ZodTypeDef,
  PayloadValidationErrorDtoValue
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => Value4$outboundSchema),
  z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PayloadValidationErrorDtoValue$ {
  /** @deprecated use `PayloadValidationErrorDtoValue$inboundSchema` instead. */
  export const inboundSchema = PayloadValidationErrorDtoValue$inboundSchema;
  /** @deprecated use `PayloadValidationErrorDtoValue$outboundSchema` instead. */
  export const outboundSchema = PayloadValidationErrorDtoValue$outboundSchema;
  /** @deprecated use `PayloadValidationErrorDtoValue$Outbound` instead. */
  export type Outbound = PayloadValidationErrorDtoValue$Outbound;
}

export function payloadValidationErrorDtoValueToJSON(
  payloadValidationErrorDtoValue: PayloadValidationErrorDtoValue
): string {
  return JSON.stringify(PayloadValidationErrorDtoValue$outboundSchema.parse(payloadValidationErrorDtoValue));
}

export function payloadValidationErrorDtoValueFromJSON(
  jsonString: string
): SafeParseResult<PayloadValidationErrorDtoValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayloadValidationErrorDtoValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayloadValidationErrorDtoValue' from JSON`
  );
}

/** @internal */
export const PayloadValidationErrorDto$inboundSchema: z.ZodType<PayloadValidationErrorDto, z.ZodTypeDef, unknown> =
  z.object({
    field: z.string(),
    message: z.string(),
    value: z
      .nullable(
        z.union([
          z.string(),
          z.number(),
          z.boolean(),
          z.lazy(() => Value4$inboundSchema),
          z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
        ])
      )
      .optional(),
    schemaPath: z.string().optional(),
  });

/** @internal */
export type PayloadValidationErrorDto$Outbound = {
  field: string;
  message: string;
  value?:
    | string
    | number
    | boolean
    | Value4$Outbound
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
  schemaPath?: string | undefined;
};

/** @internal */
export const PayloadValidationErrorDto$outboundSchema: z.ZodType<
  PayloadValidationErrorDto$Outbound,
  z.ZodTypeDef,
  PayloadValidationErrorDto
> = z.object({
  field: z.string(),
  message: z.string(),
  value: z
    .nullable(
      z.union([
        z.string(),
        z.number(),
        z.boolean(),
        z.lazy(() => Value4$outboundSchema),
        z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
      ])
    )
    .optional(),
  schemaPath: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PayloadValidationErrorDto$ {
  /** @deprecated use `PayloadValidationErrorDto$inboundSchema` instead. */
  export const inboundSchema = PayloadValidationErrorDto$inboundSchema;
  /** @deprecated use `PayloadValidationErrorDto$outboundSchema` instead. */
  export const outboundSchema = PayloadValidationErrorDto$outboundSchema;
  /** @deprecated use `PayloadValidationErrorDto$Outbound` instead. */
  export type Outbound = PayloadValidationErrorDto$Outbound;
}

export function payloadValidationErrorDtoToJSON(payloadValidationErrorDto: PayloadValidationErrorDto): string {
  return JSON.stringify(PayloadValidationErrorDto$outboundSchema.parse(payloadValidationErrorDto));
}

export function payloadValidationErrorDtoFromJSON(
  jsonString: string
): SafeParseResult<PayloadValidationErrorDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayloadValidationErrorDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayloadValidationErrorDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - value5ToJSON(value5: Value5)
 - value5FromJSON(jsonString: string)
 - value4ToJSON(value4: Value4)
 - value4FromJSON(jsonString: string)
 - payloadValidationErrorDtoValueToJSON(payloadValidationErrorDtoValue: PayloadValidationErrorDtoValue)
 - payloadValidationErrorDtoValueFromJSON(jsonString: string)
 - payloadValidationErrorDtoToJSON(payloadValidationErrorDto: PayloadValidationErrorDto)
 - payloadValidationErrorDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Value5$Outbound;
}

export function value5ToJSON(value5: Value5): string {
  return JSON.stringify(V...)
 - Outbound(Value4$Outbound;
}

export function value4ToJSON(value4: Value4): string {
  return JSON.stringify(V...)
 - Outbound(PayloadValidationErrorDtoValue$Outbound;
}

export function payloadValidationErrorDtoValueToJSON(
  ...)
 - Outbound(PayloadValidationErrorDto$Outbound;
}

export function payloadValidationErrorDtoToJSON(payloadValida...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function value5ToJSON
- export function value5FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function value4ToJSON
- export function value4FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function payloadValidationErrorDtoValueToJSON
- export function payloadValidationErrorDtoValueFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function payloadValidationErrorDtoToJSON
- export function payloadValidationErrorDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/preferencelevelenum.ts
Tamaño: 1216 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * The level of the preference (global or template)
 */
export const PreferenceLevelEnum = {
  Global: 'global',
  Template: 'template',
} as const;
/**
 * The level of the preference (global or template)
 */
export type PreferenceLevelEnum = ClosedEnum<typeof PreferenceLevelEnum>;

/** @internal */
export const PreferenceLevelEnum$inboundSchema: z.ZodNativeEnum<typeof PreferenceLevelEnum> =
  z.nativeEnum(PreferenceLevelEnum);

/** @internal */
export const PreferenceLevelEnum$outboundSchema: z.ZodNativeEnum<typeof PreferenceLevelEnum> =
  PreferenceLevelEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreferenceLevelEnum$ {
  /** @deprecated use `PreferenceLevelEnum$inboundSchema` instead. */
  export const inboundSchema = PreferenceLevelEnum$inboundSchema;
  /** @deprecated use `PreferenceLevelEnum$outboundSchema` instead. */
  export const outboundSchema = PreferenceLevelEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/preferenceoverridesourceenum.ts
Tamaño: 1340 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * The source of overrides
 */
export const PreferenceOverrideSourceEnum = {
  Subscriber: 'subscriber',
  Template: 'template',
  WorkflowOverride: 'workflowOverride',
} as const;
/**
 * The source of overrides
 */
export type PreferenceOverrideSourceEnum = ClosedEnum<typeof PreferenceOverrideSourceEnum>;

/** @internal */
export const PreferenceOverrideSourceEnum$inboundSchema: z.ZodNativeEnum<typeof PreferenceOverrideSourceEnum> =
  z.nativeEnum(PreferenceOverrideSourceEnum);

/** @internal */
export const PreferenceOverrideSourceEnum$outboundSchema: z.ZodNativeEnum<typeof PreferenceOverrideSourceEnum> =
  PreferenceOverrideSourceEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreferenceOverrideSourceEnum$ {
  /** @deprecated use `PreferenceOverrideSourceEnum$inboundSchema` instead. */
  export const inboundSchema = PreferenceOverrideSourceEnum$inboundSchema;
  /** @deprecated use `PreferenceOverrideSourceEnum$outboundSchema` instead. */
  export const outboundSchema = PreferenceOverrideSourceEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/preferencesrequestdto.ts
Tamaño: 11981 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelPreferenceDto,
  ChannelPreferenceDto$inboundSchema,
  ChannelPreferenceDto$Outbound,
  ChannelPreferenceDto$outboundSchema,
} from './channelpreferencedto.js';
import {
  WorkflowPreferenceDto,
  WorkflowPreferenceDto$inboundSchema,
  WorkflowPreferenceDto$Outbound,
  WorkflowPreferenceDto$outboundSchema,
} from './workflowpreferencedto.js';

/**
 * A preference for the workflow. The values specified here will be used if no preference is specified for a channel.
 */
export type UserAll = WorkflowPreferenceDto;

export type UserWorkflowPreferencesDto = {
  /**
   * A preference for the workflow. The values specified here will be used if no preference is specified for a channel.
   */
  all: WorkflowPreferenceDto;
  /**
   * Preferences for different communication channels
   */
  channels: { [k: string]: ChannelPreferenceDto };
};

/**
 * User workflow preferences
 */
export type User = UserWorkflowPreferencesDto;

/**
 * A preference for the workflow. The values specified here will be used if no preference is specified for a channel.
 */
export type PreferencesRequestDtoAll = WorkflowPreferenceDto;

/**
 * Workflow-specific preferences
 */
export type PreferencesRequestDtoWorkflow = {
  /**
   * A preference for the workflow. The values specified here will be used if no preference is specified for a channel.
   */
  all: WorkflowPreferenceDto;
  /**
   * Preferences for different communication channels
   */
  channels: { [k: string]: ChannelPreferenceDto };
};

export type PreferencesRequestDto = {
  /**
   * User workflow preferences
   */
  user?: UserWorkflowPreferencesDto | null | undefined;
  /**
   * Workflow-specific preferences
   */
  workflow?: PreferencesRequestDtoWorkflow | null | undefined;
};

/** @internal */
export const UserAll$inboundSchema: z.ZodType<UserAll, z.ZodTypeDef, unknown> = WorkflowPreferenceDto$inboundSchema;

/** @internal */
export type UserAll$Outbound = WorkflowPreferenceDto$Outbound;

/** @internal */
export const UserAll$outboundSchema: z.ZodType<UserAll$Outbound, z.ZodTypeDef, UserAll> =
  WorkflowPreferenceDto$outboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UserAll$ {
  /** @deprecated use `UserAll$inboundSchema` instead. */
  export const inboundSchema = UserAll$inboundSchema;
  /** @deprecated use `UserAll$outboundSchema` instead. */
  export const outboundSchema = UserAll$outboundSchema;
  /** @deprecated use `UserAll$Outbound` instead. */
  export type Outbound = UserAll$Outbound;
}

export function userAllToJSON(userAll: UserAll): string {
  return JSON.stringify(UserAll$outboundSchema.parse(userAll));
}

export function userAllFromJSON(jsonString: string): SafeParseResult<UserAll, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserAll$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserAll' from JSON`
  );
}

/** @internal */
export const UserWorkflowPreferencesDto$inboundSchema: z.ZodType<UserWorkflowPreferencesDto, z.ZodTypeDef, unknown> =
  z.object({
    all: WorkflowPreferenceDto$inboundSchema,
    channels: z.record(ChannelPreferenceDto$inboundSchema),
  });

/** @internal */
export type UserWorkflowPreferencesDto$Outbound = {
  all: WorkflowPreferenceDto$Outbound;
  channels: { [k: string]: ChannelPreferenceDto$Outbound };
};

/** @internal */
export const UserWorkflowPreferencesDto$outboundSchema: z.ZodType<
  UserWorkflowPreferencesDto$Outbound,
  z.ZodTypeDef,
  UserWorkflowPreferencesDto
> = z.object({
  all: WorkflowPreferenceDto$outboundSchema,
  channels: z.record(ChannelPreferenceDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UserWorkflowPreferencesDto$ {
  /** @deprecated use `UserWorkflowPreferencesDto$inboundSchema` instead. */
  export const inboundSchema = UserWorkflowPreferencesDto$inboundSchema;
  /** @deprecated use `UserWorkflowPreferencesDto$outboundSchema` instead. */
  export const outboundSchema = UserWorkflowPreferencesDto$outboundSchema;
  /** @deprecated use `UserWorkflowPreferencesDto$Outbound` instead. */
  export type Outbound = UserWorkflowPreferencesDto$Outbound;
}

export function userWorkflowPreferencesDtoToJSON(userWorkflowPreferencesDto: UserWorkflowPreferencesDto): string {
  return JSON.stringify(UserWorkflowPreferencesDto$outboundSchema.parse(userWorkflowPreferencesDto));
}

export function userWorkflowPreferencesDtoFromJSON(
  jsonString: string
): SafeParseResult<UserWorkflowPreferencesDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserWorkflowPreferencesDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserWorkflowPreferencesDto' from JSON`
  );
}

/** @internal */
export const User$inboundSchema: z.ZodType<User, z.ZodTypeDef, unknown> = z.lazy(
  () => UserWorkflowPreferencesDto$inboundSchema
);

/** @internal */
export type User$Outbound = UserWorkflowPreferencesDto$Outbound;

/** @internal */
export const User$outboundSchema: z.ZodType<User$Outbound, z.ZodTypeDef, User> = z.lazy(
  () => UserWorkflowPreferencesDto$outboundSchema
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace User$ {
  /** @deprecated use `User$inboundSchema` instead. */
  export const inboundSchema = User$inboundSchema;
  /** @deprecated use `User$outboundSchema` instead. */
  export const outboundSchema = User$outboundSchema;
  /** @deprecated use `User$Outbound` instead. */
  export type Outbound = User$Outbound;
}

export function userToJSON(user: User): string {
  return JSON.stringify(User$outboundSchema.parse(user));
}

export function userFromJSON(jsonString: string): SafeParseResult<User, SDKValidationError> {
  return safeParse(jsonString, (x) => User$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'User' from JSON`);
}

/** @internal */
export const PreferencesRequestDtoAll$inboundSchema: z.ZodType<PreferencesRequestDtoAll, z.ZodTypeDef, unknown> =
  WorkflowPreferenceDto$inboundSchema;

/** @internal */
export type PreferencesRequestDtoAll$Outbound = WorkflowPreferenceDto$Outbound;

/** @internal */
export const PreferencesRequestDtoAll$outboundSchema: z.ZodType<
  PreferencesRequestDtoAll$Outbound,
  z.ZodTypeDef,
  PreferencesRequestDtoAll
> = WorkflowPreferenceDto$outboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreferencesRequestDtoAll$ {
  /** @deprecated use `PreferencesRequestDtoAll$inboundSchema` instead. */
  export const inboundSchema = PreferencesRequestDtoAll$inboundSchema;
  /** @deprecated use `PreferencesRequestDtoAll$outboundSchema` instead. */
  export const outboundSchema = PreferencesRequestDtoAll$outboundSchema;
  /** @deprecated use `PreferencesRequestDtoAll$Outbound` instead. */
  export type Outbound = PreferencesRequestDtoAll$Outbound;
}

export function preferencesRequestDtoAllToJSON(preferencesRequestDtoAll: PreferencesRequestDtoAll): string {
  return JSON.stringify(PreferencesRequestDtoAll$outboundSchema.parse(preferencesRequestDtoAll));
}

export function preferencesRequestDtoAllFromJSON(
  jsonString: string
): SafeParseResult<PreferencesRequestDtoAll, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreferencesRequestDtoAll$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreferencesRequestDtoAll' from JSON`
  );
}

/** @internal */
export const PreferencesRequestDtoWorkflow$inboundSchema: z.ZodType<
  PreferencesRequestDtoWorkflow,
  z.ZodTypeDef,
  unknown
> = z.object({
  all: WorkflowPreferenceDto$inboundSchema,
  channels: z.record(ChannelPreferenceDto$inboundSchema),
});

/** @internal */
export type PreferencesRequestDtoWorkflow$Outbound = {
  all: WorkflowPreferenceDto$Outbound;
  channels: { [k: string]: ChannelPreferenceDto$Outbound };
};

/** @internal */
export const PreferencesRequestDtoWorkflow$outboundSchema: z.ZodType<
  PreferencesRequestDtoWorkflow$Outbound,
  z.ZodTypeDef,
  PreferencesRequestDtoWorkflow
> = z.object({
  all: WorkflowPreferenceDto$outboundSchema,
  channels: z.record(ChannelPreferenceDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreferencesRequestDtoWorkflow$ {
  /** @deprecated use `PreferencesRequestDtoWorkflow$inboundSchema` instead. */
  export const inboundSchema = PreferencesRequestDtoWorkflow$inboundSchema;
  /** @deprecated use `PreferencesRequestDtoWorkflow$outboundSchema` instead. */
  export const outboundSchema = PreferencesRequestDtoWorkflow$outboundSchema;
  /** @deprecated use `PreferencesRequestDtoWorkflow$Outbound` instead. */
  export type Outbound = PreferencesRequestDtoWorkflow$Outbound;
}

export function preferencesRequestDtoWorkflowToJSON(
  preferencesRequestDtoWorkflow: PreferencesRequestDtoWorkflow
): string {
  return JSON.stringify(PreferencesRequestDtoWorkflow$outboundSchema.parse(preferencesRequestDtoWorkflow));
}

export function preferencesRequestDtoWorkflowFromJSON(
  jsonString: string
): SafeParseResult<PreferencesRequestDtoWorkflow, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreferencesRequestDtoWorkflow$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreferencesRequestDtoWorkflow' from JSON`
  );
}

/** @internal */
export const PreferencesRequestDto$inboundSchema: z.ZodType<PreferencesRequestDto, z.ZodTypeDef, unknown> = z.object({
  user: z.nullable(z.lazy(() => UserWorkflowPreferencesDto$inboundSchema)).optional(),
  workflow: z.nullable(z.lazy(() => PreferencesRequestDtoWorkflow$inboundSchema)).optional(),
});

/** @internal */
export type PreferencesRequestDto$Outbound = {
  user?: UserWorkflowPreferencesDto$Outbound | null | undefined;
  workflow?: PreferencesRequestDtoWorkflow$Outbound | null | undefined;
};

/** @internal */
export const PreferencesRequestDto$outboundSchema: z.ZodType<
  PreferencesRequestDto$Outbound,
  z.ZodTypeDef,
  PreferencesRequestDto
> = z.object({
  user: z.nullable(z.lazy(() => UserWorkflowPreferencesDto$outboundSchema)).optional(),
  workflow: z.nullable(z.lazy(() => PreferencesRequestDtoWorkflow$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreferencesRequestDto$ {
  /** @deprecated use `PreferencesRequestDto$inboundSchema` instead. */
  export const inboundSchema = PreferencesRequestDto$inboundSchema;
  /** @deprecated use `PreferencesRequestDto$outboundSchema` instead. */
  export const outboundSchema = PreferencesRequestDto$outboundSchema;
  /** @deprecated use `PreferencesRequestDto$Outbound` instead. */
  export type Outbound = PreferencesRequestDto$Outbound;
}

export function preferencesRequestDtoToJSON(preferencesRequestDto: PreferencesRequestDto): string {
  return JSON.stringify(PreferencesRequestDto$outboundSchema.parse(preferencesRequestDto));
}

export function preferencesRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<PreferencesRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreferencesRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreferencesRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - userAllToJSON(userAll: UserAll)
 - userAllFromJSON(jsonString: string)
 - userWorkflowPreferencesDtoToJSON(userWorkflowPreferencesDto: UserWorkflowPreferencesDto)
 - userWorkflowPreferencesDtoFromJSON(jsonString: string)
 - userToJSON(user: User)
 - userFromJSON(jsonString: string)
 - preferencesRequestDtoAllToJSON(preferencesRequestDtoAll: PreferencesRequestDtoAll)
 - preferencesRequestDtoAllFromJSON(jsonString: string)
 - preferencesRequestDtoWorkflowToJSON(preferencesRequestDtoWorkflow: PreferencesRequestDtoWorkflow)
 - preferencesRequestDtoWorkflowFromJSON(jsonString: string)
 - preferencesRequestDtoToJSON(preferencesRequestDto: PreferencesRequestDto)
 - preferencesRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UserAll$Outbound;
}

export function userAllToJSON(userAll: UserAll): string {
  return JSON.stringi...)
 - Outbound(UserWorkflowPreferencesDto$Outbound;
}

export function userWorkflowPreferencesDtoToJSON(userWorkflo...)
 - Outbound(User$Outbound;
}

export function userToJSON(user: User): string {
  return JSON.stringify(User$outb...)
 - Outbound(PreferencesRequestDtoAll$Outbound;
}

export function preferencesRequestDtoAllToJSON(preferencesRequ...)
 - Outbound(PreferencesRequestDtoWorkflow$Outbound;
}

export function preferencesRequestDtoWorkflowToJSON(
  pr...)
 - Outbound(PreferencesRequestDto$Outbound;
}

export function preferencesRequestDtoToJSON(preferencesRequestDto...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function userAllToJSON
- export function userAllFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function userWorkflowPreferencesDtoToJSON
- export function userWorkflowPreferencesDtoFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function userToJSON
- export function userFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function preferencesRequestDtoAllToJSON
- export function preferencesRequestDtoAllFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function preferencesRequestDtoWorkflowToJSON
- export function preferencesRequestDtoWorkflowFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function preferencesRequestDtoToJSON
- export function preferencesRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/previewpayloaddto.ts
Tamaño: 5688 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  SubscriberResponseDtoOptional,
  SubscriberResponseDtoOptional$inboundSchema,
  SubscriberResponseDtoOptional$Outbound,
  SubscriberResponseDtoOptional$outboundSchema,
} from './subscriberresponsedtooptional.js';

/**
 * Rich context object with id and optional data
 */
export type Two = {
  id: string;
  /**
   * Optional additional context data
   */
  data?: { [k: string]: any } | undefined;
};

export type Context = Two | string;

export type PreviewPayloadDto = {
  /**
   * Partial subscriber information
   */
  subscriber?: SubscriberResponseDtoOptional | undefined;
  /**
   * Payload data
   */
  payload?: { [k: string]: any } | undefined;
  /**
   * Steps data
   */
  steps?: { [k: string]: any } | undefined;
  context?: { [k: string]: Two | string } | undefined;
};

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z.object({
  id: z.string(),
  data: z.record(z.any()).optional(),
});

/** @internal */
export type Two$Outbound = {
  id: string;
  data?: { [k: string]: any } | undefined;
};

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z.object({
  id: z.string(),
  data: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two$ {
  /** @deprecated use `Two$inboundSchema` instead. */
  export const inboundSchema = Two$inboundSchema;
  /** @deprecated use `Two$outboundSchema` instead. */
  export const outboundSchema = Two$outboundSchema;
  /** @deprecated use `Two$Outbound` instead. */
  export type Outbound = Two$Outbound;
}

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}

export function twoFromJSON(jsonString: string): SafeParseResult<Two, SDKValidationError> {
  return safeParse(jsonString, (x) => Two$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Two' from JSON`);
}

/** @internal */
export const Context$inboundSchema: z.ZodType<Context, z.ZodTypeDef, unknown> = z.union([
  z.lazy(() => Two$inboundSchema),
  z.string(),
]);

/** @internal */
export type Context$Outbound = Two$Outbound | string;

/** @internal */
export const Context$outboundSchema: z.ZodType<Context$Outbound, z.ZodTypeDef, Context> = z.union([
  z.lazy(() => Two$outboundSchema),
  z.string(),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Context$ {
  /** @deprecated use `Context$inboundSchema` instead. */
  export const inboundSchema = Context$inboundSchema;
  /** @deprecated use `Context$outboundSchema` instead. */
  export const outboundSchema = Context$outboundSchema;
  /** @deprecated use `Context$Outbound` instead. */
  export type Outbound = Context$Outbound;
}

export function contextToJSON(context: Context): string {
  return JSON.stringify(Context$outboundSchema.parse(context));
}

export function contextFromJSON(jsonString: string): SafeParseResult<Context, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Context$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Context' from JSON`
  );
}

/** @internal */
export const PreviewPayloadDto$inboundSchema: z.ZodType<PreviewPayloadDto, z.ZodTypeDef, unknown> = z.object({
  subscriber: SubscriberResponseDtoOptional$inboundSchema.optional(),
  payload: z.record(z.any()).optional(),
  steps: z.record(z.any()).optional(),
  context: z.record(z.union([z.lazy(() => Two$inboundSchema), z.string()])).optional(),
});

/** @internal */
export type PreviewPayloadDto$Outbound = {
  subscriber?: SubscriberResponseDtoOptional$Outbound | undefined;
  payload?: { [k: string]: any } | undefined;
  steps?: { [k: string]: any } | undefined;
  context?: { [k: string]: Two$Outbound | string } | undefined;
};

/** @internal */
export const PreviewPayloadDto$outboundSchema: z.ZodType<PreviewPayloadDto$Outbound, z.ZodTypeDef, PreviewPayloadDto> =
  z.object({
    subscriber: SubscriberResponseDtoOptional$outboundSchema.optional(),
    payload: z.record(z.any()).optional(),
    steps: z.record(z.any()).optional(),
    context: z.record(z.union([z.lazy(() => Two$outboundSchema), z.string()])).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreviewPayloadDto$ {
  /** @deprecated use `PreviewPayloadDto$inboundSchema` instead. */
  export const inboundSchema = PreviewPayloadDto$inboundSchema;
  /** @deprecated use `PreviewPayloadDto$outboundSchema` instead. */
  export const outboundSchema = PreviewPayloadDto$outboundSchema;
  /** @deprecated use `PreviewPayloadDto$Outbound` instead. */
  export type Outbound = PreviewPayloadDto$Outbound;
}

export function previewPayloadDtoToJSON(previewPayloadDto: PreviewPayloadDto): string {
  return JSON.stringify(PreviewPayloadDto$outboundSchema.parse(previewPayloadDto));
}

export function previewPayloadDtoFromJSON(jsonString: string): SafeParseResult<PreviewPayloadDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewPayloadDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewPayloadDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - twoToJSON(two: Two)
 - twoFromJSON(jsonString: string)
 - contextToJSON(context: Context)
 - contextFromJSON(jsonString: string)
 - previewPayloadDtoToJSON(previewPayloadDto: PreviewPayloadDto)
 - previewPayloadDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Two$Outbound;
}

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundS...)
 - Outbound(Context$Outbound;
}

export function contextToJSON(context: Context): string {
  return JSON.stringi...)
 - Outbound(PreviewPayloadDto$Outbound;
}

export function previewPayloadDtoToJSON(previewPayloadDto: PreviewPay...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function twoToJSON
- export function twoFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextToJSON
- export function contextFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function previewPayloadDtoToJSON
- export function previewPayloadDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/providersidenum.ts
Tamaño: 2921 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Provider ID of the job
 */
export const ProvidersIdEnum = {
  Emailjs: 'emailjs',
  Mailgun: 'mailgun',
  Mailjet: 'mailjet',
  Mandrill: 'mandrill',
  Nodemailer: 'nodemailer',
  Postmark: 'postmark',
  Sendgrid: 'sendgrid',
  Sendinblue: 'sendinblue',
  Ses: 'ses',
  Netcore: 'netcore',
  InfobipEmail: 'infobip-email',
  Resend: 'resend',
  Plunk: 'plunk',
  Mailersend: 'mailersend',
  Mailtrap: 'mailtrap',
  Clickatell: 'clickatell',
  Outlook365: 'outlook365',
  NovuEmail: 'novu-email',
  Sparkpost: 'sparkpost',
  EmailWebhook: 'email-webhook',
  Braze: 'braze',
  Nexmo: 'nexmo',
  Plivo: 'plivo',
  Sms77: 'sms77',
  SmsCentral: 'sms-central',
  Sns: 'sns',
  Telnyx: 'telnyx',
  Twilio: 'twilio',
  Gupshup: 'gupshup',
  Firetext: 'firetext',
  InfobipSms: 'infobip-sms',
  BurstSms: 'burst-sms',
  BulkSms: 'bulk-sms',
  IsendSms: 'isend-sms',
  FortySixElks: 'forty-six-elks',
  Kannel: 'kannel',
  Maqsam: 'maqsam',
  Termii: 'termii',
  AfricasTalking: 'africas-talking',
  NovuSms: 'novu-sms',
  Sendchamp: 'sendchamp',
  GenericSms: 'generic-sms',
  Clicksend: 'clicksend',
  Bandwidth: 'bandwidth',
  Messagebird: 'messagebird',
  Simpletexting: 'simpletexting',
  AzureSms: 'azure-sms',
  RingCentral: 'ring-central',
  BrevoSms: 'brevo-sms',
  EazySms: 'eazy-sms',
  Mobishastra: 'mobishastra',
  AfroMessage: 'afro-message',
  Unifonic: 'unifonic',
  Smsmode: 'smsmode',
  Imedia: 'imedia',
  Sinch: 'sinch',
  Fcm: 'fcm',
  Apns: 'apns',
  Expo: 'expo',
  OneSignal: 'one-signal',
  Pushpad: 'pushpad',
  PushWebhook: 'push-webhook',
  PusherBeams: 'pusher-beams',
  Novu: 'novu',
  Slack: 'slack',
  Discord: 'discord',
  Msteams: 'msteams',
  Mattermost: 'mattermost',
  Ryver: 'ryver',
  Zulip: 'zulip',
  GrafanaOnCall: 'grafana-on-call',
  Getstream: 'getstream',
  RocketChat: 'rocket-chat',
  WhatsappBusiness: 'whatsapp-business',
  ChatWebhook: 'chat-webhook',
  NovuSlack: 'novu-slack',
} as const;
/**
 * Provider ID of the job
 */
export type ProvidersIdEnum = ClosedEnum<typeof ProvidersIdEnum>;

/** @internal */
export const ProvidersIdEnum$inboundSchema: z.ZodNativeEnum<typeof ProvidersIdEnum> = z.nativeEnum(ProvidersIdEnum);

/** @internal */
export const ProvidersIdEnum$outboundSchema: z.ZodNativeEnum<typeof ProvidersIdEnum> = ProvidersIdEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ProvidersIdEnum$ {
  /** @deprecated use `ProvidersIdEnum$inboundSchema` instead. */
  export const inboundSchema = ProvidersIdEnum$inboundSchema;
  /** @deprecated use `ProvidersIdEnum$outboundSchema` instead. */
  export const outboundSchema = ProvidersIdEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/pushcontroldto.ts
Tamaño: 2403 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type PushControlDto = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * Subject/title of the push notification.
   */
  subject?: string | undefined;
  /**
   * Body content of the push notification.
   */
  body?: string | undefined;
};

/** @internal */
export const PushControlDto$inboundSchema: z.ZodType<PushControlDto, z.ZodTypeDef, unknown> = z.object({
  skip: z.record(z.any()).optional(),
  subject: z.string().optional(),
  body: z.string().optional(),
});

/** @internal */
export type PushControlDto$Outbound = {
  skip?: { [k: string]: any } | undefined;
  subject?: string | undefined;
  body?: string | undefined;
};

/** @internal */
export const PushControlDto$outboundSchema: z.ZodType<PushControlDto$Outbound, z.ZodTypeDef, PushControlDto> = z.object(
  {
    skip: z.record(z.any()).optional(),
    subject: z.string().optional(),
    body: z.string().optional(),
  }
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PushControlDto$ {
  /** @deprecated use `PushControlDto$inboundSchema` instead. */
  export const inboundSchema = PushControlDto$inboundSchema;
  /** @deprecated use `PushControlDto$outboundSchema` instead. */
  export const outboundSchema = PushControlDto$outboundSchema;
  /** @deprecated use `PushControlDto$Outbound` instead. */
  export type Outbound = PushControlDto$Outbound;
}

export function pushControlDtoToJSON(pushControlDto: PushControlDto): string {
  return JSON.stringify(PushControlDto$outboundSchema.parse(pushControlDto));
}

export function pushControlDtoFromJSON(jsonString: string): SafeParseResult<PushControlDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PushControlDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PushControlDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - pushControlDtoToJSON(pushControlDto: PushControlDto)
 - pushControlDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PushControlDto$Outbound;
}

export function pushControlDtoToJSON(pushControlDto: PushControlDto): st...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function pushControlDtoToJSON
- export function pushControlDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/pushcontrolsmetadataresponsedto.ts
Tamaño: 2946 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  PushControlDto,
  PushControlDto$inboundSchema,
  PushControlDto$Outbound,
  PushControlDto$outboundSchema,
} from './pushcontroldto.js';
import { UiSchema, UiSchema$inboundSchema, UiSchema$Outbound, UiSchema$outboundSchema } from './uischema.js';

export type PushControlsMetadataResponseDto = {
  /**
   * JSON Schema for data
   */
  dataSchema?: { [k: string]: any } | undefined;
  /**
   * UI Schema for rendering
   */
  uiSchema?: UiSchema | undefined;
  /**
   * Control values specific to Push
   */
  values: PushControlDto;
};

/** @internal */
export const PushControlsMetadataResponseDto$inboundSchema: z.ZodType<
  PushControlsMetadataResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$inboundSchema.optional(),
  values: PushControlDto$inboundSchema,
});

/** @internal */
export type PushControlsMetadataResponseDto$Outbound = {
  dataSchema?: { [k: string]: any } | undefined;
  uiSchema?: UiSchema$Outbound | undefined;
  values: PushControlDto$Outbound;
};

/** @internal */
export const PushControlsMetadataResponseDto$outboundSchema: z.ZodType<
  PushControlsMetadataResponseDto$Outbound,
  z.ZodTypeDef,
  PushControlsMetadataResponseDto
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$outboundSchema.optional(),
  values: PushControlDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PushControlsMetadataResponseDto$ {
  /** @deprecated use `PushControlsMetadataResponseDto$inboundSchema` instead. */
  export const inboundSchema = PushControlsMetadataResponseDto$inboundSchema;
  /** @deprecated use `PushControlsMetadataResponseDto$outboundSchema` instead. */
  export const outboundSchema = PushControlsMetadataResponseDto$outboundSchema;
  /** @deprecated use `PushControlsMetadataResponseDto$Outbound` instead. */
  export type Outbound = PushControlsMetadataResponseDto$Outbound;
}

export function pushControlsMetadataResponseDtoToJSON(
  pushControlsMetadataResponseDto: PushControlsMetadataResponseDto
): string {
  return JSON.stringify(PushControlsMetadataResponseDto$outboundSchema.parse(pushControlsMetadataResponseDto));
}

export function pushControlsMetadataResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<PushControlsMetadataResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PushControlsMetadataResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PushControlsMetadataResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - pushControlsMetadataResponseDtoToJSON(pushControlsMetadataResponseDto: PushControlsMetadataResponseDto)
 - pushControlsMetadataResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PushControlsMetadataResponseDto$Outbound;
}

export function pushControlsMetadataResponseDtoToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function pushControlsMetadataResponseDtoToJSON
- export function pushControlsMetadataResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/pushrenderoutput.ts
Tamaño: 1949 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type PushRenderOutput = {
  /**
   * Subject of the push notification
   */
  subject: string;
  /**
   * Body of the push notification
   */
  body: string;
};

/** @internal */
export const PushRenderOutput$inboundSchema: z.ZodType<PushRenderOutput, z.ZodTypeDef, unknown> = z.object({
  subject: z.string(),
  body: z.string(),
});

/** @internal */
export type PushRenderOutput$Outbound = {
  subject: string;
  body: string;
};

/** @internal */
export const PushRenderOutput$outboundSchema: z.ZodType<PushRenderOutput$Outbound, z.ZodTypeDef, PushRenderOutput> =
  z.object({
    subject: z.string(),
    body: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PushRenderOutput$ {
  /** @deprecated use `PushRenderOutput$inboundSchema` instead. */
  export const inboundSchema = PushRenderOutput$inboundSchema;
  /** @deprecated use `PushRenderOutput$outboundSchema` instead. */
  export const outboundSchema = PushRenderOutput$outboundSchema;
  /** @deprecated use `PushRenderOutput$Outbound` instead. */
  export type Outbound = PushRenderOutput$Outbound;
}

export function pushRenderOutputToJSON(pushRenderOutput: PushRenderOutput): string {
  return JSON.stringify(PushRenderOutput$outboundSchema.parse(pushRenderOutput));
}

export function pushRenderOutputFromJSON(jsonString: string): SafeParseResult<PushRenderOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PushRenderOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PushRenderOutput' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - pushRenderOutputToJSON(pushRenderOutput: PushRenderOutput)
 - pushRenderOutputFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PushRenderOutput$Outbound;
}

export function pushRenderOutputToJSON(pushRenderOutput: PushRenderOut...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function pushRenderOutputToJSON
- export function pushRenderOutputFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/pushstepresponsedto.ts
Tamaño: 7865 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { collectExtraKeys as collectExtraKeys$, safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  PushControlsMetadataResponseDto,
  PushControlsMetadataResponseDto$inboundSchema,
  PushControlsMetadataResponseDto$Outbound,
  PushControlsMetadataResponseDto$outboundSchema,
} from './pushcontrolsmetadataresponsedto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  StepIssuesDto,
  StepIssuesDto$inboundSchema,
  StepIssuesDto$Outbound,
  StepIssuesDto$outboundSchema,
} from './stepissuesdto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the push step
 */
export type PushStepResponseDtoControlValues = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * Subject/title of the push notification.
   */
  subject?: string | undefined;
  /**
   * Body content of the push notification.
   */
  body?: string | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type PushStepResponseDto = {
  /**
   * Controls metadata for the push step
   */
  controls: PushControlsMetadataResponseDto;
  /**
   * Control values for the push step
   */
  controlValues?: PushStepResponseDtoControlValues | undefined;
  /**
   * JSON Schema for variables, follows the JSON Schema standard
   */
  variables: { [k: string]: any };
  /**
   * Unique identifier of the step
   */
  stepId: string;
  /**
   * Database identifier of the step
   */
  id: string;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Slug of the step
   */
  slug: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow database identifier
   */
  workflowDatabaseId: string;
  /**
   * Issues associated with the step
   */
  issues?: StepIssuesDto | undefined;
};

/** @internal */
export const PushStepResponseDtoControlValues$inboundSchema: z.ZodType<
  PushStepResponseDtoControlValues,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z
    .object({
      skip: z.record(z.any()).optional(),
      subject: z.string().optional(),
      body: z.string().optional(),
    })
    .catchall(z.any()),
  'additionalProperties',
  true
);

/** @internal */
export type PushStepResponseDtoControlValues$Outbound = {
  skip?: { [k: string]: any } | undefined;
  subject?: string | undefined;
  body?: string | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const PushStepResponseDtoControlValues$outboundSchema: z.ZodType<
  PushStepResponseDtoControlValues$Outbound,
  z.ZodTypeDef,
  PushStepResponseDtoControlValues
> = z
  .object({
    skip: z.record(z.any()).optional(),
    subject: z.string().optional(),
    body: z.string().optional(),
    additionalProperties: z.record(z.any()).optional(),
  })
  .transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PushStepResponseDtoControlValues$ {
  /** @deprecated use `PushStepResponseDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = PushStepResponseDtoControlValues$inboundSchema;
  /** @deprecated use `PushStepResponseDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = PushStepResponseDtoControlValues$outboundSchema;
  /** @deprecated use `PushStepResponseDtoControlValues$Outbound` instead. */
  export type Outbound = PushStepResponseDtoControlValues$Outbound;
}

export function pushStepResponseDtoControlValuesToJSON(
  pushStepResponseDtoControlValues: PushStepResponseDtoControlValues
): string {
  return JSON.stringify(PushStepResponseDtoControlValues$outboundSchema.parse(pushStepResponseDtoControlValues));
}

export function pushStepResponseDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<PushStepResponseDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PushStepResponseDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PushStepResponseDtoControlValues' from JSON`
  );
}

/** @internal */
export const PushStepResponseDto$inboundSchema: z.ZodType<PushStepResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    controls: PushControlsMetadataResponseDto$inboundSchema,
    controlValues: z.lazy(() => PushStepResponseDtoControlValues$inboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    _id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$inboundSchema,
    origin: ResourceOriginEnum$inboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type PushStepResponseDto$Outbound = {
  controls: PushControlsMetadataResponseDto$Outbound;
  controlValues?: PushStepResponseDtoControlValues$Outbound | undefined;
  variables: { [k: string]: any };
  stepId: string;
  _id: string;
  name: string;
  slug: string;
  type: string;
  origin: string;
  workflowId: string;
  workflowDatabaseId: string;
  issues?: StepIssuesDto$Outbound | undefined;
};

/** @internal */
export const PushStepResponseDto$outboundSchema: z.ZodType<
  PushStepResponseDto$Outbound,
  z.ZodTypeDef,
  PushStepResponseDto
> = z
  .object({
    controls: PushControlsMetadataResponseDto$outboundSchema,
    controlValues: z.lazy(() => PushStepResponseDtoControlValues$outboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$outboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PushStepResponseDto$ {
  /** @deprecated use `PushStepResponseDto$inboundSchema` instead. */
  export const inboundSchema = PushStepResponseDto$inboundSchema;
  /** @deprecated use `PushStepResponseDto$outboundSchema` instead. */
  export const outboundSchema = PushStepResponseDto$outboundSchema;
  /** @deprecated use `PushStepResponseDto$Outbound` instead. */
  export type Outbound = PushStepResponseDto$Outbound;
}

export function pushStepResponseDtoToJSON(pushStepResponseDto: PushStepResponseDto): string {
  return JSON.stringify(PushStepResponseDto$outboundSchema.parse(pushStepResponseDto));
}

export function pushStepResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<PushStepResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PushStepResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PushStepResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - pushStepResponseDtoControlValuesToJSON(pushStepResponseDtoControlValues: PushStepResponseDtoControlValues)
 - pushStepResponseDtoControlValuesFromJSON(jsonString: string)
 - pushStepResponseDtoToJSON(pushStepResponseDto: PushStepResponseDto)
 - pushStepResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PushStepResponseDtoControlValues$Outbound;
}

export function pushStepResponseDtoControlValuesToJSON...)
 - Outbound(PushStepResponseDto$Outbound;
}

export function pushStepResponseDtoToJSON(pushStepResponseDto: Push...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function pushStepResponseDtoControlValuesToJSON
- export function pushStepResponseDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function pushStepResponseDtoToJSON
- export function pushStepResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/pushstepupsertdto.ts
Tamaño: 5201 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  PushControlDto,
  PushControlDto$inboundSchema,
  PushControlDto$Outbound,
  PushControlDto$outboundSchema,
} from './pushcontroldto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the Push step.
 */
export type PushStepUpsertDtoControlValues =
  | PushControlDto
  | {
      [k: string]: any;
    };

export type PushStepUpsertDto = {
  /**
   * Database identifier of the step. Used for updating the step.
   */
  id?: string | undefined;
  /**
   * Unique identifier for the step
   */
  stepId?: string | undefined;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Control values for the Push step.
   */
  controlValues?: PushControlDto | { [k: string]: any } | undefined;
};

/** @internal */
export const PushStepUpsertDtoControlValues$inboundSchema: z.ZodType<
  PushStepUpsertDtoControlValues,
  z.ZodTypeDef,
  unknown
> = z.union([PushControlDto$inboundSchema, z.record(z.any())]);

/** @internal */
export type PushStepUpsertDtoControlValues$Outbound = PushControlDto$Outbound | { [k: string]: any };

/** @internal */
export const PushStepUpsertDtoControlValues$outboundSchema: z.ZodType<
  PushStepUpsertDtoControlValues$Outbound,
  z.ZodTypeDef,
  PushStepUpsertDtoControlValues
> = z.union([PushControlDto$outboundSchema, z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PushStepUpsertDtoControlValues$ {
  /** @deprecated use `PushStepUpsertDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = PushStepUpsertDtoControlValues$inboundSchema;
  /** @deprecated use `PushStepUpsertDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = PushStepUpsertDtoControlValues$outboundSchema;
  /** @deprecated use `PushStepUpsertDtoControlValues$Outbound` instead. */
  export type Outbound = PushStepUpsertDtoControlValues$Outbound;
}

export function pushStepUpsertDtoControlValuesToJSON(
  pushStepUpsertDtoControlValues: PushStepUpsertDtoControlValues
): string {
  return JSON.stringify(PushStepUpsertDtoControlValues$outboundSchema.parse(pushStepUpsertDtoControlValues));
}

export function pushStepUpsertDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<PushStepUpsertDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PushStepUpsertDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PushStepUpsertDtoControlValues' from JSON`
  );
}

/** @internal */
export const PushStepUpsertDto$inboundSchema: z.ZodType<PushStepUpsertDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$inboundSchema,
    controlValues: z.union([PushControlDto$inboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type PushStepUpsertDto$Outbound = {
  _id?: string | undefined;
  stepId?: string | undefined;
  name: string;
  type: string;
  controlValues?: PushControlDto$Outbound | { [k: string]: any } | undefined;
};

/** @internal */
export const PushStepUpsertDto$outboundSchema: z.ZodType<PushStepUpsertDto$Outbound, z.ZodTypeDef, PushStepUpsertDto> =
  z
    .object({
      id: z.string().optional(),
      stepId: z.string().optional(),
      name: z.string(),
      type: StepTypeEnum$outboundSchema,
      controlValues: z.union([PushControlDto$outboundSchema, z.record(z.any())]).optional(),
    })
    .transform((v) => {
      return remap$(v, {
        id: '_id',
      });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PushStepUpsertDto$ {
  /** @deprecated use `PushStepUpsertDto$inboundSchema` instead. */
  export const inboundSchema = PushStepUpsertDto$inboundSchema;
  /** @deprecated use `PushStepUpsertDto$outboundSchema` instead. */
  export const outboundSchema = PushStepUpsertDto$outboundSchema;
  /** @deprecated use `PushStepUpsertDto$Outbound` instead. */
  export type Outbound = PushStepUpsertDto$Outbound;
}

export function pushStepUpsertDtoToJSON(pushStepUpsertDto: PushStepUpsertDto): string {
  return JSON.stringify(PushStepUpsertDto$outboundSchema.parse(pushStepUpsertDto));
}

export function pushStepUpsertDtoFromJSON(jsonString: string): SafeParseResult<PushStepUpsertDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PushStepUpsertDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PushStepUpsertDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - pushStepUpsertDtoControlValuesToJSON(pushStepUpsertDtoControlValues: PushStepUpsertDtoControlValues)
 - pushStepUpsertDtoControlValuesFromJSON(jsonString: string)
 - pushStepUpsertDtoToJSON(pushStepUpsertDto: PushStepUpsertDto)
 - pushStepUpsertDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PushStepUpsertDtoControlValues$Outbound;
}

export function pushStepUpsertDtoControlValuesToJSON(
  ...)
 - Outbound(PushStepUpsertDto$Outbound;
}

export function pushStepUpsertDtoToJSON(pushStepUpsertDto: PushStepUp...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function pushStepUpsertDtoControlValuesToJSON
- export function pushStepUpsertDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function pushStepUpsertDtoToJSON
- export function pushStepUpsertDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/redirectdto.ts
Tamaño: 2943 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Target window for the redirection.
 */
export const Target = {
  Self: '_self',
  Blank: '_blank',
  Parent: '_parent',
  Top: '_top',
  UnfencedTop: '_unfencedTop',
} as const;
/**
 * Target window for the redirection.
 */
export type Target = ClosedEnum<typeof Target>;

export type RedirectDto = {
  /**
   * URL for redirection. Must be a valid URL or start with / or {{"{{"}} variable }}.
   */
  url?: string | undefined;
  /**
   * Target window for the redirection.
   */
  target?: Target | undefined;
};

/** @internal */
export const Target$inboundSchema: z.ZodNativeEnum<typeof Target> = z.nativeEnum(Target);

/** @internal */
export const Target$outboundSchema: z.ZodNativeEnum<typeof Target> = Target$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Target$ {
  /** @deprecated use `Target$inboundSchema` instead. */
  export const inboundSchema = Target$inboundSchema;
  /** @deprecated use `Target$outboundSchema` instead. */
  export const outboundSchema = Target$outboundSchema;
}

/** @internal */
export const RedirectDto$inboundSchema: z.ZodType<RedirectDto, z.ZodTypeDef, unknown> = z.object({
  url: z.string().optional(),
  target: Target$inboundSchema.default('_self'),
});

/** @internal */
export type RedirectDto$Outbound = {
  url?: string | undefined;
  target: string;
};

/** @internal */
export const RedirectDto$outboundSchema: z.ZodType<RedirectDto$Outbound, z.ZodTypeDef, RedirectDto> = z.object({
  url: z.string().optional(),
  target: Target$outboundSchema.default('_self'),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RedirectDto$ {
  /** @deprecated use `RedirectDto$inboundSchema` instead. */
  export const inboundSchema = RedirectDto$inboundSchema;
  /** @deprecated use `RedirectDto$outboundSchema` instead. */
  export const outboundSchema = RedirectDto$outboundSchema;
  /** @deprecated use `RedirectDto$Outbound` instead. */
  export type Outbound = RedirectDto$Outbound;
}

export function redirectDtoToJSON(redirectDto: RedirectDto): string {
  return JSON.stringify(RedirectDto$outboundSchema.parse(redirectDto));
}

export function redirectDtoFromJSON(jsonString: string): SafeParseResult<RedirectDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedirectDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedirectDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - redirectDtoToJSON(redirectDto: RedirectDto)
 - redirectDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(RedirectDto$Outbound;
}

export function redirectDtoToJSON(redirectDto: RedirectDto): string {
  ret...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function redirectDtoToJSON
- export function redirectDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/removesubscriberresponsedto.ts
Tamaño: 2289 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type RemoveSubscriberResponseDto = {
  /**
   * Indicates whether the operation was acknowledged by the server
   */
  acknowledged: boolean;
  /**
   * Status of the subscriber removal operation
   */
  status: string;
};

/** @internal */
export const RemoveSubscriberResponseDto$inboundSchema: z.ZodType<RemoveSubscriberResponseDto, z.ZodTypeDef, unknown> =
  z.object({
    acknowledged: z.boolean(),
    status: z.string(),
  });

/** @internal */
export type RemoveSubscriberResponseDto$Outbound = {
  acknowledged: boolean;
  status: string;
};

/** @internal */
export const RemoveSubscriberResponseDto$outboundSchema: z.ZodType<
  RemoveSubscriberResponseDto$Outbound,
  z.ZodTypeDef,
  RemoveSubscriberResponseDto
> = z.object({
  acknowledged: z.boolean(),
  status: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RemoveSubscriberResponseDto$ {
  /** @deprecated use `RemoveSubscriberResponseDto$inboundSchema` instead. */
  export const inboundSchema = RemoveSubscriberResponseDto$inboundSchema;
  /** @deprecated use `RemoveSubscriberResponseDto$outboundSchema` instead. */
  export const outboundSchema = RemoveSubscriberResponseDto$outboundSchema;
  /** @deprecated use `RemoveSubscriberResponseDto$Outbound` instead. */
  export type Outbound = RemoveSubscriberResponseDto$Outbound;
}

export function removeSubscriberResponseDtoToJSON(removeSubscriberResponseDto: RemoveSubscriberResponseDto): string {
  return JSON.stringify(RemoveSubscriberResponseDto$outboundSchema.parse(removeSubscriberResponseDto));
}

export function removeSubscriberResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<RemoveSubscriberResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RemoveSubscriberResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RemoveSubscriberResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - removeSubscriberResponseDtoToJSON(removeSubscriberResponseDto: RemoveSubscriberResponseDto)
 - removeSubscriberResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(RemoveSubscriberResponseDto$Outbound;
}

export function removeSubscriberResponseDtoToJSON(removeSub...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function removeSubscriberResponseDtoToJSON
- export function removeSubscriberResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/replycallback.ts
Tamaño: 1990 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ReplyCallback = {
  /**
   * Indicates whether the reply callback is active.
   */
  active?: boolean | undefined;
  /**
   * The URL to which replies should be sent.
   */
  url?: string | undefined;
};

/** @internal */
export const ReplyCallback$inboundSchema: z.ZodType<ReplyCallback, z.ZodTypeDef, unknown> = z.object({
  active: z.boolean().optional(),
  url: z.string().optional(),
});

/** @internal */
export type ReplyCallback$Outbound = {
  active?: boolean | undefined;
  url?: string | undefined;
};

/** @internal */
export const ReplyCallback$outboundSchema: z.ZodType<ReplyCallback$Outbound, z.ZodTypeDef, ReplyCallback> = z.object({
  active: z.boolean().optional(),
  url: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReplyCallback$ {
  /** @deprecated use `ReplyCallback$inboundSchema` instead. */
  export const inboundSchema = ReplyCallback$inboundSchema;
  /** @deprecated use `ReplyCallback$outboundSchema` instead. */
  export const outboundSchema = ReplyCallback$outboundSchema;
  /** @deprecated use `ReplyCallback$Outbound` instead. */
  export type Outbound = ReplyCallback$Outbound;
}

export function replyCallbackToJSON(replyCallback: ReplyCallback): string {
  return JSON.stringify(ReplyCallback$outboundSchema.parse(replyCallback));
}

export function replyCallbackFromJSON(jsonString: string): SafeParseResult<ReplyCallback, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReplyCallback$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReplyCallback' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - replyCallbackToJSON(replyCallback: ReplyCallback)
 - replyCallbackFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ReplyCallback$Outbound;
}

export function replyCallbackToJSON(replyCallback: ReplyCallback): string...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function replyCallbackToJSON
- export function replyCallbackFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/requestlogresponsedto.ts
Tamaño: 5592 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Transaction identifier
 */
export type TransactionId = {};

export type RequestLogResponseDto = {
  /**
   * Request log identifier
   */
  id: string;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * Request URL
   */
  url: string;
  /**
   * URL pattern
   */
  urlPattern: string;
  /**
   * HTTP method
   */
  method: string;
  /**
   * HTTP status code
   */
  statusCode: number;
  /**
   * Request path
   */
  path: string;
  /**
   * Request hostname
   */
  hostname: string;
  /**
   * Transaction identifier
   */
  transactionId?: TransactionId | null | undefined;
  /**
   * Client IP address
   */
  ip: string;
  /**
   * User agent string
   */
  userAgent: string;
  /**
   * Request body
   */
  requestBody: string;
  /**
   * Response body
   */
  responseBody: string;
  /**
   * User identifier
   */
  userId: string;
  /**
   * Organization identifier
   */
  organizationId: string;
  /**
   * Environment identifier
   */
  environmentId: string;
  /**
   * Authentication type
   */
  authType: string;
  /**
   * Request duration in milliseconds
   */
  durationMs: number;
};

/** @internal */
export const TransactionId$inboundSchema: z.ZodType<TransactionId, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type TransactionId$Outbound = {};

/** @internal */
export const TransactionId$outboundSchema: z.ZodType<TransactionId$Outbound, z.ZodTypeDef, TransactionId> = z.object(
  {}
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionId$ {
  /** @deprecated use `TransactionId$inboundSchema` instead. */
  export const inboundSchema = TransactionId$inboundSchema;
  /** @deprecated use `TransactionId$outboundSchema` instead. */
  export const outboundSchema = TransactionId$outboundSchema;
  /** @deprecated use `TransactionId$Outbound` instead. */
  export type Outbound = TransactionId$Outbound;
}

export function transactionIdToJSON(transactionId: TransactionId): string {
  return JSON.stringify(TransactionId$outboundSchema.parse(transactionId));
}

export function transactionIdFromJSON(jsonString: string): SafeParseResult<TransactionId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransactionId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransactionId' from JSON`
  );
}

/** @internal */
export const RequestLogResponseDto$inboundSchema: z.ZodType<RequestLogResponseDto, z.ZodTypeDef, unknown> = z.object({
  id: z.string(),
  createdAt: z.string(),
  url: z.string(),
  urlPattern: z.string(),
  method: z.string(),
  statusCode: z.number(),
  path: z.string(),
  hostname: z.string(),
  transactionId: z.nullable(z.lazy(() => TransactionId$inboundSchema)).optional(),
  ip: z.string(),
  userAgent: z.string(),
  requestBody: z.string(),
  responseBody: z.string(),
  userId: z.string(),
  organizationId: z.string(),
  environmentId: z.string(),
  authType: z.string(),
  durationMs: z.number(),
});

/** @internal */
export type RequestLogResponseDto$Outbound = {
  id: string;
  createdAt: string;
  url: string;
  urlPattern: string;
  method: string;
  statusCode: number;
  path: string;
  hostname: string;
  transactionId?: TransactionId$Outbound | null | undefined;
  ip: string;
  userAgent: string;
  requestBody: string;
  responseBody: string;
  userId: string;
  organizationId: string;
  environmentId: string;
  authType: string;
  durationMs: number;
};

/** @internal */
export const RequestLogResponseDto$outboundSchema: z.ZodType<
  RequestLogResponseDto$Outbound,
  z.ZodTypeDef,
  RequestLogResponseDto
> = z.object({
  id: z.string(),
  createdAt: z.string(),
  url: z.string(),
  urlPattern: z.string(),
  method: z.string(),
  statusCode: z.number(),
  path: z.string(),
  hostname: z.string(),
  transactionId: z.nullable(z.lazy(() => TransactionId$outboundSchema)).optional(),
  ip: z.string(),
  userAgent: z.string(),
  requestBody: z.string(),
  responseBody: z.string(),
  userId: z.string(),
  organizationId: z.string(),
  environmentId: z.string(),
  authType: z.string(),
  durationMs: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestLogResponseDto$ {
  /** @deprecated use `RequestLogResponseDto$inboundSchema` instead. */
  export const inboundSchema = RequestLogResponseDto$inboundSchema;
  /** @deprecated use `RequestLogResponseDto$outboundSchema` instead. */
  export const outboundSchema = RequestLogResponseDto$outboundSchema;
  /** @deprecated use `RequestLogResponseDto$Outbound` instead. */
  export type Outbound = RequestLogResponseDto$Outbound;
}

export function requestLogResponseDtoToJSON(requestLogResponseDto: RequestLogResponseDto): string {
  return JSON.stringify(RequestLogResponseDto$outboundSchema.parse(requestLogResponseDto));
}

export function requestLogResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<RequestLogResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestLogResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestLogResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - transactionIdToJSON(transactionId: TransactionId)
 - transactionIdFromJSON(jsonString: string)
 - requestLogResponseDtoToJSON(requestLogResponseDto: RequestLogResponseDto)
 - requestLogResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TransactionId$Outbound;
}

export function transactionIdToJSON(transactionId: TransactionId): string...)
 - Outbound(RequestLogResponseDto$Outbound;
}

export function requestLogResponseDtoToJSON(requestLogResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function transactionIdToJSON
- export function transactionIdFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function requestLogResponseDtoToJSON
- export function requestLogResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/resourceoriginenum.ts
Tamaño: 1185 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Origin of the layout
 */
export const ResourceOriginEnum = {
  NovuCloud: 'novu-cloud',
  NovuCloudV1: 'novu-cloud-v1',
  External: 'external',
} as const;
/**
 * Origin of the layout
 */
export type ResourceOriginEnum = ClosedEnum<typeof ResourceOriginEnum>;

/** @internal */
export const ResourceOriginEnum$inboundSchema: z.ZodNativeEnum<typeof ResourceOriginEnum> =
  z.nativeEnum(ResourceOriginEnum);

/** @internal */
export const ResourceOriginEnum$outboundSchema: z.ZodNativeEnum<typeof ResourceOriginEnum> =
  ResourceOriginEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResourceOriginEnum$ {
  /** @deprecated use `ResourceOriginEnum$inboundSchema` instead. */
  export const inboundSchema = ResourceOriginEnum$inboundSchema;
  /** @deprecated use `ResourceOriginEnum$outboundSchema` instead. */
  export const outboundSchema = ResourceOriginEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/resourcetypeenum.ts
Tamaño: 1124 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Type of the layout
 */
export const ResourceTypeEnum = {
  Regular: 'REGULAR',
  Echo: 'ECHO',
  Bridge: 'BRIDGE',
} as const;
/**
 * Type of the layout
 */
export type ResourceTypeEnum = ClosedEnum<typeof ResourceTypeEnum>;

/** @internal */
export const ResourceTypeEnum$inboundSchema: z.ZodNativeEnum<typeof ResourceTypeEnum> = z.nativeEnum(ResourceTypeEnum);

/** @internal */
export const ResourceTypeEnum$outboundSchema: z.ZodNativeEnum<typeof ResourceTypeEnum> = ResourceTypeEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResourceTypeEnum$ {
  /** @deprecated use `ResourceTypeEnum$inboundSchema` instead. */
  export const inboundSchema = ResourceTypeEnum$inboundSchema;
  /** @deprecated use `ResourceTypeEnum$outboundSchema` instead. */
  export const outboundSchema = ResourceTypeEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/runtimeissuedto.ts
Tamaño: 3041 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export const IssueType = {
  MissingValue: 'MISSING_VALUE',
  MaxLengthAccessed: 'MAX_LENGTH_ACCESSED',
  WorkflowIdAlreadyExists: 'WORKFLOW_ID_ALREADY_EXISTS',
  DuplicatedValue: 'DUPLICATED_VALUE',
  LimitReached: 'LIMIT_REACHED',
} as const;
export type IssueType = ClosedEnum<typeof IssueType>;

export type RuntimeIssueDto = {
  issueType: IssueType;
  variableName?: string | undefined;
  message: string;
};

/** @internal */
export const IssueType$inboundSchema: z.ZodNativeEnum<typeof IssueType> = z.nativeEnum(IssueType);

/** @internal */
export const IssueType$outboundSchema: z.ZodNativeEnum<typeof IssueType> = IssueType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IssueType$ {
  /** @deprecated use `IssueType$inboundSchema` instead. */
  export const inboundSchema = IssueType$inboundSchema;
  /** @deprecated use `IssueType$outboundSchema` instead. */
  export const outboundSchema = IssueType$outboundSchema;
}

/** @internal */
export const RuntimeIssueDto$inboundSchema: z.ZodType<RuntimeIssueDto, z.ZodTypeDef, unknown> = z.object({
  issueType: IssueType$inboundSchema,
  variableName: z.string().optional(),
  message: z.string(),
});

/** @internal */
export type RuntimeIssueDto$Outbound = {
  issueType: string;
  variableName?: string | undefined;
  message: string;
};

/** @internal */
export const RuntimeIssueDto$outboundSchema: z.ZodType<RuntimeIssueDto$Outbound, z.ZodTypeDef, RuntimeIssueDto> =
  z.object({
    issueType: IssueType$outboundSchema,
    variableName: z.string().optional(),
    message: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RuntimeIssueDto$ {
  /** @deprecated use `RuntimeIssueDto$inboundSchema` instead. */
  export const inboundSchema = RuntimeIssueDto$inboundSchema;
  /** @deprecated use `RuntimeIssueDto$outboundSchema` instead. */
  export const outboundSchema = RuntimeIssueDto$outboundSchema;
  /** @deprecated use `RuntimeIssueDto$Outbound` instead. */
  export type Outbound = RuntimeIssueDto$Outbound;
}

export function runtimeIssueDtoToJSON(runtimeIssueDto: RuntimeIssueDto): string {
  return JSON.stringify(RuntimeIssueDto$outboundSchema.parse(runtimeIssueDto));
}

export function runtimeIssueDtoFromJSON(jsonString: string): SafeParseResult<RuntimeIssueDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RuntimeIssueDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RuntimeIssueDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - runtimeIssueDtoToJSON(runtimeIssueDto: RuntimeIssueDto)
 - runtimeIssueDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(RuntimeIssueDto$Outbound;
}

export function runtimeIssueDtoToJSON(runtimeIssueDto: RuntimeIssueDto)...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function runtimeIssueDtoToJSON
- export function runtimeIssueDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/scheduledto.ts
Tamaño: 16215 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  TimeRangeDto,
  TimeRangeDto$inboundSchema,
  TimeRangeDto$Outbound,
  TimeRangeDto$outboundSchema,
} from './timerangedto.js';

/**
 * Monday schedule
 */
export type Monday = {
  /**
   * Day schedule enabled
   */
  isEnabled: boolean;
  /**
   * Hours
   */
  hours?: Array<TimeRangeDto> | undefined;
};

/**
 * Tuesday schedule
 */
export type Tuesday = {
  /**
   * Day schedule enabled
   */
  isEnabled: boolean;
  /**
   * Hours
   */
  hours?: Array<TimeRangeDto> | undefined;
};

/**
 * Wednesday schedule
 */
export type Wednesday = {
  /**
   * Day schedule enabled
   */
  isEnabled: boolean;
  /**
   * Hours
   */
  hours?: Array<TimeRangeDto> | undefined;
};

/**
 * Thursday schedule
 */
export type Thursday = {
  /**
   * Day schedule enabled
   */
  isEnabled: boolean;
  /**
   * Hours
   */
  hours?: Array<TimeRangeDto> | undefined;
};

/**
 * Friday schedule
 */
export type Friday = {
  /**
   * Day schedule enabled
   */
  isEnabled: boolean;
  /**
   * Hours
   */
  hours?: Array<TimeRangeDto> | undefined;
};

/**
 * Saturday schedule
 */
export type Saturday = {
  /**
   * Day schedule enabled
   */
  isEnabled: boolean;
  /**
   * Hours
   */
  hours?: Array<TimeRangeDto> | undefined;
};

/**
 * Sunday schedule
 */
export type Sunday = {
  /**
   * Day schedule enabled
   */
  isEnabled: boolean;
  /**
   * Hours
   */
  hours?: Array<TimeRangeDto> | undefined;
};

/**
 * Weekly schedule
 */
export type WeeklySchedule = {
  /**
   * Monday schedule
   */
  monday?: Monday | undefined;
  /**
   * Tuesday schedule
   */
  tuesday?: Tuesday | undefined;
  /**
   * Wednesday schedule
   */
  wednesday?: Wednesday | undefined;
  /**
   * Thursday schedule
   */
  thursday?: Thursday | undefined;
  /**
   * Friday schedule
   */
  friday?: Friday | undefined;
  /**
   * Saturday schedule
   */
  saturday?: Saturday | undefined;
  /**
   * Sunday schedule
   */
  sunday?: Sunday | undefined;
};

export type ScheduleDto = {
  /**
   * Schedule enabled
   */
  isEnabled: boolean;
  /**
   * Weekly schedule
   */
  weeklySchedule?: WeeklySchedule | undefined;
};

/** @internal */
export const Monday$inboundSchema: z.ZodType<Monday, z.ZodTypeDef, unknown> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$inboundSchema).optional(),
});

/** @internal */
export type Monday$Outbound = {
  isEnabled: boolean;
  hours?: Array<TimeRangeDto$Outbound> | undefined;
};

/** @internal */
export const Monday$outboundSchema: z.ZodType<Monday$Outbound, z.ZodTypeDef, Monday> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Monday$ {
  /** @deprecated use `Monday$inboundSchema` instead. */
  export const inboundSchema = Monday$inboundSchema;
  /** @deprecated use `Monday$outboundSchema` instead. */
  export const outboundSchema = Monday$outboundSchema;
  /** @deprecated use `Monday$Outbound` instead. */
  export type Outbound = Monday$Outbound;
}

export function mondayToJSON(monday: Monday): string {
  return JSON.stringify(Monday$outboundSchema.parse(monday));
}

export function mondayFromJSON(jsonString: string): SafeParseResult<Monday, SDKValidationError> {
  return safeParse(jsonString, (x) => Monday$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Monday' from JSON`);
}

/** @internal */
export const Tuesday$inboundSchema: z.ZodType<Tuesday, z.ZodTypeDef, unknown> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$inboundSchema).optional(),
});

/** @internal */
export type Tuesday$Outbound = {
  isEnabled: boolean;
  hours?: Array<TimeRangeDto$Outbound> | undefined;
};

/** @internal */
export const Tuesday$outboundSchema: z.ZodType<Tuesday$Outbound, z.ZodTypeDef, Tuesday> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Tuesday$ {
  /** @deprecated use `Tuesday$inboundSchema` instead. */
  export const inboundSchema = Tuesday$inboundSchema;
  /** @deprecated use `Tuesday$outboundSchema` instead. */
  export const outboundSchema = Tuesday$outboundSchema;
  /** @deprecated use `Tuesday$Outbound` instead. */
  export type Outbound = Tuesday$Outbound;
}

export function tuesdayToJSON(tuesday: Tuesday): string {
  return JSON.stringify(Tuesday$outboundSchema.parse(tuesday));
}

export function tuesdayFromJSON(jsonString: string): SafeParseResult<Tuesday, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tuesday$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tuesday' from JSON`
  );
}

/** @internal */
export const Wednesday$inboundSchema: z.ZodType<Wednesday, z.ZodTypeDef, unknown> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$inboundSchema).optional(),
});

/** @internal */
export type Wednesday$Outbound = {
  isEnabled: boolean;
  hours?: Array<TimeRangeDto$Outbound> | undefined;
};

/** @internal */
export const Wednesday$outboundSchema: z.ZodType<Wednesday$Outbound, z.ZodTypeDef, Wednesday> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Wednesday$ {
  /** @deprecated use `Wednesday$inboundSchema` instead. */
  export const inboundSchema = Wednesday$inboundSchema;
  /** @deprecated use `Wednesday$outboundSchema` instead. */
  export const outboundSchema = Wednesday$outboundSchema;
  /** @deprecated use `Wednesday$Outbound` instead. */
  export type Outbound = Wednesday$Outbound;
}

export function wednesdayToJSON(wednesday: Wednesday): string {
  return JSON.stringify(Wednesday$outboundSchema.parse(wednesday));
}

export function wednesdayFromJSON(jsonString: string): SafeParseResult<Wednesday, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Wednesday$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Wednesday' from JSON`
  );
}

/** @internal */
export const Thursday$inboundSchema: z.ZodType<Thursday, z.ZodTypeDef, unknown> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$inboundSchema).optional(),
});

/** @internal */
export type Thursday$Outbound = {
  isEnabled: boolean;
  hours?: Array<TimeRangeDto$Outbound> | undefined;
};

/** @internal */
export const Thursday$outboundSchema: z.ZodType<Thursday$Outbound, z.ZodTypeDef, Thursday> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Thursday$ {
  /** @deprecated use `Thursday$inboundSchema` instead. */
  export const inboundSchema = Thursday$inboundSchema;
  /** @deprecated use `Thursday$outboundSchema` instead. */
  export const outboundSchema = Thursday$outboundSchema;
  /** @deprecated use `Thursday$Outbound` instead. */
  export type Outbound = Thursday$Outbound;
}

export function thursdayToJSON(thursday: Thursday): string {
  return JSON.stringify(Thursday$outboundSchema.parse(thursday));
}

export function thursdayFromJSON(jsonString: string): SafeParseResult<Thursday, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Thursday$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Thursday' from JSON`
  );
}

/** @internal */
export const Friday$inboundSchema: z.ZodType<Friday, z.ZodTypeDef, unknown> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$inboundSchema).optional(),
});

/** @internal */
export type Friday$Outbound = {
  isEnabled: boolean;
  hours?: Array<TimeRangeDto$Outbound> | undefined;
};

/** @internal */
export const Friday$outboundSchema: z.ZodType<Friday$Outbound, z.ZodTypeDef, Friday> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Friday$ {
  /** @deprecated use `Friday$inboundSchema` instead. */
  export const inboundSchema = Friday$inboundSchema;
  /** @deprecated use `Friday$outboundSchema` instead. */
  export const outboundSchema = Friday$outboundSchema;
  /** @deprecated use `Friday$Outbound` instead. */
  export type Outbound = Friday$Outbound;
}

export function fridayToJSON(friday: Friday): string {
  return JSON.stringify(Friday$outboundSchema.parse(friday));
}

export function fridayFromJSON(jsonString: string): SafeParseResult<Friday, SDKValidationError> {
  return safeParse(jsonString, (x) => Friday$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Friday' from JSON`);
}

/** @internal */
export const Saturday$inboundSchema: z.ZodType<Saturday, z.ZodTypeDef, unknown> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$inboundSchema).optional(),
});

/** @internal */
export type Saturday$Outbound = {
  isEnabled: boolean;
  hours?: Array<TimeRangeDto$Outbound> | undefined;
};

/** @internal */
export const Saturday$outboundSchema: z.ZodType<Saturday$Outbound, z.ZodTypeDef, Saturday> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Saturday$ {
  /** @deprecated use `Saturday$inboundSchema` instead. */
  export const inboundSchema = Saturday$inboundSchema;
  /** @deprecated use `Saturday$outboundSchema` instead. */
  export const outboundSchema = Saturday$outboundSchema;
  /** @deprecated use `Saturday$Outbound` instead. */
  export type Outbound = Saturday$Outbound;
}

export function saturdayToJSON(saturday: Saturday): string {
  return JSON.stringify(Saturday$outboundSchema.parse(saturday));
}

export function saturdayFromJSON(jsonString: string): SafeParseResult<Saturday, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Saturday$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Saturday' from JSON`
  );
}

/** @internal */
export const Sunday$inboundSchema: z.ZodType<Sunday, z.ZodTypeDef, unknown> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$inboundSchema).optional(),
});

/** @internal */
export type Sunday$Outbound = {
  isEnabled: boolean;
  hours?: Array<TimeRangeDto$Outbound> | undefined;
};

/** @internal */
export const Sunday$outboundSchema: z.ZodType<Sunday$Outbound, z.ZodTypeDef, Sunday> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Sunday$ {
  /** @deprecated use `Sunday$inboundSchema` instead. */
  export const inboundSchema = Sunday$inboundSchema;
  /** @deprecated use `Sunday$outboundSchema` instead. */
  export const outboundSchema = Sunday$outboundSchema;
  /** @deprecated use `Sunday$Outbound` instead. */
  export type Outbound = Sunday$Outbound;
}

export function sundayToJSON(sunday: Sunday): string {
  return JSON.stringify(Sunday$outboundSchema.parse(sunday));
}

export function sundayFromJSON(jsonString: string): SafeParseResult<Sunday, SDKValidationError> {
  return safeParse(jsonString, (x) => Sunday$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Sunday' from JSON`);
}

/** @internal */
export const WeeklySchedule$inboundSchema: z.ZodType<WeeklySchedule, z.ZodTypeDef, unknown> = z.object({
  monday: z.lazy(() => Monday$inboundSchema).optional(),
  tuesday: z.lazy(() => Tuesday$inboundSchema).optional(),
  wednesday: z.lazy(() => Wednesday$inboundSchema).optional(),
  thursday: z.lazy(() => Thursday$inboundSchema).optional(),
  friday: z.lazy(() => Friday$inboundSchema).optional(),
  saturday: z.lazy(() => Saturday$inboundSchema).optional(),
  sunday: z.lazy(() => Sunday$inboundSchema).optional(),
});

/** @internal */
export type WeeklySchedule$Outbound = {
  monday?: Monday$Outbound | undefined;
  tuesday?: Tuesday$Outbound | undefined;
  wednesday?: Wednesday$Outbound | undefined;
  thursday?: Thursday$Outbound | undefined;
  friday?: Friday$Outbound | undefined;
  saturday?: Saturday$Outbound | undefined;
  sunday?: Sunday$Outbound | undefined;
};

/** @internal */
export const WeeklySchedule$outboundSchema: z.ZodType<WeeklySchedule$Outbound, z.ZodTypeDef, WeeklySchedule> = z.object(
  {
    monday: z.lazy(() => Monday$outboundSchema).optional(),
    tuesday: z.lazy(() => Tuesday$outboundSchema).optional(),
    wednesday: z.lazy(() => Wednesday$outboundSchema).optional(),
    thursday: z.lazy(() => Thursday$outboundSchema).optional(),
    friday: z.lazy(() => Friday$outboundSchema).optional(),
    saturday: z.lazy(() => Saturday$outboundSchema).optional(),
    sunday: z.lazy(() => Sunday$outboundSchema).optional(),
  }
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WeeklySchedule$ {
  /** @deprecated use `WeeklySchedule$inboundSchema` instead. */
  export const inboundSchema = WeeklySchedule$inboundSchema;
  /** @deprecated use `WeeklySchedule$outboundSchema` instead. */
  export const outboundSchema = WeeklySchedule$outboundSchema;
  /** @deprecated use `WeeklySchedule$Outbound` instead. */
  export type Outbound = WeeklySchedule$Outbound;
}

export function weeklyScheduleToJSON(weeklySchedule: WeeklySchedule): string {
  return JSON.stringify(WeeklySchedule$outboundSchema.parse(weeklySchedule));
}

export function weeklyScheduleFromJSON(jsonString: string): SafeParseResult<WeeklySchedule, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WeeklySchedule$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WeeklySchedule' from JSON`
  );
}

/** @internal */
export const ScheduleDto$inboundSchema: z.ZodType<ScheduleDto, z.ZodTypeDef, unknown> = z.object({
  isEnabled: z.boolean(),
  weeklySchedule: z.lazy(() => WeeklySchedule$inboundSchema).optional(),
});

/** @internal */
export type ScheduleDto$Outbound = {
  isEnabled: boolean;
  weeklySchedule?: WeeklySchedule$Outbound | undefined;
};

/** @internal */
export const ScheduleDto$outboundSchema: z.ZodType<ScheduleDto$Outbound, z.ZodTypeDef, ScheduleDto> = z.object({
  isEnabled: z.boolean(),
  weeklySchedule: z.lazy(() => WeeklySchedule$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ScheduleDto$ {
  /** @deprecated use `ScheduleDto$inboundSchema` instead. */
  export const inboundSchema = ScheduleDto$inboundSchema;
  /** @deprecated use `ScheduleDto$outboundSchema` instead. */
  export const outboundSchema = ScheduleDto$outboundSchema;
  /** @deprecated use `ScheduleDto$Outbound` instead. */
  export type Outbound = ScheduleDto$Outbound;
}

export function scheduleDtoToJSON(scheduleDto: ScheduleDto): string {
  return JSON.stringify(ScheduleDto$outboundSchema.parse(scheduleDto));
}

export function scheduleDtoFromJSON(jsonString: string): SafeParseResult<ScheduleDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ScheduleDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ScheduleDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - mondayToJSON(monday: Monday)
 - mondayFromJSON(jsonString: string)
 - tuesdayToJSON(tuesday: Tuesday)
 - tuesdayFromJSON(jsonString: string)
 - wednesdayToJSON(wednesday: Wednesday)
 - wednesdayFromJSON(jsonString: string)
 - thursdayToJSON(thursday: Thursday)
 - thursdayFromJSON(jsonString: string)
 - fridayToJSON(friday: Friday)
 - fridayFromJSON(jsonString: string)
 - saturdayToJSON(saturday: Saturday)
 - saturdayFromJSON(jsonString: string)
 - sundayToJSON(sunday: Sunday)
 - sundayFromJSON(jsonString: string)
 - weeklyScheduleToJSON(weeklySchedule: WeeklySchedule)
 - weeklyScheduleFromJSON(jsonString: string)
 - scheduleDtoToJSON(scheduleDto: ScheduleDto)
 - scheduleDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Monday$Outbound;
}

export function mondayToJSON(monday: Monday): string {
  return JSON.stringify(M...)
 - Outbound(Tuesday$Outbound;
}

export function tuesdayToJSON(tuesday: Tuesday): string {
  return JSON.stringi...)
 - Outbound(Wednesday$Outbound;
}

export function wednesdayToJSON(wednesday: Wednesday): string {
  return JSON...)
 - Outbound(Thursday$Outbound;
}

export function thursdayToJSON(thursday: Thursday): string {
  return JSON.str...)
 - Outbound(Friday$Outbound;
}

export function fridayToJSON(friday: Friday): string {
  return JSON.stringify(F...)
 - Outbound(Saturday$Outbound;
}

export function saturdayToJSON(saturday: Saturday): string {
  return JSON.str...)
 - Outbound(Sunday$Outbound;
}

export function sundayToJSON(sunday: Sunday): string {
  return JSON.stringify(S...)
 - Outbound(WeeklySchedule$Outbound;
}

export function weeklyScheduleToJSON(weeklySchedule: WeeklySchedule): st...)
 - Outbound(ScheduleDto$Outbound;
}

export function scheduleDtoToJSON(scheduleDto: ScheduleDto): string {
  ret...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function mondayToJSON
- export function mondayFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function tuesdayToJSON
- export function tuesdayFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function wednesdayToJSON
- export function wednesdayFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function thursdayToJSON
- export function thursdayFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function fridayToJSON
- export function fridayFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function saturdayToJSON
- export function saturdayFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function sundayToJSON
- export function sundayFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function weeklyScheduleToJSON
- export function weeklyScheduleFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function scheduleDtoToJSON
- export function scheduleDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/security.ts
Tamaño: 1788 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type Security = {
  secretKey?: string | undefined;
  bearerAuth?: string | undefined;
};

/** @internal */
export const Security$inboundSchema: z.ZodType<Security, z.ZodTypeDef, unknown> = z.object({
  secretKey: z.string().optional(),
  bearerAuth: z.string().optional(),
});

/** @internal */
export type Security$Outbound = {
  secretKey?: string | undefined;
  bearerAuth?: string | undefined;
};

/** @internal */
export const Security$outboundSchema: z.ZodType<Security$Outbound, z.ZodTypeDef, Security> = z.object({
  secretKey: z.string().optional(),
  bearerAuth: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Security$ {
  /** @deprecated use `Security$inboundSchema` instead. */
  export const inboundSchema = Security$inboundSchema;
  /** @deprecated use `Security$outboundSchema` instead. */
  export const outboundSchema = Security$outboundSchema;
  /** @deprecated use `Security$Outbound` instead. */
  export type Outbound = Security$Outbound;
}

export function securityToJSON(security: Security): string {
  return JSON.stringify(Security$outboundSchema.parse(security));
}

export function securityFromJSON(jsonString: string): SafeParseResult<Security, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Security$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Security' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - securityToJSON(security: Security)
 - securityFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Security$Outbound;
}

export function securityToJSON(security: Security): string {
  return JSON.str...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function securityToJSON
- export function securityFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/severitylevelenum.ts
Tamaño: 1162 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Severity of the workflow
 */
export const SeverityLevelEnum = {
  High: 'high',
  Medium: 'medium',
  Low: 'low',
  None: 'none',
} as const;
/**
 * Severity of the workflow
 */
export type SeverityLevelEnum = ClosedEnum<typeof SeverityLevelEnum>;

/** @internal */
export const SeverityLevelEnum$inboundSchema: z.ZodNativeEnum<typeof SeverityLevelEnum> =
  z.nativeEnum(SeverityLevelEnum);

/** @internal */
export const SeverityLevelEnum$outboundSchema: z.ZodNativeEnum<typeof SeverityLevelEnum> =
  SeverityLevelEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SeverityLevelEnum$ {
  /** @deprecated use `SeverityLevelEnum$inboundSchema` instead. */
  export const inboundSchema = SeverityLevelEnum$inboundSchema;
  /** @deprecated use `SeverityLevelEnum$outboundSchema` instead. */
  export const outboundSchema = SeverityLevelEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/smscontroldto.ts
Tamaño: 2168 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SmsControlDto = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * Content of the SMS message.
   */
  body?: string | undefined;
};

/** @internal */
export const SmsControlDto$inboundSchema: z.ZodType<SmsControlDto, z.ZodTypeDef, unknown> = z.object({
  skip: z.record(z.any()).optional(),
  body: z.string().optional(),
});

/** @internal */
export type SmsControlDto$Outbound = {
  skip?: { [k: string]: any } | undefined;
  body?: string | undefined;
};

/** @internal */
export const SmsControlDto$outboundSchema: z.ZodType<SmsControlDto$Outbound, z.ZodTypeDef, SmsControlDto> = z.object({
  skip: z.record(z.any()).optional(),
  body: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SmsControlDto$ {
  /** @deprecated use `SmsControlDto$inboundSchema` instead. */
  export const inboundSchema = SmsControlDto$inboundSchema;
  /** @deprecated use `SmsControlDto$outboundSchema` instead. */
  export const outboundSchema = SmsControlDto$outboundSchema;
  /** @deprecated use `SmsControlDto$Outbound` instead. */
  export type Outbound = SmsControlDto$Outbound;
}

export function smsControlDtoToJSON(smsControlDto: SmsControlDto): string {
  return JSON.stringify(SmsControlDto$outboundSchema.parse(smsControlDto));
}

export function smsControlDtoFromJSON(jsonString: string): SafeParseResult<SmsControlDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SmsControlDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SmsControlDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - smsControlDtoToJSON(smsControlDto: SmsControlDto)
 - smsControlDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SmsControlDto$Outbound;
}

export function smsControlDtoToJSON(smsControlDto: SmsControlDto): string...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function smsControlDtoToJSON
- export function smsControlDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/smscontrolsmetadataresponsedto.ts
Tamaño: 2913 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  SmsControlDto,
  SmsControlDto$inboundSchema,
  SmsControlDto$Outbound,
  SmsControlDto$outboundSchema,
} from './smscontroldto.js';
import { UiSchema, UiSchema$inboundSchema, UiSchema$Outbound, UiSchema$outboundSchema } from './uischema.js';

export type SmsControlsMetadataResponseDto = {
  /**
   * JSON Schema for data
   */
  dataSchema?: { [k: string]: any } | undefined;
  /**
   * UI Schema for rendering
   */
  uiSchema?: UiSchema | undefined;
  /**
   * Control values specific to SMS
   */
  values: SmsControlDto;
};

/** @internal */
export const SmsControlsMetadataResponseDto$inboundSchema: z.ZodType<
  SmsControlsMetadataResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$inboundSchema.optional(),
  values: SmsControlDto$inboundSchema,
});

/** @internal */
export type SmsControlsMetadataResponseDto$Outbound = {
  dataSchema?: { [k: string]: any } | undefined;
  uiSchema?: UiSchema$Outbound | undefined;
  values: SmsControlDto$Outbound;
};

/** @internal */
export const SmsControlsMetadataResponseDto$outboundSchema: z.ZodType<
  SmsControlsMetadataResponseDto$Outbound,
  z.ZodTypeDef,
  SmsControlsMetadataResponseDto
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$outboundSchema.optional(),
  values: SmsControlDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SmsControlsMetadataResponseDto$ {
  /** @deprecated use `SmsControlsMetadataResponseDto$inboundSchema` instead. */
  export const inboundSchema = SmsControlsMetadataResponseDto$inboundSchema;
  /** @deprecated use `SmsControlsMetadataResponseDto$outboundSchema` instead. */
  export const outboundSchema = SmsControlsMetadataResponseDto$outboundSchema;
  /** @deprecated use `SmsControlsMetadataResponseDto$Outbound` instead. */
  export type Outbound = SmsControlsMetadataResponseDto$Outbound;
}

export function smsControlsMetadataResponseDtoToJSON(
  smsControlsMetadataResponseDto: SmsControlsMetadataResponseDto
): string {
  return JSON.stringify(SmsControlsMetadataResponseDto$outboundSchema.parse(smsControlsMetadataResponseDto));
}

export function smsControlsMetadataResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<SmsControlsMetadataResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SmsControlsMetadataResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SmsControlsMetadataResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - smsControlsMetadataResponseDtoToJSON(smsControlsMetadataResponseDto: SmsControlsMetadataResponseDto)
 - smsControlsMetadataResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SmsControlsMetadataResponseDto$Outbound;
}

export function smsControlsMetadataResponseDtoToJSON(
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function smsControlsMetadataResponseDtoToJSON
- export function smsControlsMetadataResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/smsrenderoutput.ts
Tamaño: 1784 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SmsRenderOutput = {
  /**
   * Body of the SMS message
   */
  body: string;
};

/** @internal */
export const SmsRenderOutput$inboundSchema: z.ZodType<SmsRenderOutput, z.ZodTypeDef, unknown> = z.object({
  body: z.string(),
});

/** @internal */
export type SmsRenderOutput$Outbound = {
  body: string;
};

/** @internal */
export const SmsRenderOutput$outboundSchema: z.ZodType<SmsRenderOutput$Outbound, z.ZodTypeDef, SmsRenderOutput> =
  z.object({
    body: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SmsRenderOutput$ {
  /** @deprecated use `SmsRenderOutput$inboundSchema` instead. */
  export const inboundSchema = SmsRenderOutput$inboundSchema;
  /** @deprecated use `SmsRenderOutput$outboundSchema` instead. */
  export const outboundSchema = SmsRenderOutput$outboundSchema;
  /** @deprecated use `SmsRenderOutput$Outbound` instead. */
  export type Outbound = SmsRenderOutput$Outbound;
}

export function smsRenderOutputToJSON(smsRenderOutput: SmsRenderOutput): string {
  return JSON.stringify(SmsRenderOutput$outboundSchema.parse(smsRenderOutput));
}

export function smsRenderOutputFromJSON(jsonString: string): SafeParseResult<SmsRenderOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SmsRenderOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SmsRenderOutput' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - smsRenderOutputToJSON(smsRenderOutput: SmsRenderOutput)
 - smsRenderOutputFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SmsRenderOutput$Outbound;
}

export function smsRenderOutputToJSON(smsRenderOutput: SmsRenderOutput)...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function smsRenderOutputToJSON
- export function smsRenderOutputFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/smsstepresponsedto.ts
Tamaño: 7597 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { collectExtraKeys as collectExtraKeys$, safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  SmsControlsMetadataResponseDto,
  SmsControlsMetadataResponseDto$inboundSchema,
  SmsControlsMetadataResponseDto$Outbound,
  SmsControlsMetadataResponseDto$outboundSchema,
} from './smscontrolsmetadataresponsedto.js';
import {
  StepIssuesDto,
  StepIssuesDto$inboundSchema,
  StepIssuesDto$Outbound,
  StepIssuesDto$outboundSchema,
} from './stepissuesdto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the SMS step
 */
export type SmsStepResponseDtoControlValues = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * Content of the SMS message.
   */
  body?: string | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type SmsStepResponseDto = {
  /**
   * Controls metadata for the SMS step
   */
  controls: SmsControlsMetadataResponseDto;
  /**
   * Control values for the SMS step
   */
  controlValues?: SmsStepResponseDtoControlValues | undefined;
  /**
   * JSON Schema for variables, follows the JSON Schema standard
   */
  variables: { [k: string]: any };
  /**
   * Unique identifier of the step
   */
  stepId: string;
  /**
   * Database identifier of the step
   */
  id: string;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Slug of the step
   */
  slug: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow database identifier
   */
  workflowDatabaseId: string;
  /**
   * Issues associated with the step
   */
  issues?: StepIssuesDto | undefined;
};

/** @internal */
export const SmsStepResponseDtoControlValues$inboundSchema: z.ZodType<
  SmsStepResponseDtoControlValues,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z
    .object({
      skip: z.record(z.any()).optional(),
      body: z.string().optional(),
    })
    .catchall(z.any()),
  'additionalProperties',
  true
);

/** @internal */
export type SmsStepResponseDtoControlValues$Outbound = {
  skip?: { [k: string]: any } | undefined;
  body?: string | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const SmsStepResponseDtoControlValues$outboundSchema: z.ZodType<
  SmsStepResponseDtoControlValues$Outbound,
  z.ZodTypeDef,
  SmsStepResponseDtoControlValues
> = z
  .object({
    skip: z.record(z.any()).optional(),
    body: z.string().optional(),
    additionalProperties: z.record(z.any()).optional(),
  })
  .transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SmsStepResponseDtoControlValues$ {
  /** @deprecated use `SmsStepResponseDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = SmsStepResponseDtoControlValues$inboundSchema;
  /** @deprecated use `SmsStepResponseDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = SmsStepResponseDtoControlValues$outboundSchema;
  /** @deprecated use `SmsStepResponseDtoControlValues$Outbound` instead. */
  export type Outbound = SmsStepResponseDtoControlValues$Outbound;
}

export function smsStepResponseDtoControlValuesToJSON(
  smsStepResponseDtoControlValues: SmsStepResponseDtoControlValues
): string {
  return JSON.stringify(SmsStepResponseDtoControlValues$outboundSchema.parse(smsStepResponseDtoControlValues));
}

export function smsStepResponseDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<SmsStepResponseDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SmsStepResponseDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SmsStepResponseDtoControlValues' from JSON`
  );
}

/** @internal */
export const SmsStepResponseDto$inboundSchema: z.ZodType<SmsStepResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    controls: SmsControlsMetadataResponseDto$inboundSchema,
    controlValues: z.lazy(() => SmsStepResponseDtoControlValues$inboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    _id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$inboundSchema,
    origin: ResourceOriginEnum$inboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type SmsStepResponseDto$Outbound = {
  controls: SmsControlsMetadataResponseDto$Outbound;
  controlValues?: SmsStepResponseDtoControlValues$Outbound | undefined;
  variables: { [k: string]: any };
  stepId: string;
  _id: string;
  name: string;
  slug: string;
  type: string;
  origin: string;
  workflowId: string;
  workflowDatabaseId: string;
  issues?: StepIssuesDto$Outbound | undefined;
};

/** @internal */
export const SmsStepResponseDto$outboundSchema: z.ZodType<
  SmsStepResponseDto$Outbound,
  z.ZodTypeDef,
  SmsStepResponseDto
> = z
  .object({
    controls: SmsControlsMetadataResponseDto$outboundSchema,
    controlValues: z.lazy(() => SmsStepResponseDtoControlValues$outboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$outboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SmsStepResponseDto$ {
  /** @deprecated use `SmsStepResponseDto$inboundSchema` instead. */
  export const inboundSchema = SmsStepResponseDto$inboundSchema;
  /** @deprecated use `SmsStepResponseDto$outboundSchema` instead. */
  export const outboundSchema = SmsStepResponseDto$outboundSchema;
  /** @deprecated use `SmsStepResponseDto$Outbound` instead. */
  export type Outbound = SmsStepResponseDto$Outbound;
}

export function smsStepResponseDtoToJSON(smsStepResponseDto: SmsStepResponseDto): string {
  return JSON.stringify(SmsStepResponseDto$outboundSchema.parse(smsStepResponseDto));
}

export function smsStepResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<SmsStepResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SmsStepResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SmsStepResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - smsStepResponseDtoControlValuesToJSON(smsStepResponseDtoControlValues: SmsStepResponseDtoControlValues)
 - smsStepResponseDtoControlValuesFromJSON(jsonString: string)
 - smsStepResponseDtoToJSON(smsStepResponseDto: SmsStepResponseDto)
 - smsStepResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SmsStepResponseDtoControlValues$Outbound;
}

export function smsStepResponseDtoControlValuesToJSON(
...)
 - Outbound(SmsStepResponseDto$Outbound;
}

export function smsStepResponseDtoToJSON(smsStepResponseDto: SmsStep...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function smsStepResponseDtoControlValuesToJSON
- export function smsStepResponseDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function smsStepResponseDtoToJSON
- export function smsStepResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/smsstepupsertdto.ts
Tamaño: 5131 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  SmsControlDto,
  SmsControlDto$inboundSchema,
  SmsControlDto$Outbound,
  SmsControlDto$outboundSchema,
} from './smscontroldto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the SMS step.
 */
export type SmsStepUpsertDtoControlValues =
  | SmsControlDto
  | {
      [k: string]: any;
    };

export type SmsStepUpsertDto = {
  /**
   * Database identifier of the step. Used for updating the step.
   */
  id?: string | undefined;
  /**
   * Unique identifier for the step
   */
  stepId?: string | undefined;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Control values for the SMS step.
   */
  controlValues?: SmsControlDto | { [k: string]: any } | undefined;
};

/** @internal */
export const SmsStepUpsertDtoControlValues$inboundSchema: z.ZodType<
  SmsStepUpsertDtoControlValues,
  z.ZodTypeDef,
  unknown
> = z.union([SmsControlDto$inboundSchema, z.record(z.any())]);

/** @internal */
export type SmsStepUpsertDtoControlValues$Outbound =
  | SmsControlDto$Outbound
  | {
      [k: string]: any;
    };

/** @internal */
export const SmsStepUpsertDtoControlValues$outboundSchema: z.ZodType<
  SmsStepUpsertDtoControlValues$Outbound,
  z.ZodTypeDef,
  SmsStepUpsertDtoControlValues
> = z.union([SmsControlDto$outboundSchema, z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SmsStepUpsertDtoControlValues$ {
  /** @deprecated use `SmsStepUpsertDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = SmsStepUpsertDtoControlValues$inboundSchema;
  /** @deprecated use `SmsStepUpsertDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = SmsStepUpsertDtoControlValues$outboundSchema;
  /** @deprecated use `SmsStepUpsertDtoControlValues$Outbound` instead. */
  export type Outbound = SmsStepUpsertDtoControlValues$Outbound;
}

export function smsStepUpsertDtoControlValuesToJSON(
  smsStepUpsertDtoControlValues: SmsStepUpsertDtoControlValues
): string {
  return JSON.stringify(SmsStepUpsertDtoControlValues$outboundSchema.parse(smsStepUpsertDtoControlValues));
}

export function smsStepUpsertDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<SmsStepUpsertDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SmsStepUpsertDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SmsStepUpsertDtoControlValues' from JSON`
  );
}

/** @internal */
export const SmsStepUpsertDto$inboundSchema: z.ZodType<SmsStepUpsertDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$inboundSchema,
    controlValues: z.union([SmsControlDto$inboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type SmsStepUpsertDto$Outbound = {
  _id?: string | undefined;
  stepId?: string | undefined;
  name: string;
  type: string;
  controlValues?: SmsControlDto$Outbound | { [k: string]: any } | undefined;
};

/** @internal */
export const SmsStepUpsertDto$outboundSchema: z.ZodType<SmsStepUpsertDto$Outbound, z.ZodTypeDef, SmsStepUpsertDto> = z
  .object({
    id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$outboundSchema,
    controlValues: z.union([SmsControlDto$outboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SmsStepUpsertDto$ {
  /** @deprecated use `SmsStepUpsertDto$inboundSchema` instead. */
  export const inboundSchema = SmsStepUpsertDto$inboundSchema;
  /** @deprecated use `SmsStepUpsertDto$outboundSchema` instead. */
  export const outboundSchema = SmsStepUpsertDto$outboundSchema;
  /** @deprecated use `SmsStepUpsertDto$Outbound` instead. */
  export type Outbound = SmsStepUpsertDto$Outbound;
}

export function smsStepUpsertDtoToJSON(smsStepUpsertDto: SmsStepUpsertDto): string {
  return JSON.stringify(SmsStepUpsertDto$outboundSchema.parse(smsStepUpsertDto));
}

export function smsStepUpsertDtoFromJSON(jsonString: string): SafeParseResult<SmsStepUpsertDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SmsStepUpsertDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SmsStepUpsertDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - smsStepUpsertDtoControlValuesToJSON(smsStepUpsertDtoControlValues: SmsStepUpsertDtoControlValues)
 - smsStepUpsertDtoControlValuesFromJSON(jsonString: string)
 - smsStepUpsertDtoToJSON(smsStepUpsertDto: SmsStepUpsertDto)
 - smsStepUpsertDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SmsStepUpsertDtoControlValues$Outbound;
}

export function smsStepUpsertDtoControlValuesToJSON(
  sm...)
 - Outbound(SmsStepUpsertDto$Outbound;
}

export function smsStepUpsertDtoToJSON(smsStepUpsertDto: SmsStepUpsert...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function smsStepUpsertDtoControlValuesToJSON
- export function smsStepUpsertDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function smsStepUpsertDtoToJSON
- export function smsStepUpsertDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/stepcontentissuedto.ts
Tamaño: 2436 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ContentIssueEnum,
  ContentIssueEnum$inboundSchema,
  ContentIssueEnum$outboundSchema,
} from './contentissueenum.js';

export type StepContentIssueDto = {
  /**
   * Type of step content issue
   */
  issueType: ContentIssueEnum;
  /**
   * Name of the variable related to the issue
   */
  variableName?: string | undefined;
  /**
   * Detailed message describing the issue
   */
  message: string;
};

/** @internal */
export const StepContentIssueDto$inboundSchema: z.ZodType<StepContentIssueDto, z.ZodTypeDef, unknown> = z.object({
  issueType: ContentIssueEnum$inboundSchema,
  variableName: z.string().optional(),
  message: z.string(),
});

/** @internal */
export type StepContentIssueDto$Outbound = {
  issueType: string;
  variableName?: string | undefined;
  message: string;
};

/** @internal */
export const StepContentIssueDto$outboundSchema: z.ZodType<
  StepContentIssueDto$Outbound,
  z.ZodTypeDef,
  StepContentIssueDto
> = z.object({
  issueType: ContentIssueEnum$outboundSchema,
  variableName: z.string().optional(),
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepContentIssueDto$ {
  /** @deprecated use `StepContentIssueDto$inboundSchema` instead. */
  export const inboundSchema = StepContentIssueDto$inboundSchema;
  /** @deprecated use `StepContentIssueDto$outboundSchema` instead. */
  export const outboundSchema = StepContentIssueDto$outboundSchema;
  /** @deprecated use `StepContentIssueDto$Outbound` instead. */
  export type Outbound = StepContentIssueDto$Outbound;
}

export function stepContentIssueDtoToJSON(stepContentIssueDto: StepContentIssueDto): string {
  return JSON.stringify(StepContentIssueDto$outboundSchema.parse(stepContentIssueDto));
}

export function stepContentIssueDtoFromJSON(
  jsonString: string
): SafeParseResult<StepContentIssueDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepContentIssueDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepContentIssueDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepContentIssueDtoToJSON(stepContentIssueDto: StepContentIssueDto)
 - stepContentIssueDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(StepContentIssueDto$Outbound;
}

export function stepContentIssueDtoToJSON(stepContentIssueDto: Step...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepContentIssueDtoToJSON
- export function stepContentIssueDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/stepexecutiondetaildto.ts
Tamaño: 4459 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ExecutionDetailsStatusEnum,
  ExecutionDetailsStatusEnum$inboundSchema,
  ExecutionDetailsStatusEnum$outboundSchema,
} from './executiondetailsstatusenum.js';

/**
 * Raw data of the execution
 */
export type Raw = {};

export type StepExecutionDetailDto = {
  /**
   * Unique identifier of the execution detail
   */
  id: string;
  /**
   * Creation time of the execution detail
   */
  createdAt?: string | undefined;
  /**
   * Status of the execution detail
   */
  status: ExecutionDetailsStatusEnum;
  /**
   * Detailed information about the execution
   */
  detail: string;
  /**
   * Provider identifier
   */
  providerId?: string | undefined;
  /**
   * Raw data of the execution
   */
  raw?: Raw | null | undefined;
};

/** @internal */
export const Raw$inboundSchema: z.ZodType<Raw, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Raw$Outbound = {};

/** @internal */
export const Raw$outboundSchema: z.ZodType<Raw$Outbound, z.ZodTypeDef, Raw> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Raw$ {
  /** @deprecated use `Raw$inboundSchema` instead. */
  export const inboundSchema = Raw$inboundSchema;
  /** @deprecated use `Raw$outboundSchema` instead. */
  export const outboundSchema = Raw$outboundSchema;
  /** @deprecated use `Raw$Outbound` instead. */
  export type Outbound = Raw$Outbound;
}

export function rawToJSON(raw: Raw): string {
  return JSON.stringify(Raw$outboundSchema.parse(raw));
}

export function rawFromJSON(jsonString: string): SafeParseResult<Raw, SDKValidationError> {
  return safeParse(jsonString, (x) => Raw$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Raw' from JSON`);
}

/** @internal */
export const StepExecutionDetailDto$inboundSchema: z.ZodType<StepExecutionDetailDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    createdAt: z.string().optional(),
    status: ExecutionDetailsStatusEnum$inboundSchema,
    detail: z.string(),
    providerId: z.string().optional(),
    raw: z.nullable(z.lazy(() => Raw$inboundSchema)).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type StepExecutionDetailDto$Outbound = {
  _id: string;
  createdAt?: string | undefined;
  status: string;
  detail: string;
  providerId?: string | undefined;
  raw?: Raw$Outbound | null | undefined;
};

/** @internal */
export const StepExecutionDetailDto$outboundSchema: z.ZodType<
  StepExecutionDetailDto$Outbound,
  z.ZodTypeDef,
  StepExecutionDetailDto
> = z
  .object({
    id: z.string(),
    createdAt: z.string().optional(),
    status: ExecutionDetailsStatusEnum$outboundSchema,
    detail: z.string(),
    providerId: z.string().optional(),
    raw: z.nullable(z.lazy(() => Raw$outboundSchema)).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepExecutionDetailDto$ {
  /** @deprecated use `StepExecutionDetailDto$inboundSchema` instead. */
  export const inboundSchema = StepExecutionDetailDto$inboundSchema;
  /** @deprecated use `StepExecutionDetailDto$outboundSchema` instead. */
  export const outboundSchema = StepExecutionDetailDto$outboundSchema;
  /** @deprecated use `StepExecutionDetailDto$Outbound` instead. */
  export type Outbound = StepExecutionDetailDto$Outbound;
}

export function stepExecutionDetailDtoToJSON(stepExecutionDetailDto: StepExecutionDetailDto): string {
  return JSON.stringify(StepExecutionDetailDto$outboundSchema.parse(stepExecutionDetailDto));
}

export function stepExecutionDetailDtoFromJSON(
  jsonString: string
): SafeParseResult<StepExecutionDetailDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepExecutionDetailDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepExecutionDetailDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - rawToJSON(raw: Raw)
 - rawFromJSON(jsonString: string)
 - stepExecutionDetailDtoToJSON(stepExecutionDetailDto: StepExecutionDetailDto)
 - stepExecutionDetailDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Raw$Outbound;
}

export function rawToJSON(raw: Raw): string {
  return JSON.stringify(Raw$outboundS...)
 - Outbound(StepExecutionDetailDto$Outbound;
}

export function stepExecutionDetailDtoToJSON(stepExecutionDetail...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function rawToJSON
- export function rawFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepExecutionDetailDtoToJSON
- export function stepExecutionDetailDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/stepfilterdto.ts
Tamaño: 3454 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  BuilderFieldTypeEnum,
  BuilderFieldTypeEnum$inboundSchema,
  BuilderFieldTypeEnum$outboundSchema,
} from './builderfieldtypeenum.js';
import {
  FieldFilterPartDto,
  FieldFilterPartDto$inboundSchema,
  FieldFilterPartDto$Outbound,
  FieldFilterPartDto$outboundSchema,
} from './fieldfilterpartdto.js';

export const StepFilterDtoValue = {
  And: 'AND',
  Or: 'OR',
} as const;
export type StepFilterDtoValue = ClosedEnum<typeof StepFilterDtoValue>;

export type StepFilterDto = {
  isNegated: boolean;
  type: BuilderFieldTypeEnum;
  value: StepFilterDtoValue;
  children: Array<FieldFilterPartDto>;
};

/** @internal */
export const StepFilterDtoValue$inboundSchema: z.ZodNativeEnum<typeof StepFilterDtoValue> =
  z.nativeEnum(StepFilterDtoValue);

/** @internal */
export const StepFilterDtoValue$outboundSchema: z.ZodNativeEnum<typeof StepFilterDtoValue> =
  StepFilterDtoValue$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepFilterDtoValue$ {
  /** @deprecated use `StepFilterDtoValue$inboundSchema` instead. */
  export const inboundSchema = StepFilterDtoValue$inboundSchema;
  /** @deprecated use `StepFilterDtoValue$outboundSchema` instead. */
  export const outboundSchema = StepFilterDtoValue$outboundSchema;
}

/** @internal */
export const StepFilterDto$inboundSchema: z.ZodType<StepFilterDto, z.ZodTypeDef, unknown> = z.object({
  isNegated: z.boolean(),
  type: BuilderFieldTypeEnum$inboundSchema,
  value: StepFilterDtoValue$inboundSchema,
  children: z.array(FieldFilterPartDto$inboundSchema),
});

/** @internal */
export type StepFilterDto$Outbound = {
  isNegated: boolean;
  type: string;
  value: string;
  children: Array<FieldFilterPartDto$Outbound>;
};

/** @internal */
export const StepFilterDto$outboundSchema: z.ZodType<StepFilterDto$Outbound, z.ZodTypeDef, StepFilterDto> = z.object({
  isNegated: z.boolean(),
  type: BuilderFieldTypeEnum$outboundSchema,
  value: StepFilterDtoValue$outboundSchema,
  children: z.array(FieldFilterPartDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepFilterDto$ {
  /** @deprecated use `StepFilterDto$inboundSchema` instead. */
  export const inboundSchema = StepFilterDto$inboundSchema;
  /** @deprecated use `StepFilterDto$outboundSchema` instead. */
  export const outboundSchema = StepFilterDto$outboundSchema;
  /** @deprecated use `StepFilterDto$Outbound` instead. */
  export type Outbound = StepFilterDto$Outbound;
}

export function stepFilterDtoToJSON(stepFilterDto: StepFilterDto): string {
  return JSON.stringify(StepFilterDto$outboundSchema.parse(stepFilterDto));
}

export function stepFilterDtoFromJSON(jsonString: string): SafeParseResult<StepFilterDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepFilterDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepFilterDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepFilterDtoToJSON(stepFilterDto: StepFilterDto)
 - stepFilterDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(StepFilterDto$Outbound;
}

export function stepFilterDtoToJSON(stepFilterDto: StepFilterDto): string...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepFilterDtoToJSON
- export function stepFilterDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/stepintegrationissue.ts
Tamaño: 2486 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  IntegrationIssueEnum,
  IntegrationIssueEnum$inboundSchema,
  IntegrationIssueEnum$outboundSchema,
} from './integrationissueenum.js';

export type StepIntegrationIssue = {
  /**
   * Type of integration issue
   */
  issueType: IntegrationIssueEnum;
  /**
   * Name of the variable related to the issue
   */
  variableName?: string | undefined;
  /**
   * Detailed message describing the issue
   */
  message: string;
};

/** @internal */
export const StepIntegrationIssue$inboundSchema: z.ZodType<StepIntegrationIssue, z.ZodTypeDef, unknown> = z.object({
  issueType: IntegrationIssueEnum$inboundSchema,
  variableName: z.string().optional(),
  message: z.string(),
});

/** @internal */
export type StepIntegrationIssue$Outbound = {
  issueType: string;
  variableName?: string | undefined;
  message: string;
};

/** @internal */
export const StepIntegrationIssue$outboundSchema: z.ZodType<
  StepIntegrationIssue$Outbound,
  z.ZodTypeDef,
  StepIntegrationIssue
> = z.object({
  issueType: IntegrationIssueEnum$outboundSchema,
  variableName: z.string().optional(),
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepIntegrationIssue$ {
  /** @deprecated use `StepIntegrationIssue$inboundSchema` instead. */
  export const inboundSchema = StepIntegrationIssue$inboundSchema;
  /** @deprecated use `StepIntegrationIssue$outboundSchema` instead. */
  export const outboundSchema = StepIntegrationIssue$outboundSchema;
  /** @deprecated use `StepIntegrationIssue$Outbound` instead. */
  export type Outbound = StepIntegrationIssue$Outbound;
}

export function stepIntegrationIssueToJSON(stepIntegrationIssue: StepIntegrationIssue): string {
  return JSON.stringify(StepIntegrationIssue$outboundSchema.parse(stepIntegrationIssue));
}

export function stepIntegrationIssueFromJSON(
  jsonString: string
): SafeParseResult<StepIntegrationIssue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepIntegrationIssue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepIntegrationIssue' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepIntegrationIssueToJSON(stepIntegrationIssue: StepIntegrationIssue)
 - stepIntegrationIssueFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(StepIntegrationIssue$Outbound;
}

export function stepIntegrationIssueToJSON(stepIntegrationIssue: S...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepIntegrationIssueToJSON
- export function stepIntegrationIssueFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/stepissuesdto.ts
Tamaño: 2681 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  StepContentIssueDto,
  StepContentIssueDto$inboundSchema,
  StepContentIssueDto$Outbound,
  StepContentIssueDto$outboundSchema,
} from './stepcontentissuedto.js';
import {
  StepIntegrationIssue,
  StepIntegrationIssue$inboundSchema,
  StepIntegrationIssue$Outbound,
  StepIntegrationIssue$outboundSchema,
} from './stepintegrationissue.js';

export type StepIssuesDto = {
  /**
   * Controls-related issues
   */
  controls?: { [k: string]: Array<StepContentIssueDto> } | undefined;
  /**
   * Integration-related issues
   */
  integration?: { [k: string]: Array<StepIntegrationIssue> } | undefined;
};

/** @internal */
export const StepIssuesDto$inboundSchema: z.ZodType<StepIssuesDto, z.ZodTypeDef, unknown> = z.object({
  controls: z.record(z.array(StepContentIssueDto$inboundSchema)).optional(),
  integration: z.record(z.array(StepIntegrationIssue$inboundSchema)).optional(),
});

/** @internal */
export type StepIssuesDto$Outbound = {
  controls?: { [k: string]: Array<StepContentIssueDto$Outbound> } | undefined;
  integration?: { [k: string]: Array<StepIntegrationIssue$Outbound> } | undefined;
};

/** @internal */
export const StepIssuesDto$outboundSchema: z.ZodType<StepIssuesDto$Outbound, z.ZodTypeDef, StepIssuesDto> = z.object({
  controls: z.record(z.array(StepContentIssueDto$outboundSchema)).optional(),
  integration: z.record(z.array(StepIntegrationIssue$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepIssuesDto$ {
  /** @deprecated use `StepIssuesDto$inboundSchema` instead. */
  export const inboundSchema = StepIssuesDto$inboundSchema;
  /** @deprecated use `StepIssuesDto$outboundSchema` instead. */
  export const outboundSchema = StepIssuesDto$outboundSchema;
  /** @deprecated use `StepIssuesDto$Outbound` instead. */
  export type Outbound = StepIssuesDto$Outbound;
}

export function stepIssuesDtoToJSON(stepIssuesDto: StepIssuesDto): string {
  return JSON.stringify(StepIssuesDto$outboundSchema.parse(stepIssuesDto));
}

export function stepIssuesDtoFromJSON(jsonString: string): SafeParseResult<StepIssuesDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepIssuesDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepIssuesDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepIssuesDtoToJSON(stepIssuesDto: StepIssuesDto)
 - stepIssuesDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(StepIssuesDto$Outbound;
}

export function stepIssuesDtoToJSON(stepIssuesDto: StepIssuesDto): string...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepIssuesDtoToJSON
- export function stepIssuesDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/steplistresponsedto.ts
Tamaño: 2506 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  StepIssuesDto,
  StepIssuesDto$inboundSchema,
  StepIssuesDto$Outbound,
  StepIssuesDto$outboundSchema,
} from './stepissuesdto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

export type StepListResponseDto = {
  /**
   * Slug of the step
   */
  slug: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Issues associated with the step
   */
  issues?: StepIssuesDto | undefined;
};

/** @internal */
export const StepListResponseDto$inboundSchema: z.ZodType<StepListResponseDto, z.ZodTypeDef, unknown> = z.object({
  slug: z.string(),
  type: StepTypeEnum$inboundSchema,
  issues: StepIssuesDto$inboundSchema.optional(),
});

/** @internal */
export type StepListResponseDto$Outbound = {
  slug: string;
  type: string;
  issues?: StepIssuesDto$Outbound | undefined;
};

/** @internal */
export const StepListResponseDto$outboundSchema: z.ZodType<
  StepListResponseDto$Outbound,
  z.ZodTypeDef,
  StepListResponseDto
> = z.object({
  slug: z.string(),
  type: StepTypeEnum$outboundSchema,
  issues: StepIssuesDto$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepListResponseDto$ {
  /** @deprecated use `StepListResponseDto$inboundSchema` instead. */
  export const inboundSchema = StepListResponseDto$inboundSchema;
  /** @deprecated use `StepListResponseDto$outboundSchema` instead. */
  export const outboundSchema = StepListResponseDto$outboundSchema;
  /** @deprecated use `StepListResponseDto$Outbound` instead. */
  export type Outbound = StepListResponseDto$Outbound;
}

export function stepListResponseDtoToJSON(stepListResponseDto: StepListResponseDto): string {
  return JSON.stringify(StepListResponseDto$outboundSchema.parse(stepListResponseDto));
}

export function stepListResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<StepListResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepListResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepListResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepListResponseDtoToJSON(stepListResponseDto: StepListResponseDto)
 - stepListResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(StepListResponseDto$Outbound;
}

export function stepListResponseDtoToJSON(stepListResponseDto: Step...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepListResponseDtoToJSON
- export function stepListResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/stepresponsedto.ts
Tamaño: 4511 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ControlsMetadataDto,
  ControlsMetadataDto$inboundSchema,
  ControlsMetadataDto$Outbound,
  ControlsMetadataDto$outboundSchema,
} from './controlsmetadatadto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  StepIssuesDto,
  StepIssuesDto$inboundSchema,
  StepIssuesDto$Outbound,
  StepIssuesDto$outboundSchema,
} from './stepissuesdto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

export type StepResponseDto = {
  /**
   * Controls metadata for the step
   */
  controls: ControlsMetadataDto;
  /**
   * Control values for the step (alias for controls.values)
   */
  controlValues?: { [k: string]: any } | undefined;
  /**
   * JSON Schema for variables, follows the JSON Schema standard
   */
  variables: { [k: string]: any };
  /**
   * Unique identifier of the step
   */
  stepId: string;
  /**
   * Database identifier of the step
   */
  id: string;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Slug of the step
   */
  slug: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow database identifier
   */
  workflowDatabaseId: string;
  /**
   * Issues associated with the step
   */
  issues?: StepIssuesDto | undefined;
};

/** @internal */
export const StepResponseDto$inboundSchema: z.ZodType<StepResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    controls: ControlsMetadataDto$inboundSchema,
    controlValues: z.record(z.any()).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    _id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$inboundSchema,
    origin: ResourceOriginEnum$inboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type StepResponseDto$Outbound = {
  controls: ControlsMetadataDto$Outbound;
  controlValues?: { [k: string]: any } | undefined;
  variables: { [k: string]: any };
  stepId: string;
  _id: string;
  name: string;
  slug: string;
  type: string;
  origin: string;
  workflowId: string;
  workflowDatabaseId: string;
  issues?: StepIssuesDto$Outbound | undefined;
};

/** @internal */
export const StepResponseDto$outboundSchema: z.ZodType<StepResponseDto$Outbound, z.ZodTypeDef, StepResponseDto> = z
  .object({
    controls: ControlsMetadataDto$outboundSchema,
    controlValues: z.record(z.any()).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$outboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepResponseDto$ {
  /** @deprecated use `StepResponseDto$inboundSchema` instead. */
  export const inboundSchema = StepResponseDto$inboundSchema;
  /** @deprecated use `StepResponseDto$outboundSchema` instead. */
  export const outboundSchema = StepResponseDto$outboundSchema;
  /** @deprecated use `StepResponseDto$Outbound` instead. */
  export type Outbound = StepResponseDto$Outbound;
}

export function stepResponseDtoToJSON(stepResponseDto: StepResponseDto): string {
  return JSON.stringify(StepResponseDto$outboundSchema.parse(stepResponseDto));
}

export function stepResponseDtoFromJSON(jsonString: string): SafeParseResult<StepResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepResponseDtoToJSON(stepResponseDto: StepResponseDto)
 - stepResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(StepResponseDto$Outbound;
}

export function stepResponseDtoToJSON(stepResponseDto: StepResponseDto)...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepResponseDtoToJSON
- export function stepResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/steprundto.ts
Tamaño: 5073 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  DigestMetadataDto,
  DigestMetadataDto$inboundSchema,
  DigestMetadataDto$Outbound,
  DigestMetadataDto$outboundSchema,
} from './digestmetadatadto.js';
import {
  StepExecutionDetailDto,
  StepExecutionDetailDto$inboundSchema,
  StepExecutionDetailDto$Outbound,
  StepExecutionDetailDto$outboundSchema,
} from './stepexecutiondetaildto.js';

/**
 * Step status
 */
export const StepRunDtoStatus = {
  Pending: 'pending',
  Queued: 'queued',
  Running: 'running',
  Completed: 'completed',
  Failed: 'failed',
  Delayed: 'delayed',
  Canceled: 'canceled',
  Merged: 'merged',
  Skipped: 'skipped',
} as const;
/**
 * Step status
 */
export type StepRunDtoStatus = ClosedEnum<typeof StepRunDtoStatus>;

export type StepRunDto = {
  /**
   * Step run identifier
   */
  stepRunId: string;
  /**
   * Step identifier
   */
  stepId: string;
  /**
   * Step type
   */
  stepType: string;
  /**
   * Provider identifier
   */
  providerId?: string | undefined;
  /**
   * Step status
   */
  status: StepRunDtoStatus;
  /**
   * Creation timestamp
   */
  createdAt: Date;
  /**
   * Update timestamp
   */
  updatedAt: Date;
  /**
   * Execution details
   */
  executionDetails: Array<StepExecutionDetailDto>;
  /**
   * Optional digest for the job, including metadata and events
   */
  digest?: DigestMetadataDto | undefined;
  /**
   * The number of times the digest/delay job has been extended to align with the subscribers schedule
   */
  scheduleExtensionsCount?: number | undefined;
};

/** @internal */
export const StepRunDtoStatus$inboundSchema: z.ZodNativeEnum<typeof StepRunDtoStatus> = z.nativeEnum(StepRunDtoStatus);

/** @internal */
export const StepRunDtoStatus$outboundSchema: z.ZodNativeEnum<typeof StepRunDtoStatus> = StepRunDtoStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepRunDtoStatus$ {
  /** @deprecated use `StepRunDtoStatus$inboundSchema` instead. */
  export const inboundSchema = StepRunDtoStatus$inboundSchema;
  /** @deprecated use `StepRunDtoStatus$outboundSchema` instead. */
  export const outboundSchema = StepRunDtoStatus$outboundSchema;
}

/** @internal */
export const StepRunDto$inboundSchema: z.ZodType<StepRunDto, z.ZodTypeDef, unknown> = z.object({
  stepRunId: z.string(),
  stepId: z.string(),
  stepType: z.string(),
  providerId: z.string().optional(),
  status: StepRunDtoStatus$inboundSchema,
  createdAt: z
    .string()
    .datetime({ offset: true })
    .transform((v) => new Date(v)),
  updatedAt: z
    .string()
    .datetime({ offset: true })
    .transform((v) => new Date(v)),
  executionDetails: z.array(StepExecutionDetailDto$inboundSchema),
  digest: DigestMetadataDto$inboundSchema.optional(),
  scheduleExtensionsCount: z.number().optional(),
});

/** @internal */
export type StepRunDto$Outbound = {
  stepRunId: string;
  stepId: string;
  stepType: string;
  providerId?: string | undefined;
  status: string;
  createdAt: string;
  updatedAt: string;
  executionDetails: Array<StepExecutionDetailDto$Outbound>;
  digest?: DigestMetadataDto$Outbound | undefined;
  scheduleExtensionsCount?: number | undefined;
};

/** @internal */
export const StepRunDto$outboundSchema: z.ZodType<StepRunDto$Outbound, z.ZodTypeDef, StepRunDto> = z.object({
  stepRunId: z.string(),
  stepId: z.string(),
  stepType: z.string(),
  providerId: z.string().optional(),
  status: StepRunDtoStatus$outboundSchema,
  createdAt: z.date().transform((v) => v.toISOString()),
  updatedAt: z.date().transform((v) => v.toISOString()),
  executionDetails: z.array(StepExecutionDetailDto$outboundSchema),
  digest: DigestMetadataDto$outboundSchema.optional(),
  scheduleExtensionsCount: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepRunDto$ {
  /** @deprecated use `StepRunDto$inboundSchema` instead. */
  export const inboundSchema = StepRunDto$inboundSchema;
  /** @deprecated use `StepRunDto$outboundSchema` instead. */
  export const outboundSchema = StepRunDto$outboundSchema;
  /** @deprecated use `StepRunDto$Outbound` instead. */
  export type Outbound = StepRunDto$Outbound;
}

export function stepRunDtoToJSON(stepRunDto: StepRunDto): string {
  return JSON.stringify(StepRunDto$outboundSchema.parse(stepRunDto));
}

export function stepRunDtoFromJSON(jsonString: string): SafeParseResult<StepRunDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepRunDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepRunDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepRunDtoToJSON(stepRunDto: StepRunDto)
 - stepRunDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(StepRunDto$Outbound;
}

export function stepRunDtoToJSON(stepRunDto: StepRunDto): string {
  return ...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepRunDtoToJSON
- export function stepRunDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/stepsoverrides.ts
Tamaño: 2218 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type StepsOverrides = {
  /**
   * Passing the provider id and the provider specific configurations
   */
  providers?: { [k: string]: { [k: string]: any } } | undefined;
  /**
   * Override the or remove the layout for this specific step
   */
  layoutId?: string | null | undefined;
};

/** @internal */
export const StepsOverrides$inboundSchema: z.ZodType<StepsOverrides, z.ZodTypeDef, unknown> = z.object({
  providers: z.record(z.record(z.any())).optional(),
  layoutId: z.nullable(z.string()).optional(),
});

/** @internal */
export type StepsOverrides$Outbound = {
  providers?: { [k: string]: { [k: string]: any } } | undefined;
  layoutId?: string | null | undefined;
};

/** @internal */
export const StepsOverrides$outboundSchema: z.ZodType<StepsOverrides$Outbound, z.ZodTypeDef, StepsOverrides> = z.object(
  {
    providers: z.record(z.record(z.any())).optional(),
    layoutId: z.nullable(z.string()).optional(),
  }
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepsOverrides$ {
  /** @deprecated use `StepsOverrides$inboundSchema` instead. */
  export const inboundSchema = StepsOverrides$inboundSchema;
  /** @deprecated use `StepsOverrides$outboundSchema` instead. */
  export const outboundSchema = StepsOverrides$outboundSchema;
  /** @deprecated use `StepsOverrides$Outbound` instead. */
  export type Outbound = StepsOverrides$Outbound;
}

export function stepsOverridesToJSON(stepsOverrides: StepsOverrides): string {
  return JSON.stringify(StepsOverrides$outboundSchema.parse(stepsOverrides));
}

export function stepsOverridesFromJSON(jsonString: string): SafeParseResult<StepsOverrides, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepsOverrides$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepsOverrides' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepsOverridesToJSON(stepsOverrides: StepsOverrides)
 - stepsOverridesFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(StepsOverrides$Outbound;
}

export function stepsOverridesToJSON(stepsOverrides: StepsOverrides): st...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepsOverridesToJSON
- export function stepsOverridesFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/steptypeenum.ts
Tamaño: 1193 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Type of the step
 */
export const StepTypeEnum = {
  InApp: 'in_app',
  Email: 'email',
  Sms: 'sms',
  Chat: 'chat',
  Push: 'push',
  Digest: 'digest',
  Trigger: 'trigger',
  Delay: 'delay',
  Throttle: 'throttle',
  Custom: 'custom',
} as const;
/**
 * Type of the step
 */
export type StepTypeEnum = ClosedEnum<typeof StepTypeEnum>;

/** @internal */
export const StepTypeEnum$inboundSchema: z.ZodNativeEnum<typeof StepTypeEnum> = z.nativeEnum(StepTypeEnum);

/** @internal */
export const StepTypeEnum$outboundSchema: z.ZodNativeEnum<typeof StepTypeEnum> = StepTypeEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepTypeEnum$ {
  /** @deprecated use `StepTypeEnum$inboundSchema` instead. */
  export const inboundSchema = StepTypeEnum$inboundSchema;
  /** @deprecated use `StepTypeEnum$outboundSchema` instead. */
  export const outboundSchema = StepTypeEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberchanneldto.ts
Tamaño: 4029 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelCredentialsDto,
  ChannelCredentialsDto$inboundSchema,
  ChannelCredentialsDto$Outbound,
  ChannelCredentialsDto$outboundSchema,
} from './channelcredentialsdto.js';

/**
 * The ID of the chat or push provider.
 */
export const ProviderId = {
  Slack: 'slack',
  Discord: 'discord',
  Msteams: 'msteams',
  Mattermost: 'mattermost',
  Ryver: 'ryver',
  Zulip: 'zulip',
  GrafanaOnCall: 'grafana-on-call',
  Getstream: 'getstream',
  RocketChat: 'rocket-chat',
  WhatsappBusiness: 'whatsapp-business',
  ChatWebhook: 'chat-webhook',
  NovuSlack: 'novu-slack',
  Fcm: 'fcm',
  Apns: 'apns',
  Expo: 'expo',
  OneSignal: 'one-signal',
  Pushpad: 'pushpad',
  PushWebhook: 'push-webhook',
  PusherBeams: 'pusher-beams',
} as const;
/**
 * The ID of the chat or push provider.
 */
export type ProviderId = ClosedEnum<typeof ProviderId>;

export type SubscriberChannelDto = {
  /**
   * The ID of the chat or push provider.
   */
  providerId: ProviderId;
  /**
   * An optional identifier for the integration.
   */
  integrationIdentifier?: string | undefined;
  /**
   * Credentials for the channel.
   */
  credentials: ChannelCredentialsDto;
};

/** @internal */
export const ProviderId$inboundSchema: z.ZodNativeEnum<typeof ProviderId> = z.nativeEnum(ProviderId);

/** @internal */
export const ProviderId$outboundSchema: z.ZodNativeEnum<typeof ProviderId> = ProviderId$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ProviderId$ {
  /** @deprecated use `ProviderId$inboundSchema` instead. */
  export const inboundSchema = ProviderId$inboundSchema;
  /** @deprecated use `ProviderId$outboundSchema` instead. */
  export const outboundSchema = ProviderId$outboundSchema;
}

/** @internal */
export const SubscriberChannelDto$inboundSchema: z.ZodType<SubscriberChannelDto, z.ZodTypeDef, unknown> = z.object({
  providerId: ProviderId$inboundSchema,
  integrationIdentifier: z.string().optional(),
  credentials: ChannelCredentialsDto$inboundSchema,
});

/** @internal */
export type SubscriberChannelDto$Outbound = {
  providerId: string;
  integrationIdentifier?: string | undefined;
  credentials: ChannelCredentialsDto$Outbound;
};

/** @internal */
export const SubscriberChannelDto$outboundSchema: z.ZodType<
  SubscriberChannelDto$Outbound,
  z.ZodTypeDef,
  SubscriberChannelDto
> = z.object({
  providerId: ProviderId$outboundSchema,
  integrationIdentifier: z.string().optional(),
  credentials: ChannelCredentialsDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberChannelDto$ {
  /** @deprecated use `SubscriberChannelDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberChannelDto$inboundSchema;
  /** @deprecated use `SubscriberChannelDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberChannelDto$outboundSchema;
  /** @deprecated use `SubscriberChannelDto$Outbound` instead. */
  export type Outbound = SubscriberChannelDto$Outbound;
}

export function subscriberChannelDtoToJSON(subscriberChannelDto: SubscriberChannelDto): string {
  return JSON.stringify(SubscriberChannelDto$outboundSchema.parse(subscriberChannelDto));
}

export function subscriberChannelDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriberChannelDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberChannelDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberChannelDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberChannelDtoToJSON(subscriberChannelDto: SubscriberChannelDto)
 - subscriberChannelDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberChannelDto$Outbound;
}

export function subscriberChannelDtoToJSON(subscriberChannelDto: S...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberChannelDtoToJSON
- export function subscriberChannelDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberdto.ts
Tamaño: 3015 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscriberDto = {
  /**
   * The identifier of the subscriber
   */
  id: string;
  /**
   * The external identifier of the subscriber
   */
  subscriberId: string;
  /**
   * The avatar URL of the subscriber
   */
  avatar?: string | null | undefined;
  /**
   * The first name of the subscriber
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the subscriber
   */
  lastName?: string | null | undefined;
  /**
   * The email of the subscriber
   */
  email?: string | null | undefined;
};

/** @internal */
export const SubscriberDto$inboundSchema: z.ZodType<SubscriberDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    subscriberId: z.string(),
    avatar: z.nullable(z.string()).optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type SubscriberDto$Outbound = {
  _id: string;
  subscriberId: string;
  avatar?: string | null | undefined;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  email?: string | null | undefined;
};

/** @internal */
export const SubscriberDto$outboundSchema: z.ZodType<SubscriberDto$Outbound, z.ZodTypeDef, SubscriberDto> = z
  .object({
    id: z.string(),
    subscriberId: z.string(),
    avatar: z.nullable(z.string()).optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberDto$ {
  /** @deprecated use `SubscriberDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberDto$inboundSchema;
  /** @deprecated use `SubscriberDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberDto$outboundSchema;
  /** @deprecated use `SubscriberDto$Outbound` instead. */
  export type Outbound = SubscriberDto$Outbound;
}

export function subscriberDtoToJSON(subscriberDto: SubscriberDto): string {
  return JSON.stringify(SubscriberDto$outboundSchema.parse(subscriberDto));
}

export function subscriberDtoFromJSON(jsonString: string): SafeParseResult<SubscriberDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberDtoToJSON(subscriberDto: SubscriberDto)
 - subscriberDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberDto$Outbound;
}

export function subscriberDtoToJSON(subscriberDto: SubscriberDto): string...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberDtoToJSON
- export function subscriberDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberfeedresponsedto.ts
Tamaño: 3232 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscriberFeedResponseDto = {
  /**
   * The internal ID generated by Novu for your subscriber. This ID does not match the `subscriberId` used in your queries. Refer to `subscriberId` for that identifier.
   */
  id?: string | undefined;
  /**
   * The first name of the subscriber.
   */
  firstName?: string | undefined;
  /**
   * The last name of the subscriber.
   */
  lastName?: string | undefined;
  /**
   * The URL of the subscriber's avatar image.
   */
  avatar?: string | undefined;
  /**
   * The identifier used to create this subscriber, which typically corresponds to the user ID in your system.
   */
  subscriberId: string;
};

/** @internal */
export const SubscriberFeedResponseDto$inboundSchema: z.ZodType<SubscriberFeedResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    avatar: z.string().optional(),
    subscriberId: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type SubscriberFeedResponseDto$Outbound = {
  _id?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  avatar?: string | undefined;
  subscriberId: string;
};

/** @internal */
export const SubscriberFeedResponseDto$outboundSchema: z.ZodType<
  SubscriberFeedResponseDto$Outbound,
  z.ZodTypeDef,
  SubscriberFeedResponseDto
> = z
  .object({
    id: z.string().optional(),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    avatar: z.string().optional(),
    subscriberId: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberFeedResponseDto$ {
  /** @deprecated use `SubscriberFeedResponseDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberFeedResponseDto$inboundSchema;
  /** @deprecated use `SubscriberFeedResponseDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberFeedResponseDto$outboundSchema;
  /** @deprecated use `SubscriberFeedResponseDto$Outbound` instead. */
  export type Outbound = SubscriberFeedResponseDto$Outbound;
}

export function subscriberFeedResponseDtoToJSON(subscriberFeedResponseDto: SubscriberFeedResponseDto): string {
  return JSON.stringify(SubscriberFeedResponseDto$outboundSchema.parse(subscriberFeedResponseDto));
}

export function subscriberFeedResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriberFeedResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberFeedResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberFeedResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberFeedResponseDtoToJSON(subscriberFeedResponseDto: SubscriberFeedResponseDto)
 - subscriberFeedResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberFeedResponseDto$Outbound;
}

export function subscriberFeedResponseDtoToJSON(subscriberFee...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberFeedResponseDtoToJSON
- export function subscriberFeedResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberglobalpreferencedto.ts
Tamaño: 2995 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ScheduleDto,
  ScheduleDto$inboundSchema,
  ScheduleDto$Outbound,
  ScheduleDto$outboundSchema,
} from './scheduledto.js';
import {
  SubscriberPreferenceChannels,
  SubscriberPreferenceChannels$inboundSchema,
  SubscriberPreferenceChannels$Outbound,
  SubscriberPreferenceChannels$outboundSchema,
} from './subscriberpreferencechannels.js';

export type SubscriberGlobalPreferenceDto = {
  /**
   * Whether notifications are enabled globally
   */
  enabled: boolean;
  /**
   * Channel-specific preference settings
   */
  channels: SubscriberPreferenceChannels;
  /**
   * Subscriber schedule
   */
  schedule?: ScheduleDto | undefined;
};

/** @internal */
export const SubscriberGlobalPreferenceDto$inboundSchema: z.ZodType<
  SubscriberGlobalPreferenceDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean(),
  channels: SubscriberPreferenceChannels$inboundSchema,
  schedule: ScheduleDto$inboundSchema.optional(),
});

/** @internal */
export type SubscriberGlobalPreferenceDto$Outbound = {
  enabled: boolean;
  channels: SubscriberPreferenceChannels$Outbound;
  schedule?: ScheduleDto$Outbound | undefined;
};

/** @internal */
export const SubscriberGlobalPreferenceDto$outboundSchema: z.ZodType<
  SubscriberGlobalPreferenceDto$Outbound,
  z.ZodTypeDef,
  SubscriberGlobalPreferenceDto
> = z.object({
  enabled: z.boolean(),
  channels: SubscriberPreferenceChannels$outboundSchema,
  schedule: ScheduleDto$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberGlobalPreferenceDto$ {
  /** @deprecated use `SubscriberGlobalPreferenceDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberGlobalPreferenceDto$inboundSchema;
  /** @deprecated use `SubscriberGlobalPreferenceDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberGlobalPreferenceDto$outboundSchema;
  /** @deprecated use `SubscriberGlobalPreferenceDto$Outbound` instead. */
  export type Outbound = SubscriberGlobalPreferenceDto$Outbound;
}

export function subscriberGlobalPreferenceDtoToJSON(
  subscriberGlobalPreferenceDto: SubscriberGlobalPreferenceDto
): string {
  return JSON.stringify(SubscriberGlobalPreferenceDto$outboundSchema.parse(subscriberGlobalPreferenceDto));
}

export function subscriberGlobalPreferenceDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriberGlobalPreferenceDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberGlobalPreferenceDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberGlobalPreferenceDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberGlobalPreferenceDtoToJSON(subscriberGlobalPreferenceDto: SubscriberGlobalPreferenceDto)
 - subscriberGlobalPreferenceDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberGlobalPreferenceDto$Outbound;
}

export function subscriberGlobalPreferenceDtoToJSON(
  su...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberGlobalPreferenceDtoToJSON
- export function subscriberGlobalPreferenceDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberpayloaddto.ts
Tamaño: 6025 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  SubscriberChannelDto,
  SubscriberChannelDto$inboundSchema,
  SubscriberChannelDto$Outbound,
  SubscriberChannelDto$outboundSchema,
} from './subscriberchanneldto.js';

export type SubscriberPayloadDtoData = string | Array<string> | boolean | number;

export type SubscriberPayloadDto = {
  /**
   * The internal identifier you used to create this subscriber, usually correlates to the id the user in your systems
   */
  subscriberId: string;
  /**
   * The email address of the subscriber.
   */
  email?: string | undefined;
  /**
   * The first name of the subscriber.
   */
  firstName?: string | undefined;
  /**
   * The last name of the subscriber.
   */
  lastName?: string | undefined;
  /**
   * The phone number of the subscriber.
   */
  phone?: string | undefined;
  /**
   * An HTTP URL to the profile image of your subscriber.
   */
  avatar?: string | undefined;
  /**
   * The locale of the subscriber.
   */
  locale?: string | undefined;
  /**
   * An optional payload object that can contain any properties.
   */
  data?: { [k: string]: string | Array<string> | boolean | number } | undefined;
  /**
   * An optional array of subscriber channels.
   */
  channels?: Array<SubscriberChannelDto> | undefined;
  /**
   * The timezone of the subscriber.
   */
  timezone?: string | undefined;
};

/** @internal */
export const SubscriberPayloadDtoData$inboundSchema: z.ZodType<SubscriberPayloadDtoData, z.ZodTypeDef, unknown> =
  z.union([z.string(), z.array(z.string()), z.boolean(), z.number()]);

/** @internal */
export type SubscriberPayloadDtoData$Outbound = string | Array<string> | boolean | number;

/** @internal */
export const SubscriberPayloadDtoData$outboundSchema: z.ZodType<
  SubscriberPayloadDtoData$Outbound,
  z.ZodTypeDef,
  SubscriberPayloadDtoData
> = z.union([z.string(), z.array(z.string()), z.boolean(), z.number()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberPayloadDtoData$ {
  /** @deprecated use `SubscriberPayloadDtoData$inboundSchema` instead. */
  export const inboundSchema = SubscriberPayloadDtoData$inboundSchema;
  /** @deprecated use `SubscriberPayloadDtoData$outboundSchema` instead. */
  export const outboundSchema = SubscriberPayloadDtoData$outboundSchema;
  /** @deprecated use `SubscriberPayloadDtoData$Outbound` instead. */
  export type Outbound = SubscriberPayloadDtoData$Outbound;
}

export function subscriberPayloadDtoDataToJSON(subscriberPayloadDtoData: SubscriberPayloadDtoData): string {
  return JSON.stringify(SubscriberPayloadDtoData$outboundSchema.parse(subscriberPayloadDtoData));
}

export function subscriberPayloadDtoDataFromJSON(
  jsonString: string
): SafeParseResult<SubscriberPayloadDtoData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberPayloadDtoData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberPayloadDtoData' from JSON`
  );
}

/** @internal */
export const SubscriberPayloadDto$inboundSchema: z.ZodType<SubscriberPayloadDto, z.ZodTypeDef, unknown> = z.object({
  subscriberId: z.string(),
  email: z.string().optional(),
  firstName: z.string().optional(),
  lastName: z.string().optional(),
  phone: z.string().optional(),
  avatar: z.string().optional(),
  locale: z.string().optional(),
  data: z.record(z.union([z.string(), z.array(z.string()), z.boolean(), z.number()])).optional(),
  channels: z.array(SubscriberChannelDto$inboundSchema).optional(),
  timezone: z.string().optional(),
});

/** @internal */
export type SubscriberPayloadDto$Outbound = {
  subscriberId: string;
  email?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  avatar?: string | undefined;
  locale?: string | undefined;
  data?: { [k: string]: string | Array<string> | boolean | number } | undefined;
  channels?: Array<SubscriberChannelDto$Outbound> | undefined;
  timezone?: string | undefined;
};

/** @internal */
export const SubscriberPayloadDto$outboundSchema: z.ZodType<
  SubscriberPayloadDto$Outbound,
  z.ZodTypeDef,
  SubscriberPayloadDto
> = z.object({
  subscriberId: z.string(),
  email: z.string().optional(),
  firstName: z.string().optional(),
  lastName: z.string().optional(),
  phone: z.string().optional(),
  avatar: z.string().optional(),
  locale: z.string().optional(),
  data: z.record(z.union([z.string(), z.array(z.string()), z.boolean(), z.number()])).optional(),
  channels: z.array(SubscriberChannelDto$outboundSchema).optional(),
  timezone: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberPayloadDto$ {
  /** @deprecated use `SubscriberPayloadDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberPayloadDto$inboundSchema;
  /** @deprecated use `SubscriberPayloadDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberPayloadDto$outboundSchema;
  /** @deprecated use `SubscriberPayloadDto$Outbound` instead. */
  export type Outbound = SubscriberPayloadDto$Outbound;
}

export function subscriberPayloadDtoToJSON(subscriberPayloadDto: SubscriberPayloadDto): string {
  return JSON.stringify(SubscriberPayloadDto$outboundSchema.parse(subscriberPayloadDto));
}

export function subscriberPayloadDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriberPayloadDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberPayloadDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberPayloadDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberPayloadDtoDataToJSON(subscriberPayloadDtoData: SubscriberPayloadDtoData)
 - subscriberPayloadDtoDataFromJSON(jsonString: string)
 - subscriberPayloadDtoToJSON(subscriberPayloadDto: SubscriberPayloadDto)
 - subscriberPayloadDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberPayloadDtoData$Outbound;
}

export function subscriberPayloadDtoDataToJSON(subscriberPaylo...)
 - Outbound(SubscriberPayloadDto$Outbound;
}

export function subscriberPayloadDtoToJSON(subscriberPayloadDto: S...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberPayloadDtoDataToJSON
- export function subscriberPayloadDtoDataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberPayloadDtoToJSON
- export function subscriberPayloadDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberpreferencechannels.ts
Tamaño: 3081 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscriberPreferenceChannels = {
  /**
   * Email channel preference
   */
  email?: boolean | undefined;
  /**
   * SMS channel preference
   */
  sms?: boolean | undefined;
  /**
   * In-app channel preference
   */
  inApp?: boolean | undefined;
  /**
   * Chat channel preference
   */
  chat?: boolean | undefined;
  /**
   * Push notification channel preference
   */
  push?: boolean | undefined;
};

/** @internal */
export const SubscriberPreferenceChannels$inboundSchema: z.ZodType<
  SubscriberPreferenceChannels,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    email: z.boolean().optional(),
    sms: z.boolean().optional(),
    in_app: z.boolean().optional(),
    chat: z.boolean().optional(),
    push: z.boolean().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      in_app: 'inApp',
    });
  });

/** @internal */
export type SubscriberPreferenceChannels$Outbound = {
  email?: boolean | undefined;
  sms?: boolean | undefined;
  in_app?: boolean | undefined;
  chat?: boolean | undefined;
  push?: boolean | undefined;
};

/** @internal */
export const SubscriberPreferenceChannels$outboundSchema: z.ZodType<
  SubscriberPreferenceChannels$Outbound,
  z.ZodTypeDef,
  SubscriberPreferenceChannels
> = z
  .object({
    email: z.boolean().optional(),
    sms: z.boolean().optional(),
    inApp: z.boolean().optional(),
    chat: z.boolean().optional(),
    push: z.boolean().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      inApp: 'in_app',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberPreferenceChannels$ {
  /** @deprecated use `SubscriberPreferenceChannels$inboundSchema` instead. */
  export const inboundSchema = SubscriberPreferenceChannels$inboundSchema;
  /** @deprecated use `SubscriberPreferenceChannels$outboundSchema` instead. */
  export const outboundSchema = SubscriberPreferenceChannels$outboundSchema;
  /** @deprecated use `SubscriberPreferenceChannels$Outbound` instead. */
  export type Outbound = SubscriberPreferenceChannels$Outbound;
}

export function subscriberPreferenceChannelsToJSON(subscriberPreferenceChannels: SubscriberPreferenceChannels): string {
  return JSON.stringify(SubscriberPreferenceChannels$outboundSchema.parse(subscriberPreferenceChannels));
}

export function subscriberPreferenceChannelsFromJSON(
  jsonString: string
): SafeParseResult<SubscriberPreferenceChannels, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberPreferenceChannels$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberPreferenceChannels' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberPreferenceChannelsToJSON(subscriberPreferenceChannels: SubscriberPreferenceChannels)
 - subscriberPreferenceChannelsFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberPreferenceChannels$Outbound;
}

export function subscriberPreferenceChannelsToJSON(subscri...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberPreferenceChannelsToJSON
- export function subscriberPreferenceChannelsFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberpreferenceoverridedto.ts
Tamaño: 2758 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { ChannelTypeEnum, ChannelTypeEnum$inboundSchema, ChannelTypeEnum$outboundSchema } from './channeltypeenum.js';
import {
  PreferenceOverrideSourceEnum,
  PreferenceOverrideSourceEnum$inboundSchema,
  PreferenceOverrideSourceEnum$outboundSchema,
} from './preferenceoverridesourceenum.js';

export type SubscriberPreferenceOverrideDto = {
  /**
   * Channel type through which the message is sent
   */
  channel: ChannelTypeEnum;
  /**
   * The source of overrides
   */
  source: PreferenceOverrideSourceEnum;
};

/** @internal */
export const SubscriberPreferenceOverrideDto$inboundSchema: z.ZodType<
  SubscriberPreferenceOverrideDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  channel: ChannelTypeEnum$inboundSchema,
  source: PreferenceOverrideSourceEnum$inboundSchema,
});

/** @internal */
export type SubscriberPreferenceOverrideDto$Outbound = {
  channel: string;
  source: string;
};

/** @internal */
export const SubscriberPreferenceOverrideDto$outboundSchema: z.ZodType<
  SubscriberPreferenceOverrideDto$Outbound,
  z.ZodTypeDef,
  SubscriberPreferenceOverrideDto
> = z.object({
  channel: ChannelTypeEnum$outboundSchema,
  source: PreferenceOverrideSourceEnum$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberPreferenceOverrideDto$ {
  /** @deprecated use `SubscriberPreferenceOverrideDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberPreferenceOverrideDto$inboundSchema;
  /** @deprecated use `SubscriberPreferenceOverrideDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberPreferenceOverrideDto$outboundSchema;
  /** @deprecated use `SubscriberPreferenceOverrideDto$Outbound` instead. */
  export type Outbound = SubscriberPreferenceOverrideDto$Outbound;
}

export function subscriberPreferenceOverrideDtoToJSON(
  subscriberPreferenceOverrideDto: SubscriberPreferenceOverrideDto
): string {
  return JSON.stringify(SubscriberPreferenceOverrideDto$outboundSchema.parse(subscriberPreferenceOverrideDto));
}

export function subscriberPreferenceOverrideDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriberPreferenceOverrideDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberPreferenceOverrideDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberPreferenceOverrideDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberPreferenceOverrideDtoToJSON(subscriberPreferenceOverrideDto: SubscriberPreferenceOverrideDto)
 - subscriberPreferenceOverrideDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberPreferenceOverrideDto$Outbound;
}

export function subscriberPreferenceOverrideDtoToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberPreferenceOverrideDtoToJSON
- export function subscriberPreferenceOverrideDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberpreferencesworkflowinfodto.ts
Tamaño: 2723 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscriberPreferencesWorkflowInfoDto = {
  /**
   * Workflow slug
   */
  slug: string;
  /**
   * Unique identifier of the workflow
   */
  identifier: string;
  /**
   * Display name of the workflow
   */
  name: string;
  /**
   * last updated date
   */
  updatedAt?: string | undefined;
};

/** @internal */
export const SubscriberPreferencesWorkflowInfoDto$inboundSchema: z.ZodType<
  SubscriberPreferencesWorkflowInfoDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  slug: z.string(),
  identifier: z.string(),
  name: z.string(),
  updatedAt: z.string().optional(),
});

/** @internal */
export type SubscriberPreferencesWorkflowInfoDto$Outbound = {
  slug: string;
  identifier: string;
  name: string;
  updatedAt?: string | undefined;
};

/** @internal */
export const SubscriberPreferencesWorkflowInfoDto$outboundSchema: z.ZodType<
  SubscriberPreferencesWorkflowInfoDto$Outbound,
  z.ZodTypeDef,
  SubscriberPreferencesWorkflowInfoDto
> = z.object({
  slug: z.string(),
  identifier: z.string(),
  name: z.string(),
  updatedAt: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberPreferencesWorkflowInfoDto$ {
  /** @deprecated use `SubscriberPreferencesWorkflowInfoDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberPreferencesWorkflowInfoDto$inboundSchema;
  /** @deprecated use `SubscriberPreferencesWorkflowInfoDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberPreferencesWorkflowInfoDto$outboundSchema;
  /** @deprecated use `SubscriberPreferencesWorkflowInfoDto$Outbound` instead. */
  export type Outbound = SubscriberPreferencesWorkflowInfoDto$Outbound;
}

export function subscriberPreferencesWorkflowInfoDtoToJSON(
  subscriberPreferencesWorkflowInfoDto: SubscriberPreferencesWorkflowInfoDto
): string {
  return JSON.stringify(
    SubscriberPreferencesWorkflowInfoDto$outboundSchema.parse(subscriberPreferencesWorkflowInfoDto)
  );
}

export function subscriberPreferencesWorkflowInfoDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriberPreferencesWorkflowInfoDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberPreferencesWorkflowInfoDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberPreferencesWorkflowInfoDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberPreferencesWorkflowInfoDtoToJSON(subscriberPreferencesWorkflowInfoDto: SubscriberPreferencesWorkflowInfoDto)
 - subscriberPreferencesWorkflowInfoDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberPreferencesWorkflowInfoDto$Outbound;
}

export function subscriberPreferencesWorkflowInfoD...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberPreferencesWorkflowInfoDtoToJSON
- export function subscriberPreferencesWorkflowInfoDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberresponsedto.ts
Tamaño: 7178 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelSettingsDto,
  ChannelSettingsDto$inboundSchema,
  ChannelSettingsDto$Outbound,
  ChannelSettingsDto$outboundSchema,
} from './channelsettingsdto.js';

export type SubscriberResponseDto = {
  /**
   * The internal ID generated by Novu for your subscriber. This ID does not match the `subscriberId` used in your queries. Refer to `subscriberId` for that identifier.
   */
  id?: string | undefined;
  /**
   * The first name of the subscriber.
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the subscriber.
   */
  lastName?: string | null | undefined;
  /**
   * The email address of the subscriber.
   */
  email?: string | null | undefined;
  /**
   * The phone number of the subscriber.
   */
  phone?: string | null | undefined;
  /**
   * The URL of the subscriber's avatar image.
   */
  avatar?: string | null | undefined;
  /**
   * The locale setting of the subscriber, indicating their preferred language or region.
   */
  locale?: string | null | undefined;
  /**
   * An array of channel settings associated with the subscriber.
   */
  channels?: Array<ChannelSettingsDto> | undefined;
  /**
   * An array of topics that the subscriber is subscribed to.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  topics?: Array<string> | undefined;
  /**
   * Indicates whether the subscriber is currently online.
   */
  isOnline?: boolean | null | undefined;
  /**
   * The timestamp indicating when the subscriber was last online, in ISO 8601 format.
   */
  lastOnlineAt?: string | null | undefined;
  /**
   * The version of the subscriber document.
   */
  v?: number | undefined;
  /**
   * Additional custom data for the subscriber
   */
  data?: { [k: string]: any } | null | undefined;
  /**
   * Timezone of the subscriber
   */
  timezone?: string | null | undefined;
  /**
   * The identifier used to create this subscriber, which typically corresponds to the user ID in your system.
   */
  subscriberId: string;
  /**
   * The unique identifier of the organization to which the subscriber belongs.
   */
  organizationId: string;
  /**
   * The unique identifier of the environment associated with this subscriber.
   */
  environmentId: string;
  /**
   * Indicates whether the subscriber has been deleted.
   */
  deleted: boolean;
  /**
   * The timestamp indicating when the subscriber was created, in ISO 8601 format.
   */
  createdAt: string;
  /**
   * The timestamp indicating when the subscriber was last updated, in ISO 8601 format.
   */
  updatedAt: string;
};

/** @internal */
export const SubscriberResponseDto$inboundSchema: z.ZodType<SubscriberResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
    phone: z.nullable(z.string()).optional(),
    avatar: z.nullable(z.string()).optional(),
    locale: z.nullable(z.string()).optional(),
    channels: z.array(ChannelSettingsDto$inboundSchema).optional(),
    topics: z.array(z.string()).optional(),
    isOnline: z.nullable(z.boolean()).optional(),
    lastOnlineAt: z.nullable(z.string()).optional(),
    __v: z.number().optional(),
    data: z.nullable(z.record(z.any())).optional(),
    timezone: z.nullable(z.string()).optional(),
    subscriberId: z.string(),
    _organizationId: z.string(),
    _environmentId: z.string(),
    deleted: z.boolean(),
    createdAt: z.string(),
    updatedAt: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      __v: 'v',
      _organizationId: 'organizationId',
      _environmentId: 'environmentId',
    });
  });

/** @internal */
export type SubscriberResponseDto$Outbound = {
  _id?: string | undefined;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  email?: string | null | undefined;
  phone?: string | null | undefined;
  avatar?: string | null | undefined;
  locale?: string | null | undefined;
  channels?: Array<ChannelSettingsDto$Outbound> | undefined;
  topics?: Array<string> | undefined;
  isOnline?: boolean | null | undefined;
  lastOnlineAt?: string | null | undefined;
  __v?: number | undefined;
  data?: { [k: string]: any } | null | undefined;
  timezone?: string | null | undefined;
  subscriberId: string;
  _organizationId: string;
  _environmentId: string;
  deleted: boolean;
  createdAt: string;
  updatedAt: string;
};

/** @internal */
export const SubscriberResponseDto$outboundSchema: z.ZodType<
  SubscriberResponseDto$Outbound,
  z.ZodTypeDef,
  SubscriberResponseDto
> = z
  .object({
    id: z.string().optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
    phone: z.nullable(z.string()).optional(),
    avatar: z.nullable(z.string()).optional(),
    locale: z.nullable(z.string()).optional(),
    channels: z.array(ChannelSettingsDto$outboundSchema).optional(),
    topics: z.array(z.string()).optional(),
    isOnline: z.nullable(z.boolean()).optional(),
    lastOnlineAt: z.nullable(z.string()).optional(),
    v: z.number().optional(),
    data: z.nullable(z.record(z.any())).optional(),
    timezone: z.nullable(z.string()).optional(),
    subscriberId: z.string(),
    organizationId: z.string(),
    environmentId: z.string(),
    deleted: z.boolean(),
    createdAt: z.string(),
    updatedAt: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      v: '__v',
      organizationId: '_organizationId',
      environmentId: '_environmentId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberResponseDto$ {
  /** @deprecated use `SubscriberResponseDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberResponseDto$inboundSchema;
  /** @deprecated use `SubscriberResponseDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberResponseDto$outboundSchema;
  /** @deprecated use `SubscriberResponseDto$Outbound` instead. */
  export type Outbound = SubscriberResponseDto$Outbound;
}

export function subscriberResponseDtoToJSON(subscriberResponseDto: SubscriberResponseDto): string {
  return JSON.stringify(SubscriberResponseDto$outboundSchema.parse(subscriberResponseDto));
}

export function subscriberResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriberResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberResponseDtoToJSON(subscriberResponseDto: SubscriberResponseDto)
 - subscriberResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberResponseDto$Outbound;
}

export function subscriberResponseDtoToJSON(subscriberResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberResponseDtoToJSON
- export function subscriberResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberresponsedtooptional.ts
Tamaño: 6021 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelSettingsDto,
  ChannelSettingsDto$inboundSchema,
  ChannelSettingsDto$Outbound,
  ChannelSettingsDto$outboundSchema,
} from './channelsettingsdto.js';

export type SubscriberResponseDtoOptional = {
  /**
   * The internal ID generated by Novu for your subscriber. This ID does not match the `subscriberId` used in your queries. Refer to `subscriberId` for that identifier.
   */
  id?: string | undefined;
  /**
   * The first name of the subscriber.
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the subscriber.
   */
  lastName?: string | null | undefined;
  /**
   * The email address of the subscriber.
   */
  email?: string | null | undefined;
  /**
   * The phone number of the subscriber.
   */
  phone?: string | null | undefined;
  /**
   * The URL of the subscriber's avatar image.
   */
  avatar?: string | null | undefined;
  /**
   * The locale setting of the subscriber, indicating their preferred language or region.
   */
  locale?: string | null | undefined;
  /**
   * An array of channel settings associated with the subscriber.
   */
  channels?: Array<ChannelSettingsDto> | undefined;
  /**
   * An array of topics that the subscriber is subscribed to.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  topics?: Array<string> | undefined;
  /**
   * Indicates whether the subscriber is currently online.
   */
  isOnline?: boolean | null | undefined;
  /**
   * The timestamp indicating when the subscriber was last online, in ISO 8601 format.
   */
  lastOnlineAt?: string | null | undefined;
  /**
   * The version of the subscriber document.
   */
  v?: number | undefined;
  /**
   * Additional custom data for the subscriber
   */
  data?: { [k: string]: any } | null | undefined;
  /**
   * Timezone of the subscriber
   */
  timezone?: string | null | undefined;
};

/** @internal */
export const SubscriberResponseDtoOptional$inboundSchema: z.ZodType<
  SubscriberResponseDtoOptional,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    _id: z.string().optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
    phone: z.nullable(z.string()).optional(),
    avatar: z.nullable(z.string()).optional(),
    locale: z.nullable(z.string()).optional(),
    channels: z.array(ChannelSettingsDto$inboundSchema).optional(),
    topics: z.array(z.string()).optional(),
    isOnline: z.nullable(z.boolean()).optional(),
    lastOnlineAt: z.nullable(z.string()).optional(),
    __v: z.number().optional(),
    data: z.nullable(z.record(z.any())).optional(),
    timezone: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      __v: 'v',
    });
  });

/** @internal */
export type SubscriberResponseDtoOptional$Outbound = {
  _id?: string | undefined;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  email?: string | null | undefined;
  phone?: string | null | undefined;
  avatar?: string | null | undefined;
  locale?: string | null | undefined;
  channels?: Array<ChannelSettingsDto$Outbound> | undefined;
  topics?: Array<string> | undefined;
  isOnline?: boolean | null | undefined;
  lastOnlineAt?: string | null | undefined;
  __v?: number | undefined;
  data?: { [k: string]: any } | null | undefined;
  timezone?: string | null | undefined;
};

/** @internal */
export const SubscriberResponseDtoOptional$outboundSchema: z.ZodType<
  SubscriberResponseDtoOptional$Outbound,
  z.ZodTypeDef,
  SubscriberResponseDtoOptional
> = z
  .object({
    id: z.string().optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
    phone: z.nullable(z.string()).optional(),
    avatar: z.nullable(z.string()).optional(),
    locale: z.nullable(z.string()).optional(),
    channels: z.array(ChannelSettingsDto$outboundSchema).optional(),
    topics: z.array(z.string()).optional(),
    isOnline: z.nullable(z.boolean()).optional(),
    lastOnlineAt: z.nullable(z.string()).optional(),
    v: z.number().optional(),
    data: z.nullable(z.record(z.any())).optional(),
    timezone: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      v: '__v',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberResponseDtoOptional$ {
  /** @deprecated use `SubscriberResponseDtoOptional$inboundSchema` instead. */
  export const inboundSchema = SubscriberResponseDtoOptional$inboundSchema;
  /** @deprecated use `SubscriberResponseDtoOptional$outboundSchema` instead. */
  export const outboundSchema = SubscriberResponseDtoOptional$outboundSchema;
  /** @deprecated use `SubscriberResponseDtoOptional$Outbound` instead. */
  export type Outbound = SubscriberResponseDtoOptional$Outbound;
}

export function subscriberResponseDtoOptionalToJSON(
  subscriberResponseDtoOptional: SubscriberResponseDtoOptional
): string {
  return JSON.stringify(SubscriberResponseDtoOptional$outboundSchema.parse(subscriberResponseDtoOptional));
}

export function subscriberResponseDtoOptionalFromJSON(
  jsonString: string
): SafeParseResult<SubscriberResponseDtoOptional, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberResponseDtoOptional$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberResponseDtoOptional' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberResponseDtoOptionalToJSON(subscriberResponseDtoOptional: SubscriberResponseDtoOptional)
 - subscriberResponseDtoOptionalFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberResponseDtoOptional$Outbound;
}

export function subscriberResponseDtoOptionalToJSON(
  su...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberResponseDtoOptionalToJSON
- export function subscriberResponseDtoOptionalFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberworkflowpreferencedto.ts
Tamaño: 3780 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  SubscriberPreferenceChannels,
  SubscriberPreferenceChannels$inboundSchema,
  SubscriberPreferenceChannels$Outbound,
  SubscriberPreferenceChannels$outboundSchema,
} from './subscriberpreferencechannels.js';
import {
  SubscriberPreferenceOverrideDto,
  SubscriberPreferenceOverrideDto$inboundSchema,
  SubscriberPreferenceOverrideDto$Outbound,
  SubscriberPreferenceOverrideDto$outboundSchema,
} from './subscriberpreferenceoverridedto.js';
import {
  SubscriberPreferencesWorkflowInfoDto,
  SubscriberPreferencesWorkflowInfoDto$inboundSchema,
  SubscriberPreferencesWorkflowInfoDto$Outbound,
  SubscriberPreferencesWorkflowInfoDto$outboundSchema,
} from './subscriberpreferencesworkflowinfodto.js';

export type SubscriberWorkflowPreferenceDto = {
  /**
   * Whether notifications are enabled for this workflow
   */
  enabled: boolean;
  /**
   * Channel-specific preference settings for this workflow
   */
  channels: SubscriberPreferenceChannels;
  /**
   * List of preference overrides
   */
  overrides: Array<SubscriberPreferenceOverrideDto>;
  /**
   * Workflow information
   */
  workflow: SubscriberPreferencesWorkflowInfoDto;
};

/** @internal */
export const SubscriberWorkflowPreferenceDto$inboundSchema: z.ZodType<
  SubscriberWorkflowPreferenceDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean(),
  channels: SubscriberPreferenceChannels$inboundSchema,
  overrides: z.array(SubscriberPreferenceOverrideDto$inboundSchema),
  workflow: SubscriberPreferencesWorkflowInfoDto$inboundSchema,
});

/** @internal */
export type SubscriberWorkflowPreferenceDto$Outbound = {
  enabled: boolean;
  channels: SubscriberPreferenceChannels$Outbound;
  overrides: Array<SubscriberPreferenceOverrideDto$Outbound>;
  workflow: SubscriberPreferencesWorkflowInfoDto$Outbound;
};

/** @internal */
export const SubscriberWorkflowPreferenceDto$outboundSchema: z.ZodType<
  SubscriberWorkflowPreferenceDto$Outbound,
  z.ZodTypeDef,
  SubscriberWorkflowPreferenceDto
> = z.object({
  enabled: z.boolean(),
  channels: SubscriberPreferenceChannels$outboundSchema,
  overrides: z.array(SubscriberPreferenceOverrideDto$outboundSchema),
  workflow: SubscriberPreferencesWorkflowInfoDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberWorkflowPreferenceDto$ {
  /** @deprecated use `SubscriberWorkflowPreferenceDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberWorkflowPreferenceDto$inboundSchema;
  /** @deprecated use `SubscriberWorkflowPreferenceDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberWorkflowPreferenceDto$outboundSchema;
  /** @deprecated use `SubscriberWorkflowPreferenceDto$Outbound` instead. */
  export type Outbound = SubscriberWorkflowPreferenceDto$Outbound;
}

export function subscriberWorkflowPreferenceDtoToJSON(
  subscriberWorkflowPreferenceDto: SubscriberWorkflowPreferenceDto
): string {
  return JSON.stringify(SubscriberWorkflowPreferenceDto$outboundSchema.parse(subscriberWorkflowPreferenceDto));
}

export function subscriberWorkflowPreferenceDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriberWorkflowPreferenceDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberWorkflowPreferenceDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberWorkflowPreferenceDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberWorkflowPreferenceDtoToJSON(subscriberWorkflowPreferenceDto: SubscriberWorkflowPreferenceDto)
 - subscriberWorkflowPreferenceDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberWorkflowPreferenceDto$Outbound;
}

export function subscriberWorkflowPreferenceDtoToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberWorkflowPreferenceDtoToJSON
- export function subscriberWorkflowPreferenceDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriptiondto.ts
Tamaño: 5477 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { TopicDto, TopicDto$inboundSchema, TopicDto$Outbound, TopicDto$outboundSchema } from './topicdto.js';

/**
 * The subscriber information
 */
export type Subscriber = {
  /**
   * The identifier of the subscriber
   */
  id: string;
  /**
   * The external identifier of the subscriber
   */
  subscriberId: string;
  /**
   * The avatar URL of the subscriber
   */
  avatar?: string | null | undefined;
  /**
   * The first name of the subscriber
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the subscriber
   */
  lastName?: string | null | undefined;
  /**
   * The email of the subscriber
   */
  email?: string | null | undefined;
};

export type SubscriptionDto = {
  /**
   * The unique identifier of the subscription
   */
  id: string;
  /**
   * The topic information
   */
  topic: TopicDto;
  /**
   * The subscriber information
   */
  subscriber: Subscriber | null;
  /**
   * The creation date of the subscription
   */
  createdAt: string;
  /**
   * The last update date of the subscription
   */
  updatedAt: string;
};

/** @internal */
export const Subscriber$inboundSchema: z.ZodType<Subscriber, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    subscriberId: z.string(),
    avatar: z.nullable(z.string()).optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type Subscriber$Outbound = {
  _id: string;
  subscriberId: string;
  avatar?: string | null | undefined;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  email?: string | null | undefined;
};

/** @internal */
export const Subscriber$outboundSchema: z.ZodType<Subscriber$Outbound, z.ZodTypeDef, Subscriber> = z
  .object({
    id: z.string(),
    subscriberId: z.string(),
    avatar: z.nullable(z.string()).optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Subscriber$ {
  /** @deprecated use `Subscriber$inboundSchema` instead. */
  export const inboundSchema = Subscriber$inboundSchema;
  /** @deprecated use `Subscriber$outboundSchema` instead. */
  export const outboundSchema = Subscriber$outboundSchema;
  /** @deprecated use `Subscriber$Outbound` instead. */
  export type Outbound = Subscriber$Outbound;
}

export function subscriberToJSON(subscriber: Subscriber): string {
  return JSON.stringify(Subscriber$outboundSchema.parse(subscriber));
}

export function subscriberFromJSON(jsonString: string): SafeParseResult<Subscriber, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Subscriber$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Subscriber' from JSON`
  );
}

/** @internal */
export const SubscriptionDto$inboundSchema: z.ZodType<SubscriptionDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    topic: TopicDto$inboundSchema,
    subscriber: z.nullable(z.lazy(() => Subscriber$inboundSchema)),
    createdAt: z.string(),
    updatedAt: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type SubscriptionDto$Outbound = {
  _id: string;
  topic: TopicDto$Outbound;
  subscriber: Subscriber$Outbound | null;
  createdAt: string;
  updatedAt: string;
};

/** @internal */
export const SubscriptionDto$outboundSchema: z.ZodType<SubscriptionDto$Outbound, z.ZodTypeDef, SubscriptionDto> = z
  .object({
    id: z.string(),
    topic: TopicDto$outboundSchema,
    subscriber: z.nullable(z.lazy(() => Subscriber$outboundSchema)),
    createdAt: z.string(),
    updatedAt: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionDto$ {
  /** @deprecated use `SubscriptionDto$inboundSchema` instead. */
  export const inboundSchema = SubscriptionDto$inboundSchema;
  /** @deprecated use `SubscriptionDto$outboundSchema` instead. */
  export const outboundSchema = SubscriptionDto$outboundSchema;
  /** @deprecated use `SubscriptionDto$Outbound` instead. */
  export type Outbound = SubscriptionDto$Outbound;
}

export function subscriptionDtoToJSON(subscriptionDto: SubscriptionDto): string {
  return JSON.stringify(SubscriptionDto$outboundSchema.parse(subscriptionDto));
}

export function subscriptionDtoFromJSON(jsonString: string): SafeParseResult<SubscriptionDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriptionDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriptionDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberToJSON(subscriber: Subscriber)
 - subscriberFromJSON(jsonString: string)
 - subscriptionDtoToJSON(subscriptionDto: SubscriptionDto)
 - subscriptionDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Subscriber$Outbound;
}

export function subscriberToJSON(subscriber: Subscriber): string {
  return ...)
 - Outbound(SubscriptionDto$Outbound;
}

export function subscriptionDtoToJSON(subscriptionDto: SubscriptionDto)...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberToJSON
- export function subscriberFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriptionDtoToJSON
- export function subscriptionDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriptionerrordto.ts
Tamaño: 2166 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscriptionErrorDto = {
  /**
   * The subscriber ID that failed
   */
  subscriberId: string;
  /**
   * The error code
   */
  code: string;
  /**
   * The error message
   */
  message: string;
};

/** @internal */
export const SubscriptionErrorDto$inboundSchema: z.ZodType<SubscriptionErrorDto, z.ZodTypeDef, unknown> = z.object({
  subscriberId: z.string(),
  code: z.string(),
  message: z.string(),
});

/** @internal */
export type SubscriptionErrorDto$Outbound = {
  subscriberId: string;
  code: string;
  message: string;
};

/** @internal */
export const SubscriptionErrorDto$outboundSchema: z.ZodType<
  SubscriptionErrorDto$Outbound,
  z.ZodTypeDef,
  SubscriptionErrorDto
> = z.object({
  subscriberId: z.string(),
  code: z.string(),
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionErrorDto$ {
  /** @deprecated use `SubscriptionErrorDto$inboundSchema` instead. */
  export const inboundSchema = SubscriptionErrorDto$inboundSchema;
  /** @deprecated use `SubscriptionErrorDto$outboundSchema` instead. */
  export const outboundSchema = SubscriptionErrorDto$outboundSchema;
  /** @deprecated use `SubscriptionErrorDto$Outbound` instead. */
  export type Outbound = SubscriptionErrorDto$Outbound;
}

export function subscriptionErrorDtoToJSON(subscriptionErrorDto: SubscriptionErrorDto): string {
  return JSON.stringify(SubscriptionErrorDto$outboundSchema.parse(subscriptionErrorDto));
}

export function subscriptionErrorDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriptionErrorDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriptionErrorDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriptionErrorDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriptionErrorDtoToJSON(subscriptionErrorDto: SubscriptionErrorDto)
 - subscriptionErrorDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriptionErrorDto$Outbound;
}

export function subscriptionErrorDtoToJSON(subscriptionErrorDto: S...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriptionErrorDtoToJSON
- export function subscriptionErrorDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriptionsdeleteerrordto.ts
Tamaño: 2337 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscriptionsDeleteErrorDto = {
  /**
   * The subscriber ID that failed
   */
  subscriberId: string;
  /**
   * The error code
   */
  code: string;
  /**
   * The error message
   */
  message: string;
};

/** @internal */
export const SubscriptionsDeleteErrorDto$inboundSchema: z.ZodType<SubscriptionsDeleteErrorDto, z.ZodTypeDef, unknown> =
  z.object({
    subscriberId: z.string(),
    code: z.string(),
    message: z.string(),
  });

/** @internal */
export type SubscriptionsDeleteErrorDto$Outbound = {
  subscriberId: string;
  code: string;
  message: string;
};

/** @internal */
export const SubscriptionsDeleteErrorDto$outboundSchema: z.ZodType<
  SubscriptionsDeleteErrorDto$Outbound,
  z.ZodTypeDef,
  SubscriptionsDeleteErrorDto
> = z.object({
  subscriberId: z.string(),
  code: z.string(),
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionsDeleteErrorDto$ {
  /** @deprecated use `SubscriptionsDeleteErrorDto$inboundSchema` instead. */
  export const inboundSchema = SubscriptionsDeleteErrorDto$inboundSchema;
  /** @deprecated use `SubscriptionsDeleteErrorDto$outboundSchema` instead. */
  export const outboundSchema = SubscriptionsDeleteErrorDto$outboundSchema;
  /** @deprecated use `SubscriptionsDeleteErrorDto$Outbound` instead. */
  export type Outbound = SubscriptionsDeleteErrorDto$Outbound;
}

export function subscriptionsDeleteErrorDtoToJSON(subscriptionsDeleteErrorDto: SubscriptionsDeleteErrorDto): string {
  return JSON.stringify(SubscriptionsDeleteErrorDto$outboundSchema.parse(subscriptionsDeleteErrorDto));
}

export function subscriptionsDeleteErrorDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriptionsDeleteErrorDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriptionsDeleteErrorDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriptionsDeleteErrorDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriptionsDeleteErrorDtoToJSON(subscriptionsDeleteErrorDto: SubscriptionsDeleteErrorDto)
 - subscriptionsDeleteErrorDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriptionsDeleteErrorDto$Outbound;
}

export function subscriptionsDeleteErrorDtoToJSON(subscript...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriptionsDeleteErrorDtoToJSON
- export function subscriptionsDeleteErrorDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/syncworkflowdto.ts
Tamaño: 1874 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SyncWorkflowDto = {
  /**
   * Target environment identifier to sync the workflow to
   */
  targetEnvironmentId: string;
};

/** @internal */
export const SyncWorkflowDto$inboundSchema: z.ZodType<SyncWorkflowDto, z.ZodTypeDef, unknown> = z.object({
  targetEnvironmentId: z.string(),
});

/** @internal */
export type SyncWorkflowDto$Outbound = {
  targetEnvironmentId: string;
};

/** @internal */
export const SyncWorkflowDto$outboundSchema: z.ZodType<SyncWorkflowDto$Outbound, z.ZodTypeDef, SyncWorkflowDto> =
  z.object({
    targetEnvironmentId: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SyncWorkflowDto$ {
  /** @deprecated use `SyncWorkflowDto$inboundSchema` instead. */
  export const inboundSchema = SyncWorkflowDto$inboundSchema;
  /** @deprecated use `SyncWorkflowDto$outboundSchema` instead. */
  export const outboundSchema = SyncWorkflowDto$outboundSchema;
  /** @deprecated use `SyncWorkflowDto$Outbound` instead. */
  export type Outbound = SyncWorkflowDto$Outbound;
}

export function syncWorkflowDtoToJSON(syncWorkflowDto: SyncWorkflowDto): string {
  return JSON.stringify(SyncWorkflowDto$outboundSchema.parse(syncWorkflowDto));
}

export function syncWorkflowDtoFromJSON(jsonString: string): SafeParseResult<SyncWorkflowDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncWorkflowDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncWorkflowDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - syncWorkflowDtoToJSON(syncWorkflowDto: SyncWorkflowDto)
 - syncWorkflowDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SyncWorkflowDto$Outbound;
}

export function syncWorkflowDtoToJSON(syncWorkflowDto: SyncWorkflowDto)...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function syncWorkflowDtoToJSON
- export function syncWorkflowDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/tenantpayloaddto.ts
Tamaño: 3695 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TenantPayloadDtoData = {};

export type TenantPayloadDto = {
  identifier?: string | undefined;
  name?: string | undefined;
  data?: TenantPayloadDtoData | undefined;
};

/** @internal */
export const TenantPayloadDtoData$inboundSchema: z.ZodType<TenantPayloadDtoData, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type TenantPayloadDtoData$Outbound = {};

/** @internal */
export const TenantPayloadDtoData$outboundSchema: z.ZodType<
  TenantPayloadDtoData$Outbound,
  z.ZodTypeDef,
  TenantPayloadDtoData
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TenantPayloadDtoData$ {
  /** @deprecated use `TenantPayloadDtoData$inboundSchema` instead. */
  export const inboundSchema = TenantPayloadDtoData$inboundSchema;
  /** @deprecated use `TenantPayloadDtoData$outboundSchema` instead. */
  export const outboundSchema = TenantPayloadDtoData$outboundSchema;
  /** @deprecated use `TenantPayloadDtoData$Outbound` instead. */
  export type Outbound = TenantPayloadDtoData$Outbound;
}

export function tenantPayloadDtoDataToJSON(tenantPayloadDtoData: TenantPayloadDtoData): string {
  return JSON.stringify(TenantPayloadDtoData$outboundSchema.parse(tenantPayloadDtoData));
}

export function tenantPayloadDtoDataFromJSON(
  jsonString: string
): SafeParseResult<TenantPayloadDtoData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TenantPayloadDtoData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TenantPayloadDtoData' from JSON`
  );
}

/** @internal */
export const TenantPayloadDto$inboundSchema: z.ZodType<TenantPayloadDto, z.ZodTypeDef, unknown> = z.object({
  identifier: z.string().optional(),
  name: z.string().optional(),
  data: z.lazy(() => TenantPayloadDtoData$inboundSchema).optional(),
});

/** @internal */
export type TenantPayloadDto$Outbound = {
  identifier?: string | undefined;
  name?: string | undefined;
  data?: TenantPayloadDtoData$Outbound | undefined;
};

/** @internal */
export const TenantPayloadDto$outboundSchema: z.ZodType<TenantPayloadDto$Outbound, z.ZodTypeDef, TenantPayloadDto> =
  z.object({
    identifier: z.string().optional(),
    name: z.string().optional(),
    data: z.lazy(() => TenantPayloadDtoData$outboundSchema).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TenantPayloadDto$ {
  /** @deprecated use `TenantPayloadDto$inboundSchema` instead. */
  export const inboundSchema = TenantPayloadDto$inboundSchema;
  /** @deprecated use `TenantPayloadDto$outboundSchema` instead. */
  export const outboundSchema = TenantPayloadDto$outboundSchema;
  /** @deprecated use `TenantPayloadDto$Outbound` instead. */
  export type Outbound = TenantPayloadDto$Outbound;
}

export function tenantPayloadDtoToJSON(tenantPayloadDto: TenantPayloadDto): string {
  return JSON.stringify(TenantPayloadDto$outboundSchema.parse(tenantPayloadDto));
}

export function tenantPayloadDtoFromJSON(jsonString: string): SafeParseResult<TenantPayloadDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TenantPayloadDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TenantPayloadDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - tenantPayloadDtoDataToJSON(tenantPayloadDtoData: TenantPayloadDtoData)
 - tenantPayloadDtoDataFromJSON(jsonString: string)
 - tenantPayloadDtoToJSON(tenantPayloadDto: TenantPayloadDto)
 - tenantPayloadDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TenantPayloadDtoData$Outbound;
}

export function tenantPayloadDtoDataToJSON(tenantPayloadDtoData: T...)
 - Outbound(TenantPayloadDto$Outbound;
}

export function tenantPayloadDtoToJSON(tenantPayloadDto: TenantPayload...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function tenantPayloadDtoDataToJSON
- export function tenantPayloadDtoDataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function tenantPayloadDtoToJSON
- export function tenantPayloadDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/textalignenum.ts
Tamaño: 1110 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Text alignment for the email block
 */
export const TextAlignEnum = {
  Center: 'center',
  Left: 'left',
  Right: 'right',
} as const;
/**
 * Text alignment for the email block
 */
export type TextAlignEnum = ClosedEnum<typeof TextAlignEnum>;

/** @internal */
export const TextAlignEnum$inboundSchema: z.ZodNativeEnum<typeof TextAlignEnum> = z.nativeEnum(TextAlignEnum);

/** @internal */
export const TextAlignEnum$outboundSchema: z.ZodNativeEnum<typeof TextAlignEnum> = TextAlignEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TextAlignEnum$ {
  /** @deprecated use `TextAlignEnum$inboundSchema` instead. */
  export const inboundSchema = TextAlignEnum$inboundSchema;
  /** @deprecated use `TextAlignEnum$outboundSchema` instead. */
  export const outboundSchema = TextAlignEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/throttlecontroldto.ts
Tamaño: 5836 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * The type of throttle window.
 */
export const ThrottleControlDtoType = {
  Fixed: 'fixed',
  Dynamic: 'dynamic',
} as const;
/**
 * The type of throttle window.
 */
export type ThrottleControlDtoType = ClosedEnum<typeof ThrottleControlDtoType>;

/**
 * The unit of time for the throttle window (required for fixed type).
 */
export const ThrottleControlDtoUnit = {
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
} as const;
/**
 * The unit of time for the throttle window (required for fixed type).
 */
export type ThrottleControlDtoUnit = ClosedEnum<typeof ThrottleControlDtoUnit>;

export type ThrottleControlDto = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * The type of throttle window.
   */
  type?: ThrottleControlDtoType | undefined;
  /**
   * The amount of time for the throttle window (required for fixed type).
   */
  amount?: number | undefined;
  /**
   * The unit of time for the throttle window (required for fixed type).
   */
  unit?: ThrottleControlDtoUnit | undefined;
  /**
   * Key path to retrieve dynamic window value (required for dynamic type).
   */
  dynamicKey?: string | undefined;
  /**
   * The maximum number of executions allowed within the window. Defaults to 1.
   */
  threshold?: number | undefined;
  /**
   * Optional key for grouping throttle rules. If not provided, defaults to workflow and subscriber combination.
   */
  throttleKey?: string | undefined;
};

/** @internal */
export const ThrottleControlDtoType$inboundSchema: z.ZodNativeEnum<typeof ThrottleControlDtoType> =
  z.nativeEnum(ThrottleControlDtoType);

/** @internal */
export const ThrottleControlDtoType$outboundSchema: z.ZodNativeEnum<typeof ThrottleControlDtoType> =
  ThrottleControlDtoType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleControlDtoType$ {
  /** @deprecated use `ThrottleControlDtoType$inboundSchema` instead. */
  export const inboundSchema = ThrottleControlDtoType$inboundSchema;
  /** @deprecated use `ThrottleControlDtoType$outboundSchema` instead. */
  export const outboundSchema = ThrottleControlDtoType$outboundSchema;
}

/** @internal */
export const ThrottleControlDtoUnit$inboundSchema: z.ZodNativeEnum<typeof ThrottleControlDtoUnit> =
  z.nativeEnum(ThrottleControlDtoUnit);

/** @internal */
export const ThrottleControlDtoUnit$outboundSchema: z.ZodNativeEnum<typeof ThrottleControlDtoUnit> =
  ThrottleControlDtoUnit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleControlDtoUnit$ {
  /** @deprecated use `ThrottleControlDtoUnit$inboundSchema` instead. */
  export const inboundSchema = ThrottleControlDtoUnit$inboundSchema;
  /** @deprecated use `ThrottleControlDtoUnit$outboundSchema` instead. */
  export const outboundSchema = ThrottleControlDtoUnit$outboundSchema;
}

/** @internal */
export const ThrottleControlDto$inboundSchema: z.ZodType<ThrottleControlDto, z.ZodTypeDef, unknown> = z.object({
  skip: z.record(z.any()).optional(),
  type: ThrottleControlDtoType$inboundSchema.default('fixed'),
  amount: z.number().optional(),
  unit: ThrottleControlDtoUnit$inboundSchema.optional(),
  dynamicKey: z.string().optional(),
  threshold: z.number().default(1),
  throttleKey: z.string().optional(),
});

/** @internal */
export type ThrottleControlDto$Outbound = {
  skip?: { [k: string]: any } | undefined;
  type: string;
  amount?: number | undefined;
  unit?: string | undefined;
  dynamicKey?: string | undefined;
  threshold: number;
  throttleKey?: string | undefined;
};

/** @internal */
export const ThrottleControlDto$outboundSchema: z.ZodType<
  ThrottleControlDto$Outbound,
  z.ZodTypeDef,
  ThrottleControlDto
> = z.object({
  skip: z.record(z.any()).optional(),
  type: ThrottleControlDtoType$outboundSchema.default('fixed'),
  amount: z.number().optional(),
  unit: ThrottleControlDtoUnit$outboundSchema.optional(),
  dynamicKey: z.string().optional(),
  threshold: z.number().default(1),
  throttleKey: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleControlDto$ {
  /** @deprecated use `ThrottleControlDto$inboundSchema` instead. */
  export const inboundSchema = ThrottleControlDto$inboundSchema;
  /** @deprecated use `ThrottleControlDto$outboundSchema` instead. */
  export const outboundSchema = ThrottleControlDto$outboundSchema;
  /** @deprecated use `ThrottleControlDto$Outbound` instead. */
  export type Outbound = ThrottleControlDto$Outbound;
}

export function throttleControlDtoToJSON(throttleControlDto: ThrottleControlDto): string {
  return JSON.stringify(ThrottleControlDto$outboundSchema.parse(throttleControlDto));
}

export function throttleControlDtoFromJSON(
  jsonString: string
): SafeParseResult<ThrottleControlDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ThrottleControlDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ThrottleControlDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - throttleControlDtoToJSON(throttleControlDto: ThrottleControlDto)
 - throttleControlDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ThrottleControlDto$Outbound;
}

export function throttleControlDtoToJSON(throttleControlDto: Throttl...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function throttleControlDtoToJSON
- export function throttleControlDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/throttlecontrolsmetadataresponsedto.ts
Tamaño: 3078 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ThrottleControlDto,
  ThrottleControlDto$inboundSchema,
  ThrottleControlDto$Outbound,
  ThrottleControlDto$outboundSchema,
} from './throttlecontroldto.js';
import { UiSchema, UiSchema$inboundSchema, UiSchema$Outbound, UiSchema$outboundSchema } from './uischema.js';

export type ThrottleControlsMetadataResponseDto = {
  /**
   * JSON Schema for data
   */
  dataSchema?: { [k: string]: any } | undefined;
  /**
   * UI Schema for rendering
   */
  uiSchema?: UiSchema | undefined;
  /**
   * Control values specific to Throttle
   */
  values: ThrottleControlDto;
};

/** @internal */
export const ThrottleControlsMetadataResponseDto$inboundSchema: z.ZodType<
  ThrottleControlsMetadataResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$inboundSchema.optional(),
  values: ThrottleControlDto$inboundSchema,
});

/** @internal */
export type ThrottleControlsMetadataResponseDto$Outbound = {
  dataSchema?: { [k: string]: any } | undefined;
  uiSchema?: UiSchema$Outbound | undefined;
  values: ThrottleControlDto$Outbound;
};

/** @internal */
export const ThrottleControlsMetadataResponseDto$outboundSchema: z.ZodType<
  ThrottleControlsMetadataResponseDto$Outbound,
  z.ZodTypeDef,
  ThrottleControlsMetadataResponseDto
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$outboundSchema.optional(),
  values: ThrottleControlDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleControlsMetadataResponseDto$ {
  /** @deprecated use `ThrottleControlsMetadataResponseDto$inboundSchema` instead. */
  export const inboundSchema = ThrottleControlsMetadataResponseDto$inboundSchema;
  /** @deprecated use `ThrottleControlsMetadataResponseDto$outboundSchema` instead. */
  export const outboundSchema = ThrottleControlsMetadataResponseDto$outboundSchema;
  /** @deprecated use `ThrottleControlsMetadataResponseDto$Outbound` instead. */
  export type Outbound = ThrottleControlsMetadataResponseDto$Outbound;
}

export function throttleControlsMetadataResponseDtoToJSON(
  throttleControlsMetadataResponseDto: ThrottleControlsMetadataResponseDto
): string {
  return JSON.stringify(ThrottleControlsMetadataResponseDto$outboundSchema.parse(throttleControlsMetadataResponseDto));
}

export function throttleControlsMetadataResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ThrottleControlsMetadataResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ThrottleControlsMetadataResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ThrottleControlsMetadataResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - throttleControlsMetadataResponseDtoToJSON(throttleControlsMetadataResponseDto: ThrottleControlsMetadataResponseDto)
 - throttleControlsMetadataResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ThrottleControlsMetadataResponseDto$Outbound;
}

export function throttleControlsMetadataResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function throttleControlsMetadataResponseDtoToJSON
- export function throttleControlsMetadataResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/throttlestepresponsedto.ts
Tamaño: 11656 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { collectExtraKeys as collectExtraKeys$, safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  StepIssuesDto,
  StepIssuesDto$inboundSchema,
  StepIssuesDto$Outbound,
  StepIssuesDto$outboundSchema,
} from './stepissuesdto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';
import {
  ThrottleControlsMetadataResponseDto,
  ThrottleControlsMetadataResponseDto$inboundSchema,
  ThrottleControlsMetadataResponseDto$Outbound,
  ThrottleControlsMetadataResponseDto$outboundSchema,
} from './throttlecontrolsmetadataresponsedto.js';

/**
 * The type of throttle window.
 */
export const ThrottleStepResponseDtoType = {
  Fixed: 'fixed',
  Dynamic: 'dynamic',
} as const;
/**
 * The type of throttle window.
 */
export type ThrottleStepResponseDtoType = ClosedEnum<typeof ThrottleStepResponseDtoType>;

/**
 * The unit of time for the throttle window (required for fixed type).
 */
export const ThrottleStepResponseDtoUnit = {
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
} as const;
/**
 * The unit of time for the throttle window (required for fixed type).
 */
export type ThrottleStepResponseDtoUnit = ClosedEnum<typeof ThrottleStepResponseDtoUnit>;

/**
 * Control values for the throttle step
 */
export type ThrottleStepResponseDtoControlValues = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * The type of throttle window.
   */
  type?: ThrottleStepResponseDtoType | undefined;
  /**
   * The amount of time for the throttle window (required for fixed type).
   */
  amount?: number | undefined;
  /**
   * The unit of time for the throttle window (required for fixed type).
   */
  unit?: ThrottleStepResponseDtoUnit | undefined;
  /**
   * Key path to retrieve dynamic window value (required for dynamic type).
   */
  dynamicKey?: string | undefined;
  /**
   * The maximum number of executions allowed within the window. Defaults to 1.
   */
  threshold?: number | undefined;
  /**
   * Optional key for grouping throttle rules. If not provided, defaults to workflow and subscriber combination.
   */
  throttleKey?: string | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type ThrottleStepResponseDto = {
  /**
   * Controls metadata for the throttle step
   */
  controls: ThrottleControlsMetadataResponseDto;
  /**
   * Control values for the throttle step
   */
  controlValues?: ThrottleStepResponseDtoControlValues | undefined;
  /**
   * JSON Schema for variables, follows the JSON Schema standard
   */
  variables: { [k: string]: any };
  /**
   * Unique identifier of the step
   */
  stepId: string;
  /**
   * Database identifier of the step
   */
  id: string;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Slug of the step
   */
  slug: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow database identifier
   */
  workflowDatabaseId: string;
  /**
   * Issues associated with the step
   */
  issues?: StepIssuesDto | undefined;
};

/** @internal */
export const ThrottleStepResponseDtoType$inboundSchema: z.ZodNativeEnum<typeof ThrottleStepResponseDtoType> =
  z.nativeEnum(ThrottleStepResponseDtoType);

/** @internal */
export const ThrottleStepResponseDtoType$outboundSchema: z.ZodNativeEnum<typeof ThrottleStepResponseDtoType> =
  ThrottleStepResponseDtoType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleStepResponseDtoType$ {
  /** @deprecated use `ThrottleStepResponseDtoType$inboundSchema` instead. */
  export const inboundSchema = ThrottleStepResponseDtoType$inboundSchema;
  /** @deprecated use `ThrottleStepResponseDtoType$outboundSchema` instead. */
  export const outboundSchema = ThrottleStepResponseDtoType$outboundSchema;
}

/** @internal */
export const ThrottleStepResponseDtoUnit$inboundSchema: z.ZodNativeEnum<typeof ThrottleStepResponseDtoUnit> =
  z.nativeEnum(ThrottleStepResponseDtoUnit);

/** @internal */
export const ThrottleStepResponseDtoUnit$outboundSchema: z.ZodNativeEnum<typeof ThrottleStepResponseDtoUnit> =
  ThrottleStepResponseDtoUnit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleStepResponseDtoUnit$ {
  /** @deprecated use `ThrottleStepResponseDtoUnit$inboundSchema` instead. */
  export const inboundSchema = ThrottleStepResponseDtoUnit$inboundSchema;
  /** @deprecated use `ThrottleStepResponseDtoUnit$outboundSchema` instead. */
  export const outboundSchema = ThrottleStepResponseDtoUnit$outboundSchema;
}

/** @internal */
export const ThrottleStepResponseDtoControlValues$inboundSchema: z.ZodType<
  ThrottleStepResponseDtoControlValues,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z
    .object({
      skip: z.record(z.any()).optional(),
      type: ThrottleStepResponseDtoType$inboundSchema.default('fixed'),
      amount: z.number().optional(),
      unit: ThrottleStepResponseDtoUnit$inboundSchema.optional(),
      dynamicKey: z.string().optional(),
      threshold: z.number().default(1),
      throttleKey: z.string().optional(),
    })
    .catchall(z.any()),
  'additionalProperties',
  true
);

/** @internal */
export type ThrottleStepResponseDtoControlValues$Outbound = {
  skip?: { [k: string]: any } | undefined;
  type: string;
  amount?: number | undefined;
  unit?: string | undefined;
  dynamicKey?: string | undefined;
  threshold: number;
  throttleKey?: string | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const ThrottleStepResponseDtoControlValues$outboundSchema: z.ZodType<
  ThrottleStepResponseDtoControlValues$Outbound,
  z.ZodTypeDef,
  ThrottleStepResponseDtoControlValues
> = z
  .object({
    skip: z.record(z.any()).optional(),
    type: ThrottleStepResponseDtoType$outboundSchema.default('fixed'),
    amount: z.number().optional(),
    unit: ThrottleStepResponseDtoUnit$outboundSchema.optional(),
    dynamicKey: z.string().optional(),
    threshold: z.number().default(1),
    throttleKey: z.string().optional(),
    additionalProperties: z.record(z.any()).optional(),
  })
  .transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleStepResponseDtoControlValues$ {
  /** @deprecated use `ThrottleStepResponseDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = ThrottleStepResponseDtoControlValues$inboundSchema;
  /** @deprecated use `ThrottleStepResponseDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = ThrottleStepResponseDtoControlValues$outboundSchema;
  /** @deprecated use `ThrottleStepResponseDtoControlValues$Outbound` instead. */
  export type Outbound = ThrottleStepResponseDtoControlValues$Outbound;
}

export function throttleStepResponseDtoControlValuesToJSON(
  throttleStepResponseDtoControlValues: ThrottleStepResponseDtoControlValues
): string {
  return JSON.stringify(
    ThrottleStepResponseDtoControlValues$outboundSchema.parse(throttleStepResponseDtoControlValues)
  );
}

export function throttleStepResponseDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<ThrottleStepResponseDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ThrottleStepResponseDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ThrottleStepResponseDtoControlValues' from JSON`
  );
}

/** @internal */
export const ThrottleStepResponseDto$inboundSchema: z.ZodType<ThrottleStepResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    controls: ThrottleControlsMetadataResponseDto$inboundSchema,
    controlValues: z.lazy(() => ThrottleStepResponseDtoControlValues$inboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    _id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$inboundSchema,
    origin: ResourceOriginEnum$inboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type ThrottleStepResponseDto$Outbound = {
  controls: ThrottleControlsMetadataResponseDto$Outbound;
  controlValues?: ThrottleStepResponseDtoControlValues$Outbound | undefined;
  variables: { [k: string]: any };
  stepId: string;
  _id: string;
  name: string;
  slug: string;
  type: string;
  origin: string;
  workflowId: string;
  workflowDatabaseId: string;
  issues?: StepIssuesDto$Outbound | undefined;
};

/** @internal */
export const ThrottleStepResponseDto$outboundSchema: z.ZodType<
  ThrottleStepResponseDto$Outbound,
  z.ZodTypeDef,
  ThrottleStepResponseDto
> = z
  .object({
    controls: ThrottleControlsMetadataResponseDto$outboundSchema,
    controlValues: z.lazy(() => ThrottleStepResponseDtoControlValues$outboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$outboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleStepResponseDto$ {
  /** @deprecated use `ThrottleStepResponseDto$inboundSchema` instead. */
  export const inboundSchema = ThrottleStepResponseDto$inboundSchema;
  /** @deprecated use `ThrottleStepResponseDto$outboundSchema` instead. */
  export const outboundSchema = ThrottleStepResponseDto$outboundSchema;
  /** @deprecated use `ThrottleStepResponseDto$Outbound` instead. */
  export type Outbound = ThrottleStepResponseDto$Outbound;
}

export function throttleStepResponseDtoToJSON(throttleStepResponseDto: ThrottleStepResponseDto): string {
  return JSON.stringify(ThrottleStepResponseDto$outboundSchema.parse(throttleStepResponseDto));
}

export function throttleStepResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ThrottleStepResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ThrottleStepResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ThrottleStepResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - throttleStepResponseDtoControlValuesToJSON(throttleStepResponseDtoControlValues: ThrottleStepResponseDtoControlValues)
 - throttleStepResponseDtoControlValuesFromJSON(jsonString: string)
 - throttleStepResponseDtoToJSON(throttleStepResponseDto: ThrottleStepResponseDto)
 - throttleStepResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ThrottleStepResponseDtoControlValues$Outbound;
}

export function throttleStepResponseDtoControlValu...)
 - Outbound(ThrottleStepResponseDto$Outbound;
}

export function throttleStepResponseDtoToJSON(throttleStepRespo...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function throttleStepResponseDtoControlValuesToJSON
- export function throttleStepResponseDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function throttleStepResponseDtoToJSON
- export function throttleStepResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/throttlestepupsertdto.ts
Tamaño: 5431 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';
import {
  ThrottleControlDto,
  ThrottleControlDto$inboundSchema,
  ThrottleControlDto$Outbound,
  ThrottleControlDto$outboundSchema,
} from './throttlecontroldto.js';

/**
 * Control values for the Throttle step.
 */
export type ThrottleStepUpsertDtoControlValues =
  | ThrottleControlDto
  | {
      [k: string]: any;
    };

export type ThrottleStepUpsertDto = {
  /**
   * Database identifier of the step. Used for updating the step.
   */
  id?: string | undefined;
  /**
   * Unique identifier for the step
   */
  stepId?: string | undefined;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Control values for the Throttle step.
   */
  controlValues?: ThrottleControlDto | { [k: string]: any } | undefined;
};

/** @internal */
export const ThrottleStepUpsertDtoControlValues$inboundSchema: z.ZodType<
  ThrottleStepUpsertDtoControlValues,
  z.ZodTypeDef,
  unknown
> = z.union([ThrottleControlDto$inboundSchema, z.record(z.any())]);

/** @internal */
export type ThrottleStepUpsertDtoControlValues$Outbound = ThrottleControlDto$Outbound | { [k: string]: any };

/** @internal */
export const ThrottleStepUpsertDtoControlValues$outboundSchema: z.ZodType<
  ThrottleStepUpsertDtoControlValues$Outbound,
  z.ZodTypeDef,
  ThrottleStepUpsertDtoControlValues
> = z.union([ThrottleControlDto$outboundSchema, z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleStepUpsertDtoControlValues$ {
  /** @deprecated use `ThrottleStepUpsertDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = ThrottleStepUpsertDtoControlValues$inboundSchema;
  /** @deprecated use `ThrottleStepUpsertDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = ThrottleStepUpsertDtoControlValues$outboundSchema;
  /** @deprecated use `ThrottleStepUpsertDtoControlValues$Outbound` instead. */
  export type Outbound = ThrottleStepUpsertDtoControlValues$Outbound;
}

export function throttleStepUpsertDtoControlValuesToJSON(
  throttleStepUpsertDtoControlValues: ThrottleStepUpsertDtoControlValues
): string {
  return JSON.stringify(ThrottleStepUpsertDtoControlValues$outboundSchema.parse(throttleStepUpsertDtoControlValues));
}

export function throttleStepUpsertDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<ThrottleStepUpsertDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ThrottleStepUpsertDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ThrottleStepUpsertDtoControlValues' from JSON`
  );
}

/** @internal */
export const ThrottleStepUpsertDto$inboundSchema: z.ZodType<ThrottleStepUpsertDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$inboundSchema,
    controlValues: z.union([ThrottleControlDto$inboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type ThrottleStepUpsertDto$Outbound = {
  _id?: string | undefined;
  stepId?: string | undefined;
  name: string;
  type: string;
  controlValues?: ThrottleControlDto$Outbound | { [k: string]: any } | undefined;
};

/** @internal */
export const ThrottleStepUpsertDto$outboundSchema: z.ZodType<
  ThrottleStepUpsertDto$Outbound,
  z.ZodTypeDef,
  ThrottleStepUpsertDto
> = z
  .object({
    id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$outboundSchema,
    controlValues: z.union([ThrottleControlDto$outboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleStepUpsertDto$ {
  /** @deprecated use `ThrottleStepUpsertDto$inboundSchema` instead. */
  export const inboundSchema = ThrottleStepUpsertDto$inboundSchema;
  /** @deprecated use `ThrottleStepUpsertDto$outboundSchema` instead. */
  export const outboundSchema = ThrottleStepUpsertDto$outboundSchema;
  /** @deprecated use `ThrottleStepUpsertDto$Outbound` instead. */
  export type Outbound = ThrottleStepUpsertDto$Outbound;
}

export function throttleStepUpsertDtoToJSON(throttleStepUpsertDto: ThrottleStepUpsertDto): string {
  return JSON.stringify(ThrottleStepUpsertDto$outboundSchema.parse(throttleStepUpsertDto));
}

export function throttleStepUpsertDtoFromJSON(
  jsonString: string
): SafeParseResult<ThrottleStepUpsertDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ThrottleStepUpsertDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ThrottleStepUpsertDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - throttleStepUpsertDtoControlValuesToJSON(throttleStepUpsertDtoControlValues: ThrottleStepUpsertDtoControlValues)
 - throttleStepUpsertDtoControlValuesFromJSON(jsonString: string)
 - throttleStepUpsertDtoToJSON(throttleStepUpsertDto: ThrottleStepUpsertDto)
 - throttleStepUpsertDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ThrottleStepUpsertDtoControlValues$Outbound;
}

export function throttleStepUpsertDtoControlValuesTo...)
 - Outbound(ThrottleStepUpsertDto$Outbound;
}

export function throttleStepUpsertDtoToJSON(throttleStepUpsertDto...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function throttleStepUpsertDtoControlValuesToJSON
- export function throttleStepUpsertDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function throttleStepUpsertDtoToJSON
- export function throttleStepUpsertDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/timedconfig.ts
Tamaño: 6351 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export const TimedConfigWeekDays = {
  Monday: 'monday',
  Tuesday: 'tuesday',
  Wednesday: 'wednesday',
  Thursday: 'thursday',
  Friday: 'friday',
  Saturday: 'saturday',
  Sunday: 'sunday',
} as const;
export type TimedConfigWeekDays = ClosedEnum<typeof TimedConfigWeekDays>;

export const Ordinal = {
  One: '1',
  Two: '2',
  Three: '3',
  Four: '4',
  Five: '5',
  Last: 'last',
} as const;
export type Ordinal = ClosedEnum<typeof Ordinal>;

export const OrdinalValue = {
  Day: 'day',
  Weekday: 'weekday',
  Weekend: 'weekend',
  Sunday: 'sunday',
  Monday: 'monday',
  Tuesday: 'tuesday',
  Wednesday: 'wednesday',
  Thursday: 'thursday',
  Friday: 'friday',
  Saturday: 'saturday',
} as const;
export type OrdinalValue = ClosedEnum<typeof OrdinalValue>;

export const MonthlyType = {
  Each: 'each',
  On: 'on',
} as const;
export type MonthlyType = ClosedEnum<typeof MonthlyType>;

export type TimedConfig = {
  atTime?: string | undefined;
  weekDays?: Array<TimedConfigWeekDays> | undefined;
  monthDays?: Array<string> | undefined;
  ordinal?: Ordinal | undefined;
  ordinalValue?: OrdinalValue | undefined;
  monthlyType?: MonthlyType | undefined;
};

/** @internal */
export const TimedConfigWeekDays$inboundSchema: z.ZodNativeEnum<typeof TimedConfigWeekDays> =
  z.nativeEnum(TimedConfigWeekDays);

/** @internal */
export const TimedConfigWeekDays$outboundSchema: z.ZodNativeEnum<typeof TimedConfigWeekDays> =
  TimedConfigWeekDays$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimedConfigWeekDays$ {
  /** @deprecated use `TimedConfigWeekDays$inboundSchema` instead. */
  export const inboundSchema = TimedConfigWeekDays$inboundSchema;
  /** @deprecated use `TimedConfigWeekDays$outboundSchema` instead. */
  export const outboundSchema = TimedConfigWeekDays$outboundSchema;
}

/** @internal */
export const Ordinal$inboundSchema: z.ZodNativeEnum<typeof Ordinal> = z.nativeEnum(Ordinal);

/** @internal */
export const Ordinal$outboundSchema: z.ZodNativeEnum<typeof Ordinal> = Ordinal$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Ordinal$ {
  /** @deprecated use `Ordinal$inboundSchema` instead. */
  export const inboundSchema = Ordinal$inboundSchema;
  /** @deprecated use `Ordinal$outboundSchema` instead. */
  export const outboundSchema = Ordinal$outboundSchema;
}

/** @internal */
export const OrdinalValue$inboundSchema: z.ZodNativeEnum<typeof OrdinalValue> = z.nativeEnum(OrdinalValue);

/** @internal */
export const OrdinalValue$outboundSchema: z.ZodNativeEnum<typeof OrdinalValue> = OrdinalValue$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrdinalValue$ {
  /** @deprecated use `OrdinalValue$inboundSchema` instead. */
  export const inboundSchema = OrdinalValue$inboundSchema;
  /** @deprecated use `OrdinalValue$outboundSchema` instead. */
  export const outboundSchema = OrdinalValue$outboundSchema;
}

/** @internal */
export const MonthlyType$inboundSchema: z.ZodNativeEnum<typeof MonthlyType> = z.nativeEnum(MonthlyType);

/** @internal */
export const MonthlyType$outboundSchema: z.ZodNativeEnum<typeof MonthlyType> = MonthlyType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MonthlyType$ {
  /** @deprecated use `MonthlyType$inboundSchema` instead. */
  export const inboundSchema = MonthlyType$inboundSchema;
  /** @deprecated use `MonthlyType$outboundSchema` instead. */
  export const outboundSchema = MonthlyType$outboundSchema;
}

/** @internal */
export const TimedConfig$inboundSchema: z.ZodType<TimedConfig, z.ZodTypeDef, unknown> = z.object({
  atTime: z.string().optional(),
  weekDays: z.array(TimedConfigWeekDays$inboundSchema).optional(),
  monthDays: z.array(z.string()).optional(),
  ordinal: Ordinal$inboundSchema.optional(),
  ordinalValue: OrdinalValue$inboundSchema.optional(),
  monthlyType: MonthlyType$inboundSchema.optional(),
});

/** @internal */
export type TimedConfig$Outbound = {
  atTime?: string | undefined;
  weekDays?: Array<string> | undefined;
  monthDays?: Array<string> | undefined;
  ordinal?: string | undefined;
  ordinalValue?: string | undefined;
  monthlyType?: string | undefined;
};

/** @internal */
export const TimedConfig$outboundSchema: z.ZodType<TimedConfig$Outbound, z.ZodTypeDef, TimedConfig> = z.object({
  atTime: z.string().optional(),
  weekDays: z.array(TimedConfigWeekDays$outboundSchema).optional(),
  monthDays: z.array(z.string()).optional(),
  ordinal: Ordinal$outboundSchema.optional(),
  ordinalValue: OrdinalValue$outboundSchema.optional(),
  monthlyType: MonthlyType$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimedConfig$ {
  /** @deprecated use `TimedConfig$inboundSchema` instead. */
  export const inboundSchema = TimedConfig$inboundSchema;
  /** @deprecated use `TimedConfig$outboundSchema` instead. */
  export const outboundSchema = TimedConfig$outboundSchema;
  /** @deprecated use `TimedConfig$Outbound` instead. */
  export type Outbound = TimedConfig$Outbound;
}

export function timedConfigToJSON(timedConfig: TimedConfig): string {
  return JSON.stringify(TimedConfig$outboundSchema.parse(timedConfig));
}

export function timedConfigFromJSON(jsonString: string): SafeParseResult<TimedConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimedConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimedConfig' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - timedConfigToJSON(timedConfig: TimedConfig)
 - timedConfigFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TimedConfig$Outbound;
}

export function timedConfigToJSON(timedConfig: TimedConfig): string {
  ret...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  const
- export  type
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function timedConfigToJSON
- export function timedConfigFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/timerangedto.ts
Tamaño: 1794 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TimeRangeDto = {
  /**
   * Start time
   */
  start: string;
  /**
   * End time
   */
  end: string;
};

/** @internal */
export const TimeRangeDto$inboundSchema: z.ZodType<TimeRangeDto, z.ZodTypeDef, unknown> = z.object({
  start: z.string(),
  end: z.string(),
});

/** @internal */
export type TimeRangeDto$Outbound = {
  start: string;
  end: string;
};

/** @internal */
export const TimeRangeDto$outboundSchema: z.ZodType<TimeRangeDto$Outbound, z.ZodTypeDef, TimeRangeDto> = z.object({
  start: z.string(),
  end: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeRangeDto$ {
  /** @deprecated use `TimeRangeDto$inboundSchema` instead. */
  export const inboundSchema = TimeRangeDto$inboundSchema;
  /** @deprecated use `TimeRangeDto$outboundSchema` instead. */
  export const outboundSchema = TimeRangeDto$outboundSchema;
  /** @deprecated use `TimeRangeDto$Outbound` instead. */
  export type Outbound = TimeRangeDto$Outbound;
}

export function timeRangeDtoToJSON(timeRangeDto: TimeRangeDto): string {
  return JSON.stringify(TimeRangeDto$outboundSchema.parse(timeRangeDto));
}

export function timeRangeDtoFromJSON(jsonString: string): SafeParseResult<TimeRangeDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeRangeDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeRangeDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - timeRangeDtoToJSON(timeRangeDto: TimeRangeDto)
 - timeRangeDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TimeRangeDto$Outbound;
}

export function timeRangeDtoToJSON(timeRangeDto: TimeRangeDto): string {
 ...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function timeRangeDtoToJSON
- export function timeRangeDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/timeunitenum.ts
Tamaño: 1108 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Time unit
 */
export const TimeUnitEnum = {
  Seconds: 'seconds',
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
  Weeks: 'weeks',
  Months: 'months',
} as const;
/**
 * Time unit
 */
export type TimeUnitEnum = ClosedEnum<typeof TimeUnitEnum>;

/** @internal */
export const TimeUnitEnum$inboundSchema: z.ZodNativeEnum<typeof TimeUnitEnum> = z.nativeEnum(TimeUnitEnum);

/** @internal */
export const TimeUnitEnum$outboundSchema: z.ZodNativeEnum<typeof TimeUnitEnum> = TimeUnitEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeUnitEnum$ {
  /** @deprecated use `TimeUnitEnum$inboundSchema` instead. */
  export const inboundSchema = TimeUnitEnum$inboundSchema;
  /** @deprecated use `TimeUnitEnum$outboundSchema` instead. */
  export const outboundSchema = TimeUnitEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/topicdto.ts
Tamaño: 2207 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicDto = {
  /**
   * The internal unique identifier of the topic
   */
  id: string;
  /**
   * The key identifier of the topic used in your application. Should be unique on the environment level.
   */
  key: string;
  /**
   * The name of the topic
   */
  name?: string | undefined;
};

/** @internal */
export const TopicDto$inboundSchema: z.ZodType<TopicDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    key: z.string(),
    name: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type TopicDto$Outbound = {
  _id: string;
  key: string;
  name?: string | undefined;
};

/** @internal */
export const TopicDto$outboundSchema: z.ZodType<TopicDto$Outbound, z.ZodTypeDef, TopicDto> = z
  .object({
    id: z.string(),
    key: z.string(),
    name: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicDto$ {
  /** @deprecated use `TopicDto$inboundSchema` instead. */
  export const inboundSchema = TopicDto$inboundSchema;
  /** @deprecated use `TopicDto$outboundSchema` instead. */
  export const outboundSchema = TopicDto$outboundSchema;
  /** @deprecated use `TopicDto$Outbound` instead. */
  export type Outbound = TopicDto$Outbound;
}

export function topicDtoToJSON(topicDto: TopicDto): string {
  return JSON.stringify(TopicDto$outboundSchema.parse(topicDto));
}

export function topicDtoFromJSON(jsonString: string): SafeParseResult<TopicDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicDtoToJSON(topicDto: TopicDto)
 - topicDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicDto$Outbound;
}

export function topicDtoToJSON(topicDto: TopicDto): string {
  return JSON.str...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicDtoToJSON
- export function topicDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/topicpayloaddto.ts
Tamaño: 2327 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  TriggerRecipientsTypeEnum,
  TriggerRecipientsTypeEnum$inboundSchema,
  TriggerRecipientsTypeEnum$outboundSchema,
} from './triggerrecipientstypeenum.js';

export type TopicPayloadDto = {
  topicKey: string;
  type: TriggerRecipientsTypeEnum;
  /**
   * Optional array of subscriber IDs to exclude from the topic trigger
   */
  exclude?: Array<string> | undefined;
};

/** @internal */
export const TopicPayloadDto$inboundSchema: z.ZodType<TopicPayloadDto, z.ZodTypeDef, unknown> = z.object({
  topicKey: z.string(),
  type: TriggerRecipientsTypeEnum$inboundSchema,
  exclude: z.array(z.string()).optional(),
});

/** @internal */
export type TopicPayloadDto$Outbound = {
  topicKey: string;
  type: string;
  exclude?: Array<string> | undefined;
};

/** @internal */
export const TopicPayloadDto$outboundSchema: z.ZodType<TopicPayloadDto$Outbound, z.ZodTypeDef, TopicPayloadDto> =
  z.object({
    topicKey: z.string(),
    type: TriggerRecipientsTypeEnum$outboundSchema,
    exclude: z.array(z.string()).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicPayloadDto$ {
  /** @deprecated use `TopicPayloadDto$inboundSchema` instead. */
  export const inboundSchema = TopicPayloadDto$inboundSchema;
  /** @deprecated use `TopicPayloadDto$outboundSchema` instead. */
  export const outboundSchema = TopicPayloadDto$outboundSchema;
  /** @deprecated use `TopicPayloadDto$Outbound` instead. */
  export type Outbound = TopicPayloadDto$Outbound;
}

export function topicPayloadDtoToJSON(topicPayloadDto: TopicPayloadDto): string {
  return JSON.stringify(TopicPayloadDto$outboundSchema.parse(topicPayloadDto));
}

export function topicPayloadDtoFromJSON(jsonString: string): SafeParseResult<TopicPayloadDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicPayloadDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicPayloadDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicPayloadDtoToJSON(topicPayloadDto: TopicPayloadDto)
 - topicPayloadDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicPayloadDto$Outbound;
}

export function topicPayloadDtoToJSON(topicPayloadDto: TopicPayloadDto)...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicPayloadDtoToJSON
- export function topicPayloadDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/topicresponsedto.ts
Tamaño: 2691 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicResponseDto = {
  /**
   * The identifier of the topic
   */
  id: string;
  /**
   * The unique key of the topic
   */
  key: string;
  /**
   * The name of the topic
   */
  name?: string | undefined;
  /**
   * The date the topic was created
   */
  createdAt?: string | undefined;
  /**
   * The date the topic was last updated
   */
  updatedAt?: string | undefined;
};

/** @internal */
export const TopicResponseDto$inboundSchema: z.ZodType<TopicResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    key: z.string(),
    name: z.string().optional(),
    createdAt: z.string().optional(),
    updatedAt: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type TopicResponseDto$Outbound = {
  _id: string;
  key: string;
  name?: string | undefined;
  createdAt?: string | undefined;
  updatedAt?: string | undefined;
};

/** @internal */
export const TopicResponseDto$outboundSchema: z.ZodType<TopicResponseDto$Outbound, z.ZodTypeDef, TopicResponseDto> = z
  .object({
    id: z.string(),
    key: z.string(),
    name: z.string().optional(),
    createdAt: z.string().optional(),
    updatedAt: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicResponseDto$ {
  /** @deprecated use `TopicResponseDto$inboundSchema` instead. */
  export const inboundSchema = TopicResponseDto$inboundSchema;
  /** @deprecated use `TopicResponseDto$outboundSchema` instead. */
  export const outboundSchema = TopicResponseDto$outboundSchema;
  /** @deprecated use `TopicResponseDto$Outbound` instead. */
  export type Outbound = TopicResponseDto$Outbound;
}

export function topicResponseDtoToJSON(topicResponseDto: TopicResponseDto): string {
  return JSON.stringify(TopicResponseDto$outboundSchema.parse(topicResponseDto));
}

export function topicResponseDtoFromJSON(jsonString: string): SafeParseResult<TopicResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicResponseDtoToJSON(topicResponseDto: TopicResponseDto)
 - topicResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicResponseDto$Outbound;
}

export function topicResponseDtoToJSON(topicResponseDto: TopicResponse...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicResponseDtoToJSON
- export function topicResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/topicsubscriberdto.ts
Tamaño: 3200 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicSubscriberDto = {
  /**
   * Unique identifier for the organization
   */
  organizationId: string;
  /**
   * Unique identifier for the environment
   */
  environmentId: string;
  /**
   * Unique identifier for the subscriber
   */
  subscriberId: string;
  /**
   * Unique identifier for the topic
   */
  topicId: string;
  /**
   * Key associated with the topic
   */
  topicKey: string;
  /**
   * External identifier for the subscriber
   */
  externalSubscriberId: string;
};

/** @internal */
export const TopicSubscriberDto$inboundSchema: z.ZodType<TopicSubscriberDto, z.ZodTypeDef, unknown> = z
  .object({
    _organizationId: z.string(),
    _environmentId: z.string(),
    _subscriberId: z.string(),
    _topicId: z.string(),
    topicKey: z.string(),
    externalSubscriberId: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      _organizationId: 'organizationId',
      _environmentId: 'environmentId',
      _subscriberId: 'subscriberId',
      _topicId: 'topicId',
    });
  });

/** @internal */
export type TopicSubscriberDto$Outbound = {
  _organizationId: string;
  _environmentId: string;
  _subscriberId: string;
  _topicId: string;
  topicKey: string;
  externalSubscriberId: string;
};

/** @internal */
export const TopicSubscriberDto$outboundSchema: z.ZodType<
  TopicSubscriberDto$Outbound,
  z.ZodTypeDef,
  TopicSubscriberDto
> = z
  .object({
    organizationId: z.string(),
    environmentId: z.string(),
    subscriberId: z.string(),
    topicId: z.string(),
    topicKey: z.string(),
    externalSubscriberId: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      organizationId: '_organizationId',
      environmentId: '_environmentId',
      subscriberId: '_subscriberId',
      topicId: '_topicId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicSubscriberDto$ {
  /** @deprecated use `TopicSubscriberDto$inboundSchema` instead. */
  export const inboundSchema = TopicSubscriberDto$inboundSchema;
  /** @deprecated use `TopicSubscriberDto$outboundSchema` instead. */
  export const outboundSchema = TopicSubscriberDto$outboundSchema;
  /** @deprecated use `TopicSubscriberDto$Outbound` instead. */
  export type Outbound = TopicSubscriberDto$Outbound;
}

export function topicSubscriberDtoToJSON(topicSubscriberDto: TopicSubscriberDto): string {
  return JSON.stringify(TopicSubscriberDto$outboundSchema.parse(topicSubscriberDto));
}

export function topicSubscriberDtoFromJSON(
  jsonString: string
): SafeParseResult<TopicSubscriberDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicSubscriberDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicSubscriberDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicSubscriberDtoToJSON(topicSubscriberDto: TopicSubscriberDto)
 - topicSubscriberDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicSubscriberDto$Outbound;
}

export function topicSubscriberDtoToJSON(topicSubscriberDto: TopicSu...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicSubscriberDtoToJSON
- export function topicSubscriberDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/topicsubscriptionresponsedto.ts
Tamaño: 3171 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  SubscriberDto,
  SubscriberDto$inboundSchema,
  SubscriberDto$Outbound,
  SubscriberDto$outboundSchema,
} from './subscriberdto.js';
import {
  TopicResponseDto,
  TopicResponseDto$inboundSchema,
  TopicResponseDto$Outbound,
  TopicResponseDto$outboundSchema,
} from './topicresponsedto.js';

export type TopicSubscriptionResponseDto = {
  /**
   * The identifier of the subscription
   */
  id: string;
  /**
   * The date and time the subscription was created
   */
  createdAt: string;
  /**
   * Topic information
   */
  topic: TopicResponseDto;
  /**
   * Subscriber information
   */
  subscriber: SubscriberDto;
};

/** @internal */
export const TopicSubscriptionResponseDto$inboundSchema: z.ZodType<
  TopicSubscriptionResponseDto,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    _id: z.string(),
    createdAt: z.string(),
    topic: TopicResponseDto$inboundSchema,
    subscriber: SubscriberDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type TopicSubscriptionResponseDto$Outbound = {
  _id: string;
  createdAt: string;
  topic: TopicResponseDto$Outbound;
  subscriber: SubscriberDto$Outbound;
};

/** @internal */
export const TopicSubscriptionResponseDto$outboundSchema: z.ZodType<
  TopicSubscriptionResponseDto$Outbound,
  z.ZodTypeDef,
  TopicSubscriptionResponseDto
> = z
  .object({
    id: z.string(),
    createdAt: z.string(),
    topic: TopicResponseDto$outboundSchema,
    subscriber: SubscriberDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicSubscriptionResponseDto$ {
  /** @deprecated use `TopicSubscriptionResponseDto$inboundSchema` instead. */
  export const inboundSchema = TopicSubscriptionResponseDto$inboundSchema;
  /** @deprecated use `TopicSubscriptionResponseDto$outboundSchema` instead. */
  export const outboundSchema = TopicSubscriptionResponseDto$outboundSchema;
  /** @deprecated use `TopicSubscriptionResponseDto$Outbound` instead. */
  export type Outbound = TopicSubscriptionResponseDto$Outbound;
}

export function topicSubscriptionResponseDtoToJSON(topicSubscriptionResponseDto: TopicSubscriptionResponseDto): string {
  return JSON.stringify(TopicSubscriptionResponseDto$outboundSchema.parse(topicSubscriptionResponseDto));
}

export function topicSubscriptionResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<TopicSubscriptionResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicSubscriptionResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicSubscriptionResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicSubscriptionResponseDtoToJSON(topicSubscriptionResponseDto: TopicSubscriptionResponseDto)
 - topicSubscriptionResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicSubscriptionResponseDto$Outbound;
}

export function topicSubscriptionResponseDtoToJSON(topicSu...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicSubscriptionResponseDtoToJSON
- export function topicSubscriptionResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/traceresponsedto.ts
Tamaño: 10966 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Detailed message
 */
export type Message = {};

/**
 * Raw data associated with trace
 */
export type RawData = {};

/**
 * User identifier
 */
export type UserId = {};

/**
 * External subscriber identifier
 */
export type ExternalSubscriberId = {};

/**
 * Subscriber identifier
 */
export type SubscriberId = {};

export type TraceResponseDto = {
  /**
   * Trace identifier
   */
  id: string;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * Event type (e.g., request_received, workflow_execution_started)
   */
  eventType: string;
  /**
   * Human readable title/message
   */
  title: string;
  /**
   * Detailed message
   */
  message?: Message | null | undefined;
  /**
   * Raw data associated with trace
   */
  rawData?: RawData | null | undefined;
  /**
   * Trace status (success, error, warning, pending)
   */
  status: string;
  /**
   * Entity type (request, workflow_run, step_run)
   */
  entityType: string;
  /**
   * Entity identifier
   */
  entityId: string;
  /**
   * Organization identifier
   */
  organizationId: string;
  /**
   * Environment identifier
   */
  environmentId: string;
  /**
   * User identifier
   */
  userId?: UserId | null | undefined;
  /**
   * External subscriber identifier
   */
  externalSubscriberId?: ExternalSubscriberId | null | undefined;
  /**
   * Subscriber identifier
   */
  subscriberId?: SubscriberId | null | undefined;
};

/** @internal */
export const Message$inboundSchema: z.ZodType<Message, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Message$Outbound = {};

/** @internal */
export const Message$outboundSchema: z.ZodType<Message$Outbound, z.ZodTypeDef, Message> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Message$ {
  /** @deprecated use `Message$inboundSchema` instead. */
  export const inboundSchema = Message$inboundSchema;
  /** @deprecated use `Message$outboundSchema` instead. */
  export const outboundSchema = Message$outboundSchema;
  /** @deprecated use `Message$Outbound` instead. */
  export type Outbound = Message$Outbound;
}

export function messageToJSON(message: Message): string {
  return JSON.stringify(Message$outboundSchema.parse(message));
}

export function messageFromJSON(jsonString: string): SafeParseResult<Message, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message' from JSON`
  );
}

/** @internal */
export const RawData$inboundSchema: z.ZodType<RawData, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type RawData$Outbound = {};

/** @internal */
export const RawData$outboundSchema: z.ZodType<RawData$Outbound, z.ZodTypeDef, RawData> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RawData$ {
  /** @deprecated use `RawData$inboundSchema` instead. */
  export const inboundSchema = RawData$inboundSchema;
  /** @deprecated use `RawData$outboundSchema` instead. */
  export const outboundSchema = RawData$outboundSchema;
  /** @deprecated use `RawData$Outbound` instead. */
  export type Outbound = RawData$Outbound;
}

export function rawDataToJSON(rawData: RawData): string {
  return JSON.stringify(RawData$outboundSchema.parse(rawData));
}

export function rawDataFromJSON(jsonString: string): SafeParseResult<RawData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RawData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RawData' from JSON`
  );
}

/** @internal */
export const UserId$inboundSchema: z.ZodType<UserId, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type UserId$Outbound = {};

/** @internal */
export const UserId$outboundSchema: z.ZodType<UserId$Outbound, z.ZodTypeDef, UserId> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UserId$ {
  /** @deprecated use `UserId$inboundSchema` instead. */
  export const inboundSchema = UserId$inboundSchema;
  /** @deprecated use `UserId$outboundSchema` instead. */
  export const outboundSchema = UserId$outboundSchema;
  /** @deprecated use `UserId$Outbound` instead. */
  export type Outbound = UserId$Outbound;
}

export function userIdToJSON(userId: UserId): string {
  return JSON.stringify(UserId$outboundSchema.parse(userId));
}

export function userIdFromJSON(jsonString: string): SafeParseResult<UserId, SDKValidationError> {
  return safeParse(jsonString, (x) => UserId$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'UserId' from JSON`);
}

/** @internal */
export const ExternalSubscriberId$inboundSchema: z.ZodType<ExternalSubscriberId, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type ExternalSubscriberId$Outbound = {};

/** @internal */
export const ExternalSubscriberId$outboundSchema: z.ZodType<
  ExternalSubscriberId$Outbound,
  z.ZodTypeDef,
  ExternalSubscriberId
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExternalSubscriberId$ {
  /** @deprecated use `ExternalSubscriberId$inboundSchema` instead. */
  export const inboundSchema = ExternalSubscriberId$inboundSchema;
  /** @deprecated use `ExternalSubscriberId$outboundSchema` instead. */
  export const outboundSchema = ExternalSubscriberId$outboundSchema;
  /** @deprecated use `ExternalSubscriberId$Outbound` instead. */
  export type Outbound = ExternalSubscriberId$Outbound;
}

export function externalSubscriberIdToJSON(externalSubscriberId: ExternalSubscriberId): string {
  return JSON.stringify(ExternalSubscriberId$outboundSchema.parse(externalSubscriberId));
}

export function externalSubscriberIdFromJSON(
  jsonString: string
): SafeParseResult<ExternalSubscriberId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExternalSubscriberId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExternalSubscriberId' from JSON`
  );
}

/** @internal */
export const SubscriberId$inboundSchema: z.ZodType<SubscriberId, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type SubscriberId$Outbound = {};

/** @internal */
export const SubscriberId$outboundSchema: z.ZodType<SubscriberId$Outbound, z.ZodTypeDef, SubscriberId> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberId$ {
  /** @deprecated use `SubscriberId$inboundSchema` instead. */
  export const inboundSchema = SubscriberId$inboundSchema;
  /** @deprecated use `SubscriberId$outboundSchema` instead. */
  export const outboundSchema = SubscriberId$outboundSchema;
  /** @deprecated use `SubscriberId$Outbound` instead. */
  export type Outbound = SubscriberId$Outbound;
}

export function subscriberIdToJSON(subscriberId: SubscriberId): string {
  return JSON.stringify(SubscriberId$outboundSchema.parse(subscriberId));
}

export function subscriberIdFromJSON(jsonString: string): SafeParseResult<SubscriberId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberId' from JSON`
  );
}

/** @internal */
export const TraceResponseDto$inboundSchema: z.ZodType<TraceResponseDto, z.ZodTypeDef, unknown> = z.object({
  id: z.string(),
  createdAt: z.string(),
  eventType: z.string(),
  title: z.string(),
  message: z.nullable(z.lazy(() => Message$inboundSchema)).optional(),
  rawData: z.nullable(z.lazy(() => RawData$inboundSchema)).optional(),
  status: z.string(),
  entityType: z.string(),
  entityId: z.string(),
  organizationId: z.string(),
  environmentId: z.string(),
  userId: z.nullable(z.lazy(() => UserId$inboundSchema)).optional(),
  externalSubscriberId: z.nullable(z.lazy(() => ExternalSubscriberId$inboundSchema)).optional(),
  subscriberId: z.nullable(z.lazy(() => SubscriberId$inboundSchema)).optional(),
});

/** @internal */
export type TraceResponseDto$Outbound = {
  id: string;
  createdAt: string;
  eventType: string;
  title: string;
  message?: Message$Outbound | null | undefined;
  rawData?: RawData$Outbound | null | undefined;
  status: string;
  entityType: string;
  entityId: string;
  organizationId: string;
  environmentId: string;
  userId?: UserId$Outbound | null | undefined;
  externalSubscriberId?: ExternalSubscriberId$Outbound | null | undefined;
  subscriberId?: SubscriberId$Outbound | null | undefined;
};

/** @internal */
export const TraceResponseDto$outboundSchema: z.ZodType<TraceResponseDto$Outbound, z.ZodTypeDef, TraceResponseDto> =
  z.object({
    id: z.string(),
    createdAt: z.string(),
    eventType: z.string(),
    title: z.string(),
    message: z.nullable(z.lazy(() => Message$outboundSchema)).optional(),
    rawData: z.nullable(z.lazy(() => RawData$outboundSchema)).optional(),
    status: z.string(),
    entityType: z.string(),
    entityId: z.string(),
    organizationId: z.string(),
    environmentId: z.string(),
    userId: z.nullable(z.lazy(() => UserId$outboundSchema)).optional(),
    externalSubscriberId: z.nullable(z.lazy(() => ExternalSubscriberId$outboundSchema)).optional(),
    subscriberId: z.nullable(z.lazy(() => SubscriberId$outboundSchema)).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TraceResponseDto$ {
  /** @deprecated use `TraceResponseDto$inboundSchema` instead. */
  export const inboundSchema = TraceResponseDto$inboundSchema;
  /** @deprecated use `TraceResponseDto$outboundSchema` instead. */
  export const outboundSchema = TraceResponseDto$outboundSchema;
  /** @deprecated use `TraceResponseDto$Outbound` instead. */
  export type Outbound = TraceResponseDto$Outbound;
}

export function traceResponseDtoToJSON(traceResponseDto: TraceResponseDto): string {
  return JSON.stringify(TraceResponseDto$outboundSchema.parse(traceResponseDto));
}

export function traceResponseDtoFromJSON(jsonString: string): SafeParseResult<TraceResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TraceResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TraceResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageToJSON(message: Message)
 - messageFromJSON(jsonString: string)
 - rawDataToJSON(rawData: RawData)
 - rawDataFromJSON(jsonString: string)
 - userIdToJSON(userId: UserId)
 - userIdFromJSON(jsonString: string)
 - externalSubscriberIdToJSON(externalSubscriberId: ExternalSubscriberId)
 - externalSubscriberIdFromJSON(jsonString: string)
 - subscriberIdToJSON(subscriberId: SubscriberId)
 - subscriberIdFromJSON(jsonString: string)
 - traceResponseDtoToJSON(traceResponseDto: TraceResponseDto)
 - traceResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Message$Outbound;
}

export function messageToJSON(message: Message): string {
  return JSON.stringi...)
 - Outbound(RawData$Outbound;
}

export function rawDataToJSON(rawData: RawData): string {
  return JSON.stringi...)
 - Outbound(UserId$Outbound;
}

export function userIdToJSON(userId: UserId): string {
  return JSON.stringify(U...)
 - Outbound(ExternalSubscriberId$Outbound;
}

export function externalSubscriberIdToJSON(externalSubscriberId: E...)
 - Outbound(SubscriberId$Outbound;
}

export function subscriberIdToJSON(subscriberId: SubscriberId): string {
 ...)
 - Outbound(TraceResponseDto$Outbound;
}

export function traceResponseDtoToJSON(traceResponseDto: TraceResponse...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageToJSON
- export function messageFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function rawDataToJSON
- export function rawDataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function userIdToJSON
- export function userIdFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function externalSubscriberIdToJSON
- export function externalSubscriberIdFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberIdToJSON
- export function subscriberIdFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function traceResponseDtoToJSON
- export function traceResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/translationgroupdto.ts
Tamaño: 4267 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Resource type
 */
export const TranslationGroupDtoResourceType = {
  Workflow: 'workflow',
  Layout: 'layout',
} as const;
/**
 * Resource type
 */
export type TranslationGroupDtoResourceType = ClosedEnum<typeof TranslationGroupDtoResourceType>;

export type TranslationGroupDto = {
  /**
   * Resource identifier (slugified ID)
   */
  resourceId: string;
  /**
   * Resource type
   */
  resourceType: TranslationGroupDtoResourceType;
  /**
   * Resource name (e.g., workflow name)
   */
  resourceName: string;
  /**
   * Array of available locales for this resource
   */
  locales: Array<string>;
  /**
   * Locales that are outdated compared to the default locale (only present when there are outdated locales)
   */
  outdatedLocales?: Array<string> | undefined;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * Last update timestamp
   */
  updatedAt: string;
};

/** @internal */
export const TranslationGroupDtoResourceType$inboundSchema: z.ZodNativeEnum<typeof TranslationGroupDtoResourceType> =
  z.nativeEnum(TranslationGroupDtoResourceType);

/** @internal */
export const TranslationGroupDtoResourceType$outboundSchema: z.ZodNativeEnum<typeof TranslationGroupDtoResourceType> =
  TranslationGroupDtoResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationGroupDtoResourceType$ {
  /** @deprecated use `TranslationGroupDtoResourceType$inboundSchema` instead. */
  export const inboundSchema = TranslationGroupDtoResourceType$inboundSchema;
  /** @deprecated use `TranslationGroupDtoResourceType$outboundSchema` instead. */
  export const outboundSchema = TranslationGroupDtoResourceType$outboundSchema;
}

/** @internal */
export const TranslationGroupDto$inboundSchema: z.ZodType<TranslationGroupDto, z.ZodTypeDef, unknown> = z.object({
  resourceId: z.string(),
  resourceType: TranslationGroupDtoResourceType$inboundSchema,
  resourceName: z.string(),
  locales: z.array(z.string()),
  outdatedLocales: z.array(z.string()).optional(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

/** @internal */
export type TranslationGroupDto$Outbound = {
  resourceId: string;
  resourceType: string;
  resourceName: string;
  locales: Array<string>;
  outdatedLocales?: Array<string> | undefined;
  createdAt: string;
  updatedAt: string;
};

/** @internal */
export const TranslationGroupDto$outboundSchema: z.ZodType<
  TranslationGroupDto$Outbound,
  z.ZodTypeDef,
  TranslationGroupDto
> = z.object({
  resourceId: z.string(),
  resourceType: TranslationGroupDtoResourceType$outboundSchema,
  resourceName: z.string(),
  locales: z.array(z.string()),
  outdatedLocales: z.array(z.string()).optional(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationGroupDto$ {
  /** @deprecated use `TranslationGroupDto$inboundSchema` instead. */
  export const inboundSchema = TranslationGroupDto$inboundSchema;
  /** @deprecated use `TranslationGroupDto$outboundSchema` instead. */
  export const outboundSchema = TranslationGroupDto$outboundSchema;
  /** @deprecated use `TranslationGroupDto$Outbound` instead. */
  export type Outbound = TranslationGroupDto$Outbound;
}

export function translationGroupDtoToJSON(translationGroupDto: TranslationGroupDto): string {
  return JSON.stringify(TranslationGroupDto$outboundSchema.parse(translationGroupDto));
}

export function translationGroupDtoFromJSON(
  jsonString: string
): SafeParseResult<TranslationGroupDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationGroupDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationGroupDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationGroupDtoToJSON(translationGroupDto: TranslationGroupDto)
 - translationGroupDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationGroupDto$Outbound;
}

export function translationGroupDtoToJSON(translationGroupDto: Tran...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationGroupDtoToJSON
- export function translationGroupDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/translationresponsedto.ts
Tamaño: 5883 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Resource type
 */
export const TranslationResponseDtoResourceType = {
  Workflow: 'workflow',
  Layout: 'layout',
} as const;
/**
 * Resource type
 */
export type TranslationResponseDtoResourceType = ClosedEnum<typeof TranslationResponseDtoResourceType>;

/**
 * Translation content as JSON object
 */
export type TranslationResponseDtoContent = {};

export type TranslationResponseDto = {
  /**
   * Resource identifier
   */
  resourceId: string;
  /**
   * Resource type
   */
  resourceType: TranslationResponseDtoResourceType;
  /**
   * Locale code
   */
  locale: string;
  /**
   * Translation content as JSON object
   */
  content: TranslationResponseDtoContent;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * Last update timestamp
   */
  updatedAt: string;
};

/** @internal */
export const TranslationResponseDtoResourceType$inboundSchema: z.ZodNativeEnum<
  typeof TranslationResponseDtoResourceType
> = z.nativeEnum(TranslationResponseDtoResourceType);

/** @internal */
export const TranslationResponseDtoResourceType$outboundSchema: z.ZodNativeEnum<
  typeof TranslationResponseDtoResourceType
> = TranslationResponseDtoResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationResponseDtoResourceType$ {
  /** @deprecated use `TranslationResponseDtoResourceType$inboundSchema` instead. */
  export const inboundSchema = TranslationResponseDtoResourceType$inboundSchema;
  /** @deprecated use `TranslationResponseDtoResourceType$outboundSchema` instead. */
  export const outboundSchema = TranslationResponseDtoResourceType$outboundSchema;
}

/** @internal */
export const TranslationResponseDtoContent$inboundSchema: z.ZodType<
  TranslationResponseDtoContent,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type TranslationResponseDtoContent$Outbound = {};

/** @internal */
export const TranslationResponseDtoContent$outboundSchema: z.ZodType<
  TranslationResponseDtoContent$Outbound,
  z.ZodTypeDef,
  TranslationResponseDtoContent
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationResponseDtoContent$ {
  /** @deprecated use `TranslationResponseDtoContent$inboundSchema` instead. */
  export const inboundSchema = TranslationResponseDtoContent$inboundSchema;
  /** @deprecated use `TranslationResponseDtoContent$outboundSchema` instead. */
  export const outboundSchema = TranslationResponseDtoContent$outboundSchema;
  /** @deprecated use `TranslationResponseDtoContent$Outbound` instead. */
  export type Outbound = TranslationResponseDtoContent$Outbound;
}

export function translationResponseDtoContentToJSON(
  translationResponseDtoContent: TranslationResponseDtoContent
): string {
  return JSON.stringify(TranslationResponseDtoContent$outboundSchema.parse(translationResponseDtoContent));
}

export function translationResponseDtoContentFromJSON(
  jsonString: string
): SafeParseResult<TranslationResponseDtoContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationResponseDtoContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationResponseDtoContent' from JSON`
  );
}

/** @internal */
export const TranslationResponseDto$inboundSchema: z.ZodType<TranslationResponseDto, z.ZodTypeDef, unknown> = z.object({
  resourceId: z.string(),
  resourceType: TranslationResponseDtoResourceType$inboundSchema,
  locale: z.string(),
  content: z.lazy(() => TranslationResponseDtoContent$inboundSchema),
  createdAt: z.string(),
  updatedAt: z.string(),
});

/** @internal */
export type TranslationResponseDto$Outbound = {
  resourceId: string;
  resourceType: string;
  locale: string;
  content: TranslationResponseDtoContent$Outbound;
  createdAt: string;
  updatedAt: string;
};

/** @internal */
export const TranslationResponseDto$outboundSchema: z.ZodType<
  TranslationResponseDto$Outbound,
  z.ZodTypeDef,
  TranslationResponseDto
> = z.object({
  resourceId: z.string(),
  resourceType: TranslationResponseDtoResourceType$outboundSchema,
  locale: z.string(),
  content: z.lazy(() => TranslationResponseDtoContent$outboundSchema),
  createdAt: z.string(),
  updatedAt: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationResponseDto$ {
  /** @deprecated use `TranslationResponseDto$inboundSchema` instead. */
  export const inboundSchema = TranslationResponseDto$inboundSchema;
  /** @deprecated use `TranslationResponseDto$outboundSchema` instead. */
  export const outboundSchema = TranslationResponseDto$outboundSchema;
  /** @deprecated use `TranslationResponseDto$Outbound` instead. */
  export type Outbound = TranslationResponseDto$Outbound;
}

export function translationResponseDtoToJSON(translationResponseDto: TranslationResponseDto): string {
  return JSON.stringify(TranslationResponseDto$outboundSchema.parse(translationResponseDto));
}

export function translationResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<TranslationResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationResponseDtoContentToJSON(translationResponseDtoContent: TranslationResponseDtoContent)
 - translationResponseDtoContentFromJSON(jsonString: string)
 - translationResponseDtoToJSON(translationResponseDto: TranslationResponseDto)
 - translationResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationResponseDtoContent$Outbound;
}

export function translationResponseDtoContentToJSON(
  tr...)
 - Outbound(TranslationResponseDto$Outbound;
}

export function translationResponseDtoToJSON(translationResponse...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationResponseDtoContentToJSON
- export function translationResponseDtoContentFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationResponseDtoToJSON
- export function translationResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/triggereventrequestdto.ts
Tamaño: 22077 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  EmailChannelOverrides,
  EmailChannelOverrides$inboundSchema,
  EmailChannelOverrides$Outbound,
  EmailChannelOverrides$outboundSchema,
} from './emailchanneloverrides.js';
import {
  SeverityLevelEnum,
  SeverityLevelEnum$inboundSchema,
  SeverityLevelEnum$outboundSchema,
} from './severitylevelenum.js';
import {
  StepsOverrides,
  StepsOverrides$inboundSchema,
  StepsOverrides$Outbound,
  StepsOverrides$outboundSchema,
} from './stepsoverrides.js';
import {
  SubscriberPayloadDto,
  SubscriberPayloadDto$inboundSchema,
  SubscriberPayloadDto$Outbound,
  SubscriberPayloadDto$outboundSchema,
} from './subscriberpayloaddto.js';
import {
  TenantPayloadDto,
  TenantPayloadDto$inboundSchema,
  TenantPayloadDto$Outbound,
  TenantPayloadDto$outboundSchema,
} from './tenantpayloaddto.js';
import {
  TopicPayloadDto,
  TopicPayloadDto$inboundSchema,
  TopicPayloadDto$Outbound,
  TopicPayloadDto$outboundSchema,
} from './topicpayloaddto.js';

/**
 * Channel-specific overrides that apply to all steps of a particular channel type. Step-level overrides take precedence over channel-level overrides.
 */
export type Channels = {
  /**
   * Email channel specific overrides
   */
  email?: EmailChannelOverrides | undefined;
};

/**
 * This could be used to override provider specific configurations
 */
export type Overrides = {
  /**
   * This could be used to override provider specific configurations or layout at the step level
   */
  steps?: { [k: string]: StepsOverrides } | undefined;
  /**
   * Channel-specific overrides that apply to all steps of a particular channel type. Step-level overrides take precedence over channel-level overrides.
   */
  channels?: Channels | undefined;
  /**
   * Overrides the provider configuration for the entire workflow and all steps
   */
  providers?: { [k: string]: { [k: string]: any } } | undefined;
  /**
   * Override the email provider specific configurations for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  email?: { [k: string]: any } | undefined;
  /**
   * Override the push provider specific configurations for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  push?: { [k: string]: any } | undefined;
  /**
   * Override the sms provider specific configurations for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  sms?: { [k: string]: any } | undefined;
  /**
   * Override the chat provider specific configurations for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  chat?: { [k: string]: any } | undefined;
  /**
   * Override the layout identifier for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  layoutIdentifier?: string | undefined;
  /**
   * Severity of the workflow
   */
  severity?: SeverityLevelEnum | undefined;
};

export type To1 = TopicPayloadDto | SubscriberPayloadDto | string;

/**
 * The recipients list of people who will receive the notification.
 */
export type To =
  | TopicPayloadDto
  | SubscriberPayloadDto
  | Array<TopicPayloadDto | SubscriberPayloadDto | string>
  | string;

/**
 * It is used to display the Avatar of the provided actor's subscriber id or actor object.
 *
 * @remarks
 *     If a new actor object is provided, we will create a new subscriber in our system
 */
export type Actor = SubscriberPayloadDto | string;

/**
 * It is used to specify a tenant context during trigger event.
 *
 * @remarks
 *     Existing tenants will be updated with the provided details.
 */
export type Tenant = string | TenantPayloadDto;

/**
 * Rich context object with id and optional data
 */
export type Context2 = {
  id: string;
  /**
   * Optional additional context data
   */
  data?: { [k: string]: any } | undefined;
};

export type TriggerEventRequestDtoContext = Context2 | string;

export type TriggerEventRequestDto = {
  /**
   * The trigger identifier of the workflow you wish to send. This identifier can be found on the workflow page.
   */
  workflowId: string;
  /**
   * The payload object is used to pass additional custom information that could be
   *
   * @remarks
   *     used to render the workflow, or perform routing rules based on it.
   *       This data will also be available when fetching the notifications feed from the API to display certain parts of the UI.
   */
  payload?: { [k: string]: any } | undefined;
  /**
   * This could be used to override provider specific configurations
   */
  overrides?: Overrides | undefined;
  /**
   * The recipients list of people who will receive the notification.
   */
  to: TopicPayloadDto | SubscriberPayloadDto | Array<TopicPayloadDto | SubscriberPayloadDto | string> | string;
  /**
   * A unique identifier for deduplication. If the same **transactionId** is sent again,
   *
   * @remarks
   *       the trigger is ignored. Useful to prevent duplicate notifications. The retention period depends on your billing tier.
   */
  transactionId?: string | undefined;
  /**
   * It is used to display the Avatar of the provided actor's subscriber id or actor object.
   *
   * @remarks
   *     If a new actor object is provided, we will create a new subscriber in our system
   */
  actor?: SubscriberPayloadDto | string | undefined;
  /**
   * It is used to specify a tenant context during trigger event.
   *
   * @remarks
   *     Existing tenants will be updated with the provided details.
   */
  tenant?: string | TenantPayloadDto | undefined;
  context?: { [k: string]: Context2 | string } | undefined;
};

/** @internal */
export const Channels$inboundSchema: z.ZodType<Channels, z.ZodTypeDef, unknown> = z.object({
  email: EmailChannelOverrides$inboundSchema.optional(),
});

/** @internal */
export type Channels$Outbound = {
  email?: EmailChannelOverrides$Outbound | undefined;
};

/** @internal */
export const Channels$outboundSchema: z.ZodType<Channels$Outbound, z.ZodTypeDef, Channels> = z.object({
  email: EmailChannelOverrides$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Channels$ {
  /** @deprecated use `Channels$inboundSchema` instead. */
  export const inboundSchema = Channels$inboundSchema;
  /** @deprecated use `Channels$outboundSchema` instead. */
  export const outboundSchema = Channels$outboundSchema;
  /** @deprecated use `Channels$Outbound` instead. */
  export type Outbound = Channels$Outbound;
}

export function channelsToJSON(channels: Channels): string {
  return JSON.stringify(Channels$outboundSchema.parse(channels));
}

export function channelsFromJSON(jsonString: string): SafeParseResult<Channels, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Channels$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Channels' from JSON`
  );
}

/** @internal */
export const Overrides$inboundSchema: z.ZodType<Overrides, z.ZodTypeDef, unknown> = z.object({
  steps: z.record(StepsOverrides$inboundSchema).optional(),
  channels: z.lazy(() => Channels$inboundSchema).optional(),
  providers: z.record(z.record(z.any())).optional(),
  email: z.record(z.any()).optional(),
  push: z.record(z.any()).optional(),
  sms: z.record(z.any()).optional(),
  chat: z.record(z.any()).optional(),
  layoutIdentifier: z.string().optional(),
  severity: SeverityLevelEnum$inboundSchema.optional(),
});

/** @internal */
export type Overrides$Outbound = {
  steps?: { [k: string]: StepsOverrides$Outbound } | undefined;
  channels?: Channels$Outbound | undefined;
  providers?: { [k: string]: { [k: string]: any } } | undefined;
  email?: { [k: string]: any } | undefined;
  push?: { [k: string]: any } | undefined;
  sms?: { [k: string]: any } | undefined;
  chat?: { [k: string]: any } | undefined;
  layoutIdentifier?: string | undefined;
  severity?: string | undefined;
};

/** @internal */
export const Overrides$outboundSchema: z.ZodType<Overrides$Outbound, z.ZodTypeDef, Overrides> = z.object({
  steps: z.record(StepsOverrides$outboundSchema).optional(),
  channels: z.lazy(() => Channels$outboundSchema).optional(),
  providers: z.record(z.record(z.any())).optional(),
  email: z.record(z.any()).optional(),
  push: z.record(z.any()).optional(),
  sms: z.record(z.any()).optional(),
  chat: z.record(z.any()).optional(),
  layoutIdentifier: z.string().optional(),
  severity: SeverityLevelEnum$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Overrides$ {
  /** @deprecated use `Overrides$inboundSchema` instead. */
  export const inboundSchema = Overrides$inboundSchema;
  /** @deprecated use `Overrides$outboundSchema` instead. */
  export const outboundSchema = Overrides$outboundSchema;
  /** @deprecated use `Overrides$Outbound` instead. */
  export type Outbound = Overrides$Outbound;
}

export function overridesToJSON(overrides: Overrides): string {
  return JSON.stringify(Overrides$outboundSchema.parse(overrides));
}

export function overridesFromJSON(jsonString: string): SafeParseResult<Overrides, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Overrides$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Overrides' from JSON`
  );
}

/** @internal */
export const To1$inboundSchema: z.ZodType<To1, z.ZodTypeDef, unknown> = z.union([
  TopicPayloadDto$inboundSchema,
  SubscriberPayloadDto$inboundSchema,
  z.string(),
]);

/** @internal */
export type To1$Outbound = TopicPayloadDto$Outbound | SubscriberPayloadDto$Outbound | string;

/** @internal */
export const To1$outboundSchema: z.ZodType<To1$Outbound, z.ZodTypeDef, To1> = z.union([
  TopicPayloadDto$outboundSchema,
  SubscriberPayloadDto$outboundSchema,
  z.string(),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace To1$ {
  /** @deprecated use `To1$inboundSchema` instead. */
  export const inboundSchema = To1$inboundSchema;
  /** @deprecated use `To1$outboundSchema` instead. */
  export const outboundSchema = To1$outboundSchema;
  /** @deprecated use `To1$Outbound` instead. */
  export type Outbound = To1$Outbound;
}

export function to1ToJSON(to1: To1): string {
  return JSON.stringify(To1$outboundSchema.parse(to1));
}

export function to1FromJSON(jsonString: string): SafeParseResult<To1, SDKValidationError> {
  return safeParse(jsonString, (x) => To1$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'To1' from JSON`);
}

/** @internal */
export const To$inboundSchema: z.ZodType<To, z.ZodTypeDef, unknown> = z.union([
  TopicPayloadDto$inboundSchema,
  SubscriberPayloadDto$inboundSchema,
  z.array(z.union([TopicPayloadDto$inboundSchema, SubscriberPayloadDto$inboundSchema, z.string()])),
  z.string(),
]);

/** @internal */
export type To$Outbound =
  | TopicPayloadDto$Outbound
  | SubscriberPayloadDto$Outbound
  | Array<TopicPayloadDto$Outbound | SubscriberPayloadDto$Outbound | string>
  | string;

/** @internal */
export const To$outboundSchema: z.ZodType<To$Outbound, z.ZodTypeDef, To> = z.union([
  TopicPayloadDto$outboundSchema,
  SubscriberPayloadDto$outboundSchema,
  z.array(z.union([TopicPayloadDto$outboundSchema, SubscriberPayloadDto$outboundSchema, z.string()])),
  z.string(),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace To$ {
  /** @deprecated use `To$inboundSchema` instead. */
  export const inboundSchema = To$inboundSchema;
  /** @deprecated use `To$outboundSchema` instead. */
  export const outboundSchema = To$outboundSchema;
  /** @deprecated use `To$Outbound` instead. */
  export type Outbound = To$Outbound;
}

export function toToJSON(to: To): string {
  return JSON.stringify(To$outboundSchema.parse(to));
}

export function toFromJSON(jsonString: string): SafeParseResult<To, SDKValidationError> {
  return safeParse(jsonString, (x) => To$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'To' from JSON`);
}

/** @internal */
export const Actor$inboundSchema: z.ZodType<Actor, z.ZodTypeDef, unknown> = z.union([
  SubscriberPayloadDto$inboundSchema,
  z.string(),
]);

/** @internal */
export type Actor$Outbound = SubscriberPayloadDto$Outbound | string;

/** @internal */
export const Actor$outboundSchema: z.ZodType<Actor$Outbound, z.ZodTypeDef, Actor> = z.union([
  SubscriberPayloadDto$outboundSchema,
  z.string(),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Actor$ {
  /** @deprecated use `Actor$inboundSchema` instead. */
  export const inboundSchema = Actor$inboundSchema;
  /** @deprecated use `Actor$outboundSchema` instead. */
  export const outboundSchema = Actor$outboundSchema;
  /** @deprecated use `Actor$Outbound` instead. */
  export type Outbound = Actor$Outbound;
}

export function actorToJSON(actor: Actor): string {
  return JSON.stringify(Actor$outboundSchema.parse(actor));
}

export function actorFromJSON(jsonString: string): SafeParseResult<Actor, SDKValidationError> {
  return safeParse(jsonString, (x) => Actor$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Actor' from JSON`);
}

/** @internal */
export const Tenant$inboundSchema: z.ZodType<Tenant, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  TenantPayloadDto$inboundSchema,
]);

/** @internal */
export type Tenant$Outbound = string | TenantPayloadDto$Outbound;

/** @internal */
export const Tenant$outboundSchema: z.ZodType<Tenant$Outbound, z.ZodTypeDef, Tenant> = z.union([
  z.string(),
  TenantPayloadDto$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Tenant$ {
  /** @deprecated use `Tenant$inboundSchema` instead. */
  export const inboundSchema = Tenant$inboundSchema;
  /** @deprecated use `Tenant$outboundSchema` instead. */
  export const outboundSchema = Tenant$outboundSchema;
  /** @deprecated use `Tenant$Outbound` instead. */
  export type Outbound = Tenant$Outbound;
}

export function tenantToJSON(tenant: Tenant): string {
  return JSON.stringify(Tenant$outboundSchema.parse(tenant));
}

export function tenantFromJSON(jsonString: string): SafeParseResult<Tenant, SDKValidationError> {
  return safeParse(jsonString, (x) => Tenant$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Tenant' from JSON`);
}

/** @internal */
export const Context2$inboundSchema: z.ZodType<Context2, z.ZodTypeDef, unknown> = z.object({
  id: z.string(),
  data: z.record(z.any()).optional(),
});

/** @internal */
export type Context2$Outbound = {
  id: string;
  data?: { [k: string]: any } | undefined;
};

/** @internal */
export const Context2$outboundSchema: z.ZodType<Context2$Outbound, z.ZodTypeDef, Context2> = z.object({
  id: z.string(),
  data: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Context2$ {
  /** @deprecated use `Context2$inboundSchema` instead. */
  export const inboundSchema = Context2$inboundSchema;
  /** @deprecated use `Context2$outboundSchema` instead. */
  export const outboundSchema = Context2$outboundSchema;
  /** @deprecated use `Context2$Outbound` instead. */
  export type Outbound = Context2$Outbound;
}

export function context2ToJSON(context2: Context2): string {
  return JSON.stringify(Context2$outboundSchema.parse(context2));
}

export function context2FromJSON(jsonString: string): SafeParseResult<Context2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Context2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Context2' from JSON`
  );
}

/** @internal */
export const TriggerEventRequestDtoContext$inboundSchema: z.ZodType<
  TriggerEventRequestDtoContext,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => Context2$inboundSchema), z.string()]);

/** @internal */
export type TriggerEventRequestDtoContext$Outbound = Context2$Outbound | string;

/** @internal */
export const TriggerEventRequestDtoContext$outboundSchema: z.ZodType<
  TriggerEventRequestDtoContext$Outbound,
  z.ZodTypeDef,
  TriggerEventRequestDtoContext
> = z.union([z.lazy(() => Context2$outboundSchema), z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventRequestDtoContext$ {
  /** @deprecated use `TriggerEventRequestDtoContext$inboundSchema` instead. */
  export const inboundSchema = TriggerEventRequestDtoContext$inboundSchema;
  /** @deprecated use `TriggerEventRequestDtoContext$outboundSchema` instead. */
  export const outboundSchema = TriggerEventRequestDtoContext$outboundSchema;
  /** @deprecated use `TriggerEventRequestDtoContext$Outbound` instead. */
  export type Outbound = TriggerEventRequestDtoContext$Outbound;
}

export function triggerEventRequestDtoContextToJSON(
  triggerEventRequestDtoContext: TriggerEventRequestDtoContext
): string {
  return JSON.stringify(TriggerEventRequestDtoContext$outboundSchema.parse(triggerEventRequestDtoContext));
}

export function triggerEventRequestDtoContextFromJSON(
  jsonString: string
): SafeParseResult<TriggerEventRequestDtoContext, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TriggerEventRequestDtoContext$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TriggerEventRequestDtoContext' from JSON`
  );
}

/** @internal */
export const TriggerEventRequestDto$inboundSchema: z.ZodType<TriggerEventRequestDto, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string(),
    payload: z.record(z.any()).optional(),
    overrides: z.lazy(() => Overrides$inboundSchema).optional(),
    to: z.union([
      TopicPayloadDto$inboundSchema,
      SubscriberPayloadDto$inboundSchema,
      z.array(z.union([TopicPayloadDto$inboundSchema, SubscriberPayloadDto$inboundSchema, z.string()])),
      z.string(),
    ]),
    transactionId: z.string().optional(),
    actor: z.union([SubscriberPayloadDto$inboundSchema, z.string()]).optional(),
    tenant: z.union([z.string(), TenantPayloadDto$inboundSchema]).optional(),
    context: z.record(z.union([z.lazy(() => Context2$inboundSchema), z.string()])).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      name: 'workflowId',
    });
  });

/** @internal */
export type TriggerEventRequestDto$Outbound = {
  name: string;
  payload?: { [k: string]: any } | undefined;
  overrides?: Overrides$Outbound | undefined;
  to:
    | TopicPayloadDto$Outbound
    | SubscriberPayloadDto$Outbound
    | Array<TopicPayloadDto$Outbound | SubscriberPayloadDto$Outbound | string>
    | string;
  transactionId?: string | undefined;
  actor?: SubscriberPayloadDto$Outbound | string | undefined;
  tenant?: string | TenantPayloadDto$Outbound | undefined;
  context?: { [k: string]: Context2$Outbound | string } | undefined;
};

/** @internal */
export const TriggerEventRequestDto$outboundSchema: z.ZodType<
  TriggerEventRequestDto$Outbound,
  z.ZodTypeDef,
  TriggerEventRequestDto
> = z
  .object({
    workflowId: z.string(),
    payload: z.record(z.any()).optional(),
    overrides: z.lazy(() => Overrides$outboundSchema).optional(),
    to: z.union([
      TopicPayloadDto$outboundSchema,
      SubscriberPayloadDto$outboundSchema,
      z.array(z.union([TopicPayloadDto$outboundSchema, SubscriberPayloadDto$outboundSchema, z.string()])),
      z.string(),
    ]),
    transactionId: z.string().optional(),
    actor: z.union([SubscriberPayloadDto$outboundSchema, z.string()]).optional(),
    tenant: z.union([z.string(), TenantPayloadDto$outboundSchema]).optional(),
    context: z.record(z.union([z.lazy(() => Context2$outboundSchema), z.string()])).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      workflowId: 'name',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventRequestDto$ {
  /** @deprecated use `TriggerEventRequestDto$inboundSchema` instead. */
  export const inboundSchema = TriggerEventRequestDto$inboundSchema;
  /** @deprecated use `TriggerEventRequestDto$outboundSchema` instead. */
  export const outboundSchema = TriggerEventRequestDto$outboundSchema;
  /** @deprecated use `TriggerEventRequestDto$Outbound` instead. */
  export type Outbound = TriggerEventRequestDto$Outbound;
}

export function triggerEventRequestDtoToJSON(triggerEventRequestDto: TriggerEventRequestDto): string {
  return JSON.stringify(TriggerEventRequestDto$outboundSchema.parse(triggerEventRequestDto));
}

export function triggerEventRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<TriggerEventRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TriggerEventRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TriggerEventRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - channelsToJSON(channels: Channels)
 - channelsFromJSON(jsonString: string)
 - overridesToJSON(overrides: Overrides)
 - overridesFromJSON(jsonString: string)
 - to1ToJSON(to1: To1)
 - to1FromJSON(jsonString: string)
 - toToJSON(to: To)
 - toFromJSON(jsonString: string)
 - actorToJSON(actor: Actor)
 - actorFromJSON(jsonString: string)
 - tenantToJSON(tenant: Tenant)
 - tenantFromJSON(jsonString: string)
 - context2ToJSON(context2: Context2)
 - context2FromJSON(jsonString: string)
 - triggerEventRequestDtoContextToJSON(triggerEventRequestDtoContext: TriggerEventRequestDtoContext)
 - triggerEventRequestDtoContextFromJSON(jsonString: string)
 - triggerEventRequestDtoToJSON(triggerEventRequestDto: TriggerEventRequestDto)
 - triggerEventRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Channels$Outbound;
}

export function channelsToJSON(channels: Channels): string {
  return JSON.str...)
 - Outbound(Overrides$Outbound;
}

export function overridesToJSON(overrides: Overrides): string {
  return JSON...)
 - Outbound(To1$Outbound;
}

export function to1ToJSON(to1: To1): string {
  return JSON.stringify(To1$outboundS...)
 - Outbound(To$Outbound;
}

export function toToJSON(to: To): string {
  return JSON.stringify(To$outboundSchema...)
 - Outbound(Actor$Outbound;
}

export function actorToJSON(actor: Actor): string {
  return JSON.stringify(Actor...)
 - Outbound(Tenant$Outbound;
}

export function tenantToJSON(tenant: Tenant): string {
  return JSON.stringify(T...)
 - Outbound(Context2$Outbound;
}

export function context2ToJSON(context2: Context2): string {
  return JSON.str...)
 - Outbound(TriggerEventRequestDtoContext$Outbound;
}

export function triggerEventRequestDtoContextToJSON(
  tr...)
 - Outbound(TriggerEventRequestDto$Outbound;
}

export function triggerEventRequestDtoToJSON(triggerEventRequest...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function channelsToJSON
- export function channelsFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function overridesToJSON
- export function overridesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function to1ToJSON
- export function to1FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function toToJSON
- export function toFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function actorToJSON
- export function actorFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function tenantToJSON
- export function tenantFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function context2ToJSON
- export function context2FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function triggerEventRequestDtoContextToJSON
- export function triggerEventRequestDtoContextFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function triggerEventRequestDtoToJSON
- export function triggerEventRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/triggereventresponsedto.ts
Tamaño: 4156 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Status of the trigger
 */
export const TriggerEventResponseDtoStatus = {
  Error: 'error',
  TriggerNotActive: 'trigger_not_active',
  NoWorkflowActiveStepsDefined: 'no_workflow_active_steps_defined',
  NoWorkflowStepsDefined: 'no_workflow_steps_defined',
  Processed: 'processed',
  NoTenantFound: 'no_tenant_found',
  InvalidRecipients: 'invalid_recipients',
} as const;
/**
 * Status of the trigger
 */
export type TriggerEventResponseDtoStatus = ClosedEnum<typeof TriggerEventResponseDtoStatus>;

export type TriggerEventResponseDto = {
  /**
   * Indicates whether the trigger was acknowledged or not
   */
  acknowledged: boolean;
  /**
   * Status of the trigger
   */
  status: TriggerEventResponseDtoStatus;
  /**
   * In case of an error, this field will contain the error message(s)
   */
  error?: Array<string> | undefined;
  /**
   * The returned transaction ID of the trigger
   */
  transactionId?: string | undefined;
};

/** @internal */
export const TriggerEventResponseDtoStatus$inboundSchema: z.ZodNativeEnum<typeof TriggerEventResponseDtoStatus> =
  z.nativeEnum(TriggerEventResponseDtoStatus);

/** @internal */
export const TriggerEventResponseDtoStatus$outboundSchema: z.ZodNativeEnum<typeof TriggerEventResponseDtoStatus> =
  TriggerEventResponseDtoStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventResponseDtoStatus$ {
  /** @deprecated use `TriggerEventResponseDtoStatus$inboundSchema` instead. */
  export const inboundSchema = TriggerEventResponseDtoStatus$inboundSchema;
  /** @deprecated use `TriggerEventResponseDtoStatus$outboundSchema` instead. */
  export const outboundSchema = TriggerEventResponseDtoStatus$outboundSchema;
}

/** @internal */
export const TriggerEventResponseDto$inboundSchema: z.ZodType<TriggerEventResponseDto, z.ZodTypeDef, unknown> =
  z.object({
    acknowledged: z.boolean(),
    status: TriggerEventResponseDtoStatus$inboundSchema,
    error: z.array(z.string()).optional(),
    transactionId: z.string().optional(),
  });

/** @internal */
export type TriggerEventResponseDto$Outbound = {
  acknowledged: boolean;
  status: string;
  error?: Array<string> | undefined;
  transactionId?: string | undefined;
};

/** @internal */
export const TriggerEventResponseDto$outboundSchema: z.ZodType<
  TriggerEventResponseDto$Outbound,
  z.ZodTypeDef,
  TriggerEventResponseDto
> = z.object({
  acknowledged: z.boolean(),
  status: TriggerEventResponseDtoStatus$outboundSchema,
  error: z.array(z.string()).optional(),
  transactionId: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventResponseDto$ {
  /** @deprecated use `TriggerEventResponseDto$inboundSchema` instead. */
  export const inboundSchema = TriggerEventResponseDto$inboundSchema;
  /** @deprecated use `TriggerEventResponseDto$outboundSchema` instead. */
  export const outboundSchema = TriggerEventResponseDto$outboundSchema;
  /** @deprecated use `TriggerEventResponseDto$Outbound` instead. */
  export type Outbound = TriggerEventResponseDto$Outbound;
}

export function triggerEventResponseDtoToJSON(triggerEventResponseDto: TriggerEventResponseDto): string {
  return JSON.stringify(TriggerEventResponseDto$outboundSchema.parse(triggerEventResponseDto));
}

export function triggerEventResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<TriggerEventResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TriggerEventResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TriggerEventResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - triggerEventResponseDtoToJSON(triggerEventResponseDto: TriggerEventResponseDto)
 - triggerEventResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TriggerEventResponseDto$Outbound;
}

export function triggerEventResponseDtoToJSON(triggerEventRespo...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function triggerEventResponseDtoToJSON
- export function triggerEventResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/triggereventtoallrequestdto.ts
Tamaño: 17273 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { collectExtraKeys as collectExtraKeys$, safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  EmailChannelOverrides,
  EmailChannelOverrides$inboundSchema,
  EmailChannelOverrides$Outbound,
  EmailChannelOverrides$outboundSchema,
} from './emailchanneloverrides.js';
import {
  SeverityLevelEnum,
  SeverityLevelEnum$inboundSchema,
  SeverityLevelEnum$outboundSchema,
} from './severitylevelenum.js';
import {
  StepsOverrides,
  StepsOverrides$inboundSchema,
  StepsOverrides$Outbound,
  StepsOverrides$outboundSchema,
} from './stepsoverrides.js';
import {
  SubscriberPayloadDto,
  SubscriberPayloadDto$inboundSchema,
  SubscriberPayloadDto$Outbound,
  SubscriberPayloadDto$outboundSchema,
} from './subscriberpayloaddto.js';
import {
  TenantPayloadDto,
  TenantPayloadDto$inboundSchema,
  TenantPayloadDto$Outbound,
  TenantPayloadDto$outboundSchema,
} from './tenantpayloaddto.js';

/**
 * Channel-specific overrides that apply to all steps of a particular channel type. Step-level overrides take precedence over channel-level overrides.
 */
export type TriggerEventToAllRequestDtoChannels = {
  /**
   * Email channel specific overrides
   */
  email?: EmailChannelOverrides | undefined;
};

/**
 * This could be used to override provider specific configurations
 */
export type TriggerEventToAllRequestDtoOverrides = {
  /**
   * This could be used to override provider specific configurations or layout at the step level
   */
  steps?: { [k: string]: StepsOverrides } | undefined;
  /**
   * Channel-specific overrides that apply to all steps of a particular channel type. Step-level overrides take precedence over channel-level overrides.
   */
  channels?: TriggerEventToAllRequestDtoChannels | undefined;
  /**
   * Overrides the provider configuration for the entire workflow and all steps
   */
  providers?: { [k: string]: { [k: string]: any } } | undefined;
  /**
   * Override the email provider specific configurations for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  email?: { [k: string]: any } | undefined;
  /**
   * Override the push provider specific configurations for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  push?: { [k: string]: any } | undefined;
  /**
   * Override the sms provider specific configurations for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  sms?: { [k: string]: any } | undefined;
  /**
   * Override the chat provider specific configurations for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  chat?: { [k: string]: any } | undefined;
  /**
   * Override the layout identifier for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  layoutIdentifier?: string | undefined;
  /**
   * Severity of the workflow
   */
  severity?: SeverityLevelEnum | undefined;
  additionalProperties?: { [k: string]: { [k: string]: any } } | undefined;
};

/**
 * It is used to display the Avatar of the provided actor's subscriber id or actor object.
 *
 * @remarks
 *     If a new actor object is provided, we will create a new subscriber in our system
 */
export type TriggerEventToAllRequestDtoActor = SubscriberPayloadDto | string;

/**
 * It is used to specify a tenant context during trigger event.
 *
 * @remarks
 *     If a new tenant object is provided, we will create a new tenant.
 */
export type TriggerEventToAllRequestDtoTenant = string | TenantPayloadDto;

export type TriggerEventToAllRequestDto = {
  /**
   * The trigger identifier associated for the template you wish to send. This identifier can be found on the template page.
   */
  name: string;
  /**
   * The payload object is used to pass additional information that
   *
   * @remarks
   *     could be used to render the template, or perform routing rules based on it.
   *       For In-App channel, payload data are also available in <Inbox />
   */
  payload: { [k: string]: any };
  /**
   * This could be used to override provider specific configurations
   */
  overrides?: TriggerEventToAllRequestDtoOverrides | undefined;
  /**
   * A unique identifier for this transaction, we will generated a UUID if not provided.
   */
  transactionId?: string | undefined;
  /**
   * It is used to display the Avatar of the provided actor's subscriber id or actor object.
   *
   * @remarks
   *     If a new actor object is provided, we will create a new subscriber in our system
   */
  actor?: SubscriberPayloadDto | string | undefined;
  /**
   * It is used to specify a tenant context during trigger event.
   *
   * @remarks
   *     If a new tenant object is provided, we will create a new tenant.
   */
  tenant?: string | TenantPayloadDto | undefined;
};

/** @internal */
export const TriggerEventToAllRequestDtoChannels$inboundSchema: z.ZodType<
  TriggerEventToAllRequestDtoChannels,
  z.ZodTypeDef,
  unknown
> = z.object({
  email: EmailChannelOverrides$inboundSchema.optional(),
});

/** @internal */
export type TriggerEventToAllRequestDtoChannels$Outbound = {
  email?: EmailChannelOverrides$Outbound | undefined;
};

/** @internal */
export const TriggerEventToAllRequestDtoChannels$outboundSchema: z.ZodType<
  TriggerEventToAllRequestDtoChannels$Outbound,
  z.ZodTypeDef,
  TriggerEventToAllRequestDtoChannels
> = z.object({
  email: EmailChannelOverrides$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventToAllRequestDtoChannels$ {
  /** @deprecated use `TriggerEventToAllRequestDtoChannels$inboundSchema` instead. */
  export const inboundSchema = TriggerEventToAllRequestDtoChannels$inboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDtoChannels$outboundSchema` instead. */
  export const outboundSchema = TriggerEventToAllRequestDtoChannels$outboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDtoChannels$Outbound` instead. */
  export type Outbound = TriggerEventToAllRequestDtoChannels$Outbound;
}

export function triggerEventToAllRequestDtoChannelsToJSON(
  triggerEventToAllRequestDtoChannels: TriggerEventToAllRequestDtoChannels
): string {
  return JSON.stringify(TriggerEventToAllRequestDtoChannels$outboundSchema.parse(triggerEventToAllRequestDtoChannels));
}

export function triggerEventToAllRequestDtoChannelsFromJSON(
  jsonString: string
): SafeParseResult<TriggerEventToAllRequestDtoChannels, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TriggerEventToAllRequestDtoChannels$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TriggerEventToAllRequestDtoChannels' from JSON`
  );
}

/** @internal */
export const TriggerEventToAllRequestDtoOverrides$inboundSchema: z.ZodType<
  TriggerEventToAllRequestDtoOverrides,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z
    .object({
      steps: z.record(StepsOverrides$inboundSchema).optional(),
      channels: z.lazy(() => TriggerEventToAllRequestDtoChannels$inboundSchema).optional(),
      providers: z.record(z.record(z.any())).optional(),
      email: z.record(z.any()).optional(),
      push: z.record(z.any()).optional(),
      sms: z.record(z.any()).optional(),
      chat: z.record(z.any()).optional(),
      layoutIdentifier: z.string().optional(),
      severity: SeverityLevelEnum$inboundSchema.optional(),
    })
    .catchall(z.record(z.any())),
  'additionalProperties',
  true
);

/** @internal */
export type TriggerEventToAllRequestDtoOverrides$Outbound = {
  steps?: { [k: string]: StepsOverrides$Outbound } | undefined;
  channels?: TriggerEventToAllRequestDtoChannels$Outbound | undefined;
  providers?: { [k: string]: { [k: string]: any } } | undefined;
  email?: { [k: string]: any } | undefined;
  push?: { [k: string]: any } | undefined;
  sms?: { [k: string]: any } | undefined;
  chat?: { [k: string]: any } | undefined;
  layoutIdentifier?: string | undefined;
  severity?: string | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const TriggerEventToAllRequestDtoOverrides$outboundSchema: z.ZodType<
  TriggerEventToAllRequestDtoOverrides$Outbound,
  z.ZodTypeDef,
  TriggerEventToAllRequestDtoOverrides
> = z
  .object({
    steps: z.record(StepsOverrides$outboundSchema).optional(),
    channels: z.lazy(() => TriggerEventToAllRequestDtoChannels$outboundSchema).optional(),
    providers: z.record(z.record(z.any())).optional(),
    email: z.record(z.any()).optional(),
    push: z.record(z.any()).optional(),
    sms: z.record(z.any()).optional(),
    chat: z.record(z.any()).optional(),
    layoutIdentifier: z.string().optional(),
    severity: SeverityLevelEnum$outboundSchema.optional(),
    additionalProperties: z.record(z.record(z.any())).optional(),
  })
  .transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventToAllRequestDtoOverrides$ {
  /** @deprecated use `TriggerEventToAllRequestDtoOverrides$inboundSchema` instead. */
  export const inboundSchema = TriggerEventToAllRequestDtoOverrides$inboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDtoOverrides$outboundSchema` instead. */
  export const outboundSchema = TriggerEventToAllRequestDtoOverrides$outboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDtoOverrides$Outbound` instead. */
  export type Outbound = TriggerEventToAllRequestDtoOverrides$Outbound;
}

export function triggerEventToAllRequestDtoOverridesToJSON(
  triggerEventToAllRequestDtoOverrides: TriggerEventToAllRequestDtoOverrides
): string {
  return JSON.stringify(
    TriggerEventToAllRequestDtoOverrides$outboundSchema.parse(triggerEventToAllRequestDtoOverrides)
  );
}

export function triggerEventToAllRequestDtoOverridesFromJSON(
  jsonString: string
): SafeParseResult<TriggerEventToAllRequestDtoOverrides, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TriggerEventToAllRequestDtoOverrides$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TriggerEventToAllRequestDtoOverrides' from JSON`
  );
}

/** @internal */
export const TriggerEventToAllRequestDtoActor$inboundSchema: z.ZodType<
  TriggerEventToAllRequestDtoActor,
  z.ZodTypeDef,
  unknown
> = z.union([SubscriberPayloadDto$inboundSchema, z.string()]);

/** @internal */
export type TriggerEventToAllRequestDtoActor$Outbound = SubscriberPayloadDto$Outbound | string;

/** @internal */
export const TriggerEventToAllRequestDtoActor$outboundSchema: z.ZodType<
  TriggerEventToAllRequestDtoActor$Outbound,
  z.ZodTypeDef,
  TriggerEventToAllRequestDtoActor
> = z.union([SubscriberPayloadDto$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventToAllRequestDtoActor$ {
  /** @deprecated use `TriggerEventToAllRequestDtoActor$inboundSchema` instead. */
  export const inboundSchema = TriggerEventToAllRequestDtoActor$inboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDtoActor$outboundSchema` instead. */
  export const outboundSchema = TriggerEventToAllRequestDtoActor$outboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDtoActor$Outbound` instead. */
  export type Outbound = TriggerEventToAllRequestDtoActor$Outbound;
}

export function triggerEventToAllRequestDtoActorToJSON(
  triggerEventToAllRequestDtoActor: TriggerEventToAllRequestDtoActor
): string {
  return JSON.stringify(TriggerEventToAllRequestDtoActor$outboundSchema.parse(triggerEventToAllRequestDtoActor));
}

export function triggerEventToAllRequestDtoActorFromJSON(
  jsonString: string
): SafeParseResult<TriggerEventToAllRequestDtoActor, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TriggerEventToAllRequestDtoActor$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TriggerEventToAllRequestDtoActor' from JSON`
  );
}

/** @internal */
export const TriggerEventToAllRequestDtoTenant$inboundSchema: z.ZodType<
  TriggerEventToAllRequestDtoTenant,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), TenantPayloadDto$inboundSchema]);

/** @internal */
export type TriggerEventToAllRequestDtoTenant$Outbound = string | TenantPayloadDto$Outbound;

/** @internal */
export const TriggerEventToAllRequestDtoTenant$outboundSchema: z.ZodType<
  TriggerEventToAllRequestDtoTenant$Outbound,
  z.ZodTypeDef,
  TriggerEventToAllRequestDtoTenant
> = z.union([z.string(), TenantPayloadDto$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventToAllRequestDtoTenant$ {
  /** @deprecated use `TriggerEventToAllRequestDtoTenant$inboundSchema` instead. */
  export const inboundSchema = TriggerEventToAllRequestDtoTenant$inboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDtoTenant$outboundSchema` instead. */
  export const outboundSchema = TriggerEventToAllRequestDtoTenant$outboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDtoTenant$Outbound` instead. */
  export type Outbound = TriggerEventToAllRequestDtoTenant$Outbound;
}

export function triggerEventToAllRequestDtoTenantToJSON(
  triggerEventToAllRequestDtoTenant: TriggerEventToAllRequestDtoTenant
): string {
  return JSON.stringify(TriggerEventToAllRequestDtoTenant$outboundSchema.parse(triggerEventToAllRequestDtoTenant));
}

export function triggerEventToAllRequestDtoTenantFromJSON(
  jsonString: string
): SafeParseResult<TriggerEventToAllRequestDtoTenant, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TriggerEventToAllRequestDtoTenant$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TriggerEventToAllRequestDtoTenant' from JSON`
  );
}

/** @internal */
export const TriggerEventToAllRequestDto$inboundSchema: z.ZodType<TriggerEventToAllRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    name: z.string(),
    payload: z.record(z.any()),
    overrides: z.lazy(() => TriggerEventToAllRequestDtoOverrides$inboundSchema).optional(),
    transactionId: z.string().optional(),
    actor: z.union([SubscriberPayloadDto$inboundSchema, z.string()]).optional(),
    tenant: z.union([z.string(), TenantPayloadDto$inboundSchema]).optional(),
  });

/** @internal */
export type TriggerEventToAllRequestDto$Outbound = {
  name: string;
  payload: { [k: string]: any };
  overrides?: TriggerEventToAllRequestDtoOverrides$Outbound | undefined;
  transactionId?: string | undefined;
  actor?: SubscriberPayloadDto$Outbound | string | undefined;
  tenant?: string | TenantPayloadDto$Outbound | undefined;
};

/** @internal */
export const TriggerEventToAllRequestDto$outboundSchema: z.ZodType<
  TriggerEventToAllRequestDto$Outbound,
  z.ZodTypeDef,
  TriggerEventToAllRequestDto
> = z.object({
  name: z.string(),
  payload: z.record(z.any()),
  overrides: z.lazy(() => TriggerEventToAllRequestDtoOverrides$outboundSchema).optional(),
  transactionId: z.string().optional(),
  actor: z.union([SubscriberPayloadDto$outboundSchema, z.string()]).optional(),
  tenant: z.union([z.string(), TenantPayloadDto$outboundSchema]).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventToAllRequestDto$ {
  /** @deprecated use `TriggerEventToAllRequestDto$inboundSchema` instead. */
  export const inboundSchema = TriggerEventToAllRequestDto$inboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDto$outboundSchema` instead. */
  export const outboundSchema = TriggerEventToAllRequestDto$outboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDto$Outbound` instead. */
  export type Outbound = TriggerEventToAllRequestDto$Outbound;
}

export function triggerEventToAllRequestDtoToJSON(triggerEventToAllRequestDto: TriggerEventToAllRequestDto): string {
  return JSON.stringify(TriggerEventToAllRequestDto$outboundSchema.parse(triggerEventToAllRequestDto));
}

export function triggerEventToAllRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<TriggerEventToAllRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TriggerEventToAllRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TriggerEventToAllRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - triggerEventToAllRequestDtoChannelsToJSON(triggerEventToAllRequestDtoChannels: TriggerEventToAllRequestDtoChannels)
 - triggerEventToAllRequestDtoChannelsFromJSON(jsonString: string)
 - triggerEventToAllRequestDtoOverridesToJSON(triggerEventToAllRequestDtoOverrides: TriggerEventToAllRequestDtoOverrides)
 - triggerEventToAllRequestDtoOverridesFromJSON(jsonString: string)
 - triggerEventToAllRequestDtoActorToJSON(triggerEventToAllRequestDtoActor: TriggerEventToAllRequestDtoActor)
 - triggerEventToAllRequestDtoActorFromJSON(jsonString: string)
 - triggerEventToAllRequestDtoTenantToJSON(triggerEventToAllRequestDtoTenant: TriggerEventToAllRequestDtoTenant)
 - triggerEventToAllRequestDtoTenantFromJSON(jsonString: string)
 - triggerEventToAllRequestDtoToJSON(triggerEventToAllRequestDto: TriggerEventToAllRequestDto)
 - triggerEventToAllRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TriggerEventToAllRequestDtoChannels$Outbound;
}

export function triggerEventToAllRequestDtoChannels...)
 - Outbound(TriggerEventToAllRequestDtoOverrides$Outbound;
}

export function triggerEventToAllRequestDtoOverrid...)
 - Outbound(TriggerEventToAllRequestDtoActor$Outbound;
}

export function triggerEventToAllRequestDtoActorToJSON...)
 - Outbound(TriggerEventToAllRequestDtoTenant$Outbound;
}

export function triggerEventToAllRequestDtoTenantToJS...)
 - Outbound(TriggerEventToAllRequestDto$Outbound;
}

export function triggerEventToAllRequestDtoToJSON(triggerEv...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function triggerEventToAllRequestDtoChannelsToJSON
- export function triggerEventToAllRequestDtoChannelsFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function triggerEventToAllRequestDtoOverridesToJSON
- export function triggerEventToAllRequestDtoOverridesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function triggerEventToAllRequestDtoActorToJSON
- export function triggerEventToAllRequestDtoActorFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function triggerEventToAllRequestDtoTenantToJSON
- export function triggerEventToAllRequestDtoTenantFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function triggerEventToAllRequestDtoToJSON
- export function triggerEventToAllRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/triggerrecipientstypeenum.ts
Tamaño: 1182 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

export const TriggerRecipientsTypeEnum = {
  Subscriber: 'Subscriber',
  Topic: 'Topic',
} as const;
export type TriggerRecipientsTypeEnum = ClosedEnum<typeof TriggerRecipientsTypeEnum>;

/** @internal */
export const TriggerRecipientsTypeEnum$inboundSchema: z.ZodNativeEnum<typeof TriggerRecipientsTypeEnum> =
  z.nativeEnum(TriggerRecipientsTypeEnum);

/** @internal */
export const TriggerRecipientsTypeEnum$outboundSchema: z.ZodNativeEnum<typeof TriggerRecipientsTypeEnum> =
  TriggerRecipientsTypeEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerRecipientsTypeEnum$ {
  /** @deprecated use `TriggerRecipientsTypeEnum$inboundSchema` instead. */
  export const inboundSchema = TriggerRecipientsTypeEnum$inboundSchema;
  /** @deprecated use `TriggerRecipientsTypeEnum$outboundSchema` instead. */
  export const outboundSchema = TriggerRecipientsTypeEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/uicomponentenum.ts
Tamaño: 2373 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Component type for the UI Schema Property
 */
export const UiComponentEnum = {
  EmailEditorSelect: 'EMAIL_EDITOR_SELECT',
  LayoutSelect: 'LAYOUT_SELECT',
  BlockEditor: 'BLOCK_EDITOR',
  EmailBody: 'EMAIL_BODY',
  TextFullLine: 'TEXT_FULL_LINE',
  TextInlineLabel: 'TEXT_INLINE_LABEL',
  InAppBody: 'IN_APP_BODY',
  InAppAvatar: 'IN_APP_AVATAR',
  InAppPrimarySubject: 'IN_APP_PRIMARY_SUBJECT',
  InAppButtonDropdown: 'IN_APP_BUTTON_DROPDOWN',
  InAppDisableSanitizationSwitch: 'IN_APP_DISABLE_SANITIZATION_SWITCH',
  DisableSanitizationSwitch: 'DISABLE_SANITIZATION_SWITCH',
  UrlTextBox: 'URL_TEXT_BOX',
  DigestAmount: 'DIGEST_AMOUNT',
  DigestUnit: 'DIGEST_UNIT',
  DigestType: 'DIGEST_TYPE',
  DigestKey: 'DIGEST_KEY',
  DigestCron: 'DIGEST_CRON',
  DelayAmount: 'DELAY_AMOUNT',
  DelayUnit: 'DELAY_UNIT',
  DelayType: 'DELAY_TYPE',
  DelayCron: 'DELAY_CRON',
  DelayDynamicKey: 'DELAY_DYNAMIC_KEY',
  ThrottleType: 'THROTTLE_TYPE',
  ThrottleWindow: 'THROTTLE_WINDOW',
  ThrottleUnit: 'THROTTLE_UNIT',
  ThrottleDynamicKey: 'THROTTLE_DYNAMIC_KEY',
  ThrottleThreshold: 'THROTTLE_THRESHOLD',
  ThrottleKey: 'THROTTLE_KEY',
  ExtendToSchedule: 'EXTEND_TO_SCHEDULE',
  SmsBody: 'SMS_BODY',
  ChatBody: 'CHAT_BODY',
  PushBody: 'PUSH_BODY',
  PushSubject: 'PUSH_SUBJECT',
  QueryEditor: 'QUERY_EDITOR',
  Data: 'DATA',
  LayoutEmail: 'LAYOUT_EMAIL',
} as const;
/**
 * Component type for the UI Schema Property
 */
export type UiComponentEnum = ClosedEnum<typeof UiComponentEnum>;

/** @internal */
export const UiComponentEnum$inboundSchema: z.ZodNativeEnum<typeof UiComponentEnum> = z.nativeEnum(UiComponentEnum);

/** @internal */
export const UiComponentEnum$outboundSchema: z.ZodNativeEnum<typeof UiComponentEnum> = UiComponentEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UiComponentEnum$ {
  /** @deprecated use `UiComponentEnum$inboundSchema` instead. */
  export const inboundSchema = UiComponentEnum$inboundSchema;
  /** @deprecated use `UiComponentEnum$outboundSchema` instead. */
  export const outboundSchema = UiComponentEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/uischema.ts
Tamaño: 2328 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  UiSchemaGroupEnum,
  UiSchemaGroupEnum$inboundSchema,
  UiSchemaGroupEnum$outboundSchema,
} from './uischemagroupenum.js';
import {
  UiSchemaProperty,
  UiSchemaProperty$inboundSchema,
  UiSchemaProperty$Outbound,
  UiSchemaProperty$outboundSchema,
} from './uischemaproperty.js';

export type UiSchema = {
  /**
   * Group of the UI Schema
   */
  group?: UiSchemaGroupEnum | undefined;
  /**
   * Properties of the UI Schema
   */
  properties?: { [k: string]: UiSchemaProperty } | undefined;
};

/** @internal */
export const UiSchema$inboundSchema: z.ZodType<UiSchema, z.ZodTypeDef, unknown> = z.object({
  group: UiSchemaGroupEnum$inboundSchema.optional(),
  properties: z.record(UiSchemaProperty$inboundSchema).optional(),
});

/** @internal */
export type UiSchema$Outbound = {
  group?: string | undefined;
  properties?: { [k: string]: UiSchemaProperty$Outbound } | undefined;
};

/** @internal */
export const UiSchema$outboundSchema: z.ZodType<UiSchema$Outbound, z.ZodTypeDef, UiSchema> = z.object({
  group: UiSchemaGroupEnum$outboundSchema.optional(),
  properties: z.record(UiSchemaProperty$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UiSchema$ {
  /** @deprecated use `UiSchema$inboundSchema` instead. */
  export const inboundSchema = UiSchema$inboundSchema;
  /** @deprecated use `UiSchema$outboundSchema` instead. */
  export const outboundSchema = UiSchema$outboundSchema;
  /** @deprecated use `UiSchema$Outbound` instead. */
  export type Outbound = UiSchema$Outbound;
}

export function uiSchemaToJSON(uiSchema: UiSchema): string {
  return JSON.stringify(UiSchema$outboundSchema.parse(uiSchema));
}

export function uiSchemaFromJSON(jsonString: string): SafeParseResult<UiSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UiSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UiSchema' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - uiSchemaToJSON(uiSchema: UiSchema)
 - uiSchemaFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UiSchema$Outbound;
}

export function uiSchemaToJSON(uiSchema: UiSchema): string {
  return JSON.str...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function uiSchemaToJSON
- export function uiSchemaFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/uischemagroupenum.ts
Tamaño: 1273 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Group of the UI Schema
 */
export const UiSchemaGroupEnum = {
  InApp: 'IN_APP',
  Email: 'EMAIL',
  Digest: 'DIGEST',
  Delay: 'DELAY',
  Throttle: 'THROTTLE',
  Sms: 'SMS',
  Chat: 'CHAT',
  Push: 'PUSH',
  Skip: 'SKIP',
  Layout: 'LAYOUT',
} as const;
/**
 * Group of the UI Schema
 */
export type UiSchemaGroupEnum = ClosedEnum<typeof UiSchemaGroupEnum>;

/** @internal */
export const UiSchemaGroupEnum$inboundSchema: z.ZodNativeEnum<typeof UiSchemaGroupEnum> =
  z.nativeEnum(UiSchemaGroupEnum);

/** @internal */
export const UiSchemaGroupEnum$outboundSchema: z.ZodNativeEnum<typeof UiSchemaGroupEnum> =
  UiSchemaGroupEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UiSchemaGroupEnum$ {
  /** @deprecated use `UiSchemaGroupEnum$inboundSchema` instead. */
  export const inboundSchema = UiSchemaGroupEnum$inboundSchema;
  /** @deprecated use `UiSchemaGroupEnum$outboundSchema` instead. */
  export const outboundSchema = UiSchemaGroupEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/uischemaproperty.ts
Tamaño: 6684 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { UiComponentEnum, UiComponentEnum$inboundSchema, UiComponentEnum$outboundSchema } from './uicomponentenum.js';

export type Placeholder5 = string | number | boolean | { [k: string]: any };

/**
 * Placeholder for the UI Schema Property
 */
export type Placeholder =
  | string
  | number
  | boolean
  | { [k: string]: any }
  | Array<string | number | boolean | { [k: string]: any }>;

export type UiSchemaProperty = {
  /**
   * Placeholder for the UI Schema Property
   */
  placeholder?:
    | string
    | number
    | boolean
    | { [k: string]: any }
    | Array<string | number | boolean | { [k: string]: any }>
    | null
    | undefined;
  /**
   * Component type for the UI Schema Property
   */
  component: UiComponentEnum;
  /**
   * Properties of the UI Schema
   */
  properties?: { [k: string]: UiSchemaProperty } | undefined;
};

/** @internal */
export const Placeholder5$inboundSchema: z.ZodType<Placeholder5, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/** @internal */
export type Placeholder5$Outbound =
  | string
  | number
  | boolean
  | {
      [k: string]: any;
    };

/** @internal */
export const Placeholder5$outboundSchema: z.ZodType<Placeholder5$Outbound, z.ZodTypeDef, Placeholder5> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Placeholder5$ {
  /** @deprecated use `Placeholder5$inboundSchema` instead. */
  export const inboundSchema = Placeholder5$inboundSchema;
  /** @deprecated use `Placeholder5$outboundSchema` instead. */
  export const outboundSchema = Placeholder5$outboundSchema;
  /** @deprecated use `Placeholder5$Outbound` instead. */
  export type Outbound = Placeholder5$Outbound;
}

export function placeholder5ToJSON(placeholder5: Placeholder5): string {
  return JSON.stringify(Placeholder5$outboundSchema.parse(placeholder5));
}

export function placeholder5FromJSON(jsonString: string): SafeParseResult<Placeholder5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Placeholder5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Placeholder5' from JSON`
  );
}

/** @internal */
export const Placeholder$inboundSchema: z.ZodType<Placeholder, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
  z.array(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())])),
]);

/** @internal */
export type Placeholder$Outbound =
  | string
  | number
  | boolean
  | {
      [k: string]: any;
    }
  | Array<string | number | boolean | { [k: string]: any }>;

/** @internal */
export const Placeholder$outboundSchema: z.ZodType<Placeholder$Outbound, z.ZodTypeDef, Placeholder> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
  z.array(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())])),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Placeholder$ {
  /** @deprecated use `Placeholder$inboundSchema` instead. */
  export const inboundSchema = Placeholder$inboundSchema;
  /** @deprecated use `Placeholder$outboundSchema` instead. */
  export const outboundSchema = Placeholder$outboundSchema;
  /** @deprecated use `Placeholder$Outbound` instead. */
  export type Outbound = Placeholder$Outbound;
}

export function placeholderToJSON(placeholder: Placeholder): string {
  return JSON.stringify(Placeholder$outboundSchema.parse(placeholder));
}

export function placeholderFromJSON(jsonString: string): SafeParseResult<Placeholder, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Placeholder$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Placeholder' from JSON`
  );
}

/** @internal */
export const UiSchemaProperty$inboundSchema: z.ZodType<UiSchemaProperty, z.ZodTypeDef, unknown> = z.object({
  placeholder: z
    .nullable(
      z.union([
        z.string(),
        z.number(),
        z.boolean(),
        z.record(z.any()),
        z.array(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())])),
      ])
    )
    .optional(),
  component: UiComponentEnum$inboundSchema,
  properties: z.record(z.lazy(() => UiSchemaProperty$inboundSchema)).optional(),
});

/** @internal */
export type UiSchemaProperty$Outbound = {
  placeholder?:
    | string
    | number
    | boolean
    | { [k: string]: any }
    | Array<string | number | boolean | { [k: string]: any }>
    | null
    | undefined;
  component: string;
  properties?: { [k: string]: UiSchemaProperty$Outbound } | undefined;
};

/** @internal */
export const UiSchemaProperty$outboundSchema: z.ZodType<UiSchemaProperty$Outbound, z.ZodTypeDef, UiSchemaProperty> =
  z.object({
    placeholder: z
      .nullable(
        z.union([
          z.string(),
          z.number(),
          z.boolean(),
          z.record(z.any()),
          z.array(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())])),
        ])
      )
      .optional(),
    component: UiComponentEnum$outboundSchema,
    properties: z.record(z.lazy(() => UiSchemaProperty$outboundSchema)).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UiSchemaProperty$ {
  /** @deprecated use `UiSchemaProperty$inboundSchema` instead. */
  export const inboundSchema = UiSchemaProperty$inboundSchema;
  /** @deprecated use `UiSchemaProperty$outboundSchema` instead. */
  export const outboundSchema = UiSchemaProperty$outboundSchema;
  /** @deprecated use `UiSchemaProperty$Outbound` instead. */
  export type Outbound = UiSchemaProperty$Outbound;
}

export function uiSchemaPropertyToJSON(uiSchemaProperty: UiSchemaProperty): string {
  return JSON.stringify(UiSchemaProperty$outboundSchema.parse(uiSchemaProperty));
}

export function uiSchemaPropertyFromJSON(jsonString: string): SafeParseResult<UiSchemaProperty, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UiSchemaProperty$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UiSchemaProperty' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - placeholder5ToJSON(placeholder5: Placeholder5)
 - placeholder5FromJSON(jsonString: string)
 - placeholderToJSON(placeholder: Placeholder)
 - placeholderFromJSON(jsonString: string)
 - uiSchemaPropertyToJSON(uiSchemaProperty: UiSchemaProperty)
 - uiSchemaPropertyFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Placeholder5$Outbound;
}

export function placeholder5ToJSON(placeholder5: Placeholder5): string {
 ...)
 - Outbound(Placeholder$Outbound;
}

export function placeholderToJSON(placeholder: Placeholder): string {
  ret...)
 - Outbound(UiSchemaProperty$Outbound;
}

export function uiSchemaPropertyToJSON(uiSchemaProperty: UiSchemaPrope...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function placeholder5ToJSON
- export function placeholder5FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function placeholderToJSON
- export function placeholderFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function uiSchemaPropertyToJSON
- export function uiSchemaPropertyFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/unseencountresponse.ts
Tamaño: 1845 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type UnseenCountResponse = {
  count: number;
};

/** @internal */
export const UnseenCountResponse$inboundSchema: z.ZodType<UnseenCountResponse, z.ZodTypeDef, unknown> = z.object({
  count: z.number(),
});

/** @internal */
export type UnseenCountResponse$Outbound = {
  count: number;
};

/** @internal */
export const UnseenCountResponse$outboundSchema: z.ZodType<
  UnseenCountResponse$Outbound,
  z.ZodTypeDef,
  UnseenCountResponse
> = z.object({
  count: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UnseenCountResponse$ {
  /** @deprecated use `UnseenCountResponse$inboundSchema` instead. */
  export const inboundSchema = UnseenCountResponse$inboundSchema;
  /** @deprecated use `UnseenCountResponse$outboundSchema` instead. */
  export const outboundSchema = UnseenCountResponse$outboundSchema;
  /** @deprecated use `UnseenCountResponse$Outbound` instead. */
  export type Outbound = UnseenCountResponse$Outbound;
}

export function unseenCountResponseToJSON(unseenCountResponse: UnseenCountResponse): string {
  return JSON.stringify(UnseenCountResponse$outboundSchema.parse(unseenCountResponse));
}

export function unseenCountResponseFromJSON(
  jsonString: string
): SafeParseResult<UnseenCountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UnseenCountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UnseenCountResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - unseenCountResponseToJSON(unseenCountResponse: UnseenCountResponse)
 - unseenCountResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UnseenCountResponse$Outbound;
}

export function unseenCountResponseToJSON(unseenCountResponse: Unse...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function unseenCountResponseToJSON
- export function unseenCountResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updatecontextrequestdto.ts
Tamaño: 3907 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Custom data to associate with this context. Replaces existing data.
 */
export type UpdateContextRequestDtoData = {};

export type UpdateContextRequestDto = {
  /**
   * Custom data to associate with this context. Replaces existing data.
   */
  data: UpdateContextRequestDtoData;
};

/** @internal */
export const UpdateContextRequestDtoData$inboundSchema: z.ZodType<UpdateContextRequestDtoData, z.ZodTypeDef, unknown> =
  z.object({});

/** @internal */
export type UpdateContextRequestDtoData$Outbound = {};

/** @internal */
export const UpdateContextRequestDtoData$outboundSchema: z.ZodType<
  UpdateContextRequestDtoData$Outbound,
  z.ZodTypeDef,
  UpdateContextRequestDtoData
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateContextRequestDtoData$ {
  /** @deprecated use `UpdateContextRequestDtoData$inboundSchema` instead. */
  export const inboundSchema = UpdateContextRequestDtoData$inboundSchema;
  /** @deprecated use `UpdateContextRequestDtoData$outboundSchema` instead. */
  export const outboundSchema = UpdateContextRequestDtoData$outboundSchema;
  /** @deprecated use `UpdateContextRequestDtoData$Outbound` instead. */
  export type Outbound = UpdateContextRequestDtoData$Outbound;
}

export function updateContextRequestDtoDataToJSON(updateContextRequestDtoData: UpdateContextRequestDtoData): string {
  return JSON.stringify(UpdateContextRequestDtoData$outboundSchema.parse(updateContextRequestDtoData));
}

export function updateContextRequestDtoDataFromJSON(
  jsonString: string
): SafeParseResult<UpdateContextRequestDtoData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateContextRequestDtoData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateContextRequestDtoData' from JSON`
  );
}

/** @internal */
export const UpdateContextRequestDto$inboundSchema: z.ZodType<UpdateContextRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    data: z.lazy(() => UpdateContextRequestDtoData$inboundSchema),
  });

/** @internal */
export type UpdateContextRequestDto$Outbound = {
  data: UpdateContextRequestDtoData$Outbound;
};

/** @internal */
export const UpdateContextRequestDto$outboundSchema: z.ZodType<
  UpdateContextRequestDto$Outbound,
  z.ZodTypeDef,
  UpdateContextRequestDto
> = z.object({
  data: z.lazy(() => UpdateContextRequestDtoData$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateContextRequestDto$ {
  /** @deprecated use `UpdateContextRequestDto$inboundSchema` instead. */
  export const inboundSchema = UpdateContextRequestDto$inboundSchema;
  /** @deprecated use `UpdateContextRequestDto$outboundSchema` instead. */
  export const outboundSchema = UpdateContextRequestDto$outboundSchema;
  /** @deprecated use `UpdateContextRequestDto$Outbound` instead. */
  export type Outbound = UpdateContextRequestDto$Outbound;
}

export function updateContextRequestDtoToJSON(updateContextRequestDto: UpdateContextRequestDto): string {
  return JSON.stringify(UpdateContextRequestDto$outboundSchema.parse(updateContextRequestDto));
}

export function updateContextRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<UpdateContextRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateContextRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateContextRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateContextRequestDtoDataToJSON(updateContextRequestDtoData: UpdateContextRequestDtoData)
 - updateContextRequestDtoDataFromJSON(jsonString: string)
 - updateContextRequestDtoToJSON(updateContextRequestDto: UpdateContextRequestDto)
 - updateContextRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdateContextRequestDtoData$Outbound;
}

export function updateContextRequestDtoDataToJSON(updateCon...)
 - Outbound(UpdateContextRequestDto$Outbound;
}

export function updateContextRequestDtoToJSON(updateContextRequ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateContextRequestDtoDataToJSON
- export function updateContextRequestDtoDataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateContextRequestDtoToJSON
- export function updateContextRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updatedsubscriberdto.ts
Tamaño: 1956 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type UpdatedSubscriberDto = {
  /**
   * The ID of the subscriber that was updated.
   */
  subscriberId: string;
};

/** @internal */
export const UpdatedSubscriberDto$inboundSchema: z.ZodType<UpdatedSubscriberDto, z.ZodTypeDef, unknown> = z.object({
  subscriberId: z.string(),
});

/** @internal */
export type UpdatedSubscriberDto$Outbound = {
  subscriberId: string;
};

/** @internal */
export const UpdatedSubscriberDto$outboundSchema: z.ZodType<
  UpdatedSubscriberDto$Outbound,
  z.ZodTypeDef,
  UpdatedSubscriberDto
> = z.object({
  subscriberId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatedSubscriberDto$ {
  /** @deprecated use `UpdatedSubscriberDto$inboundSchema` instead. */
  export const inboundSchema = UpdatedSubscriberDto$inboundSchema;
  /** @deprecated use `UpdatedSubscriberDto$outboundSchema` instead. */
  export const outboundSchema = UpdatedSubscriberDto$outboundSchema;
  /** @deprecated use `UpdatedSubscriberDto$Outbound` instead. */
  export type Outbound = UpdatedSubscriberDto$Outbound;
}

export function updatedSubscriberDtoToJSON(updatedSubscriberDto: UpdatedSubscriberDto): string {
  return JSON.stringify(UpdatedSubscriberDto$outboundSchema.parse(updatedSubscriberDto));
}

export function updatedSubscriberDtoFromJSON(
  jsonString: string
): SafeParseResult<UpdatedSubscriberDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatedSubscriberDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatedSubscriberDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updatedSubscriberDtoToJSON(updatedSubscriberDto: UpdatedSubscriberDto)
 - updatedSubscriberDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdatedSubscriberDto$Outbound;
}

export function updatedSubscriberDtoToJSON(updatedSubscriberDto: U...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updatedSubscriberDtoToJSON
- export function updatedSubscriberDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updateenvironmentrequestdto.ts
Tamaño: 3294 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  BridgeConfigurationDto,
  BridgeConfigurationDto$inboundSchema,
  BridgeConfigurationDto$Outbound,
  BridgeConfigurationDto$outboundSchema,
} from './bridgeconfigurationdto.js';
import {
  InBoundParseDomainDto,
  InBoundParseDomainDto$inboundSchema,
  InBoundParseDomainDto$Outbound,
  InBoundParseDomainDto$outboundSchema,
} from './inboundparsedomaindto.js';

export type UpdateEnvironmentRequestDto = {
  name?: string | undefined;
  identifier?: string | undefined;
  parentId?: string | undefined;
  color?: string | undefined;
  dns?: InBoundParseDomainDto | undefined;
  bridge?: BridgeConfigurationDto | undefined;
};

/** @internal */
export const UpdateEnvironmentRequestDto$inboundSchema: z.ZodType<UpdateEnvironmentRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    name: z.string().optional(),
    identifier: z.string().optional(),
    parentId: z.string().optional(),
    color: z.string().optional(),
    dns: InBoundParseDomainDto$inboundSchema.optional(),
    bridge: BridgeConfigurationDto$inboundSchema.optional(),
  });

/** @internal */
export type UpdateEnvironmentRequestDto$Outbound = {
  name?: string | undefined;
  identifier?: string | undefined;
  parentId?: string | undefined;
  color?: string | undefined;
  dns?: InBoundParseDomainDto$Outbound | undefined;
  bridge?: BridgeConfigurationDto$Outbound | undefined;
};

/** @internal */
export const UpdateEnvironmentRequestDto$outboundSchema: z.ZodType<
  UpdateEnvironmentRequestDto$Outbound,
  z.ZodTypeDef,
  UpdateEnvironmentRequestDto
> = z.object({
  name: z.string().optional(),
  identifier: z.string().optional(),
  parentId: z.string().optional(),
  color: z.string().optional(),
  dns: InBoundParseDomainDto$outboundSchema.optional(),
  bridge: BridgeConfigurationDto$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateEnvironmentRequestDto$ {
  /** @deprecated use `UpdateEnvironmentRequestDto$inboundSchema` instead. */
  export const inboundSchema = UpdateEnvironmentRequestDto$inboundSchema;
  /** @deprecated use `UpdateEnvironmentRequestDto$outboundSchema` instead. */
  export const outboundSchema = UpdateEnvironmentRequestDto$outboundSchema;
  /** @deprecated use `UpdateEnvironmentRequestDto$Outbound` instead. */
  export type Outbound = UpdateEnvironmentRequestDto$Outbound;
}

export function updateEnvironmentRequestDtoToJSON(updateEnvironmentRequestDto: UpdateEnvironmentRequestDto): string {
  return JSON.stringify(UpdateEnvironmentRequestDto$outboundSchema.parse(updateEnvironmentRequestDto));
}

export function updateEnvironmentRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<UpdateEnvironmentRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateEnvironmentRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateEnvironmentRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateEnvironmentRequestDtoToJSON(updateEnvironmentRequestDto: UpdateEnvironmentRequestDto)
 - updateEnvironmentRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdateEnvironmentRequestDto$Outbound;
}

export function updateEnvironmentRequestDtoToJSON(updateEnv...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateEnvironmentRequestDtoToJSON
- export function updateEnvironmentRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updateintegrationrequestdto.ts
Tamaño: 6252 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  CredentialsDto,
  CredentialsDto$inboundSchema,
  CredentialsDto$Outbound,
  CredentialsDto$outboundSchema,
} from './credentialsdto.js';
import {
  StepFilterDto,
  StepFilterDto$inboundSchema,
  StepFilterDto$Outbound,
  StepFilterDto$outboundSchema,
} from './stepfilterdto.js';

/**
 * Configurations for the integration
 */
export type UpdateIntegrationRequestDtoConfigurations = {};

export type UpdateIntegrationRequestDto = {
  name?: string | undefined;
  identifier?: string | undefined;
  environmentId?: string | undefined;
  /**
   * If the integration is active the validation on the credentials field will run
   */
  active?: boolean | undefined;
  credentials?: CredentialsDto | undefined;
  check?: boolean | undefined;
  conditions?: Array<StepFilterDto> | undefined;
  /**
   * Configurations for the integration
   */
  configurations?: UpdateIntegrationRequestDtoConfigurations | undefined;
};

/** @internal */
export const UpdateIntegrationRequestDtoConfigurations$inboundSchema: z.ZodType<
  UpdateIntegrationRequestDtoConfigurations,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type UpdateIntegrationRequestDtoConfigurations$Outbound = {};

/** @internal */
export const UpdateIntegrationRequestDtoConfigurations$outboundSchema: z.ZodType<
  UpdateIntegrationRequestDtoConfigurations$Outbound,
  z.ZodTypeDef,
  UpdateIntegrationRequestDtoConfigurations
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateIntegrationRequestDtoConfigurations$ {
  /** @deprecated use `UpdateIntegrationRequestDtoConfigurations$inboundSchema` instead. */
  export const inboundSchema = UpdateIntegrationRequestDtoConfigurations$inboundSchema;
  /** @deprecated use `UpdateIntegrationRequestDtoConfigurations$outboundSchema` instead. */
  export const outboundSchema = UpdateIntegrationRequestDtoConfigurations$outboundSchema;
  /** @deprecated use `UpdateIntegrationRequestDtoConfigurations$Outbound` instead. */
  export type Outbound = UpdateIntegrationRequestDtoConfigurations$Outbound;
}

export function updateIntegrationRequestDtoConfigurationsToJSON(
  updateIntegrationRequestDtoConfigurations: UpdateIntegrationRequestDtoConfigurations
): string {
  return JSON.stringify(
    UpdateIntegrationRequestDtoConfigurations$outboundSchema.parse(updateIntegrationRequestDtoConfigurations)
  );
}

export function updateIntegrationRequestDtoConfigurationsFromJSON(
  jsonString: string
): SafeParseResult<UpdateIntegrationRequestDtoConfigurations, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateIntegrationRequestDtoConfigurations$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateIntegrationRequestDtoConfigurations' from JSON`
  );
}

/** @internal */
export const UpdateIntegrationRequestDto$inboundSchema: z.ZodType<UpdateIntegrationRequestDto, z.ZodTypeDef, unknown> =
  z
    .object({
      name: z.string().optional(),
      identifier: z.string().optional(),
      _environmentId: z.string().optional(),
      active: z.boolean().optional(),
      credentials: CredentialsDto$inboundSchema.optional(),
      check: z.boolean().optional(),
      conditions: z.array(StepFilterDto$inboundSchema).optional(),
      configurations: z.lazy(() => UpdateIntegrationRequestDtoConfigurations$inboundSchema).optional(),
    })
    .transform((v) => {
      return remap$(v, {
        _environmentId: 'environmentId',
      });
    });

/** @internal */
export type UpdateIntegrationRequestDto$Outbound = {
  name?: string | undefined;
  identifier?: string | undefined;
  _environmentId?: string | undefined;
  active?: boolean | undefined;
  credentials?: CredentialsDto$Outbound | undefined;
  check?: boolean | undefined;
  conditions?: Array<StepFilterDto$Outbound> | undefined;
  configurations?: UpdateIntegrationRequestDtoConfigurations$Outbound | undefined;
};

/** @internal */
export const UpdateIntegrationRequestDto$outboundSchema: z.ZodType<
  UpdateIntegrationRequestDto$Outbound,
  z.ZodTypeDef,
  UpdateIntegrationRequestDto
> = z
  .object({
    name: z.string().optional(),
    identifier: z.string().optional(),
    environmentId: z.string().optional(),
    active: z.boolean().optional(),
    credentials: CredentialsDto$outboundSchema.optional(),
    check: z.boolean().optional(),
    conditions: z.array(StepFilterDto$outboundSchema).optional(),
    configurations: z.lazy(() => UpdateIntegrationRequestDtoConfigurations$outboundSchema).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      environmentId: '_environmentId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateIntegrationRequestDto$ {
  /** @deprecated use `UpdateIntegrationRequestDto$inboundSchema` instead. */
  export const inboundSchema = UpdateIntegrationRequestDto$inboundSchema;
  /** @deprecated use `UpdateIntegrationRequestDto$outboundSchema` instead. */
  export const outboundSchema = UpdateIntegrationRequestDto$outboundSchema;
  /** @deprecated use `UpdateIntegrationRequestDto$Outbound` instead. */
  export type Outbound = UpdateIntegrationRequestDto$Outbound;
}

export function updateIntegrationRequestDtoToJSON(updateIntegrationRequestDto: UpdateIntegrationRequestDto): string {
  return JSON.stringify(UpdateIntegrationRequestDto$outboundSchema.parse(updateIntegrationRequestDto));
}

export function updateIntegrationRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<UpdateIntegrationRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateIntegrationRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateIntegrationRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateIntegrationRequestDtoConfigurationsToJSON(updateIntegrationRequestDtoConfigurations: UpdateIntegrationRequestDtoConfigurations)
 - updateIntegrationRequestDtoConfigurationsFromJSON(jsonString: string)
 - updateIntegrationRequestDtoToJSON(updateIntegrationRequestDto: UpdateIntegrationRequestDto)
 - updateIntegrationRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdateIntegrationRequestDtoConfigurations$Outbound;
}

export function updateIntegrationRequestDtoCo...)
 - Outbound(UpdateIntegrationRequestDto$Outbound;
}

export function updateIntegrationRequestDtoToJSON(updateInt...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateIntegrationRequestDtoConfigurationsToJSON
- export function updateIntegrationRequestDtoConfigurationsFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateIntegrationRequestDtoToJSON
- export function updateIntegrationRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updatelayoutdto.ts
Tamaño: 4120 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  EmailControlsDto,
  EmailControlsDto$inboundSchema,
  EmailControlsDto$Outbound,
  EmailControlsDto$outboundSchema,
} from './emailcontrolsdto.js';

/**
 * Control values for the layout
 */
export type ControlValues = {
  /**
   * Email layout controls
   */
  email?: EmailControlsDto | undefined;
};

export type UpdateLayoutDto = {
  /**
   * Name of the layout
   */
  name: string;
  /**
   * Enable or disable translations for this layout
   */
  isTranslationEnabled?: boolean | undefined;
  /**
   * Control values for the layout
   */
  controlValues?: ControlValues | null | undefined;
};

/** @internal */
export const ControlValues$inboundSchema: z.ZodType<ControlValues, z.ZodTypeDef, unknown> = z.object({
  email: EmailControlsDto$inboundSchema.optional(),
});

/** @internal */
export type ControlValues$Outbound = {
  email?: EmailControlsDto$Outbound | undefined;
};

/** @internal */
export const ControlValues$outboundSchema: z.ZodType<ControlValues$Outbound, z.ZodTypeDef, ControlValues> = z.object({
  email: EmailControlsDto$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ControlValues$ {
  /** @deprecated use `ControlValues$inboundSchema` instead. */
  export const inboundSchema = ControlValues$inboundSchema;
  /** @deprecated use `ControlValues$outboundSchema` instead. */
  export const outboundSchema = ControlValues$outboundSchema;
  /** @deprecated use `ControlValues$Outbound` instead. */
  export type Outbound = ControlValues$Outbound;
}

export function controlValuesToJSON(controlValues: ControlValues): string {
  return JSON.stringify(ControlValues$outboundSchema.parse(controlValues));
}

export function controlValuesFromJSON(jsonString: string): SafeParseResult<ControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ControlValues' from JSON`
  );
}

/** @internal */
export const UpdateLayoutDto$inboundSchema: z.ZodType<UpdateLayoutDto, z.ZodTypeDef, unknown> = z.object({
  name: z.string(),
  isTranslationEnabled: z.boolean().default(false),
  controlValues: z.nullable(z.lazy(() => ControlValues$inboundSchema)).optional(),
});

/** @internal */
export type UpdateLayoutDto$Outbound = {
  name: string;
  isTranslationEnabled: boolean;
  controlValues?: ControlValues$Outbound | null | undefined;
};

/** @internal */
export const UpdateLayoutDto$outboundSchema: z.ZodType<UpdateLayoutDto$Outbound, z.ZodTypeDef, UpdateLayoutDto> =
  z.object({
    name: z.string(),
    isTranslationEnabled: z.boolean().default(false),
    controlValues: z.nullable(z.lazy(() => ControlValues$outboundSchema)).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateLayoutDto$ {
  /** @deprecated use `UpdateLayoutDto$inboundSchema` instead. */
  export const inboundSchema = UpdateLayoutDto$inboundSchema;
  /** @deprecated use `UpdateLayoutDto$outboundSchema` instead. */
  export const outboundSchema = UpdateLayoutDto$outboundSchema;
  /** @deprecated use `UpdateLayoutDto$Outbound` instead. */
  export type Outbound = UpdateLayoutDto$Outbound;
}

export function updateLayoutDtoToJSON(updateLayoutDto: UpdateLayoutDto): string {
  return JSON.stringify(UpdateLayoutDto$outboundSchema.parse(updateLayoutDto));
}

export function updateLayoutDtoFromJSON(jsonString: string): SafeParseResult<UpdateLayoutDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateLayoutDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateLayoutDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - controlValuesToJSON(controlValues: ControlValues)
 - controlValuesFromJSON(jsonString: string)
 - updateLayoutDtoToJSON(updateLayoutDto: UpdateLayoutDto)
 - updateLayoutDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ControlValues$Outbound;
}

export function controlValuesToJSON(controlValues: ControlValues): string...)
 - Outbound(UpdateLayoutDto$Outbound;
}

export function updateLayoutDtoToJSON(updateLayoutDto: UpdateLayoutDto)...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function controlValuesToJSON
- export function controlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateLayoutDtoToJSON
- export function updateLayoutDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updatesubscriberchannelrequestdto.ts
Tamaño: 3126 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelCredentials,
  ChannelCredentials$inboundSchema,
  ChannelCredentials$Outbound,
  ChannelCredentials$outboundSchema,
} from './channelcredentials.js';
import {
  ChatOrPushProviderEnum,
  ChatOrPushProviderEnum$inboundSchema,
  ChatOrPushProviderEnum$outboundSchema,
} from './chatorpushproviderenum.js';

export type UpdateSubscriberChannelRequestDto = {
  /**
   * The provider identifier for the credentials
   */
  providerId: ChatOrPushProviderEnum;
  /**
   * The integration identifier
   */
  integrationIdentifier?: string | undefined;
  /**
   * Credentials payload for the specified provider
   */
  credentials: ChannelCredentials;
};

/** @internal */
export const UpdateSubscriberChannelRequestDto$inboundSchema: z.ZodType<
  UpdateSubscriberChannelRequestDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  providerId: ChatOrPushProviderEnum$inboundSchema,
  integrationIdentifier: z.string().optional(),
  credentials: ChannelCredentials$inboundSchema,
});

/** @internal */
export type UpdateSubscriberChannelRequestDto$Outbound = {
  providerId: string;
  integrationIdentifier?: string | undefined;
  credentials: ChannelCredentials$Outbound;
};

/** @internal */
export const UpdateSubscriberChannelRequestDto$outboundSchema: z.ZodType<
  UpdateSubscriberChannelRequestDto$Outbound,
  z.ZodTypeDef,
  UpdateSubscriberChannelRequestDto
> = z.object({
  providerId: ChatOrPushProviderEnum$outboundSchema,
  integrationIdentifier: z.string().optional(),
  credentials: ChannelCredentials$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriberChannelRequestDto$ {
  /** @deprecated use `UpdateSubscriberChannelRequestDto$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriberChannelRequestDto$inboundSchema;
  /** @deprecated use `UpdateSubscriberChannelRequestDto$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriberChannelRequestDto$outboundSchema;
  /** @deprecated use `UpdateSubscriberChannelRequestDto$Outbound` instead. */
  export type Outbound = UpdateSubscriberChannelRequestDto$Outbound;
}

export function updateSubscriberChannelRequestDtoToJSON(
  updateSubscriberChannelRequestDto: UpdateSubscriberChannelRequestDto
): string {
  return JSON.stringify(UpdateSubscriberChannelRequestDto$outboundSchema.parse(updateSubscriberChannelRequestDto));
}

export function updateSubscriberChannelRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<UpdateSubscriberChannelRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriberChannelRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriberChannelRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateSubscriberChannelRequestDtoToJSON(updateSubscriberChannelRequestDto: UpdateSubscriberChannelRequestDto)
 - updateSubscriberChannelRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdateSubscriberChannelRequestDto$Outbound;
}

export function updateSubscriberChannelRequestDtoToJS...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateSubscriberChannelRequestDtoToJSON
- export function updateSubscriberChannelRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updatesubscriberonlineflagrequestdto.ts
Tamaño: 2272 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type UpdateSubscriberOnlineFlagRequestDto = {
  isOnline: boolean;
};

/** @internal */
export const UpdateSubscriberOnlineFlagRequestDto$inboundSchema: z.ZodType<
  UpdateSubscriberOnlineFlagRequestDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  isOnline: z.boolean(),
});

/** @internal */
export type UpdateSubscriberOnlineFlagRequestDto$Outbound = {
  isOnline: boolean;
};

/** @internal */
export const UpdateSubscriberOnlineFlagRequestDto$outboundSchema: z.ZodType<
  UpdateSubscriberOnlineFlagRequestDto$Outbound,
  z.ZodTypeDef,
  UpdateSubscriberOnlineFlagRequestDto
> = z.object({
  isOnline: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriberOnlineFlagRequestDto$ {
  /** @deprecated use `UpdateSubscriberOnlineFlagRequestDto$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriberOnlineFlagRequestDto$inboundSchema;
  /** @deprecated use `UpdateSubscriberOnlineFlagRequestDto$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriberOnlineFlagRequestDto$outboundSchema;
  /** @deprecated use `UpdateSubscriberOnlineFlagRequestDto$Outbound` instead. */
  export type Outbound = UpdateSubscriberOnlineFlagRequestDto$Outbound;
}

export function updateSubscriberOnlineFlagRequestDtoToJSON(
  updateSubscriberOnlineFlagRequestDto: UpdateSubscriberOnlineFlagRequestDto
): string {
  return JSON.stringify(
    UpdateSubscriberOnlineFlagRequestDto$outboundSchema.parse(updateSubscriberOnlineFlagRequestDto)
  );
}

export function updateSubscriberOnlineFlagRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<UpdateSubscriberOnlineFlagRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriberOnlineFlagRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriberOnlineFlagRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateSubscriberOnlineFlagRequestDtoToJSON(updateSubscriberOnlineFlagRequestDto: UpdateSubscriberOnlineFlagRequestDto)
 - updateSubscriberOnlineFlagRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdateSubscriberOnlineFlagRequestDto$Outbound;
}

export function updateSubscriberOnlineFlagRequestD...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateSubscriberOnlineFlagRequestDtoToJSON
- export function updateSubscriberOnlineFlagRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updatetopicrequestdto.ts
Tamaño: 1935 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type UpdateTopicRequestDto = {
  /**
   * The display name for the topic
   */
  name: string;
};

/** @internal */
export const UpdateTopicRequestDto$inboundSchema: z.ZodType<UpdateTopicRequestDto, z.ZodTypeDef, unknown> = z.object({
  name: z.string(),
});

/** @internal */
export type UpdateTopicRequestDto$Outbound = {
  name: string;
};

/** @internal */
export const UpdateTopicRequestDto$outboundSchema: z.ZodType<
  UpdateTopicRequestDto$Outbound,
  z.ZodTypeDef,
  UpdateTopicRequestDto
> = z.object({
  name: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateTopicRequestDto$ {
  /** @deprecated use `UpdateTopicRequestDto$inboundSchema` instead. */
  export const inboundSchema = UpdateTopicRequestDto$inboundSchema;
  /** @deprecated use `UpdateTopicRequestDto$outboundSchema` instead. */
  export const outboundSchema = UpdateTopicRequestDto$outboundSchema;
  /** @deprecated use `UpdateTopicRequestDto$Outbound` instead. */
  export type Outbound = UpdateTopicRequestDto$Outbound;
}

export function updateTopicRequestDtoToJSON(updateTopicRequestDto: UpdateTopicRequestDto): string {
  return JSON.stringify(UpdateTopicRequestDto$outboundSchema.parse(updateTopicRequestDto));
}

export function updateTopicRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<UpdateTopicRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateTopicRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateTopicRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateTopicRequestDtoToJSON(updateTopicRequestDto: UpdateTopicRequestDto)
 - updateTopicRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdateTopicRequestDto$Outbound;
}

export function updateTopicRequestDtoToJSON(updateTopicRequestDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateTopicRequestDtoToJSON
- export function updateTopicRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updateworkflowdto.ts
Tamaño: 13722 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChatStepUpsertDto,
  ChatStepUpsertDto$inboundSchema,
  ChatStepUpsertDto$Outbound,
  ChatStepUpsertDto$outboundSchema,
} from './chatstepupsertdto.js';
import {
  CustomStepUpsertDto,
  CustomStepUpsertDto$inboundSchema,
  CustomStepUpsertDto$Outbound,
  CustomStepUpsertDto$outboundSchema,
} from './customstepupsertdto.js';
import {
  DelayStepUpsertDto,
  DelayStepUpsertDto$inboundSchema,
  DelayStepUpsertDto$Outbound,
  DelayStepUpsertDto$outboundSchema,
} from './delaystepupsertdto.js';
import {
  DigestStepUpsertDto,
  DigestStepUpsertDto$inboundSchema,
  DigestStepUpsertDto$Outbound,
  DigestStepUpsertDto$outboundSchema,
} from './digeststepupsertdto.js';
import {
  EmailStepUpsertDto,
  EmailStepUpsertDto$inboundSchema,
  EmailStepUpsertDto$Outbound,
  EmailStepUpsertDto$outboundSchema,
} from './emailstepupsertdto.js';
import {
  InAppStepUpsertDto,
  InAppStepUpsertDto$inboundSchema,
  InAppStepUpsertDto$Outbound,
  InAppStepUpsertDto$outboundSchema,
} from './inappstepupsertdto.js';
import {
  PreferencesRequestDto,
  PreferencesRequestDto$inboundSchema,
  PreferencesRequestDto$Outbound,
  PreferencesRequestDto$outboundSchema,
} from './preferencesrequestdto.js';
import {
  PushStepUpsertDto,
  PushStepUpsertDto$inboundSchema,
  PushStepUpsertDto$Outbound,
  PushStepUpsertDto$outboundSchema,
} from './pushstepupsertdto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  SeverityLevelEnum,
  SeverityLevelEnum$inboundSchema,
  SeverityLevelEnum$outboundSchema,
} from './severitylevelenum.js';
import {
  SmsStepUpsertDto,
  SmsStepUpsertDto$inboundSchema,
  SmsStepUpsertDto$Outbound,
  SmsStepUpsertDto$outboundSchema,
} from './smsstepupsertdto.js';

export type UpdateWorkflowDtoSteps =
  | (InAppStepUpsertDto & { type: 'in_app' })
  | (EmailStepUpsertDto & { type: 'email' })
  | (SmsStepUpsertDto & { type: 'sms' })
  | (PushStepUpsertDto & { type: 'push' })
  | (ChatStepUpsertDto & { type: 'chat' })
  | (DelayStepUpsertDto & { type: 'delay' })
  | (DigestStepUpsertDto & { type: 'digest' })
  | (CustomStepUpsertDto & { type: 'custom' });

export type UpdateWorkflowDto = {
  /**
   * Name of the workflow
   */
  name: string;
  /**
   * Description of the workflow
   */
  description?: string | undefined;
  /**
   * Tags associated with the workflow
   */
  tags?: Array<string> | undefined;
  /**
   * Whether the workflow is active
   */
  active?: boolean | undefined;
  /**
   * Enable or disable payload schema validation
   */
  validatePayload?: boolean | undefined;
  /**
   * The payload JSON Schema for the workflow
   */
  payloadSchema?: { [k: string]: any } | null | undefined;
  /**
   * Enable or disable translations for this workflow
   */
  isTranslationEnabled?: boolean | undefined;
  /**
   * Workflow ID (allowed only for code-first workflows)
   */
  workflowId?: string | undefined;
  /**
   * Steps of the workflow
   */
  steps: Array<
    | (InAppStepUpsertDto & { type: 'in_app' })
    | (EmailStepUpsertDto & { type: 'email' })
    | (SmsStepUpsertDto & { type: 'sms' })
    | (PushStepUpsertDto & { type: 'push' })
    | (ChatStepUpsertDto & { type: 'chat' })
    | (DelayStepUpsertDto & { type: 'delay' })
    | (DigestStepUpsertDto & { type: 'digest' })
    | (CustomStepUpsertDto & { type: 'custom' })
  >;
  /**
   * Workflow preferences
   */
  preferences: PreferencesRequestDto;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Severity of the workflow
   */
  severity?: SeverityLevelEnum | undefined;
};

/** @internal */
export const UpdateWorkflowDtoSteps$inboundSchema: z.ZodType<UpdateWorkflowDtoSteps, z.ZodTypeDef, unknown> = z.union([
  InAppStepUpsertDto$inboundSchema.and(
    z.object({ type: z.literal('in_app') }).transform((v) => ({
      type: v.type,
    }))
  ),
  EmailStepUpsertDto$inboundSchema.and(z.object({ type: z.literal('email') }).transform((v) => ({ type: v.type }))),
  SmsStepUpsertDto$inboundSchema.and(z.object({ type: z.literal('sms') }).transform((v) => ({ type: v.type }))),
  PushStepUpsertDto$inboundSchema.and(z.object({ type: z.literal('push') }).transform((v) => ({ type: v.type }))),
  ChatStepUpsertDto$inboundSchema.and(z.object({ type: z.literal('chat') }).transform((v) => ({ type: v.type }))),
  DelayStepUpsertDto$inboundSchema.and(z.object({ type: z.literal('delay') }).transform((v) => ({ type: v.type }))),
  DigestStepUpsertDto$inboundSchema.and(
    z.object({ type: z.literal('digest') }).transform((v) => ({
      type: v.type,
    }))
  ),
  CustomStepUpsertDto$inboundSchema.and(
    z.object({ type: z.literal('custom') }).transform((v) => ({
      type: v.type,
    }))
  ),
]);

/** @internal */
export type UpdateWorkflowDtoSteps$Outbound =
  | (InAppStepUpsertDto$Outbound & { type: 'in_app' })
  | (EmailStepUpsertDto$Outbound & { type: 'email' })
  | (SmsStepUpsertDto$Outbound & { type: 'sms' })
  | (PushStepUpsertDto$Outbound & { type: 'push' })
  | (ChatStepUpsertDto$Outbound & { type: 'chat' })
  | (DelayStepUpsertDto$Outbound & { type: 'delay' })
  | (DigestStepUpsertDto$Outbound & { type: 'digest' })
  | (CustomStepUpsertDto$Outbound & { type: 'custom' });

/** @internal */
export const UpdateWorkflowDtoSteps$outboundSchema: z.ZodType<
  UpdateWorkflowDtoSteps$Outbound,
  z.ZodTypeDef,
  UpdateWorkflowDtoSteps
> = z.union([
  InAppStepUpsertDto$outboundSchema.and(
    z.object({ type: z.literal('in_app') }).transform((v) => ({
      type: v.type,
    }))
  ),
  EmailStepUpsertDto$outboundSchema.and(z.object({ type: z.literal('email') }).transform((v) => ({ type: v.type }))),
  SmsStepUpsertDto$outboundSchema.and(z.object({ type: z.literal('sms') }).transform((v) => ({ type: v.type }))),
  PushStepUpsertDto$outboundSchema.and(z.object({ type: z.literal('push') }).transform((v) => ({ type: v.type }))),
  ChatStepUpsertDto$outboundSchema.and(z.object({ type: z.literal('chat') }).transform((v) => ({ type: v.type }))),
  DelayStepUpsertDto$outboundSchema.and(z.object({ type: z.literal('delay') }).transform((v) => ({ type: v.type }))),
  DigestStepUpsertDto$outboundSchema.and(
    z.object({ type: z.literal('digest') }).transform((v) => ({
      type: v.type,
    }))
  ),
  CustomStepUpsertDto$outboundSchema.and(
    z.object({ type: z.literal('custom') }).transform((v) => ({
      type: v.type,
    }))
  ),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateWorkflowDtoSteps$ {
  /** @deprecated use `UpdateWorkflowDtoSteps$inboundSchema` instead. */
  export const inboundSchema = UpdateWorkflowDtoSteps$inboundSchema;
  /** @deprecated use `UpdateWorkflowDtoSteps$outboundSchema` instead. */
  export const outboundSchema = UpdateWorkflowDtoSteps$outboundSchema;
  /** @deprecated use `UpdateWorkflowDtoSteps$Outbound` instead. */
  export type Outbound = UpdateWorkflowDtoSteps$Outbound;
}

export function updateWorkflowDtoStepsToJSON(updateWorkflowDtoSteps: UpdateWorkflowDtoSteps): string {
  return JSON.stringify(UpdateWorkflowDtoSteps$outboundSchema.parse(updateWorkflowDtoSteps));
}

export function updateWorkflowDtoStepsFromJSON(
  jsonString: string
): SafeParseResult<UpdateWorkflowDtoSteps, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateWorkflowDtoSteps$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateWorkflowDtoSteps' from JSON`
  );
}

/** @internal */
export const UpdateWorkflowDto$inboundSchema: z.ZodType<UpdateWorkflowDto, z.ZodTypeDef, unknown> = z.object({
  name: z.string(),
  description: z.string().optional(),
  tags: z.array(z.string()).optional(),
  active: z.boolean().default(false),
  validatePayload: z.boolean().optional(),
  payloadSchema: z.nullable(z.record(z.any())).optional(),
  isTranslationEnabled: z.boolean().default(false),
  workflowId: z.string().optional(),
  steps: z.array(
    z.union([
      InAppStepUpsertDto$inboundSchema.and(
        z.object({ type: z.literal('in_app') }).transform((v) => ({
          type: v.type,
        }))
      ),
      EmailStepUpsertDto$inboundSchema.and(
        z.object({ type: z.literal('email') }).transform((v) => ({
          type: v.type,
        }))
      ),
      SmsStepUpsertDto$inboundSchema.and(
        z.object({ type: z.literal('sms') }).transform((v) => ({
          type: v.type,
        }))
      ),
      PushStepUpsertDto$inboundSchema.and(
        z.object({ type: z.literal('push') }).transform((v) => ({
          type: v.type,
        }))
      ),
      ChatStepUpsertDto$inboundSchema.and(
        z.object({ type: z.literal('chat') }).transform((v) => ({
          type: v.type,
        }))
      ),
      DelayStepUpsertDto$inboundSchema.and(
        z.object({ type: z.literal('delay') }).transform((v) => ({
          type: v.type,
        }))
      ),
      DigestStepUpsertDto$inboundSchema.and(
        z.object({ type: z.literal('digest') }).transform((v) => ({
          type: v.type,
        }))
      ),
      CustomStepUpsertDto$inboundSchema.and(
        z.object({ type: z.literal('custom') }).transform((v) => ({
          type: v.type,
        }))
      ),
    ])
  ),
  preferences: PreferencesRequestDto$inboundSchema,
  origin: ResourceOriginEnum$inboundSchema,
  severity: SeverityLevelEnum$inboundSchema.optional(),
});

/** @internal */
export type UpdateWorkflowDto$Outbound = {
  name: string;
  description?: string | undefined;
  tags?: Array<string> | undefined;
  active: boolean;
  validatePayload?: boolean | undefined;
  payloadSchema?: { [k: string]: any } | null | undefined;
  isTranslationEnabled: boolean;
  workflowId?: string | undefined;
  steps: Array<
    | (InAppStepUpsertDto$Outbound & { type: 'in_app' })
    | (EmailStepUpsertDto$Outbound & { type: 'email' })
    | (SmsStepUpsertDto$Outbound & { type: 'sms' })
    | (PushStepUpsertDto$Outbound & { type: 'push' })
    | (ChatStepUpsertDto$Outbound & { type: 'chat' })
    | (DelayStepUpsertDto$Outbound & { type: 'delay' })
    | (DigestStepUpsertDto$Outbound & { type: 'digest' })
    | (CustomStepUpsertDto$Outbound & { type: 'custom' })
  >;
  preferences: PreferencesRequestDto$Outbound;
  origin: string;
  severity?: string | undefined;
};

/** @internal */
export const UpdateWorkflowDto$outboundSchema: z.ZodType<UpdateWorkflowDto$Outbound, z.ZodTypeDef, UpdateWorkflowDto> =
  z.object({
    name: z.string(),
    description: z.string().optional(),
    tags: z.array(z.string()).optional(),
    active: z.boolean().default(false),
    validatePayload: z.boolean().optional(),
    payloadSchema: z.nullable(z.record(z.any())).optional(),
    isTranslationEnabled: z.boolean().default(false),
    workflowId: z.string().optional(),
    steps: z.array(
      z.union([
        InAppStepUpsertDto$outboundSchema.and(
          z.object({ type: z.literal('in_app') }).transform((v) => ({
            type: v.type,
          }))
        ),
        EmailStepUpsertDto$outboundSchema.and(
          z.object({ type: z.literal('email') }).transform((v) => ({
            type: v.type,
          }))
        ),
        SmsStepUpsertDto$outboundSchema.and(
          z.object({ type: z.literal('sms') }).transform((v) => ({
            type: v.type,
          }))
        ),
        PushStepUpsertDto$outboundSchema.and(
          z.object({ type: z.literal('push') }).transform((v) => ({
            type: v.type,
          }))
        ),
        ChatStepUpsertDto$outboundSchema.and(
          z.object({ type: z.literal('chat') }).transform((v) => ({
            type: v.type,
          }))
        ),
        DelayStepUpsertDto$outboundSchema.and(
          z.object({ type: z.literal('delay') }).transform((v) => ({
            type: v.type,
          }))
        ),
        DigestStepUpsertDto$outboundSchema.and(
          z.object({ type: z.literal('digest') }).transform((v) => ({
            type: v.type,
          }))
        ),
        CustomStepUpsertDto$outboundSchema.and(
          z.object({ type: z.literal('custom') }).transform((v) => ({
            type: v.type,
          }))
        ),
      ])
    ),
    preferences: PreferencesRequestDto$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    severity: SeverityLevelEnum$outboundSchema.optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateWorkflowDto$ {
  /** @deprecated use `UpdateWorkflowDto$inboundSchema` instead. */
  export const inboundSchema = UpdateWorkflowDto$inboundSchema;
  /** @deprecated use `UpdateWorkflowDto$outboundSchema` instead. */
  export const outboundSchema = UpdateWorkflowDto$outboundSchema;
  /** @deprecated use `UpdateWorkflowDto$Outbound` instead. */
  export type Outbound = UpdateWorkflowDto$Outbound;
}

export function updateWorkflowDtoToJSON(updateWorkflowDto: UpdateWorkflowDto): string {
  return JSON.stringify(UpdateWorkflowDto$outboundSchema.parse(updateWorkflowDto));
}

export function updateWorkflowDtoFromJSON(jsonString: string): SafeParseResult<UpdateWorkflowDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateWorkflowDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateWorkflowDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateWorkflowDtoStepsToJSON(updateWorkflowDtoSteps: UpdateWorkflowDtoSteps)
 - updateWorkflowDtoStepsFromJSON(jsonString: string)
 - updateWorkflowDtoToJSON(updateWorkflowDto: UpdateWorkflowDto)
 - updateWorkflowDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdateWorkflowDtoSteps$Outbound;
}

export function updateWorkflowDtoStepsToJSON(updateWorkflowDtoSt...)
 - Outbound(UpdateWorkflowDto$Outbound;
}

export function updateWorkflowDtoToJSON(updateWorkflowDto: UpdateWork...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateWorkflowDtoStepsToJSON
- export function updateWorkflowDtoStepsFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateWorkflowDtoToJSON
- export function updateWorkflowDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/uploadtranslationsrequestdto.ts
Tamaño: 3884 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * The resource type to associate localizations with
 */
export const UploadTranslationsRequestDtoResourceType = {
  Workflow: 'workflow',
  Layout: 'layout',
} as const;
/**
 * The resource type to associate localizations with
 */
export type UploadTranslationsRequestDtoResourceType = ClosedEnum<typeof UploadTranslationsRequestDtoResourceType>;

export type UploadTranslationsRequestDto = {
  /**
   * The resource ID to associate localizations with. Accepts identifier or slug format
   */
  resourceId: string;
  /**
   * The resource type to associate localizations with
   */
  resourceType: UploadTranslationsRequestDtoResourceType;
};

/** @internal */
export const UploadTranslationsRequestDtoResourceType$inboundSchema: z.ZodNativeEnum<
  typeof UploadTranslationsRequestDtoResourceType
> = z.nativeEnum(UploadTranslationsRequestDtoResourceType);

/** @internal */
export const UploadTranslationsRequestDtoResourceType$outboundSchema: z.ZodNativeEnum<
  typeof UploadTranslationsRequestDtoResourceType
> = UploadTranslationsRequestDtoResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UploadTranslationsRequestDtoResourceType$ {
  /** @deprecated use `UploadTranslationsRequestDtoResourceType$inboundSchema` instead. */
  export const inboundSchema = UploadTranslationsRequestDtoResourceType$inboundSchema;
  /** @deprecated use `UploadTranslationsRequestDtoResourceType$outboundSchema` instead. */
  export const outboundSchema = UploadTranslationsRequestDtoResourceType$outboundSchema;
}

/** @internal */
export const UploadTranslationsRequestDto$inboundSchema: z.ZodType<
  UploadTranslationsRequestDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  resourceId: z.string(),
  resourceType: UploadTranslationsRequestDtoResourceType$inboundSchema,
});

/** @internal */
export type UploadTranslationsRequestDto$Outbound = {
  resourceId: string;
  resourceType: string;
};

/** @internal */
export const UploadTranslationsRequestDto$outboundSchema: z.ZodType<
  UploadTranslationsRequestDto$Outbound,
  z.ZodTypeDef,
  UploadTranslationsRequestDto
> = z.object({
  resourceId: z.string(),
  resourceType: UploadTranslationsRequestDtoResourceType$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UploadTranslationsRequestDto$ {
  /** @deprecated use `UploadTranslationsRequestDto$inboundSchema` instead. */
  export const inboundSchema = UploadTranslationsRequestDto$inboundSchema;
  /** @deprecated use `UploadTranslationsRequestDto$outboundSchema` instead. */
  export const outboundSchema = UploadTranslationsRequestDto$outboundSchema;
  /** @deprecated use `UploadTranslationsRequestDto$Outbound` instead. */
  export type Outbound = UploadTranslationsRequestDto$Outbound;
}

export function uploadTranslationsRequestDtoToJSON(uploadTranslationsRequestDto: UploadTranslationsRequestDto): string {
  return JSON.stringify(UploadTranslationsRequestDto$outboundSchema.parse(uploadTranslationsRequestDto));
}

export function uploadTranslationsRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<UploadTranslationsRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UploadTranslationsRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UploadTranslationsRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - uploadTranslationsRequestDtoToJSON(uploadTranslationsRequestDto: UploadTranslationsRequestDto)
 - uploadTranslationsRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UploadTranslationsRequestDto$Outbound;
}

export function uploadTranslationsRequestDtoToJSON(uploadT...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function uploadTranslationsRequestDtoToJSON
- export function uploadTranslationsRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/uploadtranslationsresponsedto.ts
Tamaño: 2669 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type UploadTranslationsResponseDto = {
  /**
   * Total number of files processed
   */
  totalFiles: number;
  /**
   * Number of files successfully uploaded
   */
  successfulUploads: number;
  /**
   * Number of files that failed to upload
   */
  failedUploads: number;
  /**
   * List of error messages for failed uploads
   */
  errors: Array<string>;
};

/** @internal */
export const UploadTranslationsResponseDto$inboundSchema: z.ZodType<
  UploadTranslationsResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  totalFiles: z.number(),
  successfulUploads: z.number(),
  failedUploads: z.number(),
  errors: z.array(z.string()),
});

/** @internal */
export type UploadTranslationsResponseDto$Outbound = {
  totalFiles: number;
  successfulUploads: number;
  failedUploads: number;
  errors: Array<string>;
};

/** @internal */
export const UploadTranslationsResponseDto$outboundSchema: z.ZodType<
  UploadTranslationsResponseDto$Outbound,
  z.ZodTypeDef,
  UploadTranslationsResponseDto
> = z.object({
  totalFiles: z.number(),
  successfulUploads: z.number(),
  failedUploads: z.number(),
  errors: z.array(z.string()),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UploadTranslationsResponseDto$ {
  /** @deprecated use `UploadTranslationsResponseDto$inboundSchema` instead. */
  export const inboundSchema = UploadTranslationsResponseDto$inboundSchema;
  /** @deprecated use `UploadTranslationsResponseDto$outboundSchema` instead. */
  export const outboundSchema = UploadTranslationsResponseDto$outboundSchema;
  /** @deprecated use `UploadTranslationsResponseDto$Outbound` instead. */
  export type Outbound = UploadTranslationsResponseDto$Outbound;
}

export function uploadTranslationsResponseDtoToJSON(
  uploadTranslationsResponseDto: UploadTranslationsResponseDto
): string {
  return JSON.stringify(UploadTranslationsResponseDto$outboundSchema.parse(uploadTranslationsResponseDto));
}

export function uploadTranslationsResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<UploadTranslationsResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UploadTranslationsResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UploadTranslationsResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - uploadTranslationsResponseDtoToJSON(uploadTranslationsResponseDto: UploadTranslationsResponseDto)
 - uploadTranslationsResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UploadTranslationsResponseDto$Outbound;
}

export function uploadTranslationsResponseDtoToJSON(
  up...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function uploadTranslationsResponseDtoToJSON
- export function uploadTranslationsResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/webhookresultdto.ts
Tamaño: 2113 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { EventBody, EventBody$inboundSchema, EventBody$Outbound, EventBody$outboundSchema } from './eventbody.js';

export type WebhookResultDto = {
  /**
   * Unique identifier for the webhook result
   */
  id: string;
  /**
   * Event body containing the webhook event data
   */
  event: EventBody;
};

/** @internal */
export const WebhookResultDto$inboundSchema: z.ZodType<WebhookResultDto, z.ZodTypeDef, unknown> = z.object({
  id: z.string(),
  event: EventBody$inboundSchema,
});

/** @internal */
export type WebhookResultDto$Outbound = {
  id: string;
  event: EventBody$Outbound;
};

/** @internal */
export const WebhookResultDto$outboundSchema: z.ZodType<WebhookResultDto$Outbound, z.ZodTypeDef, WebhookResultDto> =
  z.object({
    id: z.string(),
    event: EventBody$outboundSchema,
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WebhookResultDto$ {
  /** @deprecated use `WebhookResultDto$inboundSchema` instead. */
  export const inboundSchema = WebhookResultDto$inboundSchema;
  /** @deprecated use `WebhookResultDto$outboundSchema` instead. */
  export const outboundSchema = WebhookResultDto$outboundSchema;
  /** @deprecated use `WebhookResultDto$Outbound` instead. */
  export type Outbound = WebhookResultDto$Outbound;
}

export function webhookResultDtoToJSON(webhookResultDto: WebhookResultDto): string {
  return JSON.stringify(WebhookResultDto$outboundSchema.parse(webhookResultDto));
}

export function webhookResultDtoFromJSON(jsonString: string): SafeParseResult<WebhookResultDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WebhookResultDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WebhookResultDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - webhookResultDtoToJSON(webhookResultDto: WebhookResultDto)
 - webhookResultDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WebhookResultDto$Outbound;
}

export function webhookResultDtoToJSON(webhookResultDto: WebhookResult...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function webhookResultDtoToJSON
- export function webhookResultDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowcreationsourceenum.ts
Tamaño: 1573 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Source of workflow creation
 */
export const WorkflowCreationSourceEnum = {
  TemplateStore: 'template_store',
  Editor: 'editor',
  NotificationDirectory: 'notification_directory',
  OnboardingDigestDemo: 'onboarding_digest_demo',
  OnboardingInApp: 'onboarding_in_app',
  EmptyState: 'empty_state',
  Dropdown: 'dropdown',
  OnboardingGetStarted: 'onboarding_get_started',
  Bridge: 'bridge',
  Dashboard: 'dashboard',
} as const;
/**
 * Source of workflow creation
 */
export type WorkflowCreationSourceEnum = ClosedEnum<typeof WorkflowCreationSourceEnum>;

/** @internal */
export const WorkflowCreationSourceEnum$inboundSchema: z.ZodNativeEnum<typeof WorkflowCreationSourceEnum> =
  z.nativeEnum(WorkflowCreationSourceEnum);

/** @internal */
export const WorkflowCreationSourceEnum$outboundSchema: z.ZodNativeEnum<typeof WorkflowCreationSourceEnum> =
  WorkflowCreationSourceEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowCreationSourceEnum$ {
  /** @deprecated use `WorkflowCreationSourceEnum$inboundSchema` instead. */
  export const inboundSchema = WorkflowCreationSourceEnum$inboundSchema;
  /** @deprecated use `WorkflowCreationSourceEnum$outboundSchema` instead. */
  export const outboundSchema = WorkflowCreationSourceEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowinfodto.ts
Tamaño: 1938 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowInfoDto = {
  /**
   * The name of the workflow
   */
  name: string;
  /**
   * The unique identifier of the workflow
   */
  workflowId: string;
};

/** @internal */
export const WorkflowInfoDto$inboundSchema: z.ZodType<WorkflowInfoDto, z.ZodTypeDef, unknown> = z.object({
  name: z.string(),
  workflowId: z.string(),
});

/** @internal */
export type WorkflowInfoDto$Outbound = {
  name: string;
  workflowId: string;
};

/** @internal */
export const WorkflowInfoDto$outboundSchema: z.ZodType<WorkflowInfoDto$Outbound, z.ZodTypeDef, WorkflowInfoDto> =
  z.object({
    name: z.string(),
    workflowId: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowInfoDto$ {
  /** @deprecated use `WorkflowInfoDto$inboundSchema` instead. */
  export const inboundSchema = WorkflowInfoDto$inboundSchema;
  /** @deprecated use `WorkflowInfoDto$outboundSchema` instead. */
  export const outboundSchema = WorkflowInfoDto$outboundSchema;
  /** @deprecated use `WorkflowInfoDto$Outbound` instead. */
  export type Outbound = WorkflowInfoDto$Outbound;
}

export function workflowInfoDtoToJSON(workflowInfoDto: WorkflowInfoDto): string {
  return JSON.stringify(WorkflowInfoDto$outboundSchema.parse(workflowInfoDto));
}

export function workflowInfoDtoFromJSON(jsonString: string): SafeParseResult<WorkflowInfoDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowInfoDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowInfoDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowInfoDtoToJSON(workflowInfoDto: WorkflowInfoDto)
 - workflowInfoDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowInfoDto$Outbound;
}

export function workflowInfoDtoToJSON(workflowInfoDto: WorkflowInfoDto)...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowInfoDtoToJSON
- export function workflowInfoDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowlistresponsedto.ts
Tamaño: 11673 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  StepListResponseDto,
  StepListResponseDto$inboundSchema,
  StepListResponseDto$Outbound,
  StepListResponseDto$outboundSchema,
} from './steplistresponsedto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';
import {
  WorkflowStatusEnum,
  WorkflowStatusEnum$inboundSchema,
  WorkflowStatusEnum$outboundSchema,
} from './workflowstatusenum.js';

/**
 * User who last updated the workflow
 */
export type WorkflowListResponseDtoUpdatedBy = {
  /**
   * User ID
   */
  id: string;
  /**
   * User first name
   */
  firstName?: string | null | undefined;
  /**
   * User last name
   */
  lastName?: string | null | undefined;
  /**
   * User external ID
   */
  externalId?: string | null | undefined;
};

/**
 * User who last published the workflow
 */
export type WorkflowListResponseDtoLastPublishedBy = {
  /**
   * User ID
   */
  id: string;
  /**
   * User first name
   */
  firstName?: string | null | undefined;
  /**
   * User last name
   */
  lastName?: string | null | undefined;
  /**
   * User external ID
   */
  externalId?: string | null | undefined;
};

export type WorkflowListResponseDto = {
  /**
   * Name of the workflow
   */
  name: string;
  /**
   * Tags associated with the workflow
   */
  tags?: Array<string> | undefined;
  /**
   * Last updated timestamp
   */
  updatedAt: string;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * User who last updated the workflow
   */
  updatedBy?: WorkflowListResponseDtoUpdatedBy | null | undefined;
  /**
   * Timestamp of the last workflow publication
   */
  lastPublishedAt?: string | null | undefined;
  /**
   * User who last published the workflow
   */
  lastPublishedBy?: WorkflowListResponseDtoLastPublishedBy | null | undefined;
  /**
   * Unique database identifier
   */
  id: string;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow slug
   */
  slug: string;
  /**
   * Status of the workflow
   */
  status: WorkflowStatusEnum;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Timestamp of the last workflow trigger
   */
  lastTriggeredAt?: string | null | undefined;
  /**
   * Overview of step types in the workflow
   */
  stepTypeOverviews: Array<StepTypeEnum>;
  /**
   * Is translation enabled for the workflow
   */
  isTranslationEnabled?: boolean | undefined;
  /**
   * Steps of the workflow
   */
  steps: Array<StepListResponseDto>;
};

/** @internal */
export const WorkflowListResponseDtoUpdatedBy$inboundSchema: z.ZodType<
  WorkflowListResponseDtoUpdatedBy,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    _id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type WorkflowListResponseDtoUpdatedBy$Outbound = {
  _id: string;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  externalId?: string | null | undefined;
};

/** @internal */
export const WorkflowListResponseDtoUpdatedBy$outboundSchema: z.ZodType<
  WorkflowListResponseDtoUpdatedBy$Outbound,
  z.ZodTypeDef,
  WorkflowListResponseDtoUpdatedBy
> = z
  .object({
    id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowListResponseDtoUpdatedBy$ {
  /** @deprecated use `WorkflowListResponseDtoUpdatedBy$inboundSchema` instead. */
  export const inboundSchema = WorkflowListResponseDtoUpdatedBy$inboundSchema;
  /** @deprecated use `WorkflowListResponseDtoUpdatedBy$outboundSchema` instead. */
  export const outboundSchema = WorkflowListResponseDtoUpdatedBy$outboundSchema;
  /** @deprecated use `WorkflowListResponseDtoUpdatedBy$Outbound` instead. */
  export type Outbound = WorkflowListResponseDtoUpdatedBy$Outbound;
}

export function workflowListResponseDtoUpdatedByToJSON(
  workflowListResponseDtoUpdatedBy: WorkflowListResponseDtoUpdatedBy
): string {
  return JSON.stringify(WorkflowListResponseDtoUpdatedBy$outboundSchema.parse(workflowListResponseDtoUpdatedBy));
}

export function workflowListResponseDtoUpdatedByFromJSON(
  jsonString: string
): SafeParseResult<WorkflowListResponseDtoUpdatedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowListResponseDtoUpdatedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowListResponseDtoUpdatedBy' from JSON`
  );
}

/** @internal */
export const WorkflowListResponseDtoLastPublishedBy$inboundSchema: z.ZodType<
  WorkflowListResponseDtoLastPublishedBy,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    _id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type WorkflowListResponseDtoLastPublishedBy$Outbound = {
  _id: string;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  externalId?: string | null | undefined;
};

/** @internal */
export const WorkflowListResponseDtoLastPublishedBy$outboundSchema: z.ZodType<
  WorkflowListResponseDtoLastPublishedBy$Outbound,
  z.ZodTypeDef,
  WorkflowListResponseDtoLastPublishedBy
> = z
  .object({
    id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowListResponseDtoLastPublishedBy$ {
  /** @deprecated use `WorkflowListResponseDtoLastPublishedBy$inboundSchema` instead. */
  export const inboundSchema = WorkflowListResponseDtoLastPublishedBy$inboundSchema;
  /** @deprecated use `WorkflowListResponseDtoLastPublishedBy$outboundSchema` instead. */
  export const outboundSchema = WorkflowListResponseDtoLastPublishedBy$outboundSchema;
  /** @deprecated use `WorkflowListResponseDtoLastPublishedBy$Outbound` instead. */
  export type Outbound = WorkflowListResponseDtoLastPublishedBy$Outbound;
}

export function workflowListResponseDtoLastPublishedByToJSON(
  workflowListResponseDtoLastPublishedBy: WorkflowListResponseDtoLastPublishedBy
): string {
  return JSON.stringify(
    WorkflowListResponseDtoLastPublishedBy$outboundSchema.parse(workflowListResponseDtoLastPublishedBy)
  );
}

export function workflowListResponseDtoLastPublishedByFromJSON(
  jsonString: string
): SafeParseResult<WorkflowListResponseDtoLastPublishedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowListResponseDtoLastPublishedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowListResponseDtoLastPublishedBy' from JSON`
  );
}

/** @internal */
export const WorkflowListResponseDto$inboundSchema: z.ZodType<WorkflowListResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string(),
    tags: z.array(z.string()).optional(),
    updatedAt: z.string(),
    createdAt: z.string(),
    updatedBy: z.nullable(z.lazy(() => WorkflowListResponseDtoUpdatedBy$inboundSchema)).optional(),
    lastPublishedAt: z.nullable(z.string()).optional(),
    lastPublishedBy: z.nullable(z.lazy(() => WorkflowListResponseDtoLastPublishedBy$inboundSchema)).optional(),
    _id: z.string(),
    workflowId: z.string(),
    slug: z.string(),
    status: WorkflowStatusEnum$inboundSchema,
    origin: ResourceOriginEnum$inboundSchema,
    lastTriggeredAt: z.nullable(z.string()).optional(),
    stepTypeOverviews: z.array(StepTypeEnum$inboundSchema),
    isTranslationEnabled: z.boolean().optional(),
    steps: z.array(StepListResponseDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type WorkflowListResponseDto$Outbound = {
  name: string;
  tags?: Array<string> | undefined;
  updatedAt: string;
  createdAt: string;
  updatedBy?: WorkflowListResponseDtoUpdatedBy$Outbound | null | undefined;
  lastPublishedAt?: string | null | undefined;
  lastPublishedBy?: WorkflowListResponseDtoLastPublishedBy$Outbound | null | undefined;
  _id: string;
  workflowId: string;
  slug: string;
  status: string;
  origin: string;
  lastTriggeredAt?: string | null | undefined;
  stepTypeOverviews: Array<string>;
  isTranslationEnabled?: boolean | undefined;
  steps: Array<StepListResponseDto$Outbound>;
};

/** @internal */
export const WorkflowListResponseDto$outboundSchema: z.ZodType<
  WorkflowListResponseDto$Outbound,
  z.ZodTypeDef,
  WorkflowListResponseDto
> = z
  .object({
    name: z.string(),
    tags: z.array(z.string()).optional(),
    updatedAt: z.string(),
    createdAt: z.string(),
    updatedBy: z.nullable(z.lazy(() => WorkflowListResponseDtoUpdatedBy$outboundSchema)).optional(),
    lastPublishedAt: z.nullable(z.string()).optional(),
    lastPublishedBy: z.nullable(z.lazy(() => WorkflowListResponseDtoLastPublishedBy$outboundSchema)).optional(),
    id: z.string(),
    workflowId: z.string(),
    slug: z.string(),
    status: WorkflowStatusEnum$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    lastTriggeredAt: z.nullable(z.string()).optional(),
    stepTypeOverviews: z.array(StepTypeEnum$outboundSchema),
    isTranslationEnabled: z.boolean().optional(),
    steps: z.array(StepListResponseDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowListResponseDto$ {
  /** @deprecated use `WorkflowListResponseDto$inboundSchema` instead. */
  export const inboundSchema = WorkflowListResponseDto$inboundSchema;
  /** @deprecated use `WorkflowListResponseDto$outboundSchema` instead. */
  export const outboundSchema = WorkflowListResponseDto$outboundSchema;
  /** @deprecated use `WorkflowListResponseDto$Outbound` instead. */
  export type Outbound = WorkflowListResponseDto$Outbound;
}

export function workflowListResponseDtoToJSON(workflowListResponseDto: WorkflowListResponseDto): string {
  return JSON.stringify(WorkflowListResponseDto$outboundSchema.parse(workflowListResponseDto));
}

export function workflowListResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<WorkflowListResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowListResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowListResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowListResponseDtoUpdatedByToJSON(workflowListResponseDtoUpdatedBy: WorkflowListResponseDtoUpdatedBy)
 - workflowListResponseDtoUpdatedByFromJSON(jsonString: string)
 - workflowListResponseDtoLastPublishedByToJSON(workflowListResponseDtoLastPublishedBy: WorkflowListResponseDtoLastPublishedBy)
 - workflowListResponseDtoLastPublishedByFromJSON(jsonString: string)
 - workflowListResponseDtoToJSON(workflowListResponseDto: WorkflowListResponseDto)
 - workflowListResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowListResponseDtoUpdatedBy$Outbound;
}

export function workflowListResponseDtoUpdatedByToJSON...)
 - Outbound(WorkflowListResponseDtoLastPublishedBy$Outbound;
}

export function workflowListResponseDtoLastPubli...)
 - Outbound(WorkflowListResponseDto$Outbound;
}

export function workflowListResponseDtoToJSON(workflowListRespo...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowListResponseDtoUpdatedByToJSON
- export function workflowListResponseDtoUpdatedByFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowListResponseDtoLastPublishedByToJSON
- export function workflowListResponseDtoLastPublishedByFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowListResponseDtoToJSON
- export function workflowListResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowpreferencedto.ts
Tamaño: 2426 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowPreferenceDto = {
  /**
   * A flag specifying if notification delivery is enabled for the workflow. If true, notification delivery is enabled by default for all channels. This setting can be overridden by the channel preferences.
   */
  enabled?: boolean | undefined;
  /**
   * A flag specifying if the preference is read-only. If true, the preference cannot be changed by the Subscriber.
   */
  readOnly?: boolean | undefined;
};

/** @internal */
export const WorkflowPreferenceDto$inboundSchema: z.ZodType<WorkflowPreferenceDto, z.ZodTypeDef, unknown> = z.object({
  enabled: z.boolean().default(true),
  readOnly: z.boolean().default(false),
});

/** @internal */
export type WorkflowPreferenceDto$Outbound = {
  enabled: boolean;
  readOnly: boolean;
};

/** @internal */
export const WorkflowPreferenceDto$outboundSchema: z.ZodType<
  WorkflowPreferenceDto$Outbound,
  z.ZodTypeDef,
  WorkflowPreferenceDto
> = z.object({
  enabled: z.boolean().default(true),
  readOnly: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowPreferenceDto$ {
  /** @deprecated use `WorkflowPreferenceDto$inboundSchema` instead. */
  export const inboundSchema = WorkflowPreferenceDto$inboundSchema;
  /** @deprecated use `WorkflowPreferenceDto$outboundSchema` instead. */
  export const outboundSchema = WorkflowPreferenceDto$outboundSchema;
  /** @deprecated use `WorkflowPreferenceDto$Outbound` instead. */
  export type Outbound = WorkflowPreferenceDto$Outbound;
}

export function workflowPreferenceDtoToJSON(workflowPreferenceDto: WorkflowPreferenceDto): string {
  return JSON.stringify(WorkflowPreferenceDto$outboundSchema.parse(workflowPreferenceDto));
}

export function workflowPreferenceDtoFromJSON(
  jsonString: string
): SafeParseResult<WorkflowPreferenceDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowPreferenceDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowPreferenceDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowPreferenceDtoToJSON(workflowPreferenceDto: WorkflowPreferenceDto)
 - workflowPreferenceDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowPreferenceDto$Outbound;
}

export function workflowPreferenceDtoToJSON(workflowPreferenceDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowPreferenceDtoToJSON
- export function workflowPreferenceDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowpreferencesdto.ts
Tamaño: 4085 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelPreferenceDto,
  ChannelPreferenceDto$inboundSchema,
  ChannelPreferenceDto$Outbound,
  ChannelPreferenceDto$outboundSchema,
} from './channelpreferencedto.js';
import {
  WorkflowPreferenceDto,
  WorkflowPreferenceDto$inboundSchema,
  WorkflowPreferenceDto$Outbound,
  WorkflowPreferenceDto$outboundSchema,
} from './workflowpreferencedto.js';

/**
 * A preference for the workflow. The values specified here will be used if no preference is specified for a channel.
 */
export type All = WorkflowPreferenceDto;

export type WorkflowPreferencesDto = {
  /**
   * A preference for the workflow. The values specified here will be used if no preference is specified for a channel.
   */
  all: WorkflowPreferenceDto;
  /**
   * Preferences for different communication channels
   */
  channels: { [k: string]: ChannelPreferenceDto };
};

/** @internal */
export const All$inboundSchema: z.ZodType<All, z.ZodTypeDef, unknown> = WorkflowPreferenceDto$inboundSchema;

/** @internal */
export type All$Outbound = WorkflowPreferenceDto$Outbound;

/** @internal */
export const All$outboundSchema: z.ZodType<All$Outbound, z.ZodTypeDef, All> = WorkflowPreferenceDto$outboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace All$ {
  /** @deprecated use `All$inboundSchema` instead. */
  export const inboundSchema = All$inboundSchema;
  /** @deprecated use `All$outboundSchema` instead. */
  export const outboundSchema = All$outboundSchema;
  /** @deprecated use `All$Outbound` instead. */
  export type Outbound = All$Outbound;
}

export function allToJSON(all: All): string {
  return JSON.stringify(All$outboundSchema.parse(all));
}

export function allFromJSON(jsonString: string): SafeParseResult<All, SDKValidationError> {
  return safeParse(jsonString, (x) => All$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'All' from JSON`);
}

/** @internal */
export const WorkflowPreferencesDto$inboundSchema: z.ZodType<WorkflowPreferencesDto, z.ZodTypeDef, unknown> = z.object({
  all: WorkflowPreferenceDto$inboundSchema,
  channels: z.record(ChannelPreferenceDto$inboundSchema),
});

/** @internal */
export type WorkflowPreferencesDto$Outbound = {
  all: WorkflowPreferenceDto$Outbound;
  channels: { [k: string]: ChannelPreferenceDto$Outbound };
};

/** @internal */
export const WorkflowPreferencesDto$outboundSchema: z.ZodType<
  WorkflowPreferencesDto$Outbound,
  z.ZodTypeDef,
  WorkflowPreferencesDto
> = z.object({
  all: WorkflowPreferenceDto$outboundSchema,
  channels: z.record(ChannelPreferenceDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowPreferencesDto$ {
  /** @deprecated use `WorkflowPreferencesDto$inboundSchema` instead. */
  export const inboundSchema = WorkflowPreferencesDto$inboundSchema;
  /** @deprecated use `WorkflowPreferencesDto$outboundSchema` instead. */
  export const outboundSchema = WorkflowPreferencesDto$outboundSchema;
  /** @deprecated use `WorkflowPreferencesDto$Outbound` instead. */
  export type Outbound = WorkflowPreferencesDto$Outbound;
}

export function workflowPreferencesDtoToJSON(workflowPreferencesDto: WorkflowPreferencesDto): string {
  return JSON.stringify(WorkflowPreferencesDto$outboundSchema.parse(workflowPreferencesDto));
}

export function workflowPreferencesDtoFromJSON(
  jsonString: string
): SafeParseResult<WorkflowPreferencesDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowPreferencesDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowPreferencesDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - allToJSON(all: All)
 - allFromJSON(jsonString: string)
 - workflowPreferencesDtoToJSON(workflowPreferencesDto: WorkflowPreferencesDto)
 - workflowPreferencesDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(All$Outbound;
}

export function allToJSON(all: All): string {
  return JSON.stringify(All$outboundS...)
 - Outbound(WorkflowPreferencesDto$Outbound;
}

export function workflowPreferencesDtoToJSON(workflowPreferences...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function allToJSON
- export function allFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowPreferencesDtoToJSON
- export function workflowPreferencesDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowpreferencesresponsedto.ts
Tamaño: 7687 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelPreferenceDto,
  ChannelPreferenceDto$inboundSchema,
  ChannelPreferenceDto$Outbound,
  ChannelPreferenceDto$outboundSchema,
} from './channelpreferencedto.js';
import {
  WorkflowPreferenceDto,
  WorkflowPreferenceDto$inboundSchema,
  WorkflowPreferenceDto$Outbound,
  WorkflowPreferenceDto$outboundSchema,
} from './workflowpreferencedto.js';
import {
  WorkflowPreferencesDto,
  WorkflowPreferencesDto$inboundSchema,
  WorkflowPreferencesDto$Outbound,
  WorkflowPreferencesDto$outboundSchema,
} from './workflowpreferencesdto.js';

/**
 * A preference for the workflow. The values specified here will be used if no preference is specified for a channel.
 */
export type WorkflowPreferencesResponseDtoAll = WorkflowPreferenceDto;

/**
 * User-specific workflow preferences
 */
export type WorkflowPreferencesResponseDtoUser = {
  /**
   * A preference for the workflow. The values specified here will be used if no preference is specified for a channel.
   */
  all: WorkflowPreferenceDto;
  /**
   * Preferences for different communication channels
   */
  channels: { [k: string]: ChannelPreferenceDto };
};

export type WorkflowPreferencesResponseDto = {
  /**
   * User-specific workflow preferences
   */
  user?: WorkflowPreferencesResponseDtoUser | null | undefined;
  /**
   * Default workflow preferences
   */
  default: WorkflowPreferencesDto;
};

/** @internal */
export const WorkflowPreferencesResponseDtoAll$inboundSchema: z.ZodType<
  WorkflowPreferencesResponseDtoAll,
  z.ZodTypeDef,
  unknown
> = WorkflowPreferenceDto$inboundSchema;

/** @internal */
export type WorkflowPreferencesResponseDtoAll$Outbound = WorkflowPreferenceDto$Outbound;

/** @internal */
export const WorkflowPreferencesResponseDtoAll$outboundSchema: z.ZodType<
  WorkflowPreferencesResponseDtoAll$Outbound,
  z.ZodTypeDef,
  WorkflowPreferencesResponseDtoAll
> = WorkflowPreferenceDto$outboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowPreferencesResponseDtoAll$ {
  /** @deprecated use `WorkflowPreferencesResponseDtoAll$inboundSchema` instead. */
  export const inboundSchema = WorkflowPreferencesResponseDtoAll$inboundSchema;
  /** @deprecated use `WorkflowPreferencesResponseDtoAll$outboundSchema` instead. */
  export const outboundSchema = WorkflowPreferencesResponseDtoAll$outboundSchema;
  /** @deprecated use `WorkflowPreferencesResponseDtoAll$Outbound` instead. */
  export type Outbound = WorkflowPreferencesResponseDtoAll$Outbound;
}

export function workflowPreferencesResponseDtoAllToJSON(
  workflowPreferencesResponseDtoAll: WorkflowPreferencesResponseDtoAll
): string {
  return JSON.stringify(WorkflowPreferencesResponseDtoAll$outboundSchema.parse(workflowPreferencesResponseDtoAll));
}

export function workflowPreferencesResponseDtoAllFromJSON(
  jsonString: string
): SafeParseResult<WorkflowPreferencesResponseDtoAll, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowPreferencesResponseDtoAll$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowPreferencesResponseDtoAll' from JSON`
  );
}

/** @internal */
export const WorkflowPreferencesResponseDtoUser$inboundSchema: z.ZodType<
  WorkflowPreferencesResponseDtoUser,
  z.ZodTypeDef,
  unknown
> = z.object({
  all: WorkflowPreferenceDto$inboundSchema,
  channels: z.record(ChannelPreferenceDto$inboundSchema),
});

/** @internal */
export type WorkflowPreferencesResponseDtoUser$Outbound = {
  all: WorkflowPreferenceDto$Outbound;
  channels: { [k: string]: ChannelPreferenceDto$Outbound };
};

/** @internal */
export const WorkflowPreferencesResponseDtoUser$outboundSchema: z.ZodType<
  WorkflowPreferencesResponseDtoUser$Outbound,
  z.ZodTypeDef,
  WorkflowPreferencesResponseDtoUser
> = z.object({
  all: WorkflowPreferenceDto$outboundSchema,
  channels: z.record(ChannelPreferenceDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowPreferencesResponseDtoUser$ {
  /** @deprecated use `WorkflowPreferencesResponseDtoUser$inboundSchema` instead. */
  export const inboundSchema = WorkflowPreferencesResponseDtoUser$inboundSchema;
  /** @deprecated use `WorkflowPreferencesResponseDtoUser$outboundSchema` instead. */
  export const outboundSchema = WorkflowPreferencesResponseDtoUser$outboundSchema;
  /** @deprecated use `WorkflowPreferencesResponseDtoUser$Outbound` instead. */
  export type Outbound = WorkflowPreferencesResponseDtoUser$Outbound;
}

export function workflowPreferencesResponseDtoUserToJSON(
  workflowPreferencesResponseDtoUser: WorkflowPreferencesResponseDtoUser
): string {
  return JSON.stringify(WorkflowPreferencesResponseDtoUser$outboundSchema.parse(workflowPreferencesResponseDtoUser));
}

export function workflowPreferencesResponseDtoUserFromJSON(
  jsonString: string
): SafeParseResult<WorkflowPreferencesResponseDtoUser, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowPreferencesResponseDtoUser$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowPreferencesResponseDtoUser' from JSON`
  );
}

/** @internal */
export const WorkflowPreferencesResponseDto$inboundSchema: z.ZodType<
  WorkflowPreferencesResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  user: z.nullable(z.lazy(() => WorkflowPreferencesResponseDtoUser$inboundSchema)).optional(),
  default: WorkflowPreferencesDto$inboundSchema,
});

/** @internal */
export type WorkflowPreferencesResponseDto$Outbound = {
  user?: WorkflowPreferencesResponseDtoUser$Outbound | null | undefined;
  default: WorkflowPreferencesDto$Outbound;
};

/** @internal */
export const WorkflowPreferencesResponseDto$outboundSchema: z.ZodType<
  WorkflowPreferencesResponseDto$Outbound,
  z.ZodTypeDef,
  WorkflowPreferencesResponseDto
> = z.object({
  user: z.nullable(z.lazy(() => WorkflowPreferencesResponseDtoUser$outboundSchema)).optional(),
  default: WorkflowPreferencesDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowPreferencesResponseDto$ {
  /** @deprecated use `WorkflowPreferencesResponseDto$inboundSchema` instead. */
  export const inboundSchema = WorkflowPreferencesResponseDto$inboundSchema;
  /** @deprecated use `WorkflowPreferencesResponseDto$outboundSchema` instead. */
  export const outboundSchema = WorkflowPreferencesResponseDto$outboundSchema;
  /** @deprecated use `WorkflowPreferencesResponseDto$Outbound` instead. */
  export type Outbound = WorkflowPreferencesResponseDto$Outbound;
}

export function workflowPreferencesResponseDtoToJSON(
  workflowPreferencesResponseDto: WorkflowPreferencesResponseDto
): string {
  return JSON.stringify(WorkflowPreferencesResponseDto$outboundSchema.parse(workflowPreferencesResponseDto));
}

export function workflowPreferencesResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<WorkflowPreferencesResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowPreferencesResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowPreferencesResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowPreferencesResponseDtoAllToJSON(workflowPreferencesResponseDtoAll: WorkflowPreferencesResponseDtoAll)
 - workflowPreferencesResponseDtoAllFromJSON(jsonString: string)
 - workflowPreferencesResponseDtoUserToJSON(workflowPreferencesResponseDtoUser: WorkflowPreferencesResponseDtoUser)
 - workflowPreferencesResponseDtoUserFromJSON(jsonString: string)
 - workflowPreferencesResponseDtoToJSON(workflowPreferencesResponseDto: WorkflowPreferencesResponseDto)
 - workflowPreferencesResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowPreferencesResponseDtoAll$Outbound;
}

export function workflowPreferencesResponseDtoAllToJS...)
 - Outbound(WorkflowPreferencesResponseDtoUser$Outbound;
}

export function workflowPreferencesResponseDtoUserTo...)
 - Outbound(WorkflowPreferencesResponseDto$Outbound;
}

export function workflowPreferencesResponseDtoToJSON(
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowPreferencesResponseDtoAllToJSON
- export function workflowPreferencesResponseDtoAllFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowPreferencesResponseDtoUserToJSON
- export function workflowPreferencesResponseDtoUserFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowPreferencesResponseDtoToJSON
- export function workflowPreferencesResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowresponse.ts
Tamaño: 9183 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  NotificationGroup,
  NotificationGroup$inboundSchema,
  NotificationGroup$Outbound,
  NotificationGroup$outboundSchema,
} from './notificationgroup.js';
import {
  NotificationStepDto,
  NotificationStepDto$inboundSchema,
  NotificationStepDto$Outbound,
  NotificationStepDto$outboundSchema,
} from './notificationstepdto.js';
import {
  NotificationTrigger,
  NotificationTrigger$inboundSchema,
  NotificationTrigger$Outbound,
  NotificationTrigger$outboundSchema,
} from './notificationtrigger.js';
import {
  SubscriberPreferenceChannels,
  SubscriberPreferenceChannels$inboundSchema,
  SubscriberPreferenceChannels$Outbound,
  SubscriberPreferenceChannels$outboundSchema,
} from './subscriberpreferencechannels.js';

export type WorkflowResponseData = {};

export type WorkflowIntegrationStatus = {};

export type WorkflowResponse = {
  id?: string | undefined;
  name: string;
  description: string;
  active: boolean;
  draft: boolean;
  preferenceSettings: SubscriberPreferenceChannels;
  critical: boolean;
  tags: Array<string>;
  steps: Array<NotificationStepDto>;
  organizationId: string;
  creatorId: string;
  environmentId: string;
  triggers: Array<NotificationTrigger>;
  notificationGroupId: string;
  parentId?: string | undefined;
  deleted: boolean;
  deletedAt: string;
  deletedBy: string;
  notificationGroup?: NotificationGroup | undefined;
  data?: WorkflowResponseData | undefined;
  workflowIntegrationStatus?: WorkflowIntegrationStatus | undefined;
};

/** @internal */
export const WorkflowResponseData$inboundSchema: z.ZodType<WorkflowResponseData, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type WorkflowResponseData$Outbound = {};

/** @internal */
export const WorkflowResponseData$outboundSchema: z.ZodType<
  WorkflowResponseData$Outbound,
  z.ZodTypeDef,
  WorkflowResponseData
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowResponseData$ {
  /** @deprecated use `WorkflowResponseData$inboundSchema` instead. */
  export const inboundSchema = WorkflowResponseData$inboundSchema;
  /** @deprecated use `WorkflowResponseData$outboundSchema` instead. */
  export const outboundSchema = WorkflowResponseData$outboundSchema;
  /** @deprecated use `WorkflowResponseData$Outbound` instead. */
  export type Outbound = WorkflowResponseData$Outbound;
}

export function workflowResponseDataToJSON(workflowResponseData: WorkflowResponseData): string {
  return JSON.stringify(WorkflowResponseData$outboundSchema.parse(workflowResponseData));
}

export function workflowResponseDataFromJSON(
  jsonString: string
): SafeParseResult<WorkflowResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowResponseData' from JSON`
  );
}

/** @internal */
export const WorkflowIntegrationStatus$inboundSchema: z.ZodType<WorkflowIntegrationStatus, z.ZodTypeDef, unknown> =
  z.object({});

/** @internal */
export type WorkflowIntegrationStatus$Outbound = {};

/** @internal */
export const WorkflowIntegrationStatus$outboundSchema: z.ZodType<
  WorkflowIntegrationStatus$Outbound,
  z.ZodTypeDef,
  WorkflowIntegrationStatus
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowIntegrationStatus$ {
  /** @deprecated use `WorkflowIntegrationStatus$inboundSchema` instead. */
  export const inboundSchema = WorkflowIntegrationStatus$inboundSchema;
  /** @deprecated use `WorkflowIntegrationStatus$outboundSchema` instead. */
  export const outboundSchema = WorkflowIntegrationStatus$outboundSchema;
  /** @deprecated use `WorkflowIntegrationStatus$Outbound` instead. */
  export type Outbound = WorkflowIntegrationStatus$Outbound;
}

export function workflowIntegrationStatusToJSON(workflowIntegrationStatus: WorkflowIntegrationStatus): string {
  return JSON.stringify(WorkflowIntegrationStatus$outboundSchema.parse(workflowIntegrationStatus));
}

export function workflowIntegrationStatusFromJSON(
  jsonString: string
): SafeParseResult<WorkflowIntegrationStatus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowIntegrationStatus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowIntegrationStatus' from JSON`
  );
}

/** @internal */
export const WorkflowResponse$inboundSchema: z.ZodType<WorkflowResponse, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    name: z.string(),
    description: z.string(),
    active: z.boolean(),
    draft: z.boolean(),
    preferenceSettings: SubscriberPreferenceChannels$inboundSchema,
    critical: z.boolean(),
    tags: z.array(z.string()),
    steps: z.array(NotificationStepDto$inboundSchema),
    _organizationId: z.string(),
    _creatorId: z.string(),
    _environmentId: z.string(),
    triggers: z.array(NotificationTrigger$inboundSchema),
    _notificationGroupId: z.string(),
    _parentId: z.string().optional(),
    deleted: z.boolean(),
    deletedAt: z.string(),
    deletedBy: z.string(),
    notificationGroup: NotificationGroup$inboundSchema.optional(),
    data: z.lazy(() => WorkflowResponseData$inboundSchema).optional(),
    workflowIntegrationStatus: z.lazy(() => WorkflowIntegrationStatus$inboundSchema).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      _organizationId: 'organizationId',
      _creatorId: 'creatorId',
      _environmentId: 'environmentId',
      _notificationGroupId: 'notificationGroupId',
      _parentId: 'parentId',
    });
  });

/** @internal */
export type WorkflowResponse$Outbound = {
  _id?: string | undefined;
  name: string;
  description: string;
  active: boolean;
  draft: boolean;
  preferenceSettings: SubscriberPreferenceChannels$Outbound;
  critical: boolean;
  tags: Array<string>;
  steps: Array<NotificationStepDto$Outbound>;
  _organizationId: string;
  _creatorId: string;
  _environmentId: string;
  triggers: Array<NotificationTrigger$Outbound>;
  _notificationGroupId: string;
  _parentId?: string | undefined;
  deleted: boolean;
  deletedAt: string;
  deletedBy: string;
  notificationGroup?: NotificationGroup$Outbound | undefined;
  data?: WorkflowResponseData$Outbound | undefined;
  workflowIntegrationStatus?: WorkflowIntegrationStatus$Outbound | undefined;
};

/** @internal */
export const WorkflowResponse$outboundSchema: z.ZodType<WorkflowResponse$Outbound, z.ZodTypeDef, WorkflowResponse> = z
  .object({
    id: z.string().optional(),
    name: z.string(),
    description: z.string(),
    active: z.boolean(),
    draft: z.boolean(),
    preferenceSettings: SubscriberPreferenceChannels$outboundSchema,
    critical: z.boolean(),
    tags: z.array(z.string()),
    steps: z.array(NotificationStepDto$outboundSchema),
    organizationId: z.string(),
    creatorId: z.string(),
    environmentId: z.string(),
    triggers: z.array(NotificationTrigger$outboundSchema),
    notificationGroupId: z.string(),
    parentId: z.string().optional(),
    deleted: z.boolean(),
    deletedAt: z.string(),
    deletedBy: z.string(),
    notificationGroup: NotificationGroup$outboundSchema.optional(),
    data: z.lazy(() => WorkflowResponseData$outboundSchema).optional(),
    workflowIntegrationStatus: z.lazy(() => WorkflowIntegrationStatus$outboundSchema).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      organizationId: '_organizationId',
      creatorId: '_creatorId',
      environmentId: '_environmentId',
      notificationGroupId: '_notificationGroupId',
      parentId: '_parentId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowResponse$ {
  /** @deprecated use `WorkflowResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowResponse$inboundSchema;
  /** @deprecated use `WorkflowResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowResponse$outboundSchema;
  /** @deprecated use `WorkflowResponse$Outbound` instead. */
  export type Outbound = WorkflowResponse$Outbound;
}

export function workflowResponseToJSON(workflowResponse: WorkflowResponse): string {
  return JSON.stringify(WorkflowResponse$outboundSchema.parse(workflowResponse));
}

export function workflowResponseFromJSON(jsonString: string): SafeParseResult<WorkflowResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowResponseDataToJSON(workflowResponseData: WorkflowResponseData)
 - workflowResponseDataFromJSON(jsonString: string)
 - workflowIntegrationStatusToJSON(workflowIntegrationStatus: WorkflowIntegrationStatus)
 - workflowIntegrationStatusFromJSON(jsonString: string)
 - workflowResponseToJSON(workflowResponse: WorkflowResponse)
 - workflowResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowResponseData$Outbound;
}

export function workflowResponseDataToJSON(workflowResponseData: W...)
 - Outbound(WorkflowIntegrationStatus$Outbound;
}

export function workflowIntegrationStatusToJSON(workflowInteg...)
 - Outbound(WorkflowResponse$Outbound;
}

export function workflowResponseToJSON(workflowResponse: WorkflowRespo...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowResponseDataToJSON
- export function workflowResponseDataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowIntegrationStatusToJSON
- export function workflowIntegrationStatusFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowResponseToJSON
- export function workflowResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowresponsedto.ts
Tamaño: 23277 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChatStepResponseDto,
  ChatStepResponseDto$inboundSchema,
  ChatStepResponseDto$Outbound,
  ChatStepResponseDto$outboundSchema,
} from './chatstepresponsedto.js';
import {
  CustomStepResponseDto,
  CustomStepResponseDto$inboundSchema,
  CustomStepResponseDto$Outbound,
  CustomStepResponseDto$outboundSchema,
} from './customstepresponsedto.js';
import {
  DelayStepResponseDto,
  DelayStepResponseDto$inboundSchema,
  DelayStepResponseDto$Outbound,
  DelayStepResponseDto$outboundSchema,
} from './delaystepresponsedto.js';
import {
  DigestStepResponseDto,
  DigestStepResponseDto$inboundSchema,
  DigestStepResponseDto$Outbound,
  DigestStepResponseDto$outboundSchema,
} from './digeststepresponsedto.js';
import {
  EmailStepResponseDto,
  EmailStepResponseDto$inboundSchema,
  EmailStepResponseDto$Outbound,
  EmailStepResponseDto$outboundSchema,
} from './emailstepresponsedto.js';
import {
  InAppStepResponseDto,
  InAppStepResponseDto$inboundSchema,
  InAppStepResponseDto$Outbound,
  InAppStepResponseDto$outboundSchema,
} from './inappstepresponsedto.js';
import {
  PushStepResponseDto,
  PushStepResponseDto$inboundSchema,
  PushStepResponseDto$Outbound,
  PushStepResponseDto$outboundSchema,
} from './pushstepresponsedto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  RuntimeIssueDto,
  RuntimeIssueDto$inboundSchema,
  RuntimeIssueDto$Outbound,
  RuntimeIssueDto$outboundSchema,
} from './runtimeissuedto.js';
import {
  SeverityLevelEnum,
  SeverityLevelEnum$inboundSchema,
  SeverityLevelEnum$outboundSchema,
} from './severitylevelenum.js';
import {
  SmsStepResponseDto,
  SmsStepResponseDto$inboundSchema,
  SmsStepResponseDto$Outbound,
  SmsStepResponseDto$outboundSchema,
} from './smsstepresponsedto.js';
import {
  ThrottleStepResponseDto,
  ThrottleStepResponseDto$inboundSchema,
  ThrottleStepResponseDto$Outbound,
  ThrottleStepResponseDto$outboundSchema,
} from './throttlestepresponsedto.js';
import {
  WorkflowPreferencesResponseDto,
  WorkflowPreferencesResponseDto$inboundSchema,
  WorkflowPreferencesResponseDto$Outbound,
  WorkflowPreferencesResponseDto$outboundSchema,
} from './workflowpreferencesresponsedto.js';
import {
  WorkflowStatusEnum,
  WorkflowStatusEnum$inboundSchema,
  WorkflowStatusEnum$outboundSchema,
} from './workflowstatusenum.js';

/**
 * User who last updated the workflow
 */
export type WorkflowResponseDtoUpdatedBy = {
  /**
   * User ID
   */
  id: string;
  /**
   * User first name
   */
  firstName?: string | null | undefined;
  /**
   * User last name
   */
  lastName?: string | null | undefined;
  /**
   * User external ID
   */
  externalId?: string | null | undefined;
};

/**
 * User who last published the workflow
 */
export type LastPublishedBy = {
  /**
   * User ID
   */
  id: string;
  /**
   * User first name
   */
  firstName?: string | null | undefined;
  /**
   * User last name
   */
  lastName?: string | null | undefined;
  /**
   * User external ID
   */
  externalId?: string | null | undefined;
};

export type WorkflowResponseDtoSteps =
  | (InAppStepResponseDto & { type: 'in_app' })
  | (EmailStepResponseDto & { type: 'email' })
  | (SmsStepResponseDto & { type: 'sms' })
  | (PushStepResponseDto & { type: 'push' })
  | (ChatStepResponseDto & { type: 'chat' })
  | (DelayStepResponseDto & { type: 'delay' })
  | (DigestStepResponseDto & { type: 'digest' })
  | (CustomStepResponseDto & { type: 'custom' })
  | (ThrottleStepResponseDto & { type: 'throttle' });

export type WorkflowResponseDto = {
  /**
   * Name of the workflow
   */
  name: string;
  /**
   * Description of the workflow
   */
  description?: string | undefined;
  /**
   * Tags associated with the workflow
   */
  tags?: Array<string> | undefined;
  /**
   * Whether the workflow is active
   */
  active?: boolean | undefined;
  /**
   * Enable or disable payload schema validation
   */
  validatePayload?: boolean | undefined;
  /**
   * The payload JSON Schema for the workflow
   */
  payloadSchema?: { [k: string]: any } | null | undefined;
  /**
   * Enable or disable translations for this workflow
   */
  isTranslationEnabled?: boolean | undefined;
  /**
   * Database identifier of the workflow
   */
  id: string;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Slug of the workflow
   */
  slug: string;
  /**
   * Last updated timestamp
   */
  updatedAt: string;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * User who last updated the workflow
   */
  updatedBy?: WorkflowResponseDtoUpdatedBy | null | undefined;
  /**
   * Timestamp of the last workflow publication
   */
  lastPublishedAt?: string | null | undefined;
  /**
   * User who last published the workflow
   */
  lastPublishedBy?: LastPublishedBy | null | undefined;
  /**
   * Steps of the workflow
   */
  steps: Array<
    | (InAppStepResponseDto & { type: 'in_app' })
    | (EmailStepResponseDto & { type: 'email' })
    | (SmsStepResponseDto & { type: 'sms' })
    | (PushStepResponseDto & { type: 'push' })
    | (ChatStepResponseDto & { type: 'chat' })
    | (DelayStepResponseDto & { type: 'delay' })
    | (DigestStepResponseDto & { type: 'digest' })
    | (CustomStepResponseDto & { type: 'custom' })
    | (ThrottleStepResponseDto & { type: 'throttle' })
  >;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Preferences for the workflow
   */
  preferences: WorkflowPreferencesResponseDto;
  /**
   * Status of the workflow
   */
  status: WorkflowStatusEnum;
  /**
   * Runtime issues for workflow creation and update
   */
  issues?: { [k: string]: RuntimeIssueDto } | undefined;
  /**
   * Timestamp of the last workflow trigger
   */
  lastTriggeredAt?: string | null | undefined;
  /**
   * Generated payload example based on the payload schema
   */
  payloadExample?: { [k: string]: any } | null | undefined;
  /**
   * Severity of the workflow
   */
  severity: SeverityLevelEnum;
};

/** @internal */
export const WorkflowResponseDtoUpdatedBy$inboundSchema: z.ZodType<
  WorkflowResponseDtoUpdatedBy,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    _id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type WorkflowResponseDtoUpdatedBy$Outbound = {
  _id: string;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  externalId?: string | null | undefined;
};

/** @internal */
export const WorkflowResponseDtoUpdatedBy$outboundSchema: z.ZodType<
  WorkflowResponseDtoUpdatedBy$Outbound,
  z.ZodTypeDef,
  WorkflowResponseDtoUpdatedBy
> = z
  .object({
    id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowResponseDtoUpdatedBy$ {
  /** @deprecated use `WorkflowResponseDtoUpdatedBy$inboundSchema` instead. */
  export const inboundSchema = WorkflowResponseDtoUpdatedBy$inboundSchema;
  /** @deprecated use `WorkflowResponseDtoUpdatedBy$outboundSchema` instead. */
  export const outboundSchema = WorkflowResponseDtoUpdatedBy$outboundSchema;
  /** @deprecated use `WorkflowResponseDtoUpdatedBy$Outbound` instead. */
  export type Outbound = WorkflowResponseDtoUpdatedBy$Outbound;
}

export function workflowResponseDtoUpdatedByToJSON(workflowResponseDtoUpdatedBy: WorkflowResponseDtoUpdatedBy): string {
  return JSON.stringify(WorkflowResponseDtoUpdatedBy$outboundSchema.parse(workflowResponseDtoUpdatedBy));
}

export function workflowResponseDtoUpdatedByFromJSON(
  jsonString: string
): SafeParseResult<WorkflowResponseDtoUpdatedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowResponseDtoUpdatedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowResponseDtoUpdatedBy' from JSON`
  );
}

/** @internal */
export const LastPublishedBy$inboundSchema: z.ZodType<LastPublishedBy, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type LastPublishedBy$Outbound = {
  _id: string;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  externalId?: string | null | undefined;
};

/** @internal */
export const LastPublishedBy$outboundSchema: z.ZodType<LastPublishedBy$Outbound, z.ZodTypeDef, LastPublishedBy> = z
  .object({
    id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LastPublishedBy$ {
  /** @deprecated use `LastPublishedBy$inboundSchema` instead. */
  export const inboundSchema = LastPublishedBy$inboundSchema;
  /** @deprecated use `LastPublishedBy$outboundSchema` instead. */
  export const outboundSchema = LastPublishedBy$outboundSchema;
  /** @deprecated use `LastPublishedBy$Outbound` instead. */
  export type Outbound = LastPublishedBy$Outbound;
}

export function lastPublishedByToJSON(lastPublishedBy: LastPublishedBy): string {
  return JSON.stringify(LastPublishedBy$outboundSchema.parse(lastPublishedBy));
}

export function lastPublishedByFromJSON(jsonString: string): SafeParseResult<LastPublishedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LastPublishedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LastPublishedBy' from JSON`
  );
}

/** @internal */
export const WorkflowResponseDtoSteps$inboundSchema: z.ZodType<WorkflowResponseDtoSteps, z.ZodTypeDef, unknown> =
  z.union([
    InAppStepResponseDto$inboundSchema.and(
      z.object({ type: z.literal('in_app') }).transform((v) => ({
        type: v.type,
      }))
    ),
    EmailStepResponseDto$inboundSchema.and(z.object({ type: z.literal('email') }).transform((v) => ({ type: v.type }))),
    SmsStepResponseDto$inboundSchema.and(z.object({ type: z.literal('sms') }).transform((v) => ({ type: v.type }))),
    PushStepResponseDto$inboundSchema.and(z.object({ type: z.literal('push') }).transform((v) => ({ type: v.type }))),
    ChatStepResponseDto$inboundSchema.and(z.object({ type: z.literal('chat') }).transform((v) => ({ type: v.type }))),
    DelayStepResponseDto$inboundSchema.and(z.object({ type: z.literal('delay') }).transform((v) => ({ type: v.type }))),
    DigestStepResponseDto$inboundSchema.and(
      z.object({ type: z.literal('digest') }).transform((v) => ({
        type: v.type,
      }))
    ),
    CustomStepResponseDto$inboundSchema.and(
      z.object({ type: z.literal('custom') }).transform((v) => ({
        type: v.type,
      }))
    ),
    ThrottleStepResponseDto$inboundSchema.and(
      z.object({ type: z.literal('throttle') }).transform((v) => ({
        type: v.type,
      }))
    ),
  ]);

/** @internal */
export type WorkflowResponseDtoSteps$Outbound =
  | (InAppStepResponseDto$Outbound & { type: 'in_app' })
  | (EmailStepResponseDto$Outbound & { type: 'email' })
  | (SmsStepResponseDto$Outbound & { type: 'sms' })
  | (PushStepResponseDto$Outbound & { type: 'push' })
  | (ChatStepResponseDto$Outbound & { type: 'chat' })
  | (DelayStepResponseDto$Outbound & { type: 'delay' })
  | (DigestStepResponseDto$Outbound & { type: 'digest' })
  | (CustomStepResponseDto$Outbound & { type: 'custom' })
  | (ThrottleStepResponseDto$Outbound & { type: 'throttle' });

/** @internal */
export const WorkflowResponseDtoSteps$outboundSchema: z.ZodType<
  WorkflowResponseDtoSteps$Outbound,
  z.ZodTypeDef,
  WorkflowResponseDtoSteps
> = z.union([
  InAppStepResponseDto$outboundSchema.and(
    z.object({ type: z.literal('in_app') }).transform((v) => ({
      type: v.type,
    }))
  ),
  EmailStepResponseDto$outboundSchema.and(z.object({ type: z.literal('email') }).transform((v) => ({ type: v.type }))),
  SmsStepResponseDto$outboundSchema.and(z.object({ type: z.literal('sms') }).transform((v) => ({ type: v.type }))),
  PushStepResponseDto$outboundSchema.and(z.object({ type: z.literal('push') }).transform((v) => ({ type: v.type }))),
  ChatStepResponseDto$outboundSchema.and(z.object({ type: z.literal('chat') }).transform((v) => ({ type: v.type }))),
  DelayStepResponseDto$outboundSchema.and(z.object({ type: z.literal('delay') }).transform((v) => ({ type: v.type }))),
  DigestStepResponseDto$outboundSchema.and(
    z.object({ type: z.literal('digest') }).transform((v) => ({
      type: v.type,
    }))
  ),
  CustomStepResponseDto$outboundSchema.and(
    z.object({ type: z.literal('custom') }).transform((v) => ({
      type: v.type,
    }))
  ),
  ThrottleStepResponseDto$outboundSchema.and(
    z.object({ type: z.literal('throttle') }).transform((v) => ({
      type: v.type,
    }))
  ),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowResponseDtoSteps$ {
  /** @deprecated use `WorkflowResponseDtoSteps$inboundSchema` instead. */
  export const inboundSchema = WorkflowResponseDtoSteps$inboundSchema;
  /** @deprecated use `WorkflowResponseDtoSteps$outboundSchema` instead. */
  export const outboundSchema = WorkflowResponseDtoSteps$outboundSchema;
  /** @deprecated use `WorkflowResponseDtoSteps$Outbound` instead. */
  export type Outbound = WorkflowResponseDtoSteps$Outbound;
}

export function workflowResponseDtoStepsToJSON(workflowResponseDtoSteps: WorkflowResponseDtoSteps): string {
  return JSON.stringify(WorkflowResponseDtoSteps$outboundSchema.parse(workflowResponseDtoSteps));
}

export function workflowResponseDtoStepsFromJSON(
  jsonString: string
): SafeParseResult<WorkflowResponseDtoSteps, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowResponseDtoSteps$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowResponseDtoSteps' from JSON`
  );
}

/** @internal */
export const WorkflowResponseDto$inboundSchema: z.ZodType<WorkflowResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string(),
    description: z.string().optional(),
    tags: z.array(z.string()).optional(),
    active: z.boolean().default(false),
    validatePayload: z.boolean().optional(),
    payloadSchema: z.nullable(z.record(z.any())).optional(),
    isTranslationEnabled: z.boolean().default(false),
    _id: z.string(),
    workflowId: z.string(),
    slug: z.string(),
    updatedAt: z.string(),
    createdAt: z.string(),
    updatedBy: z.nullable(z.lazy(() => WorkflowResponseDtoUpdatedBy$inboundSchema)).optional(),
    lastPublishedAt: z.nullable(z.string()).optional(),
    lastPublishedBy: z.nullable(z.lazy(() => LastPublishedBy$inboundSchema)).optional(),
    steps: z.array(
      z.union([
        InAppStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('in_app') }).transform((v) => ({
            type: v.type,
          }))
        ),
        EmailStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('email') }).transform((v) => ({
            type: v.type,
          }))
        ),
        SmsStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('sms') }).transform((v) => ({
            type: v.type,
          }))
        ),
        PushStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('push') }).transform((v) => ({
            type: v.type,
          }))
        ),
        ChatStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('chat') }).transform((v) => ({
            type: v.type,
          }))
        ),
        DelayStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('delay') }).transform((v) => ({
            type: v.type,
          }))
        ),
        DigestStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('digest') }).transform((v) => ({
            type: v.type,
          }))
        ),
        CustomStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('custom') }).transform((v) => ({
            type: v.type,
          }))
        ),
        ThrottleStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('throttle') }).transform((v) => ({
            type: v.type,
          }))
        ),
      ])
    ),
    origin: ResourceOriginEnum$inboundSchema,
    preferences: WorkflowPreferencesResponseDto$inboundSchema,
    status: WorkflowStatusEnum$inboundSchema,
    issues: z.record(RuntimeIssueDto$inboundSchema).optional(),
    lastTriggeredAt: z.nullable(z.string()).optional(),
    payloadExample: z.nullable(z.record(z.any())).optional(),
    severity: SeverityLevelEnum$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type WorkflowResponseDto$Outbound = {
  name: string;
  description?: string | undefined;
  tags?: Array<string> | undefined;
  active: boolean;
  validatePayload?: boolean | undefined;
  payloadSchema?: { [k: string]: any } | null | undefined;
  isTranslationEnabled: boolean;
  _id: string;
  workflowId: string;
  slug: string;
  updatedAt: string;
  createdAt: string;
  updatedBy?: WorkflowResponseDtoUpdatedBy$Outbound | null | undefined;
  lastPublishedAt?: string | null | undefined;
  lastPublishedBy?: LastPublishedBy$Outbound | null | undefined;
  steps: Array<
    | (InAppStepResponseDto$Outbound & { type: 'in_app' })
    | (EmailStepResponseDto$Outbound & { type: 'email' })
    | (SmsStepResponseDto$Outbound & { type: 'sms' })
    | (PushStepResponseDto$Outbound & { type: 'push' })
    | (ChatStepResponseDto$Outbound & { type: 'chat' })
    | (DelayStepResponseDto$Outbound & { type: 'delay' })
    | (DigestStepResponseDto$Outbound & { type: 'digest' })
    | (CustomStepResponseDto$Outbound & { type: 'custom' })
    | (ThrottleStepResponseDto$Outbound & { type: 'throttle' })
  >;
  origin: string;
  preferences: WorkflowPreferencesResponseDto$Outbound;
  status: string;
  issues?: { [k: string]: RuntimeIssueDto$Outbound } | undefined;
  lastTriggeredAt?: string | null | undefined;
  payloadExample?: { [k: string]: any } | null | undefined;
  severity: string;
};

/** @internal */
export const WorkflowResponseDto$outboundSchema: z.ZodType<
  WorkflowResponseDto$Outbound,
  z.ZodTypeDef,
  WorkflowResponseDto
> = z
  .object({
    name: z.string(),
    description: z.string().optional(),
    tags: z.array(z.string()).optional(),
    active: z.boolean().default(false),
    validatePayload: z.boolean().optional(),
    payloadSchema: z.nullable(z.record(z.any())).optional(),
    isTranslationEnabled: z.boolean().default(false),
    id: z.string(),
    workflowId: z.string(),
    slug: z.string(),
    updatedAt: z.string(),
    createdAt: z.string(),
    updatedBy: z.nullable(z.lazy(() => WorkflowResponseDtoUpdatedBy$outboundSchema)).optional(),
    lastPublishedAt: z.nullable(z.string()).optional(),
    lastPublishedBy: z.nullable(z.lazy(() => LastPublishedBy$outboundSchema)).optional(),
    steps: z.array(
      z.union([
        InAppStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('in_app') }).transform((v) => ({
            type: v.type,
          }))
        ),
        EmailStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('email') }).transform((v) => ({
            type: v.type,
          }))
        ),
        SmsStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('sms') }).transform((v) => ({
            type: v.type,
          }))
        ),
        PushStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('push') }).transform((v) => ({
            type: v.type,
          }))
        ),
        ChatStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('chat') }).transform((v) => ({
            type: v.type,
          }))
        ),
        DelayStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('delay') }).transform((v) => ({
            type: v.type,
          }))
        ),
        DigestStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('digest') }).transform((v) => ({
            type: v.type,
          }))
        ),
        CustomStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('custom') }).transform((v) => ({
            type: v.type,
          }))
        ),
        ThrottleStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('throttle') }).transform((v) => ({
            type: v.type,
          }))
        ),
      ])
    ),
    origin: ResourceOriginEnum$outboundSchema,
    preferences: WorkflowPreferencesResponseDto$outboundSchema,
    status: WorkflowStatusEnum$outboundSchema,
    issues: z.record(RuntimeIssueDto$outboundSchema).optional(),
    lastTriggeredAt: z.nullable(z.string()).optional(),
    payloadExample: z.nullable(z.record(z.any())).optional(),
    severity: SeverityLevelEnum$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowResponseDto$ {
  /** @deprecated use `WorkflowResponseDto$inboundSchema` instead. */
  export const inboundSchema = WorkflowResponseDto$inboundSchema;
  /** @deprecated use `WorkflowResponseDto$outboundSchema` instead. */
  export const outboundSchema = WorkflowResponseDto$outboundSchema;
  /** @deprecated use `WorkflowResponseDto$Outbound` instead. */
  export type Outbound = WorkflowResponseDto$Outbound;
}

export function workflowResponseDtoToJSON(workflowResponseDto: WorkflowResponseDto): string {
  return JSON.stringify(WorkflowResponseDto$outboundSchema.parse(workflowResponseDto));
}

export function workflowResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<WorkflowResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowResponseDtoUpdatedByToJSON(workflowResponseDtoUpdatedBy: WorkflowResponseDtoUpdatedBy)
 - workflowResponseDtoUpdatedByFromJSON(jsonString: string)
 - lastPublishedByToJSON(lastPublishedBy: LastPublishedBy)
 - lastPublishedByFromJSON(jsonString: string)
 - workflowResponseDtoStepsToJSON(workflowResponseDtoSteps: WorkflowResponseDtoSteps)
 - workflowResponseDtoStepsFromJSON(jsonString: string)
 - workflowResponseDtoToJSON(workflowResponseDto: WorkflowResponseDto)
 - workflowResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowResponseDtoUpdatedBy$Outbound;
}

export function workflowResponseDtoUpdatedByToJSON(workflo...)
 - Outbound(LastPublishedBy$Outbound;
}

export function lastPublishedByToJSON(lastPublishedBy: LastPublishedBy)...)
 - Outbound(WorkflowResponseDtoSteps$Outbound;
}

export function workflowResponseDtoStepsToJSON(workflowRespons...)
 - Outbound(WorkflowResponseDto$Outbound;
}

export function workflowResponseDtoToJSON(workflowResponseDto: Work...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowResponseDtoUpdatedByToJSON
- export function workflowResponseDtoUpdatedByFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function lastPublishedByToJSON
- export function lastPublishedByFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowResponseDtoStepsToJSON
- export function workflowResponseDtoStepsFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowResponseDtoToJSON
- export function workflowResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowresponsedtosortfield.ts
Tamaño: 1284 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

export const WorkflowResponseDtoSortField = {
  CreatedAt: 'createdAt',
  UpdatedAt: 'updatedAt',
  Name: 'name',
  LastTriggeredAt: 'lastTriggeredAt',
} as const;
export type WorkflowResponseDtoSortField = ClosedEnum<typeof WorkflowResponseDtoSortField>;

/** @internal */
export const WorkflowResponseDtoSortField$inboundSchema: z.ZodNativeEnum<typeof WorkflowResponseDtoSortField> =
  z.nativeEnum(WorkflowResponseDtoSortField);

/** @internal */
export const WorkflowResponseDtoSortField$outboundSchema: z.ZodNativeEnum<typeof WorkflowResponseDtoSortField> =
  WorkflowResponseDtoSortField$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowResponseDtoSortField$ {
  /** @deprecated use `WorkflowResponseDtoSortField$inboundSchema` instead. */
  export const inboundSchema = WorkflowResponseDtoSortField$inboundSchema;
  /** @deprecated use `WorkflowResponseDtoSortField$outboundSchema` instead. */
  export const outboundSchema = WorkflowResponseDtoSortField$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowrunstepsdetailsdto.ts
Tamaño: 3863 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Step status
 */
export const WorkflowRunStepsDetailsDtoStatus = {
  Pending: 'pending',
  Queued: 'queued',
  Running: 'running',
  Completed: 'completed',
  Failed: 'failed',
  Delayed: 'delayed',
  Canceled: 'canceled',
  Merged: 'merged',
  Skipped: 'skipped',
} as const;
/**
 * Step status
 */
export type WorkflowRunStepsDetailsDtoStatus = ClosedEnum<typeof WorkflowRunStepsDetailsDtoStatus>;

export type WorkflowRunStepsDetailsDto = {
  /**
   * Step run identifier
   */
  id: string;
  /**
   * Step identifier
   */
  stepRunId: string;
  /**
   * Step type
   */
  stepType: string;
  /**
   * Step status
   */
  status: WorkflowRunStepsDetailsDtoStatus;
};

/** @internal */
export const WorkflowRunStepsDetailsDtoStatus$inboundSchema: z.ZodNativeEnum<typeof WorkflowRunStepsDetailsDtoStatus> =
  z.nativeEnum(WorkflowRunStepsDetailsDtoStatus);

/** @internal */
export const WorkflowRunStepsDetailsDtoStatus$outboundSchema: z.ZodNativeEnum<typeof WorkflowRunStepsDetailsDtoStatus> =
  WorkflowRunStepsDetailsDtoStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowRunStepsDetailsDtoStatus$ {
  /** @deprecated use `WorkflowRunStepsDetailsDtoStatus$inboundSchema` instead. */
  export const inboundSchema = WorkflowRunStepsDetailsDtoStatus$inboundSchema;
  /** @deprecated use `WorkflowRunStepsDetailsDtoStatus$outboundSchema` instead. */
  export const outboundSchema = WorkflowRunStepsDetailsDtoStatus$outboundSchema;
}

/** @internal */
export const WorkflowRunStepsDetailsDto$inboundSchema: z.ZodType<WorkflowRunStepsDetailsDto, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    stepRunId: z.string(),
    stepType: z.string(),
    status: WorkflowRunStepsDetailsDtoStatus$inboundSchema,
  });

/** @internal */
export type WorkflowRunStepsDetailsDto$Outbound = {
  id: string;
  stepRunId: string;
  stepType: string;
  status: string;
};

/** @internal */
export const WorkflowRunStepsDetailsDto$outboundSchema: z.ZodType<
  WorkflowRunStepsDetailsDto$Outbound,
  z.ZodTypeDef,
  WorkflowRunStepsDetailsDto
> = z.object({
  id: z.string(),
  stepRunId: z.string(),
  stepType: z.string(),
  status: WorkflowRunStepsDetailsDtoStatus$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowRunStepsDetailsDto$ {
  /** @deprecated use `WorkflowRunStepsDetailsDto$inboundSchema` instead. */
  export const inboundSchema = WorkflowRunStepsDetailsDto$inboundSchema;
  /** @deprecated use `WorkflowRunStepsDetailsDto$outboundSchema` instead. */
  export const outboundSchema = WorkflowRunStepsDetailsDto$outboundSchema;
  /** @deprecated use `WorkflowRunStepsDetailsDto$Outbound` instead. */
  export type Outbound = WorkflowRunStepsDetailsDto$Outbound;
}

export function workflowRunStepsDetailsDtoToJSON(workflowRunStepsDetailsDto: WorkflowRunStepsDetailsDto): string {
  return JSON.stringify(WorkflowRunStepsDetailsDto$outboundSchema.parse(workflowRunStepsDetailsDto));
}

export function workflowRunStepsDetailsDtoFromJSON(
  jsonString: string
): SafeParseResult<WorkflowRunStepsDetailsDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowRunStepsDetailsDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowRunStepsDetailsDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowRunStepsDetailsDtoToJSON(workflowRunStepsDetailsDto: WorkflowRunStepsDetailsDto)
 - workflowRunStepsDetailsDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowRunStepsDetailsDto$Outbound;
}

export function workflowRunStepsDetailsDtoToJSON(workflowRun...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowRunStepsDetailsDtoToJSON
- export function workflowRunStepsDetailsDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowstatusenum.ts
Tamaño: 1168 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Status of the workflow
 */
export const WorkflowStatusEnum = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE',
  Error: 'ERROR',
} as const;
/**
 * Status of the workflow
 */
export type WorkflowStatusEnum = ClosedEnum<typeof WorkflowStatusEnum>;

/** @internal */
export const WorkflowStatusEnum$inboundSchema: z.ZodNativeEnum<typeof WorkflowStatusEnum> =
  z.nativeEnum(WorkflowStatusEnum);

/** @internal */
export const WorkflowStatusEnum$outboundSchema: z.ZodNativeEnum<typeof WorkflowStatusEnum> =
  WorkflowStatusEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowStatusEnum$ {
  /** @deprecated use `WorkflowStatusEnum$inboundSchema` instead. */
  export const inboundSchema = WorkflowStatusEnum$inboundSchema;
  /** @deprecated use `WorkflowStatusEnum$outboundSchema` instead. */
  export const outboundSchema = WorkflowStatusEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/errordto.ts
Tamaño: 8739 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { NovuError } from './novuerror.js';
import { SDKValidationError } from './sdkvalidationerror.js';

export type Five = string | number | boolean | { [k: string]: any };

export type Four = {};

/**
 * Value that failed validation
 */
export type Message = string | number | boolean | Four | Array<string | number | boolean | { [k: string]: any } | null>;

export type ErrorDtoData = {
  /**
   * HTTP status code of the error response.
   */
  statusCode: number;
  /**
   * Timestamp of when the error occurred.
   */
  timestamp: string;
  /**
   * The path where the error occurred.
   */
  path: string;
  /**
   * Value that failed validation
   */
  message?:
    | string
    | number
    | boolean
    | Four
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
  /**
   * Optional context object for additional error details.
   */
  ctx?: { [k: string]: any } | undefined;
  /**
   * Optional unique identifier for the error, useful for tracking using Sentry and
   *
   * @remarks
   *       New Relic, only available for 500.
   */
  errorId?: string | undefined;
};

export class ErrorDto extends NovuError {
  /**
   * Timestamp of when the error occurred.
   */
  timestamp: string;
  /**
   * The path where the error occurred.
   */
  path: string;
  /**
   * Optional context object for additional error details.
   */
  ctx?: { [k: string]: any } | undefined;
  /**
   * Optional unique identifier for the error, useful for tracking using Sentry and
   *
   * @remarks
   *       New Relic, only available for 500.
   */
  errorId?: string | undefined;

  /** The original data that was passed to this error instance. */
  data$: ErrorDtoData;

  constructor(err: ErrorDtoData, httpMeta: { response: Response; request: Request; body: string }) {
    const message =
      'message' in err && typeof err.message === 'string' ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.timestamp = err.timestamp;
    this.path = err.path;
    if (err.ctx != null) this.ctx = err.ctx;
    if (err.errorId != null) this.errorId = err.errorId;

    this.name = 'ErrorDto';
  }
}

/** @internal */
export const Five$inboundSchema: z.ZodType<Five, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/** @internal */
export type Five$Outbound = string | number | boolean | { [k: string]: any };

/** @internal */
export const Five$outboundSchema: z.ZodType<Five$Outbound, z.ZodTypeDef, Five> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Five$ {
  /** @deprecated use `Five$inboundSchema` instead. */
  export const inboundSchema = Five$inboundSchema;
  /** @deprecated use `Five$outboundSchema` instead. */
  export const outboundSchema = Five$outboundSchema;
  /** @deprecated use `Five$Outbound` instead. */
  export type Outbound = Five$Outbound;
}

export function fiveToJSON(five: Five): string {
  return JSON.stringify(Five$outboundSchema.parse(five));
}

export function fiveFromJSON(jsonString: string): SafeParseResult<Five, SDKValidationError> {
  return safeParse(jsonString, (x) => Five$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Five' from JSON`);
}

/** @internal */
export const Four$inboundSchema: z.ZodType<Four, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Four$Outbound = {};

/** @internal */
export const Four$outboundSchema: z.ZodType<Four$Outbound, z.ZodTypeDef, Four> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Four$ {
  /** @deprecated use `Four$inboundSchema` instead. */
  export const inboundSchema = Four$inboundSchema;
  /** @deprecated use `Four$outboundSchema` instead. */
  export const outboundSchema = Four$outboundSchema;
  /** @deprecated use `Four$Outbound` instead. */
  export type Outbound = Four$Outbound;
}

export function fourToJSON(four: Four): string {
  return JSON.stringify(Four$outboundSchema.parse(four));
}

export function fourFromJSON(jsonString: string): SafeParseResult<Four, SDKValidationError> {
  return safeParse(jsonString, (x) => Four$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Four' from JSON`);
}

/** @internal */
export const Message$inboundSchema: z.ZodType<Message, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => Four$inboundSchema),
  z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
]);

/** @internal */
export type Message$Outbound =
  | string
  | number
  | boolean
  | Four$Outbound
  | Array<string | number | boolean | { [k: string]: any } | null>;

/** @internal */
export const Message$outboundSchema: z.ZodType<Message$Outbound, z.ZodTypeDef, Message> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => Four$outboundSchema),
  z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Message$ {
  /** @deprecated use `Message$inboundSchema` instead. */
  export const inboundSchema = Message$inboundSchema;
  /** @deprecated use `Message$outboundSchema` instead. */
  export const outboundSchema = Message$outboundSchema;
  /** @deprecated use `Message$Outbound` instead. */
  export type Outbound = Message$Outbound;
}

export function messageToJSON(message: Message): string {
  return JSON.stringify(Message$outboundSchema.parse(message));
}

export function messageFromJSON(jsonString: string): SafeParseResult<Message, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message' from JSON`
  );
}

/** @internal */
export const ErrorDto$inboundSchema: z.ZodType<ErrorDto, z.ZodTypeDef, unknown> = z
  .object({
    statusCode: z.number(),
    timestamp: z.string(),
    path: z.string(),
    message: z
      .nullable(
        z.union([
          z.string(),
          z.number(),
          z.boolean(),
          z.lazy(() => Four$inboundSchema),
          z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
        ])
      )
      .optional(),
    ctx: z.record(z.any()).optional(),
    errorId: z.string().optional(),
    request$: z.instanceof(Request),
    response$: z.instanceof(Response),
    body$: z.string(),
  })
  .transform((v) => {
    return new ErrorDto(v, {
      request: v.request$,
      response: v.response$,
      body: v.body$,
    });
  });

/** @internal */
export type ErrorDto$Outbound = {
  statusCode: number;
  timestamp: string;
  path: string;
  message?:
    | string
    | number
    | boolean
    | Four$Outbound
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
  ctx?: { [k: string]: any } | undefined;
  errorId?: string | undefined;
};

/** @internal */
export const ErrorDto$outboundSchema: z.ZodType<ErrorDto$Outbound, z.ZodTypeDef, ErrorDto> = z
  .instanceof(ErrorDto)
  .transform((v) => v.data$)
  .pipe(
    z.object({
      statusCode: z.number(),
      timestamp: z.string(),
      path: z.string(),
      message: z
        .nullable(
          z.union([
            z.string(),
            z.number(),
            z.boolean(),
            z.lazy(() => Four$outboundSchema),
            z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
          ])
        )
        .optional(),
      ctx: z.record(z.any()).optional(),
      errorId: z.string().optional(),
    })
  );

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ErrorDto$ {
  /** @deprecated use `ErrorDto$inboundSchema` instead. */
  export const inboundSchema = ErrorDto$inboundSchema;
  /** @deprecated use `ErrorDto$outboundSchema` instead. */
  export const outboundSchema = ErrorDto$outboundSchema;
  /** @deprecated use `ErrorDto$Outbound` instead. */
  export type Outbound = ErrorDto$Outbound;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - fiveToJSON(five: Five)
 - fiveFromJSON(jsonString: string)
 - fourToJSON(four: Four)
 - fourFromJSON(jsonString: string)
 - messageToJSON(message: Message)
 - messageFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Five$Outbound;
}

export function fiveToJSON(five: Five): string {
  return JSON.stringify(Five$outb...)
 - Outbound(Four$Outbound;
}

export function fourToJSON(four: Four): string {
  return JSON.stringify(Four$outb...)
 - Outbound(Message$Outbound;
}

export function messageToJSON(message: Message): string {
  return JSON.stringi...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export class ErrorDto
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function fiveToJSON
- export function fiveFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function fourToJSON
- export function fourFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageToJSON
- export function messageFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/httpclienterrors.ts
Tamaño: 1651 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

/**
 * Base class for all HTTP errors.
 */
export class HTTPClientError extends Error {
  /** The underlying cause of the error. */
  override readonly cause: unknown;
  override name = "HTTPClientError";
  constructor(message: string, opts?: { cause?: unknown }) {
    let msg = message;
    if (opts?.cause) {
      msg += `: ${opts.cause}`;
    }

    super(msg, opts);
    // In older runtimes, the cause field would not have been assigned through
    // the super() call.
    if (typeof this.cause === "undefined") {
      this.cause = opts?.cause;
    }
  }
}

/**
 * An error to capture unrecognised or unexpected errors when making HTTP calls.
 */
export class UnexpectedClientError extends HTTPClientError {
  override name = "UnexpectedClientError";
}

/**
 * An error that is raised when any inputs used to create a request are invalid.
 */
export class InvalidRequestError extends HTTPClientError {
  override name = "InvalidRequestError";
}

/**
 * An error that is raised when a HTTP request was aborted by the client error.
 */
export class RequestAbortedError extends HTTPClientError {
  override readonly name = "RequestAbortedError";
}

/**
 * An error that is raised when a HTTP request timed out due to an AbortSignal
 * signal timeout.
 */
export class RequestTimeoutError extends HTTPClientError {
  override readonly name = "RequestTimeoutError";
}

/**
 * An error that is raised when a HTTP client is unable to make a request to
 * a server.
 */
export class ConnectionError extends HTTPClientError {
  override readonly name = "ConnectionError";
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class HTTPClientError
- export class UnexpectedClientError
- export class InvalidRequestError
- export class RequestAbortedError
- export class RequestTimeoutError
- export class ConnectionError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/index.ts
Tamaño: 473 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export * from "./errordto.js";
export * from "./httpclienterrors.js";
export * from "./novuerror.js";
export * from "./payloadvalidationexceptiondto.js";
export * from "./responsevalidationerror.js";
export * from "./sdkerror.js";
export * from "./sdkvalidationerror.js";
export * from "./subscriberresponsedto.js";
export * from "./topicresponsedto.js";
export * from "./validationerrordto.js";


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/novuerror.ts
Tamaño: 904 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

/** The base class for all HTTP error responses */
export class NovuError extends Error {
  /** HTTP status code */
  public readonly statusCode: number;
  /** HTTP body */
  public readonly body: string;
  /** HTTP headers */
  public readonly headers: Headers;
  /** HTTP content type */
  public readonly contentType: string;
  /** Raw response */
  public readonly rawResponse: Response;

  constructor(
    message: string,
    httpMeta: {
      response: Response;
      request: Request;
      body: string;
    },
  ) {
    super(message);
    this.statusCode = httpMeta.response.status;
    this.body = httpMeta.body;
    this.headers = httpMeta.response.headers;
    this.contentType = httpMeta.response.headers.get("content-type") || "";
    this.rawResponse = httpMeta.response;

    this.name = "NovuError";
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NovuError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/payloadvalidationexceptiondto.ts
Tamaño: 14119 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { NovuError } from './novuerror.js';
import { SDKValidationError } from './sdkvalidationerror.js';

export type MessagePayloadValidationExceptionDto5 = string | number | boolean | { [k: string]: any };

export type MessagePayloadValidationExceptionDto4 = {};

/**
 * Value that failed validation
 */
export type PayloadValidationExceptionDtoMessage =
  | string
  | number
  | boolean
  | MessagePayloadValidationExceptionDto4
  | Array<string | number | boolean | { [k: string]: any } | null>;

/**
 * The JSON schema that was used for validation
 */
export type Schema = {};

export type PayloadValidationExceptionDtoData = {
  /**
   * HTTP status code of the error response.
   */
  statusCode: number;
  /**
   * Timestamp of when the error occurred.
   */
  timestamp: string;
  /**
   * The path where the error occurred.
   */
  path: string;
  /**
   * Value that failed validation
   */
  message?:
    | string
    | number
    | boolean
    | MessagePayloadValidationExceptionDto4
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
  /**
   * Optional context object for additional error details.
   */
  ctx?: { [k: string]: any } | undefined;
  /**
   * Optional unique identifier for the error, useful for tracking using Sentry and
   *
   * @remarks
   *       New Relic, only available for 500.
   */
  errorId?: string | undefined;
  /**
   * Type identifier for payload validation errors
   */
  type: string;
  /**
   * Array of detailed validation errors
   */
  errors: Array<components.PayloadValidationErrorDto>;
  /**
   * The JSON schema that was used for validation
   */
  schema?: Schema | undefined;
};

export class PayloadValidationExceptionDto extends NovuError {
  /**
   * Timestamp of when the error occurred.
   */
  timestamp: string;
  /**
   * The path where the error occurred.
   */
  path: string;
  /**
   * Optional context object for additional error details.
   */
  ctx?: { [k: string]: any } | undefined;
  /**
   * Optional unique identifier for the error, useful for tracking using Sentry and
   *
   * @remarks
   *       New Relic, only available for 500.
   */
  errorId?: string | undefined;
  /**
   * Type identifier for payload validation errors
   */
  type: string;
  /**
   * Array of detailed validation errors
   */
  errors: Array<components.PayloadValidationErrorDto>;
  /**
   * The JSON schema that was used for validation
   */
  schema?: Schema | undefined;

  /** The original data that was passed to this error instance. */
  data$: PayloadValidationExceptionDtoData;

  constructor(
    err: PayloadValidationExceptionDtoData,
    httpMeta: { response: Response; request: Request; body: string }
  ) {
    const message =
      'message' in err && typeof err.message === 'string' ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.timestamp = err.timestamp;
    this.path = err.path;
    if (err.ctx != null) this.ctx = err.ctx;
    if (err.errorId != null) this.errorId = err.errorId;
    this.type = err.type;
    this.errors = err.errors;
    if (err.schema != null) this.schema = err.schema;

    this.name = 'PayloadValidationExceptionDto';
  }
}

/** @internal */
export const MessagePayloadValidationExceptionDto5$inboundSchema: z.ZodType<
  MessagePayloadValidationExceptionDto5,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]);

/** @internal */
export type MessagePayloadValidationExceptionDto5$Outbound = string | number | boolean | { [k: string]: any };

/** @internal */
export const MessagePayloadValidationExceptionDto5$outboundSchema: z.ZodType<
  MessagePayloadValidationExceptionDto5$Outbound,
  z.ZodTypeDef,
  MessagePayloadValidationExceptionDto5
> = z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagePayloadValidationExceptionDto5$ {
  /** @deprecated use `MessagePayloadValidationExceptionDto5$inboundSchema` instead. */
  export const inboundSchema = MessagePayloadValidationExceptionDto5$inboundSchema;
  /** @deprecated use `MessagePayloadValidationExceptionDto5$outboundSchema` instead. */
  export const outboundSchema = MessagePayloadValidationExceptionDto5$outboundSchema;
  /** @deprecated use `MessagePayloadValidationExceptionDto5$Outbound` instead. */
  export type Outbound = MessagePayloadValidationExceptionDto5$Outbound;
}

export function messagePayloadValidationExceptionDto5ToJSON(
  messagePayloadValidationExceptionDto5: MessagePayloadValidationExceptionDto5
): string {
  return JSON.stringify(
    MessagePayloadValidationExceptionDto5$outboundSchema.parse(messagePayloadValidationExceptionDto5)
  );
}

export function messagePayloadValidationExceptionDto5FromJSON(
  jsonString: string
): SafeParseResult<MessagePayloadValidationExceptionDto5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagePayloadValidationExceptionDto5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagePayloadValidationExceptionDto5' from JSON`
  );
}

/** @internal */
export const MessagePayloadValidationExceptionDto4$inboundSchema: z.ZodType<
  MessagePayloadValidationExceptionDto4,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type MessagePayloadValidationExceptionDto4$Outbound = {};

/** @internal */
export const MessagePayloadValidationExceptionDto4$outboundSchema: z.ZodType<
  MessagePayloadValidationExceptionDto4$Outbound,
  z.ZodTypeDef,
  MessagePayloadValidationExceptionDto4
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagePayloadValidationExceptionDto4$ {
  /** @deprecated use `MessagePayloadValidationExceptionDto4$inboundSchema` instead. */
  export const inboundSchema = MessagePayloadValidationExceptionDto4$inboundSchema;
  /** @deprecated use `MessagePayloadValidationExceptionDto4$outboundSchema` instead. */
  export const outboundSchema = MessagePayloadValidationExceptionDto4$outboundSchema;
  /** @deprecated use `MessagePayloadValidationExceptionDto4$Outbound` instead. */
  export type Outbound = MessagePayloadValidationExceptionDto4$Outbound;
}

export function messagePayloadValidationExceptionDto4ToJSON(
  messagePayloadValidationExceptionDto4: MessagePayloadValidationExceptionDto4
): string {
  return JSON.stringify(
    MessagePayloadValidationExceptionDto4$outboundSchema.parse(messagePayloadValidationExceptionDto4)
  );
}

export function messagePayloadValidationExceptionDto4FromJSON(
  jsonString: string
): SafeParseResult<MessagePayloadValidationExceptionDto4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagePayloadValidationExceptionDto4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagePayloadValidationExceptionDto4' from JSON`
  );
}

/** @internal */
export const PayloadValidationExceptionDtoMessage$inboundSchema: z.ZodType<
  PayloadValidationExceptionDtoMessage,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => MessagePayloadValidationExceptionDto4$inboundSchema),
  z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
]);

/** @internal */
export type PayloadValidationExceptionDtoMessage$Outbound =
  | string
  | number
  | boolean
  | MessagePayloadValidationExceptionDto4$Outbound
  | Array<string | number | boolean | { [k: string]: any } | null>;

/** @internal */
export const PayloadValidationExceptionDtoMessage$outboundSchema: z.ZodType<
  PayloadValidationExceptionDtoMessage$Outbound,
  z.ZodTypeDef,
  PayloadValidationExceptionDtoMessage
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => MessagePayloadValidationExceptionDto4$outboundSchema),
  z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PayloadValidationExceptionDtoMessage$ {
  /** @deprecated use `PayloadValidationExceptionDtoMessage$inboundSchema` instead. */
  export const inboundSchema = PayloadValidationExceptionDtoMessage$inboundSchema;
  /** @deprecated use `PayloadValidationExceptionDtoMessage$outboundSchema` instead. */
  export const outboundSchema = PayloadValidationExceptionDtoMessage$outboundSchema;
  /** @deprecated use `PayloadValidationExceptionDtoMessage$Outbound` instead. */
  export type Outbound = PayloadValidationExceptionDtoMessage$Outbound;
}

export function payloadValidationExceptionDtoMessageToJSON(
  payloadValidationExceptionDtoMessage: PayloadValidationExceptionDtoMessage
): string {
  return JSON.stringify(
    PayloadValidationExceptionDtoMessage$outboundSchema.parse(payloadValidationExceptionDtoMessage)
  );
}

export function payloadValidationExceptionDtoMessageFromJSON(
  jsonString: string
): SafeParseResult<PayloadValidationExceptionDtoMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayloadValidationExceptionDtoMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayloadValidationExceptionDtoMessage' from JSON`
  );
}

/** @internal */
export const Schema$inboundSchema: z.ZodType<Schema, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Schema$Outbound = {};

/** @internal */
export const Schema$outboundSchema: z.ZodType<Schema$Outbound, z.ZodTypeDef, Schema> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Schema$ {
  /** @deprecated use `Schema$inboundSchema` instead. */
  export const inboundSchema = Schema$inboundSchema;
  /** @deprecated use `Schema$outboundSchema` instead. */
  export const outboundSchema = Schema$outboundSchema;
  /** @deprecated use `Schema$Outbound` instead. */
  export type Outbound = Schema$Outbound;
}

export function schemaToJSON(schema: Schema): string {
  return JSON.stringify(Schema$outboundSchema.parse(schema));
}

export function schemaFromJSON(jsonString: string): SafeParseResult<Schema, SDKValidationError> {
  return safeParse(jsonString, (x) => Schema$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Schema' from JSON`);
}

/** @internal */
export const PayloadValidationExceptionDto$inboundSchema: z.ZodType<
  PayloadValidationExceptionDto,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    statusCode: z.number(),
    timestamp: z.string(),
    path: z.string(),
    message: z
      .nullable(
        z.union([
          z.string(),
          z.number(),
          z.boolean(),
          z.lazy(() => MessagePayloadValidationExceptionDto4$inboundSchema),
          z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
        ])
      )
      .optional(),
    ctx: z.record(z.any()).optional(),
    errorId: z.string().optional(),
    type: z.string(),
    errors: z.array(components.PayloadValidationErrorDto$inboundSchema),
    schema: z.lazy(() => Schema$inboundSchema).optional(),
    request$: z.instanceof(Request),
    response$: z.instanceof(Response),
    body$: z.string(),
  })
  .transform((v) => {
    return new PayloadValidationExceptionDto(v, {
      request: v.request$,
      response: v.response$,
      body: v.body$,
    });
  });

/** @internal */
export type PayloadValidationExceptionDto$Outbound = {
  statusCode: number;
  timestamp: string;
  path: string;
  message?:
    | string
    | number
    | boolean
    | MessagePayloadValidationExceptionDto4$Outbound
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
  ctx?: { [k: string]: any } | undefined;
  errorId?: string | undefined;
  type: string;
  errors: Array<components.PayloadValidationErrorDto$Outbound>;
  schema?: Schema$Outbound | undefined;
};

/** @internal */
export const PayloadValidationExceptionDto$outboundSchema: z.ZodType<
  PayloadValidationExceptionDto$Outbound,
  z.ZodTypeDef,
  PayloadValidationExceptionDto
> = z
  .instanceof(PayloadValidationExceptionDto)
  .transform((v) => v.data$)
  .pipe(
    z.object({
      statusCode: z.number(),
      timestamp: z.string(),
      path: z.string(),
      message: z
        .nullable(
          z.union([
            z.string(),
            z.number(),
            z.boolean(),
            z.lazy(() => MessagePayloadValidationExceptionDto4$outboundSchema),
            z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
          ])
        )
        .optional(),
      ctx: z.record(z.any()).optional(),
      errorId: z.string().optional(),
      type: z.string(),
      errors: z.array(components.PayloadValidationErrorDto$outboundSchema),
      schema: z.lazy(() => Schema$outboundSchema).optional(),
    })
  );

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PayloadValidationExceptionDto$ {
  /** @deprecated use `PayloadValidationExceptionDto$inboundSchema` instead. */
  export const inboundSchema = PayloadValidationExceptionDto$inboundSchema;
  /** @deprecated use `PayloadValidationExceptionDto$outboundSchema` instead. */
  export const outboundSchema = PayloadValidationExceptionDto$outboundSchema;
  /** @deprecated use `PayloadValidationExceptionDto$Outbound` instead. */
  export type Outbound = PayloadValidationExceptionDto$Outbound;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messagePayloadValidationExceptionDto5ToJSON(messagePayloadValidationExceptionDto5: MessagePayloadValidationExceptionDto5)
 - messagePayloadValidationExceptionDto5FromJSON(jsonString: string)
 - messagePayloadValidationExceptionDto4ToJSON(messagePayloadValidationExceptionDto4: MessagePayloadValidationExceptionDto4)
 - messagePayloadValidationExceptionDto4FromJSON(jsonString: string)
 - payloadValidationExceptionDtoMessageToJSON(payloadValidationExceptionDtoMessage: PayloadValidationExceptionDtoMessage)
 - payloadValidationExceptionDtoMessageFromJSON(jsonString: string)
 - schemaToJSON(schema: Schema)
 - schemaFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessagePayloadValidationExceptionDto5$Outbound;
}

export function messagePayloadValidationException...)
 - Outbound(MessagePayloadValidationExceptionDto4$Outbound;
}

export function messagePayloadValidationException...)
 - Outbound(PayloadValidationExceptionDtoMessage$Outbound;
}

export function payloadValidationExceptionDtoMessa...)
 - Outbound(Schema$Outbound;
}

export function schemaToJSON(schema: Schema): string {
  return JSON.stringify(S...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export class PayloadValidationExceptionDto
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagePayloadValidationExceptionDto5ToJSON
- export function messagePayloadValidationExceptionDto5FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagePayloadValidationExceptionDto4ToJSON
- export function messagePayloadValidationExceptionDto4FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function payloadValidationExceptionDtoMessageToJSON
- export function payloadValidationExceptionDtoMessageFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function schemaToJSON
- export function schemaFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/responsevalidationerror.ts
Tamaño: 1232 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { NovuError } from './novuerror.js';
import { formatZodError } from './sdkvalidationerror.js';

export class ResponseValidationError extends NovuError {
  /**
   * The raw value that failed validation.
   */
  public readonly rawValue: unknown;

  /**
   * The raw message that failed validation.
   */
  public readonly rawMessage: unknown;

  constructor(
    message: string,
    extra: {
      response: Response;
      request: Request;
      body: string;
      cause: unknown;
      rawValue: unknown;
      rawMessage: unknown;
    }
  ) {
    super(message, extra);
    this.name = 'ResponseValidationError';
    this.cause = extra.cause;
    this.rawValue = extra.rawValue;
    this.rawMessage = extra.rawMessage;
  }

  /**
   * Return a pretty-formatted error message if the underlying validation error
   * is a ZodError or some other recognized error type, otherwise return the
   * default error message.
   */
  public pretty(): string {
    if (this.cause instanceof z.ZodError) {
      return `${this.rawMessage}\n${formatZodError(this.cause)}`;
    } else {
      return this.toString();
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ResponseValidationError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/sdkerror.ts
Tamaño: 1167 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuError } from "./novuerror.js";

/** The fallback error class if no more specific error class is matched */
export class SDKError extends NovuError {
  constructor(
    message: string,
    httpMeta: {
      response: Response;
      request: Request;
      body: string;
    },
  ) {
    if (message) {
      message += `: `;
    }
    message += `Status ${httpMeta.response.status}`;
    const contentType = httpMeta.response.headers.get("content-type") || `""`;
    if (contentType !== "application/json") {
      message += ` Content-Type ${
        contentType.includes(" ") ? `"${contentType}"` : contentType
      }`;
    }
    const body = httpMeta.body || `""`;
    message += body.length > 100 ? "\n" : ". ";
    let bodyDisplay = body;
    if (body.length > 10000) {
      const truncated = body.substring(0, 10000);
      const remaining = body.length - 10000;
      bodyDisplay = `${truncated}...and ${remaining} more chars`;
    }
    message += `Body: ${bodyDisplay}`;
    message = message.trim();
    super(message, httpMeta);
    this.name = "SDKError";
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SDKError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/sdkvalidationerror.ts
Tamaño: 3113 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';

export class SDKValidationError extends Error {
  /**
   * The raw value that failed validation.
   */
  public readonly rawValue: unknown;

  /**
   * The raw message that failed validation.
   */
  public readonly rawMessage: unknown;

  // Allows for backwards compatibility for `instanceof` checks of `ResponseValidationError`
  static override [Symbol.hasInstance](instance: unknown): instance is SDKValidationError {
    if (!(instance instanceof Error)) return false;
    if (!('rawValue' in instance)) return false;
    if (!('rawMessage' in instance)) return false;
    if (!('pretty' in instance)) return false;
    if (typeof instance.pretty !== 'function') return false;
    return true;
  }

  constructor(message: string, cause: unknown, rawValue: unknown) {
    super(`${message}: ${cause}`);
    this.name = 'SDKValidationError';
    this.cause = cause;
    this.rawValue = rawValue;
    this.rawMessage = message;
  }

  /**
   * Return a pretty-formatted error message if the underlying validation error
   * is a ZodError or some other recognized error type, otherwise return the
   * default error message.
   */
  public pretty(): string {
    if (this.cause instanceof z.ZodError) {
      return `${this.rawMessage}\n${formatZodError(this.cause)}`;
    } else {
      return this.toString();
    }
  }
}

export function formatZodError(err: z.ZodError, level = 0): string {
  let pre = '  '.repeat(level);
  pre = level > 0 ? `│${pre}` : pre;
  pre += ' '.repeat(level);

  let message = '';
  const append = (str: string) => (message += `\n${pre}${str}`);

  const len = err.issues.length;
  const headline = len === 1 ? `${len} issue found` : `${len} issues found`;

  if (len) {
    append(`┌ ${headline}:`);
  }

  for (const issue of err.issues) {
    let path = issue.path.join('.');
    path = path ? `<root>.${path}` : '<root>';
    append(`│ • [${path}]: ${issue.message} (${issue.code})`);
    switch (issue.code) {
      case 'invalid_literal':
      case 'invalid_type': {
        append(`│     Want: ${issue.expected}`);
        append(`│      Got: ${issue.received}`);
        break;
      }
      case 'unrecognized_keys': {
        append(`│     Keys: ${issue.keys.join(', ')}`);
        break;
      }
      case 'invalid_enum_value': {
        append(`│     Allowed: ${issue.options.join(', ')}`);
        append(`│         Got: ${issue.received}`);
        break;
      }
      case 'invalid_union_discriminator': {
        append(`│     Allowed: ${issue.options.join(', ')}`);
        break;
      }
      case 'invalid_union': {
        const len = issue.unionErrors.length;
        append(`│   ✖︎ Attemped to deserialize into one of ${len} union members:`);
        issue.unionErrors.forEach((err, i) => {
          append(`│   ✖︎ Member ${i + 1} of ${len}`);
          append(`${formatZodError(err, level + 1)}`);
        });
      }
    }
  }

  if (err.issues.length) {
    append(`└─*`);
  }

  return message.slice(1);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - formatZodError(err: z.ZodError, level = 0)
Asignaciones con arrow functions encontradas (posibles funciones):
 - append(str: string))
 - len(issue.unionErrors.length;
        append(`│   ✖︎ Attemped to deserialize into one of ${len} union me...)
Declaraciones 'export' encontradas:
- export class SDKValidationError
- export function formatZodError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/subscriberresponsedto.ts
Tamaño: 10862 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import * as components from '../components/index.js';
import { NovuError } from './novuerror.js';

export type SubscriberResponseDtoData = {
  /**
   * The internal ID generated by Novu for your subscriber. This ID does not match the `subscriberId` used in your queries. Refer to `subscriberId` for that identifier.
   */
  id?: string | undefined;
  /**
   * The first name of the subscriber.
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the subscriber.
   */
  lastName?: string | null | undefined;
  /**
   * The email address of the subscriber.
   */
  email?: string | null | undefined;
  /**
   * The phone number of the subscriber.
   */
  phone?: string | null | undefined;
  /**
   * The URL of the subscriber's avatar image.
   */
  avatar?: string | null | undefined;
  /**
   * The locale setting of the subscriber, indicating their preferred language or region.
   */
  locale?: string | null | undefined;
  /**
   * An array of channel settings associated with the subscriber.
   */
  channels?: Array<components.ChannelSettingsDto> | undefined;
  /**
   * An array of topics that the subscriber is subscribed to.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  topics?: Array<string> | undefined;
  /**
   * Indicates whether the subscriber is currently online.
   */
  isOnline?: boolean | null | undefined;
  /**
   * The timestamp indicating when the subscriber was last online, in ISO 8601 format.
   */
  lastOnlineAt?: string | null | undefined;
  /**
   * The version of the subscriber document.
   */
  v?: number | undefined;
  /**
   * Additional custom data for the subscriber
   */
  data?: { [k: string]: any } | null | undefined;
  /**
   * Timezone of the subscriber
   */
  timezone?: string | null | undefined;
  /**
   * The identifier used to create this subscriber, which typically corresponds to the user ID in your system.
   */
  subscriberId: string;
  /**
   * The unique identifier of the organization to which the subscriber belongs.
   */
  organizationId: string;
  /**
   * The unique identifier of the environment associated with this subscriber.
   */
  environmentId: string;
  /**
   * Indicates whether the subscriber has been deleted.
   */
  deleted: boolean;
  /**
   * The timestamp indicating when the subscriber was created, in ISO 8601 format.
   */
  createdAt: string;
  /**
   * The timestamp indicating when the subscriber was last updated, in ISO 8601 format.
   */
  updatedAt: string;
};

export class SubscriberResponseDto extends NovuError {
  /**
   * The internal ID generated by Novu for your subscriber. This ID does not match the `subscriberId` used in your queries. Refer to `subscriberId` for that identifier.
   */
  id?: string | undefined;
  /**
   * The first name of the subscriber.
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the subscriber.
   */
  lastName?: string | null | undefined;
  /**
   * The email address of the subscriber.
   */
  email?: string | null | undefined;
  /**
   * The phone number of the subscriber.
   */
  phone?: string | null | undefined;
  /**
   * The URL of the subscriber's avatar image.
   */
  avatar?: string | null | undefined;
  /**
   * The locale setting of the subscriber, indicating their preferred language or region.
   */
  locale?: string | null | undefined;
  /**
   * An array of channel settings associated with the subscriber.
   */
  channels?: Array<components.ChannelSettingsDto> | undefined;
  /**
   * An array of topics that the subscriber is subscribed to.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  topics?: Array<string> | undefined;
  /**
   * Indicates whether the subscriber is currently online.
   */
  isOnline?: boolean | null | undefined;
  /**
   * The timestamp indicating when the subscriber was last online, in ISO 8601 format.
   */
  lastOnlineAt?: string | null | undefined;
  /**
   * The version of the subscriber document.
   */
  v?: number | undefined;
  /**
   * Additional custom data for the subscriber
   */
  data?: { [k: string]: any } | null | undefined;
  /**
   * Timezone of the subscriber
   */
  timezone?: string | null | undefined;
  /**
   * The identifier used to create this subscriber, which typically corresponds to the user ID in your system.
   */
  subscriberId: string;
  /**
   * The unique identifier of the organization to which the subscriber belongs.
   */
  organizationId: string;
  /**
   * The unique identifier of the environment associated with this subscriber.
   */
  environmentId: string;
  /**
   * Indicates whether the subscriber has been deleted.
   */
  deleted: boolean;
  /**
   * The timestamp indicating when the subscriber was created, in ISO 8601 format.
   */
  createdAt: string;
  /**
   * The timestamp indicating when the subscriber was last updated, in ISO 8601 format.
   */
  updatedAt: string;

  /** The original data that was passed to this error instance. */
  data$: SubscriberResponseDtoData;

  constructor(err: SubscriberResponseDtoData, httpMeta: { response: Response; request: Request; body: string }) {
    const message =
      'message' in err && typeof err.message === 'string' ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    if (err.id != null) this.id = err.id;
    if (err.firstName != null) this.firstName = err.firstName;
    if (err.lastName != null) this.lastName = err.lastName;
    if (err.email != null) this.email = err.email;
    if (err.phone != null) this.phone = err.phone;
    if (err.avatar != null) this.avatar = err.avatar;
    if (err.locale != null) this.locale = err.locale;
    if (err.channels != null) this.channels = err.channels;
    if (err.topics != null) this.topics = err.topics;
    if (err.isOnline != null) this.isOnline = err.isOnline;
    if (err.lastOnlineAt != null) this.lastOnlineAt = err.lastOnlineAt;
    if (err.v != null) this.v = err.v;
    if (err.data != null) this.data = err.data;
    if (err.timezone != null) this.timezone = err.timezone;
    this.subscriberId = err.subscriberId;
    this.organizationId = err.organizationId;
    this.environmentId = err.environmentId;
    this.deleted = err.deleted;
    this.createdAt = err.createdAt;
    this.updatedAt = err.updatedAt;

    this.name = 'SubscriberResponseDto';
  }
}

/** @internal */
export const SubscriberResponseDto$inboundSchema: z.ZodType<SubscriberResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
    phone: z.nullable(z.string()).optional(),
    avatar: z.nullable(z.string()).optional(),
    locale: z.nullable(z.string()).optional(),
    channels: z.array(components.ChannelSettingsDto$inboundSchema).optional(),
    topics: z.array(z.string()).optional(),
    isOnline: z.nullable(z.boolean()).optional(),
    lastOnlineAt: z.nullable(z.string()).optional(),
    __v: z.number().optional(),
    data: z.nullable(z.record(z.any())).optional(),
    timezone: z.nullable(z.string()).optional(),
    subscriberId: z.string(),
    _organizationId: z.string(),
    _environmentId: z.string(),
    deleted: z.boolean(),
    createdAt: z.string(),
    updatedAt: z.string(),
    request$: z.instanceof(Request),
    response$: z.instanceof(Response),
    body$: z.string(),
  })
  .transform((v) => {
    const remapped = remap$(v, {
      _id: 'id',
      __v: 'v',
      _organizationId: 'organizationId',
      _environmentId: 'environmentId',
    });

    return new SubscriberResponseDto(remapped, {
      request: v.request$,
      response: v.response$,
      body: v.body$,
    });
  });

/** @internal */
export type SubscriberResponseDto$Outbound = {
  _id?: string | undefined;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  email?: string | null | undefined;
  phone?: string | null | undefined;
  avatar?: string | null | undefined;
  locale?: string | null | undefined;
  channels?: Array<components.ChannelSettingsDto$Outbound> | undefined;
  topics?: Array<string> | undefined;
  isOnline?: boolean | null | undefined;
  lastOnlineAt?: string | null | undefined;
  __v?: number | undefined;
  data?: { [k: string]: any } | null | undefined;
  timezone?: string | null | undefined;
  subscriberId: string;
  _organizationId: string;
  _environmentId: string;
  deleted: boolean;
  createdAt: string;
  updatedAt: string;
};

/** @internal */
export const SubscriberResponseDto$outboundSchema: z.ZodType<
  SubscriberResponseDto$Outbound,
  z.ZodTypeDef,
  SubscriberResponseDto
> = z
  .instanceof(SubscriberResponseDto)
  .transform((v) => v.data$)
  .pipe(
    z
      .object({
        id: z.string().optional(),
        firstName: z.nullable(z.string()).optional(),
        lastName: z.nullable(z.string()).optional(),
        email: z.nullable(z.string()).optional(),
        phone: z.nullable(z.string()).optional(),
        avatar: z.nullable(z.string()).optional(),
        locale: z.nullable(z.string()).optional(),
        channels: z.array(components.ChannelSettingsDto$outboundSchema).optional(),
        topics: z.array(z.string()).optional(),
        isOnline: z.nullable(z.boolean()).optional(),
        lastOnlineAt: z.nullable(z.string()).optional(),
        v: z.number().optional(),
        data: z.nullable(z.record(z.any())).optional(),
        timezone: z.nullable(z.string()).optional(),
        subscriberId: z.string(),
        organizationId: z.string(),
        environmentId: z.string(),
        deleted: z.boolean(),
        createdAt: z.string(),
        updatedAt: z.string(),
      })
      .transform((v) => {
        return remap$(v, {
          id: '_id',
          v: '__v',
          organizationId: '_organizationId',
          environmentId: '_environmentId',
        });
      })
  );

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberResponseDto$ {
  /** @deprecated use `SubscriberResponseDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberResponseDto$inboundSchema;
  /** @deprecated use `SubscriberResponseDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberResponseDto$outboundSchema;
  /** @deprecated use `SubscriberResponseDto$Outbound` instead. */
  export type Outbound = SubscriberResponseDto$Outbound;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export class SubscriberResponseDto
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/topicresponsedto.ts
Tamaño: 3431 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { NovuError } from './novuerror.js';

export type TopicResponseDtoData = {
  /**
   * The identifier of the topic
   */
  id: string;
  /**
   * The unique key of the topic
   */
  key: string;
  /**
   * The name of the topic
   */
  name?: string | undefined;
  /**
   * The date the topic was created
   */
  createdAt?: string | undefined;
  /**
   * The date the topic was last updated
   */
  updatedAt?: string | undefined;
};

export class TopicResponseDto extends NovuError {
  /**
   * The identifier of the topic
   */
  id: string;
  /**
   * The unique key of the topic
   */
  key: string;
  /**
   * The date the topic was created
   */
  createdAt?: string | undefined;
  /**
   * The date the topic was last updated
   */
  updatedAt?: string | undefined;

  /** The original data that was passed to this error instance. */
  data$: TopicResponseDtoData;

  constructor(err: TopicResponseDtoData, httpMeta: { response: Response; request: Request; body: string }) {
    const message =
      'message' in err && typeof err.message === 'string' ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.id = err.id;
    this.key = err.key;
    if (err.createdAt != null) this.createdAt = err.createdAt;
    if (err.updatedAt != null) this.updatedAt = err.updatedAt;

    this.name = 'TopicResponseDto';
  }
}

/** @internal */
export const TopicResponseDto$inboundSchema: z.ZodType<TopicResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    key: z.string(),
    name: z.string().optional(),
    createdAt: z.string().optional(),
    updatedAt: z.string().optional(),
    request$: z.instanceof(Request),
    response$: z.instanceof(Response),
    body$: z.string(),
  })
  .transform((v) => {
    const remapped = remap$(v, {
      _id: 'id',
    });

    return new TopicResponseDto(remapped, {
      request: v.request$,
      response: v.response$,
      body: v.body$,
    });
  });

/** @internal */
export type TopicResponseDto$Outbound = {
  _id: string;
  key: string;
  name?: string | undefined;
  createdAt?: string | undefined;
  updatedAt?: string | undefined;
};

/** @internal */
export const TopicResponseDto$outboundSchema: z.ZodType<TopicResponseDto$Outbound, z.ZodTypeDef, TopicResponseDto> = z
  .instanceof(TopicResponseDto)
  .transform((v) => v.data$)
  .pipe(
    z
      .object({
        id: z.string(),
        key: z.string(),
        name: z.string().optional(),
        createdAt: z.string().optional(),
        updatedAt: z.string().optional(),
      })
      .transform((v) => {
        return remap$(v, {
          id: '_id',
        });
      })
  );

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicResponseDto$ {
  /** @deprecated use `TopicResponseDto$inboundSchema` instead. */
  export const inboundSchema = TopicResponseDto$inboundSchema;
  /** @deprecated use `TopicResponseDto$outboundSchema` instead. */
  export const outboundSchema = TopicResponseDto$outboundSchema;
  /** @deprecated use `TopicResponseDto$Outbound` instead. */
  export type Outbound = TopicResponseDto$Outbound;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export class TopicResponseDto
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/validationerrordto.ts
Tamaño: 10216 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { NovuError } from './novuerror.js';
import { SDKValidationError } from './sdkvalidationerror.js';

export type Message5 = string | number | boolean | { [k: string]: any };

export type Message4 = {};

/**
 * Value that failed validation
 */
export type ValidationErrorDtoMessage =
  | string
  | number
  | boolean
  | Message4
  | Array<string | number | boolean | { [k: string]: any } | null>;

export type ValidationErrorDtoData = {
  /**
   * HTTP status code of the error response.
   */
  statusCode: number;
  /**
   * Timestamp of when the error occurred.
   */
  timestamp: string;
  /**
   * The path where the error occurred.
   */
  path: string;
  /**
   * Value that failed validation
   */
  message?:
    | string
    | number
    | boolean
    | Message4
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
  /**
   * Optional context object for additional error details.
   */
  ctx?: { [k: string]: any } | undefined;
  /**
   * Optional unique identifier for the error, useful for tracking using Sentry and
   *
   * @remarks
   *       New Relic, only available for 500.
   */
  errorId?: string | undefined;
  /**
   * A record of validation errors keyed by field name
   */
  errors: { [k: string]: components.ConstraintValidation };
};

export class ValidationErrorDto extends NovuError {
  /**
   * Timestamp of when the error occurred.
   */
  timestamp: string;
  /**
   * The path where the error occurred.
   */
  path: string;
  /**
   * Optional context object for additional error details.
   */
  ctx?: { [k: string]: any } | undefined;
  /**
   * Optional unique identifier for the error, useful for tracking using Sentry and
   *
   * @remarks
   *       New Relic, only available for 500.
   */
  errorId?: string | undefined;
  /**
   * A record of validation errors keyed by field name
   */
  errors: { [k: string]: components.ConstraintValidation };

  /** The original data that was passed to this error instance. */
  data$: ValidationErrorDtoData;

  constructor(err: ValidationErrorDtoData, httpMeta: { response: Response; request: Request; body: string }) {
    const message =
      'message' in err && typeof err.message === 'string' ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.timestamp = err.timestamp;
    this.path = err.path;
    if (err.ctx != null) this.ctx = err.ctx;
    if (err.errorId != null) this.errorId = err.errorId;
    this.errors = err.errors;

    this.name = 'ValidationErrorDto';
  }
}

/** @internal */
export const Message5$inboundSchema: z.ZodType<Message5, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/** @internal */
export type Message5$Outbound =
  | string
  | number
  | boolean
  | {
      [k: string]: any;
    };

/** @internal */
export const Message5$outboundSchema: z.ZodType<Message5$Outbound, z.ZodTypeDef, Message5> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Message5$ {
  /** @deprecated use `Message5$inboundSchema` instead. */
  export const inboundSchema = Message5$inboundSchema;
  /** @deprecated use `Message5$outboundSchema` instead. */
  export const outboundSchema = Message5$outboundSchema;
  /** @deprecated use `Message5$Outbound` instead. */
  export type Outbound = Message5$Outbound;
}

export function message5ToJSON(message5: Message5): string {
  return JSON.stringify(Message5$outboundSchema.parse(message5));
}

export function message5FromJSON(jsonString: string): SafeParseResult<Message5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message5' from JSON`
  );
}

/** @internal */
export const Message4$inboundSchema: z.ZodType<Message4, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Message4$Outbound = {};

/** @internal */
export const Message4$outboundSchema: z.ZodType<Message4$Outbound, z.ZodTypeDef, Message4> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Message4$ {
  /** @deprecated use `Message4$inboundSchema` instead. */
  export const inboundSchema = Message4$inboundSchema;
  /** @deprecated use `Message4$outboundSchema` instead. */
  export const outboundSchema = Message4$outboundSchema;
  /** @deprecated use `Message4$Outbound` instead. */
  export type Outbound = Message4$Outbound;
}

export function message4ToJSON(message4: Message4): string {
  return JSON.stringify(Message4$outboundSchema.parse(message4));
}

export function message4FromJSON(jsonString: string): SafeParseResult<Message4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message4' from JSON`
  );
}

/** @internal */
export const ValidationErrorDtoMessage$inboundSchema: z.ZodType<ValidationErrorDtoMessage, z.ZodTypeDef, unknown> =
  z.union([
    z.string(),
    z.number(),
    z.boolean(),
    z.lazy(() => Message4$inboundSchema),
    z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
  ]);

/** @internal */
export type ValidationErrorDtoMessage$Outbound =
  | string
  | number
  | boolean
  | Message4$Outbound
  | Array<string | number | boolean | { [k: string]: any } | null>;

/** @internal */
export const ValidationErrorDtoMessage$outboundSchema: z.ZodType<
  ValidationErrorDtoMessage$Outbound,
  z.ZodTypeDef,
  ValidationErrorDtoMessage
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => Message4$outboundSchema),
  z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ValidationErrorDtoMessage$ {
  /** @deprecated use `ValidationErrorDtoMessage$inboundSchema` instead. */
  export const inboundSchema = ValidationErrorDtoMessage$inboundSchema;
  /** @deprecated use `ValidationErrorDtoMessage$outboundSchema` instead. */
  export const outboundSchema = ValidationErrorDtoMessage$outboundSchema;
  /** @deprecated use `ValidationErrorDtoMessage$Outbound` instead. */
  export type Outbound = ValidationErrorDtoMessage$Outbound;
}

export function validationErrorDtoMessageToJSON(validationErrorDtoMessage: ValidationErrorDtoMessage): string {
  return JSON.stringify(ValidationErrorDtoMessage$outboundSchema.parse(validationErrorDtoMessage));
}

export function validationErrorDtoMessageFromJSON(
  jsonString: string
): SafeParseResult<ValidationErrorDtoMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ValidationErrorDtoMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ValidationErrorDtoMessage' from JSON`
  );
}

/** @internal */
export const ValidationErrorDto$inboundSchema: z.ZodType<ValidationErrorDto, z.ZodTypeDef, unknown> = z
  .object({
    statusCode: z.number(),
    timestamp: z.string(),
    path: z.string(),
    message: z
      .nullable(
        z.union([
          z.string(),
          z.number(),
          z.boolean(),
          z.lazy(() => Message4$inboundSchema),
          z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
        ])
      )
      .optional(),
    ctx: z.record(z.any()).optional(),
    errorId: z.string().optional(),
    errors: z.record(components.ConstraintValidation$inboundSchema),
    request$: z.instanceof(Request),
    response$: z.instanceof(Response),
    body$: z.string(),
  })
  .transform((v) => {
    return new ValidationErrorDto(v, {
      request: v.request$,
      response: v.response$,
      body: v.body$,
    });
  });

/** @internal */
export type ValidationErrorDto$Outbound = {
  statusCode: number;
  timestamp: string;
  path: string;
  message?:
    | string
    | number
    | boolean
    | Message4$Outbound
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
  ctx?: { [k: string]: any } | undefined;
  errorId?: string | undefined;
  errors: { [k: string]: components.ConstraintValidation$Outbound };
};

/** @internal */
export const ValidationErrorDto$outboundSchema: z.ZodType<
  ValidationErrorDto$Outbound,
  z.ZodTypeDef,
  ValidationErrorDto
> = z
  .instanceof(ValidationErrorDto)
  .transform((v) => v.data$)
  .pipe(
    z.object({
      statusCode: z.number(),
      timestamp: z.string(),
      path: z.string(),
      message: z
        .nullable(
          z.union([
            z.string(),
            z.number(),
            z.boolean(),
            z.lazy(() => Message4$outboundSchema),
            z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
          ])
        )
        .optional(),
      ctx: z.record(z.any()).optional(),
      errorId: z.string().optional(),
      errors: z.record(components.ConstraintValidation$outboundSchema),
    })
  );

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ValidationErrorDto$ {
  /** @deprecated use `ValidationErrorDto$inboundSchema` instead. */
  export const inboundSchema = ValidationErrorDto$inboundSchema;
  /** @deprecated use `ValidationErrorDto$outboundSchema` instead. */
  export const outboundSchema = ValidationErrorDto$outboundSchema;
  /** @deprecated use `ValidationErrorDto$Outbound` instead. */
  export type Outbound = ValidationErrorDto$Outbound;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - message5ToJSON(message5: Message5)
 - message5FromJSON(jsonString: string)
 - message4ToJSON(message4: Message4)
 - message4FromJSON(jsonString: string)
 - validationErrorDtoMessageToJSON(validationErrorDtoMessage: ValidationErrorDtoMessage)
 - validationErrorDtoMessageFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Message5$Outbound;
}

export function message5ToJSON(message5: Message5): string {
  return JSON.str...)
 - Outbound(Message4$Outbound;
}

export function message4ToJSON(message4: Message4): string {
  return JSON.str...)
 - Outbound(ValidationErrorDtoMessage$Outbound;
}

export function validationErrorDtoMessageToJSON(validationErr...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export class ValidationErrorDto
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function message5ToJSON
- export function message5FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function message4ToJSON
- export function message4FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function validationErrorDtoMessageToJSON
- export function validationErrorDtoMessageFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/activitycontrollergetcharts.ts
Tamaño: 6337 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export const ReportType = {
  DeliveryTrend: 'delivery-trend',
  InteractionTrend: 'interaction-trend',
  WorkflowByVolume: 'workflow-by-volume',
  ProviderByVolume: 'provider-by-volume',
  MessagesDelivered: 'messages-delivered',
  ActiveSubscribers: 'active-subscribers',
  AvgMessagesPerSubscriber: 'avg-messages-per-subscriber',
  WorkflowRunsMetric: 'workflow-runs-metric',
  TotalInteractions: 'total-interactions',
  WorkflowRunsTrend: 'workflow-runs-trend',
  ActiveSubscribersTrend: 'active-subscribers-trend',
  WorkflowRunsCount: 'workflow-runs-count',
} as const;
export type ReportType = ClosedEnum<typeof ReportType>;

export const Statuses = {
  Processing: 'processing',
  Completed: 'completed',
  Error: 'error',
} as const;
export type Statuses = ClosedEnum<typeof Statuses>;

export type ActivityControllerGetChartsRequest = {
  createdAtGte?: string | undefined;
  createdAtLte?: string | undefined;
  reportType: Array<ReportType>;
  workflowIds?: Array<string> | undefined;
  subscriberIds?: Array<string> | undefined;
  transactionIds?: Array<string> | undefined;
  statuses?: Array<Statuses> | undefined;
  channels?: Array<string> | undefined;
  topicKey?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const ReportType$inboundSchema: z.ZodNativeEnum<typeof ReportType> = z.nativeEnum(ReportType);

/** @internal */
export const ReportType$outboundSchema: z.ZodNativeEnum<typeof ReportType> = ReportType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReportType$ {
  /** @deprecated use `ReportType$inboundSchema` instead. */
  export const inboundSchema = ReportType$inboundSchema;
  /** @deprecated use `ReportType$outboundSchema` instead. */
  export const outboundSchema = ReportType$outboundSchema;
}

/** @internal */
export const Statuses$inboundSchema: z.ZodNativeEnum<typeof Statuses> = z.nativeEnum(Statuses);

/** @internal */
export const Statuses$outboundSchema: z.ZodNativeEnum<typeof Statuses> = Statuses$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Statuses$ {
  /** @deprecated use `Statuses$inboundSchema` instead. */
  export const inboundSchema = Statuses$inboundSchema;
  /** @deprecated use `Statuses$outboundSchema` instead. */
  export const outboundSchema = Statuses$outboundSchema;
}

/** @internal */
export const ActivityControllerGetChartsRequest$inboundSchema: z.ZodType<
  ActivityControllerGetChartsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    createdAtGte: z.string().optional(),
    createdAtLte: z.string().optional(),
    reportType: z.array(ReportType$inboundSchema),
    workflowIds: z.array(z.string()).optional(),
    subscriberIds: z.array(z.string()).optional(),
    transactionIds: z.array(z.string()).optional(),
    statuses: z.array(Statuses$inboundSchema).optional(),
    channels: z.array(z.string()).optional(),
    topicKey: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type ActivityControllerGetChartsRequest$Outbound = {
  createdAtGte?: string | undefined;
  createdAtLte?: string | undefined;
  reportType: Array<string>;
  workflowIds?: Array<string> | undefined;
  subscriberIds?: Array<string> | undefined;
  transactionIds?: Array<string> | undefined;
  statuses?: Array<string> | undefined;
  channels?: Array<string> | undefined;
  topicKey?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const ActivityControllerGetChartsRequest$outboundSchema: z.ZodType<
  ActivityControllerGetChartsRequest$Outbound,
  z.ZodTypeDef,
  ActivityControllerGetChartsRequest
> = z
  .object({
    createdAtGte: z.string().optional(),
    createdAtLte: z.string().optional(),
    reportType: z.array(ReportType$outboundSchema),
    workflowIds: z.array(z.string()).optional(),
    subscriberIds: z.array(z.string()).optional(),
    transactionIds: z.array(z.string()).optional(),
    statuses: z.array(Statuses$outboundSchema).optional(),
    channels: z.array(z.string()).optional(),
    topicKey: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityControllerGetChartsRequest$ {
  /** @deprecated use `ActivityControllerGetChartsRequest$inboundSchema` instead. */
  export const inboundSchema = ActivityControllerGetChartsRequest$inboundSchema;
  /** @deprecated use `ActivityControllerGetChartsRequest$outboundSchema` instead. */
  export const outboundSchema = ActivityControllerGetChartsRequest$outboundSchema;
  /** @deprecated use `ActivityControllerGetChartsRequest$Outbound` instead. */
  export type Outbound = ActivityControllerGetChartsRequest$Outbound;
}

export function activityControllerGetChartsRequestToJSON(
  activityControllerGetChartsRequest: ActivityControllerGetChartsRequest
): string {
  return JSON.stringify(ActivityControllerGetChartsRequest$outboundSchema.parse(activityControllerGetChartsRequest));
}

export function activityControllerGetChartsRequestFromJSON(
  jsonString: string
): SafeParseResult<ActivityControllerGetChartsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityControllerGetChartsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityControllerGetChartsRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityControllerGetChartsRequestToJSON(activityControllerGetChartsRequest: ActivityControllerGetChartsRequest)
 - activityControllerGetChartsRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityControllerGetChartsRequest$Outbound;
}

export function activityControllerGetChartsRequestTo...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityControllerGetChartsRequestToJSON
- export function activityControllerGetChartsRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/activitycontrollergetlogs.ts
Tamaño: 3761 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ActivityControllerGetLogsRequest = {
  /**
   * Page number for pagination
   */
  page?: number | undefined;
  /**
   * Number of items per page
   */
  limit?: number | undefined;
  /**
   * Filter by HTTP status codes
   */
  statusCodes?: Array<number> | undefined;
  /**
   * Filter by URL pattern
   */
  urlPattern?: string | undefined;
  /**
   * Filter by transaction identifier
   */
  transactionId?: string | undefined;
  /**
   * Filter requests created after this timestamp (Unix timestamp)
   */
  createdGte?: number | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const ActivityControllerGetLogsRequest$inboundSchema: z.ZodType<
  ActivityControllerGetLogsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    page: z.number().optional(),
    limit: z.number().optional(),
    statusCodes: z.array(z.number()).optional(),
    urlPattern: z.string().optional(),
    transactionId: z.string().optional(),
    createdGte: z.number().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type ActivityControllerGetLogsRequest$Outbound = {
  page?: number | undefined;
  limit?: number | undefined;
  statusCodes?: Array<number> | undefined;
  urlPattern?: string | undefined;
  transactionId?: string | undefined;
  createdGte?: number | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const ActivityControllerGetLogsRequest$outboundSchema: z.ZodType<
  ActivityControllerGetLogsRequest$Outbound,
  z.ZodTypeDef,
  ActivityControllerGetLogsRequest
> = z
  .object({
    page: z.number().optional(),
    limit: z.number().optional(),
    statusCodes: z.array(z.number()).optional(),
    urlPattern: z.string().optional(),
    transactionId: z.string().optional(),
    createdGte: z.number().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityControllerGetLogsRequest$ {
  /** @deprecated use `ActivityControllerGetLogsRequest$inboundSchema` instead. */
  export const inboundSchema = ActivityControllerGetLogsRequest$inboundSchema;
  /** @deprecated use `ActivityControllerGetLogsRequest$outboundSchema` instead. */
  export const outboundSchema = ActivityControllerGetLogsRequest$outboundSchema;
  /** @deprecated use `ActivityControllerGetLogsRequest$Outbound` instead. */
  export type Outbound = ActivityControllerGetLogsRequest$Outbound;
}

export function activityControllerGetLogsRequestToJSON(
  activityControllerGetLogsRequest: ActivityControllerGetLogsRequest
): string {
  return JSON.stringify(ActivityControllerGetLogsRequest$outboundSchema.parse(activityControllerGetLogsRequest));
}

export function activityControllerGetLogsRequestFromJSON(
  jsonString: string
): SafeParseResult<ActivityControllerGetLogsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityControllerGetLogsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityControllerGetLogsRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityControllerGetLogsRequestToJSON(activityControllerGetLogsRequest: ActivityControllerGetLogsRequest)
 - activityControllerGetLogsRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityControllerGetLogsRequest$Outbound;
}

export function activityControllerGetLogsRequestToJSON...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityControllerGetLogsRequestToJSON
- export function activityControllerGetLogsRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/activitycontrollergetrequesttraces.ts
Tamaño: 2881 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ActivityControllerGetRequestTracesRequest = {
  requestId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const ActivityControllerGetRequestTracesRequest$inboundSchema: z.ZodType<
  ActivityControllerGetRequestTracesRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    requestId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type ActivityControllerGetRequestTracesRequest$Outbound = {
  requestId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const ActivityControllerGetRequestTracesRequest$outboundSchema: z.ZodType<
  ActivityControllerGetRequestTracesRequest$Outbound,
  z.ZodTypeDef,
  ActivityControllerGetRequestTracesRequest
> = z
  .object({
    requestId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityControllerGetRequestTracesRequest$ {
  /** @deprecated use `ActivityControllerGetRequestTracesRequest$inboundSchema` instead. */
  export const inboundSchema = ActivityControllerGetRequestTracesRequest$inboundSchema;
  /** @deprecated use `ActivityControllerGetRequestTracesRequest$outboundSchema` instead. */
  export const outboundSchema = ActivityControllerGetRequestTracesRequest$outboundSchema;
  /** @deprecated use `ActivityControllerGetRequestTracesRequest$Outbound` instead. */
  export type Outbound = ActivityControllerGetRequestTracesRequest$Outbound;
}

export function activityControllerGetRequestTracesRequestToJSON(
  activityControllerGetRequestTracesRequest: ActivityControllerGetRequestTracesRequest
): string {
  return JSON.stringify(
    ActivityControllerGetRequestTracesRequest$outboundSchema.parse(activityControllerGetRequestTracesRequest)
  );
}

export function activityControllerGetRequestTracesRequestFromJSON(
  jsonString: string
): SafeParseResult<ActivityControllerGetRequestTracesRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityControllerGetRequestTracesRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityControllerGetRequestTracesRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityControllerGetRequestTracesRequestToJSON(activityControllerGetRequestTracesRequest: ActivityControllerGetRequestTracesRequest)
 - activityControllerGetRequestTracesRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityControllerGetRequestTracesRequest$Outbound;
}

export function activityControllerGetRequestT...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityControllerGetRequestTracesRequestToJSON
- export function activityControllerGetRequestTracesRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/activitycontrollergetworkflowrun.ts
Tamaño: 2851 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ActivityControllerGetWorkflowRunRequest = {
  workflowRunId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const ActivityControllerGetWorkflowRunRequest$inboundSchema: z.ZodType<
  ActivityControllerGetWorkflowRunRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowRunId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type ActivityControllerGetWorkflowRunRequest$Outbound = {
  workflowRunId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const ActivityControllerGetWorkflowRunRequest$outboundSchema: z.ZodType<
  ActivityControllerGetWorkflowRunRequest$Outbound,
  z.ZodTypeDef,
  ActivityControllerGetWorkflowRunRequest
> = z
  .object({
    workflowRunId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityControllerGetWorkflowRunRequest$ {
  /** @deprecated use `ActivityControllerGetWorkflowRunRequest$inboundSchema` instead. */
  export const inboundSchema = ActivityControllerGetWorkflowRunRequest$inboundSchema;
  /** @deprecated use `ActivityControllerGetWorkflowRunRequest$outboundSchema` instead. */
  export const outboundSchema = ActivityControllerGetWorkflowRunRequest$outboundSchema;
  /** @deprecated use `ActivityControllerGetWorkflowRunRequest$Outbound` instead. */
  export type Outbound = ActivityControllerGetWorkflowRunRequest$Outbound;
}

export function activityControllerGetWorkflowRunRequestToJSON(
  activityControllerGetWorkflowRunRequest: ActivityControllerGetWorkflowRunRequest
): string {
  return JSON.stringify(
    ActivityControllerGetWorkflowRunRequest$outboundSchema.parse(activityControllerGetWorkflowRunRequest)
  );
}

export function activityControllerGetWorkflowRunRequestFromJSON(
  jsonString: string
): SafeParseResult<ActivityControllerGetWorkflowRunRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityControllerGetWorkflowRunRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityControllerGetWorkflowRunRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityControllerGetWorkflowRunRequestToJSON(activityControllerGetWorkflowRunRequest: ActivityControllerGetWorkflowRunRequest)
 - activityControllerGetWorkflowRunRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityControllerGetWorkflowRunRequest$Outbound;
}

export function activityControllerGetWorkflowRu...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityControllerGetWorkflowRunRequestToJSON
- export function activityControllerGetWorkflowRunRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/activitycontrollergetworkflowruns.ts
Tamaño: 6610 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export const QueryParamStatuses = {
  Processing: 'processing',
  Completed: 'completed',
  Error: 'error',
} as const;
export type QueryParamStatuses = ClosedEnum<typeof QueryParamStatuses>;

export const Severity = {
  High: 'high',
  Medium: 'medium',
  Low: 'low',
  None: 'none',
} as const;
export type Severity = ClosedEnum<typeof Severity>;

export type ActivityControllerGetWorkflowRunsRequest = {
  limit?: number | undefined;
  cursor?: string | undefined;
  workflowIds?: Array<string> | undefined;
  subscriberIds?: Array<string> | undefined;
  transactionIds?: Array<string> | undefined;
  statuses?: Array<QueryParamStatuses> | undefined;
  channels?: Array<string> | undefined;
  topicKey?: string | undefined;
  createdGte?: string | undefined;
  createdLte?: string | undefined;
  severity?: Array<Severity> | undefined;
  contextKeys?: Array<string> | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const QueryParamStatuses$inboundSchema: z.ZodNativeEnum<typeof QueryParamStatuses> =
  z.nativeEnum(QueryParamStatuses);

/** @internal */
export const QueryParamStatuses$outboundSchema: z.ZodNativeEnum<typeof QueryParamStatuses> =
  QueryParamStatuses$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueryParamStatuses$ {
  /** @deprecated use `QueryParamStatuses$inboundSchema` instead. */
  export const inboundSchema = QueryParamStatuses$inboundSchema;
  /** @deprecated use `QueryParamStatuses$outboundSchema` instead. */
  export const outboundSchema = QueryParamStatuses$outboundSchema;
}

/** @internal */
export const Severity$inboundSchema: z.ZodNativeEnum<typeof Severity> = z.nativeEnum(Severity);

/** @internal */
export const Severity$outboundSchema: z.ZodNativeEnum<typeof Severity> = Severity$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Severity$ {
  /** @deprecated use `Severity$inboundSchema` instead. */
  export const inboundSchema = Severity$inboundSchema;
  /** @deprecated use `Severity$outboundSchema` instead. */
  export const outboundSchema = Severity$outboundSchema;
}

/** @internal */
export const ActivityControllerGetWorkflowRunsRequest$inboundSchema: z.ZodType<
  ActivityControllerGetWorkflowRunsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    limit: z.number().default(10),
    cursor: z.string().optional(),
    workflowIds: z.array(z.string()).optional(),
    subscriberIds: z.array(z.string()).optional(),
    transactionIds: z.array(z.string()).optional(),
    statuses: z.array(QueryParamStatuses$inboundSchema).optional(),
    channels: z.array(z.string()).optional(),
    topicKey: z.string().optional(),
    createdGte: z.string().optional(),
    createdLte: z.string().optional(),
    severity: z.array(Severity$inboundSchema).optional(),
    contextKeys: z.array(z.string()).optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type ActivityControllerGetWorkflowRunsRequest$Outbound = {
  limit: number;
  cursor?: string | undefined;
  workflowIds?: Array<string> | undefined;
  subscriberIds?: Array<string> | undefined;
  transactionIds?: Array<string> | undefined;
  statuses?: Array<string> | undefined;
  channels?: Array<string> | undefined;
  topicKey?: string | undefined;
  createdGte?: string | undefined;
  createdLte?: string | undefined;
  severity?: Array<string> | undefined;
  contextKeys?: Array<string> | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const ActivityControllerGetWorkflowRunsRequest$outboundSchema: z.ZodType<
  ActivityControllerGetWorkflowRunsRequest$Outbound,
  z.ZodTypeDef,
  ActivityControllerGetWorkflowRunsRequest
> = z
  .object({
    limit: z.number().default(10),
    cursor: z.string().optional(),
    workflowIds: z.array(z.string()).optional(),
    subscriberIds: z.array(z.string()).optional(),
    transactionIds: z.array(z.string()).optional(),
    statuses: z.array(QueryParamStatuses$outboundSchema).optional(),
    channels: z.array(z.string()).optional(),
    topicKey: z.string().optional(),
    createdGte: z.string().optional(),
    createdLte: z.string().optional(),
    severity: z.array(Severity$outboundSchema).optional(),
    contextKeys: z.array(z.string()).optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityControllerGetWorkflowRunsRequest$ {
  /** @deprecated use `ActivityControllerGetWorkflowRunsRequest$inboundSchema` instead. */
  export const inboundSchema = ActivityControllerGetWorkflowRunsRequest$inboundSchema;
  /** @deprecated use `ActivityControllerGetWorkflowRunsRequest$outboundSchema` instead. */
  export const outboundSchema = ActivityControllerGetWorkflowRunsRequest$outboundSchema;
  /** @deprecated use `ActivityControllerGetWorkflowRunsRequest$Outbound` instead. */
  export type Outbound = ActivityControllerGetWorkflowRunsRequest$Outbound;
}

export function activityControllerGetWorkflowRunsRequestToJSON(
  activityControllerGetWorkflowRunsRequest: ActivityControllerGetWorkflowRunsRequest
): string {
  return JSON.stringify(
    ActivityControllerGetWorkflowRunsRequest$outboundSchema.parse(activityControllerGetWorkflowRunsRequest)
  );
}

export function activityControllerGetWorkflowRunsRequestFromJSON(
  jsonString: string
): SafeParseResult<ActivityControllerGetWorkflowRunsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityControllerGetWorkflowRunsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityControllerGetWorkflowRunsRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityControllerGetWorkflowRunsRequestToJSON(activityControllerGetWorkflowRunsRequest: ActivityControllerGetWorkflowRunsRequest)
 - activityControllerGetWorkflowRunsRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityControllerGetWorkflowRunsRequest$Outbound;
}

export function activityControllerGetWorkflowR...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityControllerGetWorkflowRunsRequestToJSON
- export function activityControllerGetWorkflowRunsRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/contextscontrollercreatecontext.ts
Tamaño: 5758 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ContextsControllerCreateContextRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  createContextRequestDto: components.CreateContextRequestDto;
};

export type ContextsControllerCreateContextResponse = {
  headers: { [k: string]: Array<string> };
  result: components.GetContextResponseDto;
};

/** @internal */
export const ContextsControllerCreateContextRequest$inboundSchema: z.ZodType<
  ContextsControllerCreateContextRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    CreateContextRequestDto: components.CreateContextRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateContextRequestDto: 'createContextRequestDto',
    });
  });

/** @internal */
export type ContextsControllerCreateContextRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  CreateContextRequestDto: components.CreateContextRequestDto$Outbound;
};

/** @internal */
export const ContextsControllerCreateContextRequest$outboundSchema: z.ZodType<
  ContextsControllerCreateContextRequest$Outbound,
  z.ZodTypeDef,
  ContextsControllerCreateContextRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    createContextRequestDto: components.CreateContextRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createContextRequestDto: 'CreateContextRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerCreateContextRequest$ {
  /** @deprecated use `ContextsControllerCreateContextRequest$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerCreateContextRequest$inboundSchema;
  /** @deprecated use `ContextsControllerCreateContextRequest$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerCreateContextRequest$outboundSchema;
  /** @deprecated use `ContextsControllerCreateContextRequest$Outbound` instead. */
  export type Outbound = ContextsControllerCreateContextRequest$Outbound;
}

export function contextsControllerCreateContextRequestToJSON(
  contextsControllerCreateContextRequest: ContextsControllerCreateContextRequest
): string {
  return JSON.stringify(
    ContextsControllerCreateContextRequest$outboundSchema.parse(contextsControllerCreateContextRequest)
  );
}

export function contextsControllerCreateContextRequestFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerCreateContextRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerCreateContextRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerCreateContextRequest' from JSON`
  );
}

/** @internal */
export const ContextsControllerCreateContextResponse$inboundSchema: z.ZodType<
  ContextsControllerCreateContextResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.GetContextResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type ContextsControllerCreateContextResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.GetContextResponseDto$Outbound;
};

/** @internal */
export const ContextsControllerCreateContextResponse$outboundSchema: z.ZodType<
  ContextsControllerCreateContextResponse$Outbound,
  z.ZodTypeDef,
  ContextsControllerCreateContextResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.GetContextResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerCreateContextResponse$ {
  /** @deprecated use `ContextsControllerCreateContextResponse$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerCreateContextResponse$inboundSchema;
  /** @deprecated use `ContextsControllerCreateContextResponse$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerCreateContextResponse$outboundSchema;
  /** @deprecated use `ContextsControllerCreateContextResponse$Outbound` instead. */
  export type Outbound = ContextsControllerCreateContextResponse$Outbound;
}

export function contextsControllerCreateContextResponseToJSON(
  contextsControllerCreateContextResponse: ContextsControllerCreateContextResponse
): string {
  return JSON.stringify(
    ContextsControllerCreateContextResponse$outboundSchema.parse(contextsControllerCreateContextResponse)
  );
}

export function contextsControllerCreateContextResponseFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerCreateContextResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerCreateContextResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerCreateContextResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - contextsControllerCreateContextRequestToJSON(contextsControllerCreateContextRequest: ContextsControllerCreateContextRequest)
 - contextsControllerCreateContextRequestFromJSON(jsonString: string)
 - contextsControllerCreateContextResponseToJSON(contextsControllerCreateContextResponse: ContextsControllerCreateContextResponse)
 - contextsControllerCreateContextResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ContextsControllerCreateContextRequest$Outbound;
}

export function contextsControllerCreateContextR...)
 - Outbound(ContextsControllerCreateContextResponse$Outbound;
}

export function contextsControllerCreateContext...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerCreateContextRequestToJSON
- export function contextsControllerCreateContextRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerCreateContextResponseToJSON
- export function contextsControllerCreateContextResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/contextscontrollerdeletecontext.ts
Tamaño: 5230 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ContextsControllerDeleteContextRequest = {
  /**
   * Context type
   */
  type: string;
  /**
   * Context ID
   */
  id: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type ContextsControllerDeleteContextResponse = {
  headers: { [k: string]: Array<string> };
};

/** @internal */
export const ContextsControllerDeleteContextRequest$inboundSchema: z.ZodType<
  ContextsControllerDeleteContextRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    type: z.string(),
    id: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type ContextsControllerDeleteContextRequest$Outbound = {
  type: string;
  id: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const ContextsControllerDeleteContextRequest$outboundSchema: z.ZodType<
  ContextsControllerDeleteContextRequest$Outbound,
  z.ZodTypeDef,
  ContextsControllerDeleteContextRequest
> = z
  .object({
    type: z.string(),
    id: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerDeleteContextRequest$ {
  /** @deprecated use `ContextsControllerDeleteContextRequest$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerDeleteContextRequest$inboundSchema;
  /** @deprecated use `ContextsControllerDeleteContextRequest$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerDeleteContextRequest$outboundSchema;
  /** @deprecated use `ContextsControllerDeleteContextRequest$Outbound` instead. */
  export type Outbound = ContextsControllerDeleteContextRequest$Outbound;
}

export function contextsControllerDeleteContextRequestToJSON(
  contextsControllerDeleteContextRequest: ContextsControllerDeleteContextRequest
): string {
  return JSON.stringify(
    ContextsControllerDeleteContextRequest$outboundSchema.parse(contextsControllerDeleteContextRequest)
  );
}

export function contextsControllerDeleteContextRequestFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerDeleteContextRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerDeleteContextRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerDeleteContextRequest' from JSON`
  );
}

/** @internal */
export const ContextsControllerDeleteContextResponse$inboundSchema: z.ZodType<
  ContextsControllerDeleteContextResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
    });
  });

/** @internal */
export type ContextsControllerDeleteContextResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
};

/** @internal */
export const ContextsControllerDeleteContextResponse$outboundSchema: z.ZodType<
  ContextsControllerDeleteContextResponse$Outbound,
  z.ZodTypeDef,
  ContextsControllerDeleteContextResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerDeleteContextResponse$ {
  /** @deprecated use `ContextsControllerDeleteContextResponse$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerDeleteContextResponse$inboundSchema;
  /** @deprecated use `ContextsControllerDeleteContextResponse$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerDeleteContextResponse$outboundSchema;
  /** @deprecated use `ContextsControllerDeleteContextResponse$Outbound` instead. */
  export type Outbound = ContextsControllerDeleteContextResponse$Outbound;
}

export function contextsControllerDeleteContextResponseToJSON(
  contextsControllerDeleteContextResponse: ContextsControllerDeleteContextResponse
): string {
  return JSON.stringify(
    ContextsControllerDeleteContextResponse$outboundSchema.parse(contextsControllerDeleteContextResponse)
  );
}

export function contextsControllerDeleteContextResponseFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerDeleteContextResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerDeleteContextResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerDeleteContextResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - contextsControllerDeleteContextRequestToJSON(contextsControllerDeleteContextRequest: ContextsControllerDeleteContextRequest)
 - contextsControllerDeleteContextRequestFromJSON(jsonString: string)
 - contextsControllerDeleteContextResponseToJSON(contextsControllerDeleteContextResponse: ContextsControllerDeleteContextResponse)
 - contextsControllerDeleteContextResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ContextsControllerDeleteContextRequest$Outbound;
}

export function contextsControllerDeleteContextR...)
 - Outbound(ContextsControllerDeleteContextResponse$Outbound;
}

export function contextsControllerDeleteContext...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerDeleteContextRequestToJSON
- export function contextsControllerDeleteContextRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerDeleteContextResponseToJSON
- export function contextsControllerDeleteContextResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/contextscontrollergetcontext.ts
Tamaño: 5404 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ContextsControllerGetContextRequest = {
  /**
   * Context type
   */
  type: string;
  /**
   * Context ID
   */
  id: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type ContextsControllerGetContextResponse = {
  headers: { [k: string]: Array<string> };
  result: components.GetContextResponseDto;
};

/** @internal */
export const ContextsControllerGetContextRequest$inboundSchema: z.ZodType<
  ContextsControllerGetContextRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    type: z.string(),
    id: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type ContextsControllerGetContextRequest$Outbound = {
  type: string;
  id: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const ContextsControllerGetContextRequest$outboundSchema: z.ZodType<
  ContextsControllerGetContextRequest$Outbound,
  z.ZodTypeDef,
  ContextsControllerGetContextRequest
> = z
  .object({
    type: z.string(),
    id: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerGetContextRequest$ {
  /** @deprecated use `ContextsControllerGetContextRequest$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerGetContextRequest$inboundSchema;
  /** @deprecated use `ContextsControllerGetContextRequest$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerGetContextRequest$outboundSchema;
  /** @deprecated use `ContextsControllerGetContextRequest$Outbound` instead. */
  export type Outbound = ContextsControllerGetContextRequest$Outbound;
}

export function contextsControllerGetContextRequestToJSON(
  contextsControllerGetContextRequest: ContextsControllerGetContextRequest
): string {
  return JSON.stringify(ContextsControllerGetContextRequest$outboundSchema.parse(contextsControllerGetContextRequest));
}

export function contextsControllerGetContextRequestFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerGetContextRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerGetContextRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerGetContextRequest' from JSON`
  );
}

/** @internal */
export const ContextsControllerGetContextResponse$inboundSchema: z.ZodType<
  ContextsControllerGetContextResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.GetContextResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type ContextsControllerGetContextResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.GetContextResponseDto$Outbound;
};

/** @internal */
export const ContextsControllerGetContextResponse$outboundSchema: z.ZodType<
  ContextsControllerGetContextResponse$Outbound,
  z.ZodTypeDef,
  ContextsControllerGetContextResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.GetContextResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerGetContextResponse$ {
  /** @deprecated use `ContextsControllerGetContextResponse$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerGetContextResponse$inboundSchema;
  /** @deprecated use `ContextsControllerGetContextResponse$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerGetContextResponse$outboundSchema;
  /** @deprecated use `ContextsControllerGetContextResponse$Outbound` instead. */
  export type Outbound = ContextsControllerGetContextResponse$Outbound;
}

export function contextsControllerGetContextResponseToJSON(
  contextsControllerGetContextResponse: ContextsControllerGetContextResponse
): string {
  return JSON.stringify(
    ContextsControllerGetContextResponse$outboundSchema.parse(contextsControllerGetContextResponse)
  );
}

export function contextsControllerGetContextResponseFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerGetContextResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerGetContextResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerGetContextResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - contextsControllerGetContextRequestToJSON(contextsControllerGetContextRequest: ContextsControllerGetContextRequest)
 - contextsControllerGetContextRequestFromJSON(jsonString: string)
 - contextsControllerGetContextResponseToJSON(contextsControllerGetContextResponse: ContextsControllerGetContextResponse)
 - contextsControllerGetContextResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ContextsControllerGetContextRequest$Outbound;
}

export function contextsControllerGetContextRequest...)
 - Outbound(ContextsControllerGetContextResponse$Outbound;
}

export function contextsControllerGetContextRespon...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerGetContextRequestToJSON
- export function contextsControllerGetContextRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerGetContextResponseToJSON
- export function contextsControllerGetContextResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/contextscontrollerlistcontexts.ts
Tamaño: 8091 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Direction of sorting
 */
export const OrderDirection = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;
/**
 * Direction of sorting
 */
export type OrderDirection = ClosedEnum<typeof OrderDirection>;

export type ContextsControllerListContextsRequest = {
  /**
   * Cursor for pagination indicating the starting point after which to fetch results.
   */
  after?: string | undefined;
  /**
   * Cursor for pagination indicating the ending point before which to fetch results.
   */
  before?: string | undefined;
  /**
   * Limit the number of items to return
   */
  limit?: number | undefined;
  /**
   * Direction of sorting
   */
  orderDirection?: OrderDirection | undefined;
  /**
   * Field to order by
   */
  orderBy?: string | undefined;
  /**
   * Include cursor item in response
   */
  includeCursor?: boolean | undefined;
  /**
   * Filter contexts by type
   */
  type?: string | undefined;
  /**
   * Filter contexts by id
   */
  id?: string | undefined;
  /**
   * Search contexts by type or id (supports partial matching across both fields)
   */
  search?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type ContextsControllerListContextsResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ListContextsResponseDto;
};

/** @internal */
export const OrderDirection$inboundSchema: z.ZodNativeEnum<typeof OrderDirection> = z.nativeEnum(OrderDirection);

/** @internal */
export const OrderDirection$outboundSchema: z.ZodNativeEnum<typeof OrderDirection> = OrderDirection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderDirection$ {
  /** @deprecated use `OrderDirection$inboundSchema` instead. */
  export const inboundSchema = OrderDirection$inboundSchema;
  /** @deprecated use `OrderDirection$outboundSchema` instead. */
  export const outboundSchema = OrderDirection$outboundSchema;
}

/** @internal */
export const ContextsControllerListContextsRequest$inboundSchema: z.ZodType<
  ContextsControllerListContextsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: OrderDirection$inboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    type: z.string().optional(),
    id: z.string().optional(),
    search: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type ContextsControllerListContextsRequest$Outbound = {
  after?: string | undefined;
  before?: string | undefined;
  limit?: number | undefined;
  orderDirection?: string | undefined;
  orderBy?: string | undefined;
  includeCursor?: boolean | undefined;
  type?: string | undefined;
  id?: string | undefined;
  search?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const ContextsControllerListContextsRequest$outboundSchema: z.ZodType<
  ContextsControllerListContextsRequest$Outbound,
  z.ZodTypeDef,
  ContextsControllerListContextsRequest
> = z
  .object({
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: OrderDirection$outboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    type: z.string().optional(),
    id: z.string().optional(),
    search: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerListContextsRequest$ {
  /** @deprecated use `ContextsControllerListContextsRequest$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerListContextsRequest$inboundSchema;
  /** @deprecated use `ContextsControllerListContextsRequest$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerListContextsRequest$outboundSchema;
  /** @deprecated use `ContextsControllerListContextsRequest$Outbound` instead. */
  export type Outbound = ContextsControllerListContextsRequest$Outbound;
}

export function contextsControllerListContextsRequestToJSON(
  contextsControllerListContextsRequest: ContextsControllerListContextsRequest
): string {
  return JSON.stringify(
    ContextsControllerListContextsRequest$outboundSchema.parse(contextsControllerListContextsRequest)
  );
}

export function contextsControllerListContextsRequestFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerListContextsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerListContextsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerListContextsRequest' from JSON`
  );
}

/** @internal */
export const ContextsControllerListContextsResponse$inboundSchema: z.ZodType<
  ContextsControllerListContextsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ListContextsResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type ContextsControllerListContextsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ListContextsResponseDto$Outbound;
};

/** @internal */
export const ContextsControllerListContextsResponse$outboundSchema: z.ZodType<
  ContextsControllerListContextsResponse$Outbound,
  z.ZodTypeDef,
  ContextsControllerListContextsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ListContextsResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerListContextsResponse$ {
  /** @deprecated use `ContextsControllerListContextsResponse$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerListContextsResponse$inboundSchema;
  /** @deprecated use `ContextsControllerListContextsResponse$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerListContextsResponse$outboundSchema;
  /** @deprecated use `ContextsControllerListContextsResponse$Outbound` instead. */
  export type Outbound = ContextsControllerListContextsResponse$Outbound;
}

export function contextsControllerListContextsResponseToJSON(
  contextsControllerListContextsResponse: ContextsControllerListContextsResponse
): string {
  return JSON.stringify(
    ContextsControllerListContextsResponse$outboundSchema.parse(contextsControllerListContextsResponse)
  );
}

export function contextsControllerListContextsResponseFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerListContextsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerListContextsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerListContextsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - contextsControllerListContextsRequestToJSON(contextsControllerListContextsRequest: ContextsControllerListContextsRequest)
 - contextsControllerListContextsRequestFromJSON(jsonString: string)
 - contextsControllerListContextsResponseToJSON(contextsControllerListContextsResponse: ContextsControllerListContextsResponse)
 - contextsControllerListContextsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ContextsControllerListContextsRequest$Outbound;
}

export function contextsControllerListContextsReq...)
 - Outbound(ContextsControllerListContextsResponse$Outbound;
}

export function contextsControllerListContextsRe...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerListContextsRequestToJSON
- export function contextsControllerListContextsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerListContextsResponseToJSON
- export function contextsControllerListContextsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/contextscontrollerupdatecontext.ts
Tamaño: 5960 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ContextsControllerUpdateContextRequest = {
  /**
   * Context type
   */
  type: string;
  /**
   * Context ID
   */
  id: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  updateContextRequestDto: components.UpdateContextRequestDto;
};

export type ContextsControllerUpdateContextResponse = {
  headers: { [k: string]: Array<string> };
  result: components.GetContextResponseDto;
};

/** @internal */
export const ContextsControllerUpdateContextRequest$inboundSchema: z.ZodType<
  ContextsControllerUpdateContextRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    type: z.string(),
    id: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateContextRequestDto: components.UpdateContextRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateContextRequestDto: 'updateContextRequestDto',
    });
  });

/** @internal */
export type ContextsControllerUpdateContextRequest$Outbound = {
  type: string;
  id: string;
  'idempotency-key'?: string | undefined;
  UpdateContextRequestDto: components.UpdateContextRequestDto$Outbound;
};

/** @internal */
export const ContextsControllerUpdateContextRequest$outboundSchema: z.ZodType<
  ContextsControllerUpdateContextRequest$Outbound,
  z.ZodTypeDef,
  ContextsControllerUpdateContextRequest
> = z
  .object({
    type: z.string(),
    id: z.string(),
    idempotencyKey: z.string().optional(),
    updateContextRequestDto: components.UpdateContextRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateContextRequestDto: 'UpdateContextRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerUpdateContextRequest$ {
  /** @deprecated use `ContextsControllerUpdateContextRequest$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerUpdateContextRequest$inboundSchema;
  /** @deprecated use `ContextsControllerUpdateContextRequest$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerUpdateContextRequest$outboundSchema;
  /** @deprecated use `ContextsControllerUpdateContextRequest$Outbound` instead. */
  export type Outbound = ContextsControllerUpdateContextRequest$Outbound;
}

export function contextsControllerUpdateContextRequestToJSON(
  contextsControllerUpdateContextRequest: ContextsControllerUpdateContextRequest
): string {
  return JSON.stringify(
    ContextsControllerUpdateContextRequest$outboundSchema.parse(contextsControllerUpdateContextRequest)
  );
}

export function contextsControllerUpdateContextRequestFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerUpdateContextRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerUpdateContextRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerUpdateContextRequest' from JSON`
  );
}

/** @internal */
export const ContextsControllerUpdateContextResponse$inboundSchema: z.ZodType<
  ContextsControllerUpdateContextResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.GetContextResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type ContextsControllerUpdateContextResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.GetContextResponseDto$Outbound;
};

/** @internal */
export const ContextsControllerUpdateContextResponse$outboundSchema: z.ZodType<
  ContextsControllerUpdateContextResponse$Outbound,
  z.ZodTypeDef,
  ContextsControllerUpdateContextResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.GetContextResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerUpdateContextResponse$ {
  /** @deprecated use `ContextsControllerUpdateContextResponse$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerUpdateContextResponse$inboundSchema;
  /** @deprecated use `ContextsControllerUpdateContextResponse$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerUpdateContextResponse$outboundSchema;
  /** @deprecated use `ContextsControllerUpdateContextResponse$Outbound` instead. */
  export type Outbound = ContextsControllerUpdateContextResponse$Outbound;
}

export function contextsControllerUpdateContextResponseToJSON(
  contextsControllerUpdateContextResponse: ContextsControllerUpdateContextResponse
): string {
  return JSON.stringify(
    ContextsControllerUpdateContextResponse$outboundSchema.parse(contextsControllerUpdateContextResponse)
  );
}

export function contextsControllerUpdateContextResponseFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerUpdateContextResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerUpdateContextResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerUpdateContextResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - contextsControllerUpdateContextRequestToJSON(contextsControllerUpdateContextRequest: ContextsControllerUpdateContextRequest)
 - contextsControllerUpdateContextRequestFromJSON(jsonString: string)
 - contextsControllerUpdateContextResponseToJSON(contextsControllerUpdateContextResponse: ContextsControllerUpdateContextResponse)
 - contextsControllerUpdateContextResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ContextsControllerUpdateContextRequest$Outbound;
}

export function contextsControllerUpdateContextR...)
 - Outbound(ContextsControllerUpdateContextResponse$Outbound;
}

export function contextsControllerUpdateContext...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerUpdateContextRequestToJSON
- export function contextsControllerUpdateContextRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerUpdateContextResponseToJSON
- export function contextsControllerUpdateContextResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/environmentscontrollergetenvironmenttags.ts
Tamaño: 6004 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EnvironmentsControllerGetEnvironmentTagsRequest = {
  /**
   * Environment internal ID (MongoDB ObjectId) or identifier
   */
  environmentId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type EnvironmentsControllerGetEnvironmentTagsResponse = {
  headers: { [k: string]: Array<string> };
  result: Array<components.GetEnvironmentTagsDto>;
};

/** @internal */
export const EnvironmentsControllerGetEnvironmentTagsRequest$inboundSchema: z.ZodType<
  EnvironmentsControllerGetEnvironmentTagsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    environmentId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type EnvironmentsControllerGetEnvironmentTagsRequest$Outbound = {
  environmentId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const EnvironmentsControllerGetEnvironmentTagsRequest$outboundSchema: z.ZodType<
  EnvironmentsControllerGetEnvironmentTagsRequest$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerGetEnvironmentTagsRequest
> = z
  .object({
    environmentId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerGetEnvironmentTagsRequest$ {
  /** @deprecated use `EnvironmentsControllerGetEnvironmentTagsRequest$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerGetEnvironmentTagsRequest$inboundSchema;
  /** @deprecated use `EnvironmentsControllerGetEnvironmentTagsRequest$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerGetEnvironmentTagsRequest$outboundSchema;
  /** @deprecated use `EnvironmentsControllerGetEnvironmentTagsRequest$Outbound` instead. */
  export type Outbound = EnvironmentsControllerGetEnvironmentTagsRequest$Outbound;
}

export function environmentsControllerGetEnvironmentTagsRequestToJSON(
  environmentsControllerGetEnvironmentTagsRequest: EnvironmentsControllerGetEnvironmentTagsRequest
): string {
  return JSON.stringify(
    EnvironmentsControllerGetEnvironmentTagsRequest$outboundSchema.parse(
      environmentsControllerGetEnvironmentTagsRequest
    )
  );
}

export function environmentsControllerGetEnvironmentTagsRequestFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerGetEnvironmentTagsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerGetEnvironmentTagsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerGetEnvironmentTagsRequest' from JSON`
  );
}

/** @internal */
export const EnvironmentsControllerGetEnvironmentTagsResponse$inboundSchema: z.ZodType<
  EnvironmentsControllerGetEnvironmentTagsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.array(components.GetEnvironmentTagsDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type EnvironmentsControllerGetEnvironmentTagsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: Array<components.GetEnvironmentTagsDto$Outbound>;
};

/** @internal */
export const EnvironmentsControllerGetEnvironmentTagsResponse$outboundSchema: z.ZodType<
  EnvironmentsControllerGetEnvironmentTagsResponse$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerGetEnvironmentTagsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.array(components.GetEnvironmentTagsDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerGetEnvironmentTagsResponse$ {
  /** @deprecated use `EnvironmentsControllerGetEnvironmentTagsResponse$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerGetEnvironmentTagsResponse$inboundSchema;
  /** @deprecated use `EnvironmentsControllerGetEnvironmentTagsResponse$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerGetEnvironmentTagsResponse$outboundSchema;
  /** @deprecated use `EnvironmentsControllerGetEnvironmentTagsResponse$Outbound` instead. */
  export type Outbound = EnvironmentsControllerGetEnvironmentTagsResponse$Outbound;
}

export function environmentsControllerGetEnvironmentTagsResponseToJSON(
  environmentsControllerGetEnvironmentTagsResponse: EnvironmentsControllerGetEnvironmentTagsResponse
): string {
  return JSON.stringify(
    EnvironmentsControllerGetEnvironmentTagsResponse$outboundSchema.parse(
      environmentsControllerGetEnvironmentTagsResponse
    )
  );
}

export function environmentsControllerGetEnvironmentTagsResponseFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerGetEnvironmentTagsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerGetEnvironmentTagsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerGetEnvironmentTagsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - environmentsControllerGetEnvironmentTagsRequestToJSON(environmentsControllerGetEnvironmentTagsRequest: EnvironmentsControllerGetEnvironmentTagsRequest)
 - environmentsControllerGetEnvironmentTagsRequestFromJSON(jsonString: string)
 - environmentsControllerGetEnvironmentTagsResponseToJSON(environmentsControllerGetEnvironmentTagsResponse: EnvironmentsControllerGetEnvironmentTagsResponse)
 - environmentsControllerGetEnvironmentTagsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EnvironmentsControllerGetEnvironmentTagsRequest$Outbound;
}

export function environmentsControllerG...)
 - Outbound(EnvironmentsControllerGetEnvironmentTagsResponse$Outbound;
}

export function environmentsController...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerGetEnvironmentTagsRequestToJSON
- export function environmentsControllerGetEnvironmentTagsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerGetEnvironmentTagsResponseToJSON
- export function environmentsControllerGetEnvironmentTagsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/environmentscontrollerv1createenvironment.ts
Tamaño: 6294 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EnvironmentsControllerV1CreateEnvironmentRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  createEnvironmentRequestDto: components.CreateEnvironmentRequestDto;
};

export type EnvironmentsControllerV1CreateEnvironmentResponse = {
  headers: { [k: string]: Array<string> };
  result: components.EnvironmentResponseDto;
};

/** @internal */
export const EnvironmentsControllerV1CreateEnvironmentRequest$inboundSchema: z.ZodType<
  EnvironmentsControllerV1CreateEnvironmentRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    CreateEnvironmentRequestDto: components.CreateEnvironmentRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateEnvironmentRequestDto: 'createEnvironmentRequestDto',
    });
  });

/** @internal */
export type EnvironmentsControllerV1CreateEnvironmentRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  CreateEnvironmentRequestDto: components.CreateEnvironmentRequestDto$Outbound;
};

/** @internal */
export const EnvironmentsControllerV1CreateEnvironmentRequest$outboundSchema: z.ZodType<
  EnvironmentsControllerV1CreateEnvironmentRequest$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerV1CreateEnvironmentRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    createEnvironmentRequestDto: components.CreateEnvironmentRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createEnvironmentRequestDto: 'CreateEnvironmentRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerV1CreateEnvironmentRequest$ {
  /** @deprecated use `EnvironmentsControllerV1CreateEnvironmentRequest$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerV1CreateEnvironmentRequest$inboundSchema;
  /** @deprecated use `EnvironmentsControllerV1CreateEnvironmentRequest$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerV1CreateEnvironmentRequest$outboundSchema;
  /** @deprecated use `EnvironmentsControllerV1CreateEnvironmentRequest$Outbound` instead. */
  export type Outbound = EnvironmentsControllerV1CreateEnvironmentRequest$Outbound;
}

export function environmentsControllerV1CreateEnvironmentRequestToJSON(
  environmentsControllerV1CreateEnvironmentRequest: EnvironmentsControllerV1CreateEnvironmentRequest
): string {
  return JSON.stringify(
    EnvironmentsControllerV1CreateEnvironmentRequest$outboundSchema.parse(
      environmentsControllerV1CreateEnvironmentRequest
    )
  );
}

export function environmentsControllerV1CreateEnvironmentRequestFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerV1CreateEnvironmentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerV1CreateEnvironmentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerV1CreateEnvironmentRequest' from JSON`
  );
}

/** @internal */
export const EnvironmentsControllerV1CreateEnvironmentResponse$inboundSchema: z.ZodType<
  EnvironmentsControllerV1CreateEnvironmentResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.EnvironmentResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type EnvironmentsControllerV1CreateEnvironmentResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.EnvironmentResponseDto$Outbound;
};

/** @internal */
export const EnvironmentsControllerV1CreateEnvironmentResponse$outboundSchema: z.ZodType<
  EnvironmentsControllerV1CreateEnvironmentResponse$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerV1CreateEnvironmentResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.EnvironmentResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerV1CreateEnvironmentResponse$ {
  /** @deprecated use `EnvironmentsControllerV1CreateEnvironmentResponse$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerV1CreateEnvironmentResponse$inboundSchema;
  /** @deprecated use `EnvironmentsControllerV1CreateEnvironmentResponse$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerV1CreateEnvironmentResponse$outboundSchema;
  /** @deprecated use `EnvironmentsControllerV1CreateEnvironmentResponse$Outbound` instead. */
  export type Outbound = EnvironmentsControllerV1CreateEnvironmentResponse$Outbound;
}

export function environmentsControllerV1CreateEnvironmentResponseToJSON(
  environmentsControllerV1CreateEnvironmentResponse: EnvironmentsControllerV1CreateEnvironmentResponse
): string {
  return JSON.stringify(
    EnvironmentsControllerV1CreateEnvironmentResponse$outboundSchema.parse(
      environmentsControllerV1CreateEnvironmentResponse
    )
  );
}

export function environmentsControllerV1CreateEnvironmentResponseFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerV1CreateEnvironmentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerV1CreateEnvironmentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerV1CreateEnvironmentResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - environmentsControllerV1CreateEnvironmentRequestToJSON(environmentsControllerV1CreateEnvironmentRequest: EnvironmentsControllerV1CreateEnvironmentRequest)
 - environmentsControllerV1CreateEnvironmentRequestFromJSON(jsonString: string)
 - environmentsControllerV1CreateEnvironmentResponseToJSON(environmentsControllerV1CreateEnvironmentResponse: EnvironmentsControllerV1CreateEnvironmentResponse)
 - environmentsControllerV1CreateEnvironmentResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EnvironmentsControllerV1CreateEnvironmentRequest$Outbound;
}

export function environmentsController...)
 - Outbound(EnvironmentsControllerV1CreateEnvironmentResponse$Outbound;
}

export function environmentsControlle...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerV1CreateEnvironmentRequestToJSON
- export function environmentsControllerV1CreateEnvironmentRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerV1CreateEnvironmentResponseToJSON
- export function environmentsControllerV1CreateEnvironmentResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/environmentscontrollerv1deleteenvironment.ts
Tamaño: 5682 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EnvironmentsControllerV1DeleteEnvironmentRequest = {
  /**
   * The unique identifier of the environment
   */
  environmentId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type EnvironmentsControllerV1DeleteEnvironmentResponse = {
  headers: { [k: string]: Array<string> };
};

/** @internal */
export const EnvironmentsControllerV1DeleteEnvironmentRequest$inboundSchema: z.ZodType<
  EnvironmentsControllerV1DeleteEnvironmentRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    environmentId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type EnvironmentsControllerV1DeleteEnvironmentRequest$Outbound = {
  environmentId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const EnvironmentsControllerV1DeleteEnvironmentRequest$outboundSchema: z.ZodType<
  EnvironmentsControllerV1DeleteEnvironmentRequest$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerV1DeleteEnvironmentRequest
> = z
  .object({
    environmentId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerV1DeleteEnvironmentRequest$ {
  /** @deprecated use `EnvironmentsControllerV1DeleteEnvironmentRequest$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerV1DeleteEnvironmentRequest$inboundSchema;
  /** @deprecated use `EnvironmentsControllerV1DeleteEnvironmentRequest$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerV1DeleteEnvironmentRequest$outboundSchema;
  /** @deprecated use `EnvironmentsControllerV1DeleteEnvironmentRequest$Outbound` instead. */
  export type Outbound = EnvironmentsControllerV1DeleteEnvironmentRequest$Outbound;
}

export function environmentsControllerV1DeleteEnvironmentRequestToJSON(
  environmentsControllerV1DeleteEnvironmentRequest: EnvironmentsControllerV1DeleteEnvironmentRequest
): string {
  return JSON.stringify(
    EnvironmentsControllerV1DeleteEnvironmentRequest$outboundSchema.parse(
      environmentsControllerV1DeleteEnvironmentRequest
    )
  );
}

export function environmentsControllerV1DeleteEnvironmentRequestFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerV1DeleteEnvironmentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerV1DeleteEnvironmentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerV1DeleteEnvironmentRequest' from JSON`
  );
}

/** @internal */
export const EnvironmentsControllerV1DeleteEnvironmentResponse$inboundSchema: z.ZodType<
  EnvironmentsControllerV1DeleteEnvironmentResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
    });
  });

/** @internal */
export type EnvironmentsControllerV1DeleteEnvironmentResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
};

/** @internal */
export const EnvironmentsControllerV1DeleteEnvironmentResponse$outboundSchema: z.ZodType<
  EnvironmentsControllerV1DeleteEnvironmentResponse$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerV1DeleteEnvironmentResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerV1DeleteEnvironmentResponse$ {
  /** @deprecated use `EnvironmentsControllerV1DeleteEnvironmentResponse$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerV1DeleteEnvironmentResponse$inboundSchema;
  /** @deprecated use `EnvironmentsControllerV1DeleteEnvironmentResponse$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerV1DeleteEnvironmentResponse$outboundSchema;
  /** @deprecated use `EnvironmentsControllerV1DeleteEnvironmentResponse$Outbound` instead. */
  export type Outbound = EnvironmentsControllerV1DeleteEnvironmentResponse$Outbound;
}

export function environmentsControllerV1DeleteEnvironmentResponseToJSON(
  environmentsControllerV1DeleteEnvironmentResponse: EnvironmentsControllerV1DeleteEnvironmentResponse
): string {
  return JSON.stringify(
    EnvironmentsControllerV1DeleteEnvironmentResponse$outboundSchema.parse(
      environmentsControllerV1DeleteEnvironmentResponse
    )
  );
}

export function environmentsControllerV1DeleteEnvironmentResponseFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerV1DeleteEnvironmentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerV1DeleteEnvironmentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerV1DeleteEnvironmentResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - environmentsControllerV1DeleteEnvironmentRequestToJSON(environmentsControllerV1DeleteEnvironmentRequest: EnvironmentsControllerV1DeleteEnvironmentRequest)
 - environmentsControllerV1DeleteEnvironmentRequestFromJSON(jsonString: string)
 - environmentsControllerV1DeleteEnvironmentResponseToJSON(environmentsControllerV1DeleteEnvironmentResponse: EnvironmentsControllerV1DeleteEnvironmentResponse)
 - environmentsControllerV1DeleteEnvironmentResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EnvironmentsControllerV1DeleteEnvironmentRequest$Outbound;
}

export function environmentsController...)
 - Outbound(EnvironmentsControllerV1DeleteEnvironmentResponse$Outbound;
}

export function environmentsControlle...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerV1DeleteEnvironmentRequestToJSON
- export function environmentsControllerV1DeleteEnvironmentRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerV1DeleteEnvironmentResponseToJSON
- export function environmentsControllerV1DeleteEnvironmentResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/environmentscontrollerv1listmyenvironments.ts
Tamaño: 5914 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EnvironmentsControllerV1ListMyEnvironmentsRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type EnvironmentsControllerV1ListMyEnvironmentsResponse = {
  headers: { [k: string]: Array<string> };
  result: Array<components.EnvironmentResponseDto>;
};

/** @internal */
export const EnvironmentsControllerV1ListMyEnvironmentsRequest$inboundSchema: z.ZodType<
  EnvironmentsControllerV1ListMyEnvironmentsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type EnvironmentsControllerV1ListMyEnvironmentsRequest$Outbound = {
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const EnvironmentsControllerV1ListMyEnvironmentsRequest$outboundSchema: z.ZodType<
  EnvironmentsControllerV1ListMyEnvironmentsRequest$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerV1ListMyEnvironmentsRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerV1ListMyEnvironmentsRequest$ {
  /** @deprecated use `EnvironmentsControllerV1ListMyEnvironmentsRequest$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerV1ListMyEnvironmentsRequest$inboundSchema;
  /** @deprecated use `EnvironmentsControllerV1ListMyEnvironmentsRequest$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerV1ListMyEnvironmentsRequest$outboundSchema;
  /** @deprecated use `EnvironmentsControllerV1ListMyEnvironmentsRequest$Outbound` instead. */
  export type Outbound = EnvironmentsControllerV1ListMyEnvironmentsRequest$Outbound;
}

export function environmentsControllerV1ListMyEnvironmentsRequestToJSON(
  environmentsControllerV1ListMyEnvironmentsRequest: EnvironmentsControllerV1ListMyEnvironmentsRequest
): string {
  return JSON.stringify(
    EnvironmentsControllerV1ListMyEnvironmentsRequest$outboundSchema.parse(
      environmentsControllerV1ListMyEnvironmentsRequest
    )
  );
}

export function environmentsControllerV1ListMyEnvironmentsRequestFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerV1ListMyEnvironmentsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerV1ListMyEnvironmentsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerV1ListMyEnvironmentsRequest' from JSON`
  );
}

/** @internal */
export const EnvironmentsControllerV1ListMyEnvironmentsResponse$inboundSchema: z.ZodType<
  EnvironmentsControllerV1ListMyEnvironmentsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.array(components.EnvironmentResponseDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type EnvironmentsControllerV1ListMyEnvironmentsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: Array<components.EnvironmentResponseDto$Outbound>;
};

/** @internal */
export const EnvironmentsControllerV1ListMyEnvironmentsResponse$outboundSchema: z.ZodType<
  EnvironmentsControllerV1ListMyEnvironmentsResponse$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerV1ListMyEnvironmentsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.array(components.EnvironmentResponseDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerV1ListMyEnvironmentsResponse$ {
  /** @deprecated use `EnvironmentsControllerV1ListMyEnvironmentsResponse$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerV1ListMyEnvironmentsResponse$inboundSchema;
  /** @deprecated use `EnvironmentsControllerV1ListMyEnvironmentsResponse$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerV1ListMyEnvironmentsResponse$outboundSchema;
  /** @deprecated use `EnvironmentsControllerV1ListMyEnvironmentsResponse$Outbound` instead. */
  export type Outbound = EnvironmentsControllerV1ListMyEnvironmentsResponse$Outbound;
}

export function environmentsControllerV1ListMyEnvironmentsResponseToJSON(
  environmentsControllerV1ListMyEnvironmentsResponse: EnvironmentsControllerV1ListMyEnvironmentsResponse
): string {
  return JSON.stringify(
    EnvironmentsControllerV1ListMyEnvironmentsResponse$outboundSchema.parse(
      environmentsControllerV1ListMyEnvironmentsResponse
    )
  );
}

export function environmentsControllerV1ListMyEnvironmentsResponseFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerV1ListMyEnvironmentsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerV1ListMyEnvironmentsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerV1ListMyEnvironmentsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - environmentsControllerV1ListMyEnvironmentsRequestToJSON(environmentsControllerV1ListMyEnvironmentsRequest: EnvironmentsControllerV1ListMyEnvironmentsRequest)
 - environmentsControllerV1ListMyEnvironmentsRequestFromJSON(jsonString: string)
 - environmentsControllerV1ListMyEnvironmentsResponseToJSON(environmentsControllerV1ListMyEnvironmentsResponse: EnvironmentsControllerV1ListMyEnvironmentsResponse)
 - environmentsControllerV1ListMyEnvironmentsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EnvironmentsControllerV1ListMyEnvironmentsRequest$Outbound;
}

export function environmentsControlle...)
 - Outbound(EnvironmentsControllerV1ListMyEnvironmentsResponse$Outbound;
}

export function environmentsControll...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerV1ListMyEnvironmentsRequestToJSON
- export function environmentsControllerV1ListMyEnvironmentsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerV1ListMyEnvironmentsResponseToJSON
- export function environmentsControllerV1ListMyEnvironmentsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/environmentscontrollerv1updatemyenvironment.ts
Tamaño: 6556 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EnvironmentsControllerV1UpdateMyEnvironmentRequest = {
  /**
   * The unique identifier of the environment
   */
  environmentId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  updateEnvironmentRequestDto: components.UpdateEnvironmentRequestDto;
};

export type EnvironmentsControllerV1UpdateMyEnvironmentResponse = {
  headers: { [k: string]: Array<string> };
  result: components.EnvironmentResponseDto;
};

/** @internal */
export const EnvironmentsControllerV1UpdateMyEnvironmentRequest$inboundSchema: z.ZodType<
  EnvironmentsControllerV1UpdateMyEnvironmentRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    environmentId: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateEnvironmentRequestDto: components.UpdateEnvironmentRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateEnvironmentRequestDto: 'updateEnvironmentRequestDto',
    });
  });

/** @internal */
export type EnvironmentsControllerV1UpdateMyEnvironmentRequest$Outbound = {
  environmentId: string;
  'idempotency-key'?: string | undefined;
  UpdateEnvironmentRequestDto: components.UpdateEnvironmentRequestDto$Outbound;
};

/** @internal */
export const EnvironmentsControllerV1UpdateMyEnvironmentRequest$outboundSchema: z.ZodType<
  EnvironmentsControllerV1UpdateMyEnvironmentRequest$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerV1UpdateMyEnvironmentRequest
> = z
  .object({
    environmentId: z.string(),
    idempotencyKey: z.string().optional(),
    updateEnvironmentRequestDto: components.UpdateEnvironmentRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateEnvironmentRequestDto: 'UpdateEnvironmentRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerV1UpdateMyEnvironmentRequest$ {
  /** @deprecated use `EnvironmentsControllerV1UpdateMyEnvironmentRequest$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerV1UpdateMyEnvironmentRequest$inboundSchema;
  /** @deprecated use `EnvironmentsControllerV1UpdateMyEnvironmentRequest$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerV1UpdateMyEnvironmentRequest$outboundSchema;
  /** @deprecated use `EnvironmentsControllerV1UpdateMyEnvironmentRequest$Outbound` instead. */
  export type Outbound = EnvironmentsControllerV1UpdateMyEnvironmentRequest$Outbound;
}

export function environmentsControllerV1UpdateMyEnvironmentRequestToJSON(
  environmentsControllerV1UpdateMyEnvironmentRequest: EnvironmentsControllerV1UpdateMyEnvironmentRequest
): string {
  return JSON.stringify(
    EnvironmentsControllerV1UpdateMyEnvironmentRequest$outboundSchema.parse(
      environmentsControllerV1UpdateMyEnvironmentRequest
    )
  );
}

export function environmentsControllerV1UpdateMyEnvironmentRequestFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerV1UpdateMyEnvironmentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerV1UpdateMyEnvironmentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerV1UpdateMyEnvironmentRequest' from JSON`
  );
}

/** @internal */
export const EnvironmentsControllerV1UpdateMyEnvironmentResponse$inboundSchema: z.ZodType<
  EnvironmentsControllerV1UpdateMyEnvironmentResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.EnvironmentResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type EnvironmentsControllerV1UpdateMyEnvironmentResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.EnvironmentResponseDto$Outbound;
};

/** @internal */
export const EnvironmentsControllerV1UpdateMyEnvironmentResponse$outboundSchema: z.ZodType<
  EnvironmentsControllerV1UpdateMyEnvironmentResponse$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerV1UpdateMyEnvironmentResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.EnvironmentResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerV1UpdateMyEnvironmentResponse$ {
  /** @deprecated use `EnvironmentsControllerV1UpdateMyEnvironmentResponse$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerV1UpdateMyEnvironmentResponse$inboundSchema;
  /** @deprecated use `EnvironmentsControllerV1UpdateMyEnvironmentResponse$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerV1UpdateMyEnvironmentResponse$outboundSchema;
  /** @deprecated use `EnvironmentsControllerV1UpdateMyEnvironmentResponse$Outbound` instead. */
  export type Outbound = EnvironmentsControllerV1UpdateMyEnvironmentResponse$Outbound;
}

export function environmentsControllerV1UpdateMyEnvironmentResponseToJSON(
  environmentsControllerV1UpdateMyEnvironmentResponse: EnvironmentsControllerV1UpdateMyEnvironmentResponse
): string {
  return JSON.stringify(
    EnvironmentsControllerV1UpdateMyEnvironmentResponse$outboundSchema.parse(
      environmentsControllerV1UpdateMyEnvironmentResponse
    )
  );
}

export function environmentsControllerV1UpdateMyEnvironmentResponseFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerV1UpdateMyEnvironmentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerV1UpdateMyEnvironmentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerV1UpdateMyEnvironmentResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - environmentsControllerV1UpdateMyEnvironmentRequestToJSON(environmentsControllerV1UpdateMyEnvironmentRequest: EnvironmentsControllerV1UpdateMyEnvironmentRequest)
 - environmentsControllerV1UpdateMyEnvironmentRequestFromJSON(jsonString: string)
 - environmentsControllerV1UpdateMyEnvironmentResponseToJSON(environmentsControllerV1UpdateMyEnvironmentResponse: EnvironmentsControllerV1UpdateMyEnvironmentResponse)
 - environmentsControllerV1UpdateMyEnvironmentResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EnvironmentsControllerV1UpdateMyEnvironmentRequest$Outbound;
}

export function environmentsControll...)
 - Outbound(EnvironmentsControllerV1UpdateMyEnvironmentResponse$Outbound;
}

export function environmentsControl...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerV1UpdateMyEnvironmentRequestToJSON
- export function environmentsControllerV1UpdateMyEnvironmentRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerV1UpdateMyEnvironmentResponseToJSON
- export function environmentsControllerV1UpdateMyEnvironmentResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/eventscontrollerbroadcasteventtoall.ts
Tamaño: 5998 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EventsControllerBroadcastEventToAllRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  triggerEventToAllRequestDto: components.TriggerEventToAllRequestDto;
};

export type EventsControllerBroadcastEventToAllResponse = {
  headers: { [k: string]: Array<string> };
  result: components.TriggerEventResponseDto;
};

/** @internal */
export const EventsControllerBroadcastEventToAllRequest$inboundSchema: z.ZodType<
  EventsControllerBroadcastEventToAllRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    TriggerEventToAllRequestDto: components.TriggerEventToAllRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      TriggerEventToAllRequestDto: 'triggerEventToAllRequestDto',
    });
  });

/** @internal */
export type EventsControllerBroadcastEventToAllRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  TriggerEventToAllRequestDto: components.TriggerEventToAllRequestDto$Outbound;
};

/** @internal */
export const EventsControllerBroadcastEventToAllRequest$outboundSchema: z.ZodType<
  EventsControllerBroadcastEventToAllRequest$Outbound,
  z.ZodTypeDef,
  EventsControllerBroadcastEventToAllRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    triggerEventToAllRequestDto: components.TriggerEventToAllRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      triggerEventToAllRequestDto: 'TriggerEventToAllRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventsControllerBroadcastEventToAllRequest$ {
  /** @deprecated use `EventsControllerBroadcastEventToAllRequest$inboundSchema` instead. */
  export const inboundSchema = EventsControllerBroadcastEventToAllRequest$inboundSchema;
  /** @deprecated use `EventsControllerBroadcastEventToAllRequest$outboundSchema` instead. */
  export const outboundSchema = EventsControllerBroadcastEventToAllRequest$outboundSchema;
  /** @deprecated use `EventsControllerBroadcastEventToAllRequest$Outbound` instead. */
  export type Outbound = EventsControllerBroadcastEventToAllRequest$Outbound;
}

export function eventsControllerBroadcastEventToAllRequestToJSON(
  eventsControllerBroadcastEventToAllRequest: EventsControllerBroadcastEventToAllRequest
): string {
  return JSON.stringify(
    EventsControllerBroadcastEventToAllRequest$outboundSchema.parse(eventsControllerBroadcastEventToAllRequest)
  );
}

export function eventsControllerBroadcastEventToAllRequestFromJSON(
  jsonString: string
): SafeParseResult<EventsControllerBroadcastEventToAllRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventsControllerBroadcastEventToAllRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventsControllerBroadcastEventToAllRequest' from JSON`
  );
}

/** @internal */
export const EventsControllerBroadcastEventToAllResponse$inboundSchema: z.ZodType<
  EventsControllerBroadcastEventToAllResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.TriggerEventResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type EventsControllerBroadcastEventToAllResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.TriggerEventResponseDto$Outbound;
};

/** @internal */
export const EventsControllerBroadcastEventToAllResponse$outboundSchema: z.ZodType<
  EventsControllerBroadcastEventToAllResponse$Outbound,
  z.ZodTypeDef,
  EventsControllerBroadcastEventToAllResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.TriggerEventResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventsControllerBroadcastEventToAllResponse$ {
  /** @deprecated use `EventsControllerBroadcastEventToAllResponse$inboundSchema` instead. */
  export const inboundSchema = EventsControllerBroadcastEventToAllResponse$inboundSchema;
  /** @deprecated use `EventsControllerBroadcastEventToAllResponse$outboundSchema` instead. */
  export const outboundSchema = EventsControllerBroadcastEventToAllResponse$outboundSchema;
  /** @deprecated use `EventsControllerBroadcastEventToAllResponse$Outbound` instead. */
  export type Outbound = EventsControllerBroadcastEventToAllResponse$Outbound;
}

export function eventsControllerBroadcastEventToAllResponseToJSON(
  eventsControllerBroadcastEventToAllResponse: EventsControllerBroadcastEventToAllResponse
): string {
  return JSON.stringify(
    EventsControllerBroadcastEventToAllResponse$outboundSchema.parse(eventsControllerBroadcastEventToAllResponse)
  );
}

export function eventsControllerBroadcastEventToAllResponseFromJSON(
  jsonString: string
): SafeParseResult<EventsControllerBroadcastEventToAllResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventsControllerBroadcastEventToAllResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventsControllerBroadcastEventToAllResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - eventsControllerBroadcastEventToAllRequestToJSON(eventsControllerBroadcastEventToAllRequest: EventsControllerBroadcastEventToAllRequest)
 - eventsControllerBroadcastEventToAllRequestFromJSON(jsonString: string)
 - eventsControllerBroadcastEventToAllResponseToJSON(eventsControllerBroadcastEventToAllResponse: EventsControllerBroadcastEventToAllResponse)
 - eventsControllerBroadcastEventToAllResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EventsControllerBroadcastEventToAllRequest$Outbound;
}

export function eventsControllerBroadcastEve...)
 - Outbound(EventsControllerBroadcastEventToAllResponse$Outbound;
}

export function eventsControllerBroadcastEv...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventsControllerBroadcastEventToAllRequestToJSON
- export function eventsControllerBroadcastEventToAllRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventsControllerBroadcastEventToAllResponseToJSON
- export function eventsControllerBroadcastEventToAllResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/eventscontrollercancel.ts
Tamaño: 4846 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EventsControllerCancelRequest = {
  transactionId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type EventsControllerCancelResponse = {
  headers: { [k: string]: Array<string> };
  result: boolean;
};

/** @internal */
export const EventsControllerCancelRequest$inboundSchema: z.ZodType<
  EventsControllerCancelRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    transactionId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type EventsControllerCancelRequest$Outbound = {
  transactionId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const EventsControllerCancelRequest$outboundSchema: z.ZodType<
  EventsControllerCancelRequest$Outbound,
  z.ZodTypeDef,
  EventsControllerCancelRequest
> = z
  .object({
    transactionId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventsControllerCancelRequest$ {
  /** @deprecated use `EventsControllerCancelRequest$inboundSchema` instead. */
  export const inboundSchema = EventsControllerCancelRequest$inboundSchema;
  /** @deprecated use `EventsControllerCancelRequest$outboundSchema` instead. */
  export const outboundSchema = EventsControllerCancelRequest$outboundSchema;
  /** @deprecated use `EventsControllerCancelRequest$Outbound` instead. */
  export type Outbound = EventsControllerCancelRequest$Outbound;
}

export function eventsControllerCancelRequestToJSON(
  eventsControllerCancelRequest: EventsControllerCancelRequest
): string {
  return JSON.stringify(EventsControllerCancelRequest$outboundSchema.parse(eventsControllerCancelRequest));
}

export function eventsControllerCancelRequestFromJSON(
  jsonString: string
): SafeParseResult<EventsControllerCancelRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventsControllerCancelRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventsControllerCancelRequest' from JSON`
  );
}

/** @internal */
export const EventsControllerCancelResponse$inboundSchema: z.ZodType<
  EventsControllerCancelResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.boolean(),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type EventsControllerCancelResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: boolean;
};

/** @internal */
export const EventsControllerCancelResponse$outboundSchema: z.ZodType<
  EventsControllerCancelResponse$Outbound,
  z.ZodTypeDef,
  EventsControllerCancelResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.boolean(),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventsControllerCancelResponse$ {
  /** @deprecated use `EventsControllerCancelResponse$inboundSchema` instead. */
  export const inboundSchema = EventsControllerCancelResponse$inboundSchema;
  /** @deprecated use `EventsControllerCancelResponse$outboundSchema` instead. */
  export const outboundSchema = EventsControllerCancelResponse$outboundSchema;
  /** @deprecated use `EventsControllerCancelResponse$Outbound` instead. */
  export type Outbound = EventsControllerCancelResponse$Outbound;
}

export function eventsControllerCancelResponseToJSON(
  eventsControllerCancelResponse: EventsControllerCancelResponse
): string {
  return JSON.stringify(EventsControllerCancelResponse$outboundSchema.parse(eventsControllerCancelResponse));
}

export function eventsControllerCancelResponseFromJSON(
  jsonString: string
): SafeParseResult<EventsControllerCancelResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventsControllerCancelResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventsControllerCancelResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - eventsControllerCancelRequestToJSON(eventsControllerCancelRequest: EventsControllerCancelRequest)
 - eventsControllerCancelRequestFromJSON(jsonString: string)
 - eventsControllerCancelResponseToJSON(eventsControllerCancelResponse: EventsControllerCancelResponse)
 - eventsControllerCancelResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EventsControllerCancelRequest$Outbound;
}

export function eventsControllerCancelRequestToJSON(
  ev...)
 - Outbound(EventsControllerCancelResponse$Outbound;
}

export function eventsControllerCancelResponseToJSON(
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventsControllerCancelRequestToJSON
- export function eventsControllerCancelRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventsControllerCancelResponseToJSON
- export function eventsControllerCancelResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/eventscontrollertrigger.ts
Tamaño: 5370 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EventsControllerTriggerRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  triggerEventRequestDto: components.TriggerEventRequestDto;
};

export type EventsControllerTriggerResponse = {
  headers: { [k: string]: Array<string> };
  result: components.TriggerEventResponseDto;
};

/** @internal */
export const EventsControllerTriggerRequest$inboundSchema: z.ZodType<
  EventsControllerTriggerRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    TriggerEventRequestDto: components.TriggerEventRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      TriggerEventRequestDto: 'triggerEventRequestDto',
    });
  });

/** @internal */
export type EventsControllerTriggerRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  TriggerEventRequestDto: components.TriggerEventRequestDto$Outbound;
};

/** @internal */
export const EventsControllerTriggerRequest$outboundSchema: z.ZodType<
  EventsControllerTriggerRequest$Outbound,
  z.ZodTypeDef,
  EventsControllerTriggerRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    triggerEventRequestDto: components.TriggerEventRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      triggerEventRequestDto: 'TriggerEventRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventsControllerTriggerRequest$ {
  /** @deprecated use `EventsControllerTriggerRequest$inboundSchema` instead. */
  export const inboundSchema = EventsControllerTriggerRequest$inboundSchema;
  /** @deprecated use `EventsControllerTriggerRequest$outboundSchema` instead. */
  export const outboundSchema = EventsControllerTriggerRequest$outboundSchema;
  /** @deprecated use `EventsControllerTriggerRequest$Outbound` instead. */
  export type Outbound = EventsControllerTriggerRequest$Outbound;
}

export function eventsControllerTriggerRequestToJSON(
  eventsControllerTriggerRequest: EventsControllerTriggerRequest
): string {
  return JSON.stringify(EventsControllerTriggerRequest$outboundSchema.parse(eventsControllerTriggerRequest));
}

export function eventsControllerTriggerRequestFromJSON(
  jsonString: string
): SafeParseResult<EventsControllerTriggerRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventsControllerTriggerRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventsControllerTriggerRequest' from JSON`
  );
}

/** @internal */
export const EventsControllerTriggerResponse$inboundSchema: z.ZodType<
  EventsControllerTriggerResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.TriggerEventResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type EventsControllerTriggerResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.TriggerEventResponseDto$Outbound;
};

/** @internal */
export const EventsControllerTriggerResponse$outboundSchema: z.ZodType<
  EventsControllerTriggerResponse$Outbound,
  z.ZodTypeDef,
  EventsControllerTriggerResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.TriggerEventResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventsControllerTriggerResponse$ {
  /** @deprecated use `EventsControllerTriggerResponse$inboundSchema` instead. */
  export const inboundSchema = EventsControllerTriggerResponse$inboundSchema;
  /** @deprecated use `EventsControllerTriggerResponse$outboundSchema` instead. */
  export const outboundSchema = EventsControllerTriggerResponse$outboundSchema;
  /** @deprecated use `EventsControllerTriggerResponse$Outbound` instead. */
  export type Outbound = EventsControllerTriggerResponse$Outbound;
}

export function eventsControllerTriggerResponseToJSON(
  eventsControllerTriggerResponse: EventsControllerTriggerResponse
): string {
  return JSON.stringify(EventsControllerTriggerResponse$outboundSchema.parse(eventsControllerTriggerResponse));
}

export function eventsControllerTriggerResponseFromJSON(
  jsonString: string
): SafeParseResult<EventsControllerTriggerResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventsControllerTriggerResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventsControllerTriggerResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - eventsControllerTriggerRequestToJSON(eventsControllerTriggerRequest: EventsControllerTriggerRequest)
 - eventsControllerTriggerRequestFromJSON(jsonString: string)
 - eventsControllerTriggerResponseToJSON(eventsControllerTriggerResponse: EventsControllerTriggerResponse)
 - eventsControllerTriggerResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EventsControllerTriggerRequest$Outbound;
}

export function eventsControllerTriggerRequestToJSON(
  ...)
 - Outbound(EventsControllerTriggerResponse$Outbound;
}

export function eventsControllerTriggerResponseToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventsControllerTriggerRequestToJSON
- export function eventsControllerTriggerRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventsControllerTriggerResponseToJSON
- export function eventsControllerTriggerResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/eventscontrollertriggerbulk.ts
Tamaño: 5550 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EventsControllerTriggerBulkRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  bulkTriggerEventDto: components.BulkTriggerEventDto;
};

export type EventsControllerTriggerBulkResponse = {
  headers: { [k: string]: Array<string> };
  result: Array<components.TriggerEventResponseDto>;
};

/** @internal */
export const EventsControllerTriggerBulkRequest$inboundSchema: z.ZodType<
  EventsControllerTriggerBulkRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    BulkTriggerEventDto: components.BulkTriggerEventDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      BulkTriggerEventDto: 'bulkTriggerEventDto',
    });
  });

/** @internal */
export type EventsControllerTriggerBulkRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  BulkTriggerEventDto: components.BulkTriggerEventDto$Outbound;
};

/** @internal */
export const EventsControllerTriggerBulkRequest$outboundSchema: z.ZodType<
  EventsControllerTriggerBulkRequest$Outbound,
  z.ZodTypeDef,
  EventsControllerTriggerBulkRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    bulkTriggerEventDto: components.BulkTriggerEventDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      bulkTriggerEventDto: 'BulkTriggerEventDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventsControllerTriggerBulkRequest$ {
  /** @deprecated use `EventsControllerTriggerBulkRequest$inboundSchema` instead. */
  export const inboundSchema = EventsControllerTriggerBulkRequest$inboundSchema;
  /** @deprecated use `EventsControllerTriggerBulkRequest$outboundSchema` instead. */
  export const outboundSchema = EventsControllerTriggerBulkRequest$outboundSchema;
  /** @deprecated use `EventsControllerTriggerBulkRequest$Outbound` instead. */
  export type Outbound = EventsControllerTriggerBulkRequest$Outbound;
}

export function eventsControllerTriggerBulkRequestToJSON(
  eventsControllerTriggerBulkRequest: EventsControllerTriggerBulkRequest
): string {
  return JSON.stringify(EventsControllerTriggerBulkRequest$outboundSchema.parse(eventsControllerTriggerBulkRequest));
}

export function eventsControllerTriggerBulkRequestFromJSON(
  jsonString: string
): SafeParseResult<EventsControllerTriggerBulkRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventsControllerTriggerBulkRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventsControllerTriggerBulkRequest' from JSON`
  );
}

/** @internal */
export const EventsControllerTriggerBulkResponse$inboundSchema: z.ZodType<
  EventsControllerTriggerBulkResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.array(components.TriggerEventResponseDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type EventsControllerTriggerBulkResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: Array<components.TriggerEventResponseDto$Outbound>;
};

/** @internal */
export const EventsControllerTriggerBulkResponse$outboundSchema: z.ZodType<
  EventsControllerTriggerBulkResponse$Outbound,
  z.ZodTypeDef,
  EventsControllerTriggerBulkResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.array(components.TriggerEventResponseDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventsControllerTriggerBulkResponse$ {
  /** @deprecated use `EventsControllerTriggerBulkResponse$inboundSchema` instead. */
  export const inboundSchema = EventsControllerTriggerBulkResponse$inboundSchema;
  /** @deprecated use `EventsControllerTriggerBulkResponse$outboundSchema` instead. */
  export const outboundSchema = EventsControllerTriggerBulkResponse$outboundSchema;
  /** @deprecated use `EventsControllerTriggerBulkResponse$Outbound` instead. */
  export type Outbound = EventsControllerTriggerBulkResponse$Outbound;
}

export function eventsControllerTriggerBulkResponseToJSON(
  eventsControllerTriggerBulkResponse: EventsControllerTriggerBulkResponse
): string {
  return JSON.stringify(EventsControllerTriggerBulkResponse$outboundSchema.parse(eventsControllerTriggerBulkResponse));
}

export function eventsControllerTriggerBulkResponseFromJSON(
  jsonString: string
): SafeParseResult<EventsControllerTriggerBulkResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventsControllerTriggerBulkResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventsControllerTriggerBulkResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - eventsControllerTriggerBulkRequestToJSON(eventsControllerTriggerBulkRequest: EventsControllerTriggerBulkRequest)
 - eventsControllerTriggerBulkRequestFromJSON(jsonString: string)
 - eventsControllerTriggerBulkResponseToJSON(eventsControllerTriggerBulkResponse: EventsControllerTriggerBulkResponse)
 - eventsControllerTriggerBulkResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EventsControllerTriggerBulkRequest$Outbound;
}

export function eventsControllerTriggerBulkRequestTo...)
 - Outbound(EventsControllerTriggerBulkResponse$Outbound;
}

export function eventsControllerTriggerBulkResponse...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventsControllerTriggerBulkRequestToJSON
- export function eventsControllerTriggerBulkRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventsControllerTriggerBulkResponseToJSON
- export function eventsControllerTriggerBulkResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/inboundwebhookscontrollerhandlewebhook.ts
Tamaño: 3489 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type InboundWebhooksControllerHandleWebhookRequest = {
  /**
   * The environment identifier
   */
  environmentId: string;
  /**
   * The integration identifier for the delivery provider
   */
  integrationId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Webhook event payload from the delivery provider
   */
  requestBody?: any | undefined;
};

/** @internal */
export const InboundWebhooksControllerHandleWebhookRequest$inboundSchema: z.ZodType<
  InboundWebhooksControllerHandleWebhookRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    environmentId: z.string(),
    integrationId: z.string(),
    'idempotency-key': z.string().optional(),
    RequestBody: z.any().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      RequestBody: 'requestBody',
    });
  });

/** @internal */
export type InboundWebhooksControllerHandleWebhookRequest$Outbound = {
  environmentId: string;
  integrationId: string;
  'idempotency-key'?: string | undefined;
  RequestBody?: any | undefined;
};

/** @internal */
export const InboundWebhooksControllerHandleWebhookRequest$outboundSchema: z.ZodType<
  InboundWebhooksControllerHandleWebhookRequest$Outbound,
  z.ZodTypeDef,
  InboundWebhooksControllerHandleWebhookRequest
> = z
  .object({
    environmentId: z.string(),
    integrationId: z.string(),
    idempotencyKey: z.string().optional(),
    requestBody: z.any().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      requestBody: 'RequestBody',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InboundWebhooksControllerHandleWebhookRequest$ {
  /** @deprecated use `InboundWebhooksControllerHandleWebhookRequest$inboundSchema` instead. */
  export const inboundSchema = InboundWebhooksControllerHandleWebhookRequest$inboundSchema;
  /** @deprecated use `InboundWebhooksControllerHandleWebhookRequest$outboundSchema` instead. */
  export const outboundSchema = InboundWebhooksControllerHandleWebhookRequest$outboundSchema;
  /** @deprecated use `InboundWebhooksControllerHandleWebhookRequest$Outbound` instead. */
  export type Outbound = InboundWebhooksControllerHandleWebhookRequest$Outbound;
}

export function inboundWebhooksControllerHandleWebhookRequestToJSON(
  inboundWebhooksControllerHandleWebhookRequest: InboundWebhooksControllerHandleWebhookRequest
): string {
  return JSON.stringify(
    InboundWebhooksControllerHandleWebhookRequest$outboundSchema.parse(inboundWebhooksControllerHandleWebhookRequest)
  );
}

export function inboundWebhooksControllerHandleWebhookRequestFromJSON(
  jsonString: string
): SafeParseResult<InboundWebhooksControllerHandleWebhookRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InboundWebhooksControllerHandleWebhookRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InboundWebhooksControllerHandleWebhookRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - inboundWebhooksControllerHandleWebhookRequestToJSON(inboundWebhooksControllerHandleWebhookRequest: InboundWebhooksControllerHandleWebhookRequest)
 - inboundWebhooksControllerHandleWebhookRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(InboundWebhooksControllerHandleWebhookRequest$Outbound;
}

export function inboundWebhooksController...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function inboundWebhooksControllerHandleWebhookRequestToJSON
- export function inboundWebhooksControllerHandleWebhookRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/index.ts
Tamaño: 5196 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export * from "./activitycontrollergetcharts.js";
export * from "./activitycontrollergetlogs.js";
export * from "./activitycontrollergetrequesttraces.js";
export * from "./activitycontrollergetworkflowrun.js";
export * from "./activitycontrollergetworkflowruns.js";
export * from "./contextscontrollercreatecontext.js";
export * from "./contextscontrollerdeletecontext.js";
export * from "./contextscontrollergetcontext.js";
export * from "./contextscontrollerlistcontexts.js";
export * from "./contextscontrollerupdatecontext.js";
export * from "./environmentscontrollergetenvironmenttags.js";
export * from "./environmentscontrollerv1createenvironment.js";
export * from "./environmentscontrollerv1deleteenvironment.js";
export * from "./environmentscontrollerv1listmyenvironments.js";
export * from "./environmentscontrollerv1updatemyenvironment.js";
export * from "./eventscontrollerbroadcasteventtoall.js";
export * from "./eventscontrollercancel.js";
export * from "./eventscontrollertrigger.js";
export * from "./eventscontrollertriggerbulk.js";
export * from "./inboundwebhookscontrollerhandlewebhook.js";
export * from "./integrationscontrollerautoconfigureintegration.js";
export * from "./integrationscontrollercreateintegration.js";
export * from "./integrationscontrollergetactiveintegrations.js";
export * from "./integrationscontrollerlistintegrations.js";
export * from "./integrationscontrollerremoveintegration.js";
export * from "./integrationscontrollersetintegrationasprimary.js";
export * from "./integrationscontrollerupdateintegrationbyid.js";
export * from "./layoutscontrollercreate.js";
export * from "./layoutscontrollerdelete.js";
export * from "./layoutscontrollerduplicate.js";
export * from "./layoutscontrollergeneratepreview.js";
export * from "./layoutscontrollerget.js";
export * from "./layoutscontrollergetusage.js";
export * from "./layoutscontrollerlist.js";
export * from "./layoutscontrollerupdate.js";
export * from "./messagescontrollerdeletemessage.js";
export * from "./messagescontrollerdeletemessagesbytransactionid.js";
export * from "./messagescontrollergetmessages.js";
export * from "./notificationscontrollergetnotification.js";
export * from "./notificationscontrollerlistnotifications.js";
export * from "./subscriberscontrollerbulkupdatesubscriberpreferences.js";
export * from "./subscriberscontrollercreatesubscriber.js";
export * from "./subscriberscontrollergetsubscriber.js";
export * from "./subscriberscontrollergetsubscriberpreferences.js";
export * from "./subscriberscontrollerlistsubscribertopics.js";
export * from "./subscriberscontrollerpatchsubscriber.js";
export * from "./subscriberscontrollerremovesubscriber.js";
export * from "./subscriberscontrollersearchsubscribers.js";
export * from "./subscriberscontrollerupdatesubscriberpreferences.js";
export * from "./subscribersv1controllerbulkcreatesubscribers.js";
export * from "./subscribersv1controllerdeletesubscribercredentials.js";
export * from "./subscribersv1controllergetnotificationsfeed.js";
export * from "./subscribersv1controllergetunseencount.js";
export * from "./subscribersv1controllermarkactionasseen.js";
export * from "./subscribersv1controllermarkallunreadasread.js";
export * from "./subscribersv1controllermarkmessagesas.js";
export * from "./subscribersv1controllermodifysubscriberchannel.js";
export * from "./subscribersv1controllerupdatesubscriberchannel.js";
export * from "./subscribersv1controllerupdatesubscriberonlineflag.js";
export * from "./topicscontrollercreatetopicsubscriptions.js";
export * from "./topicscontrollerdeletetopic.js";
export * from "./topicscontrollerdeletetopicsubscriptions.js";
export * from "./topicscontrollergettopic.js";
export * from "./topicscontrollerlisttopics.js";
export * from "./topicscontrollerlisttopicsubscriptions.js";
export * from "./topicscontrollerupdatetopic.js";
export * from "./topicscontrollerupserttopic.js";
export * from "./topicsv1controllergettopicsubscriber.js";
export * from "./translationcontrollercreatetranslationendpoint.js";
export * from "./translationcontrollerdeletetranslationendpoint.js";
export * from "./translationcontrollerdeletetranslationgroupendpoint.js";
export * from "./translationcontrollergetmasterjsonendpoint.js";
export * from "./translationcontrollergetsingletranslation.js";
export * from "./translationcontrollergettranslationgroupendpoint.js";
export * from "./translationcontrollerimportmasterjsonendpoint.js";
export * from "./translationcontrolleruploadmasterjsonendpoint.js";
export * from "./translationcontrolleruploadtranslationfiles.js";
export * from "./workflowcontrollercreate.js";
export * from "./workflowcontrollerduplicateworkflow.js";
export * from "./workflowcontrollergeneratepreview.js";
export * from "./workflowcontrollergetworkflow.js";
export * from "./workflowcontrollergetworkflowstepdata.js";
export * from "./workflowcontrollerpatchworkflow.js";
export * from "./workflowcontrollerremoveworkflow.js";
export * from "./workflowcontrollersearchworkflows.js";
export * from "./workflowcontrollersync.js";
export * from "./workflowcontrollerupdate.js";


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/integrationscontrollerautoconfigureintegration.ts
Tamaño: 6230 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type IntegrationsControllerAutoConfigureIntegrationRequest = {
  integrationId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type IntegrationsControllerAutoConfigureIntegrationResponse = {
  headers: { [k: string]: Array<string> };
  result: components.AutoConfigureIntegrationResponseDto;
};

/** @internal */
export const IntegrationsControllerAutoConfigureIntegrationRequest$inboundSchema: z.ZodType<
  IntegrationsControllerAutoConfigureIntegrationRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    integrationId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type IntegrationsControllerAutoConfigureIntegrationRequest$Outbound = {
  integrationId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const IntegrationsControllerAutoConfigureIntegrationRequest$outboundSchema: z.ZodType<
  IntegrationsControllerAutoConfigureIntegrationRequest$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerAutoConfigureIntegrationRequest
> = z
  .object({
    integrationId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerAutoConfigureIntegrationRequest$ {
  /** @deprecated use `IntegrationsControllerAutoConfigureIntegrationRequest$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerAutoConfigureIntegrationRequest$inboundSchema;
  /** @deprecated use `IntegrationsControllerAutoConfigureIntegrationRequest$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerAutoConfigureIntegrationRequest$outboundSchema;
  /** @deprecated use `IntegrationsControllerAutoConfigureIntegrationRequest$Outbound` instead. */
  export type Outbound = IntegrationsControllerAutoConfigureIntegrationRequest$Outbound;
}

export function integrationsControllerAutoConfigureIntegrationRequestToJSON(
  integrationsControllerAutoConfigureIntegrationRequest: IntegrationsControllerAutoConfigureIntegrationRequest
): string {
  return JSON.stringify(
    IntegrationsControllerAutoConfigureIntegrationRequest$outboundSchema.parse(
      integrationsControllerAutoConfigureIntegrationRequest
    )
  );
}

export function integrationsControllerAutoConfigureIntegrationRequestFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerAutoConfigureIntegrationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerAutoConfigureIntegrationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerAutoConfigureIntegrationRequest' from JSON`
  );
}

/** @internal */
export const IntegrationsControllerAutoConfigureIntegrationResponse$inboundSchema: z.ZodType<
  IntegrationsControllerAutoConfigureIntegrationResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.AutoConfigureIntegrationResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type IntegrationsControllerAutoConfigureIntegrationResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.AutoConfigureIntegrationResponseDto$Outbound;
};

/** @internal */
export const IntegrationsControllerAutoConfigureIntegrationResponse$outboundSchema: z.ZodType<
  IntegrationsControllerAutoConfigureIntegrationResponse$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerAutoConfigureIntegrationResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.AutoConfigureIntegrationResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerAutoConfigureIntegrationResponse$ {
  /** @deprecated use `IntegrationsControllerAutoConfigureIntegrationResponse$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerAutoConfigureIntegrationResponse$inboundSchema;
  /** @deprecated use `IntegrationsControllerAutoConfigureIntegrationResponse$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerAutoConfigureIntegrationResponse$outboundSchema;
  /** @deprecated use `IntegrationsControllerAutoConfigureIntegrationResponse$Outbound` instead. */
  export type Outbound = IntegrationsControllerAutoConfigureIntegrationResponse$Outbound;
}

export function integrationsControllerAutoConfigureIntegrationResponseToJSON(
  integrationsControllerAutoConfigureIntegrationResponse: IntegrationsControllerAutoConfigureIntegrationResponse
): string {
  return JSON.stringify(
    IntegrationsControllerAutoConfigureIntegrationResponse$outboundSchema.parse(
      integrationsControllerAutoConfigureIntegrationResponse
    )
  );
}

export function integrationsControllerAutoConfigureIntegrationResponseFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerAutoConfigureIntegrationResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerAutoConfigureIntegrationResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerAutoConfigureIntegrationResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsControllerAutoConfigureIntegrationRequestToJSON(integrationsControllerAutoConfigureIntegrationRequest: IntegrationsControllerAutoConfigureIntegrationRequest)
 - integrationsControllerAutoConfigureIntegrationRequestFromJSON(jsonString: string)
 - integrationsControllerAutoConfigureIntegrationResponseToJSON(integrationsControllerAutoConfigureIntegrationResponse: IntegrationsControllerAutoConfigureIntegrationResponse)
 - integrationsControllerAutoConfigureIntegrationResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(IntegrationsControllerAutoConfigureIntegrationRequest$Outbound;
}

export function integrationsContr...)
 - Outbound(IntegrationsControllerAutoConfigureIntegrationResponse$Outbound;
}

export function integrationsCont...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerAutoConfigureIntegrationRequestToJSON
- export function integrationsControllerAutoConfigureIntegrationRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerAutoConfigureIntegrationResponseToJSON
- export function integrationsControllerAutoConfigureIntegrationResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/integrationscontrollercreateintegration.ts
Tamaño: 6190 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type IntegrationsControllerCreateIntegrationRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  createIntegrationRequestDto: components.CreateIntegrationRequestDto;
};

export type IntegrationsControllerCreateIntegrationResponse = {
  headers: { [k: string]: Array<string> };
  result: components.IntegrationResponseDto;
};

/** @internal */
export const IntegrationsControllerCreateIntegrationRequest$inboundSchema: z.ZodType<
  IntegrationsControllerCreateIntegrationRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    CreateIntegrationRequestDto: components.CreateIntegrationRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateIntegrationRequestDto: 'createIntegrationRequestDto',
    });
  });

/** @internal */
export type IntegrationsControllerCreateIntegrationRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  CreateIntegrationRequestDto: components.CreateIntegrationRequestDto$Outbound;
};

/** @internal */
export const IntegrationsControllerCreateIntegrationRequest$outboundSchema: z.ZodType<
  IntegrationsControllerCreateIntegrationRequest$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerCreateIntegrationRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    createIntegrationRequestDto: components.CreateIntegrationRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createIntegrationRequestDto: 'CreateIntegrationRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerCreateIntegrationRequest$ {
  /** @deprecated use `IntegrationsControllerCreateIntegrationRequest$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerCreateIntegrationRequest$inboundSchema;
  /** @deprecated use `IntegrationsControllerCreateIntegrationRequest$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerCreateIntegrationRequest$outboundSchema;
  /** @deprecated use `IntegrationsControllerCreateIntegrationRequest$Outbound` instead. */
  export type Outbound = IntegrationsControllerCreateIntegrationRequest$Outbound;
}

export function integrationsControllerCreateIntegrationRequestToJSON(
  integrationsControllerCreateIntegrationRequest: IntegrationsControllerCreateIntegrationRequest
): string {
  return JSON.stringify(
    IntegrationsControllerCreateIntegrationRequest$outboundSchema.parse(integrationsControllerCreateIntegrationRequest)
  );
}

export function integrationsControllerCreateIntegrationRequestFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerCreateIntegrationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerCreateIntegrationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerCreateIntegrationRequest' from JSON`
  );
}

/** @internal */
export const IntegrationsControllerCreateIntegrationResponse$inboundSchema: z.ZodType<
  IntegrationsControllerCreateIntegrationResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.IntegrationResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type IntegrationsControllerCreateIntegrationResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.IntegrationResponseDto$Outbound;
};

/** @internal */
export const IntegrationsControllerCreateIntegrationResponse$outboundSchema: z.ZodType<
  IntegrationsControllerCreateIntegrationResponse$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerCreateIntegrationResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.IntegrationResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerCreateIntegrationResponse$ {
  /** @deprecated use `IntegrationsControllerCreateIntegrationResponse$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerCreateIntegrationResponse$inboundSchema;
  /** @deprecated use `IntegrationsControllerCreateIntegrationResponse$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerCreateIntegrationResponse$outboundSchema;
  /** @deprecated use `IntegrationsControllerCreateIntegrationResponse$Outbound` instead. */
  export type Outbound = IntegrationsControllerCreateIntegrationResponse$Outbound;
}

export function integrationsControllerCreateIntegrationResponseToJSON(
  integrationsControllerCreateIntegrationResponse: IntegrationsControllerCreateIntegrationResponse
): string {
  return JSON.stringify(
    IntegrationsControllerCreateIntegrationResponse$outboundSchema.parse(
      integrationsControllerCreateIntegrationResponse
    )
  );
}

export function integrationsControllerCreateIntegrationResponseFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerCreateIntegrationResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerCreateIntegrationResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerCreateIntegrationResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsControllerCreateIntegrationRequestToJSON(integrationsControllerCreateIntegrationRequest: IntegrationsControllerCreateIntegrationRequest)
 - integrationsControllerCreateIntegrationRequestFromJSON(jsonString: string)
 - integrationsControllerCreateIntegrationResponseToJSON(integrationsControllerCreateIntegrationResponse: IntegrationsControllerCreateIntegrationResponse)
 - integrationsControllerCreateIntegrationResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(IntegrationsControllerCreateIntegrationRequest$Outbound;
}

export function integrationsControllerCr...)
 - Outbound(IntegrationsControllerCreateIntegrationResponse$Outbound;
}

export function integrationsControllerC...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerCreateIntegrationRequestToJSON
- export function integrationsControllerCreateIntegrationRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerCreateIntegrationResponseToJSON
- export function integrationsControllerCreateIntegrationResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/integrationscontrollergetactiveintegrations.ts
Tamaño: 5960 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type IntegrationsControllerGetActiveIntegrationsRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type IntegrationsControllerGetActiveIntegrationsResponse = {
  headers: { [k: string]: Array<string> };
  result: Array<components.IntegrationResponseDto>;
};

/** @internal */
export const IntegrationsControllerGetActiveIntegrationsRequest$inboundSchema: z.ZodType<
  IntegrationsControllerGetActiveIntegrationsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type IntegrationsControllerGetActiveIntegrationsRequest$Outbound = {
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const IntegrationsControllerGetActiveIntegrationsRequest$outboundSchema: z.ZodType<
  IntegrationsControllerGetActiveIntegrationsRequest$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerGetActiveIntegrationsRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerGetActiveIntegrationsRequest$ {
  /** @deprecated use `IntegrationsControllerGetActiveIntegrationsRequest$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerGetActiveIntegrationsRequest$inboundSchema;
  /** @deprecated use `IntegrationsControllerGetActiveIntegrationsRequest$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerGetActiveIntegrationsRequest$outboundSchema;
  /** @deprecated use `IntegrationsControllerGetActiveIntegrationsRequest$Outbound` instead. */
  export type Outbound = IntegrationsControllerGetActiveIntegrationsRequest$Outbound;
}

export function integrationsControllerGetActiveIntegrationsRequestToJSON(
  integrationsControllerGetActiveIntegrationsRequest: IntegrationsControllerGetActiveIntegrationsRequest
): string {
  return JSON.stringify(
    IntegrationsControllerGetActiveIntegrationsRequest$outboundSchema.parse(
      integrationsControllerGetActiveIntegrationsRequest
    )
  );
}

export function integrationsControllerGetActiveIntegrationsRequestFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerGetActiveIntegrationsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerGetActiveIntegrationsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerGetActiveIntegrationsRequest' from JSON`
  );
}

/** @internal */
export const IntegrationsControllerGetActiveIntegrationsResponse$inboundSchema: z.ZodType<
  IntegrationsControllerGetActiveIntegrationsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.array(components.IntegrationResponseDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type IntegrationsControllerGetActiveIntegrationsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: Array<components.IntegrationResponseDto$Outbound>;
};

/** @internal */
export const IntegrationsControllerGetActiveIntegrationsResponse$outboundSchema: z.ZodType<
  IntegrationsControllerGetActiveIntegrationsResponse$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerGetActiveIntegrationsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.array(components.IntegrationResponseDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerGetActiveIntegrationsResponse$ {
  /** @deprecated use `IntegrationsControllerGetActiveIntegrationsResponse$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerGetActiveIntegrationsResponse$inboundSchema;
  /** @deprecated use `IntegrationsControllerGetActiveIntegrationsResponse$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerGetActiveIntegrationsResponse$outboundSchema;
  /** @deprecated use `IntegrationsControllerGetActiveIntegrationsResponse$Outbound` instead. */
  export type Outbound = IntegrationsControllerGetActiveIntegrationsResponse$Outbound;
}

export function integrationsControllerGetActiveIntegrationsResponseToJSON(
  integrationsControllerGetActiveIntegrationsResponse: IntegrationsControllerGetActiveIntegrationsResponse
): string {
  return JSON.stringify(
    IntegrationsControllerGetActiveIntegrationsResponse$outboundSchema.parse(
      integrationsControllerGetActiveIntegrationsResponse
    )
  );
}

export function integrationsControllerGetActiveIntegrationsResponseFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerGetActiveIntegrationsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerGetActiveIntegrationsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerGetActiveIntegrationsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsControllerGetActiveIntegrationsRequestToJSON(integrationsControllerGetActiveIntegrationsRequest: IntegrationsControllerGetActiveIntegrationsRequest)
 - integrationsControllerGetActiveIntegrationsRequestFromJSON(jsonString: string)
 - integrationsControllerGetActiveIntegrationsResponseToJSON(integrationsControllerGetActiveIntegrationsResponse: IntegrationsControllerGetActiveIntegrationsResponse)
 - integrationsControllerGetActiveIntegrationsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(IntegrationsControllerGetActiveIntegrationsRequest$Outbound;
}

export function integrationsControll...)
 - Outbound(IntegrationsControllerGetActiveIntegrationsResponse$Outbound;
}

export function integrationsControl...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerGetActiveIntegrationsRequestToJSON
- export function integrationsControllerGetActiveIntegrationsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerGetActiveIntegrationsResponseToJSON
- export function integrationsControllerGetActiveIntegrationsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/integrationscontrollerlistintegrations.ts
Tamaño: 5706 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type IntegrationsControllerListIntegrationsRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type IntegrationsControllerListIntegrationsResponse = {
  headers: { [k: string]: Array<string> };
  result: Array<components.IntegrationResponseDto>;
};

/** @internal */
export const IntegrationsControllerListIntegrationsRequest$inboundSchema: z.ZodType<
  IntegrationsControllerListIntegrationsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type IntegrationsControllerListIntegrationsRequest$Outbound = {
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const IntegrationsControllerListIntegrationsRequest$outboundSchema: z.ZodType<
  IntegrationsControllerListIntegrationsRequest$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerListIntegrationsRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerListIntegrationsRequest$ {
  /** @deprecated use `IntegrationsControllerListIntegrationsRequest$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerListIntegrationsRequest$inboundSchema;
  /** @deprecated use `IntegrationsControllerListIntegrationsRequest$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerListIntegrationsRequest$outboundSchema;
  /** @deprecated use `IntegrationsControllerListIntegrationsRequest$Outbound` instead. */
  export type Outbound = IntegrationsControllerListIntegrationsRequest$Outbound;
}

export function integrationsControllerListIntegrationsRequestToJSON(
  integrationsControllerListIntegrationsRequest: IntegrationsControllerListIntegrationsRequest
): string {
  return JSON.stringify(
    IntegrationsControllerListIntegrationsRequest$outboundSchema.parse(integrationsControllerListIntegrationsRequest)
  );
}

export function integrationsControllerListIntegrationsRequestFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerListIntegrationsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerListIntegrationsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerListIntegrationsRequest' from JSON`
  );
}

/** @internal */
export const IntegrationsControllerListIntegrationsResponse$inboundSchema: z.ZodType<
  IntegrationsControllerListIntegrationsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.array(components.IntegrationResponseDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type IntegrationsControllerListIntegrationsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: Array<components.IntegrationResponseDto$Outbound>;
};

/** @internal */
export const IntegrationsControllerListIntegrationsResponse$outboundSchema: z.ZodType<
  IntegrationsControllerListIntegrationsResponse$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerListIntegrationsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.array(components.IntegrationResponseDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerListIntegrationsResponse$ {
  /** @deprecated use `IntegrationsControllerListIntegrationsResponse$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerListIntegrationsResponse$inboundSchema;
  /** @deprecated use `IntegrationsControllerListIntegrationsResponse$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerListIntegrationsResponse$outboundSchema;
  /** @deprecated use `IntegrationsControllerListIntegrationsResponse$Outbound` instead. */
  export type Outbound = IntegrationsControllerListIntegrationsResponse$Outbound;
}

export function integrationsControllerListIntegrationsResponseToJSON(
  integrationsControllerListIntegrationsResponse: IntegrationsControllerListIntegrationsResponse
): string {
  return JSON.stringify(
    IntegrationsControllerListIntegrationsResponse$outboundSchema.parse(integrationsControllerListIntegrationsResponse)
  );
}

export function integrationsControllerListIntegrationsResponseFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerListIntegrationsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerListIntegrationsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerListIntegrationsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsControllerListIntegrationsRequestToJSON(integrationsControllerListIntegrationsRequest: IntegrationsControllerListIntegrationsRequest)
 - integrationsControllerListIntegrationsRequestFromJSON(jsonString: string)
 - integrationsControllerListIntegrationsResponseToJSON(integrationsControllerListIntegrationsResponse: IntegrationsControllerListIntegrationsResponse)
 - integrationsControllerListIntegrationsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(IntegrationsControllerListIntegrationsRequest$Outbound;
}

export function integrationsControllerLis...)
 - Outbound(IntegrationsControllerListIntegrationsResponse$Outbound;
}

export function integrationsControllerLi...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerListIntegrationsRequestToJSON
- export function integrationsControllerListIntegrationsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerListIntegrationsResponseToJSON
- export function integrationsControllerListIntegrationsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/integrationscontrollerremoveintegration.ts
Tamaño: 5876 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type IntegrationsControllerRemoveIntegrationRequest = {
  integrationId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type IntegrationsControllerRemoveIntegrationResponse = {
  headers: { [k: string]: Array<string> };
  result: Array<components.IntegrationResponseDto>;
};

/** @internal */
export const IntegrationsControllerRemoveIntegrationRequest$inboundSchema: z.ZodType<
  IntegrationsControllerRemoveIntegrationRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    integrationId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type IntegrationsControllerRemoveIntegrationRequest$Outbound = {
  integrationId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const IntegrationsControllerRemoveIntegrationRequest$outboundSchema: z.ZodType<
  IntegrationsControllerRemoveIntegrationRequest$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerRemoveIntegrationRequest
> = z
  .object({
    integrationId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerRemoveIntegrationRequest$ {
  /** @deprecated use `IntegrationsControllerRemoveIntegrationRequest$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerRemoveIntegrationRequest$inboundSchema;
  /** @deprecated use `IntegrationsControllerRemoveIntegrationRequest$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerRemoveIntegrationRequest$outboundSchema;
  /** @deprecated use `IntegrationsControllerRemoveIntegrationRequest$Outbound` instead. */
  export type Outbound = IntegrationsControllerRemoveIntegrationRequest$Outbound;
}

export function integrationsControllerRemoveIntegrationRequestToJSON(
  integrationsControllerRemoveIntegrationRequest: IntegrationsControllerRemoveIntegrationRequest
): string {
  return JSON.stringify(
    IntegrationsControllerRemoveIntegrationRequest$outboundSchema.parse(integrationsControllerRemoveIntegrationRequest)
  );
}

export function integrationsControllerRemoveIntegrationRequestFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerRemoveIntegrationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerRemoveIntegrationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerRemoveIntegrationRequest' from JSON`
  );
}

/** @internal */
export const IntegrationsControllerRemoveIntegrationResponse$inboundSchema: z.ZodType<
  IntegrationsControllerRemoveIntegrationResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.array(components.IntegrationResponseDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type IntegrationsControllerRemoveIntegrationResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: Array<components.IntegrationResponseDto$Outbound>;
};

/** @internal */
export const IntegrationsControllerRemoveIntegrationResponse$outboundSchema: z.ZodType<
  IntegrationsControllerRemoveIntegrationResponse$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerRemoveIntegrationResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.array(components.IntegrationResponseDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerRemoveIntegrationResponse$ {
  /** @deprecated use `IntegrationsControllerRemoveIntegrationResponse$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerRemoveIntegrationResponse$inboundSchema;
  /** @deprecated use `IntegrationsControllerRemoveIntegrationResponse$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerRemoveIntegrationResponse$outboundSchema;
  /** @deprecated use `IntegrationsControllerRemoveIntegrationResponse$Outbound` instead. */
  export type Outbound = IntegrationsControllerRemoveIntegrationResponse$Outbound;
}

export function integrationsControllerRemoveIntegrationResponseToJSON(
  integrationsControllerRemoveIntegrationResponse: IntegrationsControllerRemoveIntegrationResponse
): string {
  return JSON.stringify(
    IntegrationsControllerRemoveIntegrationResponse$outboundSchema.parse(
      integrationsControllerRemoveIntegrationResponse
    )
  );
}

export function integrationsControllerRemoveIntegrationResponseFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerRemoveIntegrationResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerRemoveIntegrationResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerRemoveIntegrationResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsControllerRemoveIntegrationRequestToJSON(integrationsControllerRemoveIntegrationRequest: IntegrationsControllerRemoveIntegrationRequest)
 - integrationsControllerRemoveIntegrationRequestFromJSON(jsonString: string)
 - integrationsControllerRemoveIntegrationResponseToJSON(integrationsControllerRemoveIntegrationResponse: IntegrationsControllerRemoveIntegrationResponse)
 - integrationsControllerRemoveIntegrationResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(IntegrationsControllerRemoveIntegrationRequest$Outbound;
}

export function integrationsControllerRe...)
 - Outbound(IntegrationsControllerRemoveIntegrationResponse$Outbound;
}

export function integrationsControllerR...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerRemoveIntegrationRequestToJSON
- export function integrationsControllerRemoveIntegrationRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerRemoveIntegrationResponseToJSON
- export function integrationsControllerRemoveIntegrationResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/integrationscontrollersetintegrationasprimary.ts
Tamaño: 6132 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type IntegrationsControllerSetIntegrationAsPrimaryRequest = {
  integrationId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type IntegrationsControllerSetIntegrationAsPrimaryResponse = {
  headers: { [k: string]: Array<string> };
  result: components.IntegrationResponseDto;
};

/** @internal */
export const IntegrationsControllerSetIntegrationAsPrimaryRequest$inboundSchema: z.ZodType<
  IntegrationsControllerSetIntegrationAsPrimaryRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    integrationId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type IntegrationsControllerSetIntegrationAsPrimaryRequest$Outbound = {
  integrationId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const IntegrationsControllerSetIntegrationAsPrimaryRequest$outboundSchema: z.ZodType<
  IntegrationsControllerSetIntegrationAsPrimaryRequest$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerSetIntegrationAsPrimaryRequest
> = z
  .object({
    integrationId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerSetIntegrationAsPrimaryRequest$ {
  /** @deprecated use `IntegrationsControllerSetIntegrationAsPrimaryRequest$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerSetIntegrationAsPrimaryRequest$inboundSchema;
  /** @deprecated use `IntegrationsControllerSetIntegrationAsPrimaryRequest$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerSetIntegrationAsPrimaryRequest$outboundSchema;
  /** @deprecated use `IntegrationsControllerSetIntegrationAsPrimaryRequest$Outbound` instead. */
  export type Outbound = IntegrationsControllerSetIntegrationAsPrimaryRequest$Outbound;
}

export function integrationsControllerSetIntegrationAsPrimaryRequestToJSON(
  integrationsControllerSetIntegrationAsPrimaryRequest: IntegrationsControllerSetIntegrationAsPrimaryRequest
): string {
  return JSON.stringify(
    IntegrationsControllerSetIntegrationAsPrimaryRequest$outboundSchema.parse(
      integrationsControllerSetIntegrationAsPrimaryRequest
    )
  );
}

export function integrationsControllerSetIntegrationAsPrimaryRequestFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerSetIntegrationAsPrimaryRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerSetIntegrationAsPrimaryRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerSetIntegrationAsPrimaryRequest' from JSON`
  );
}

/** @internal */
export const IntegrationsControllerSetIntegrationAsPrimaryResponse$inboundSchema: z.ZodType<
  IntegrationsControllerSetIntegrationAsPrimaryResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.IntegrationResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type IntegrationsControllerSetIntegrationAsPrimaryResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.IntegrationResponseDto$Outbound;
};

/** @internal */
export const IntegrationsControllerSetIntegrationAsPrimaryResponse$outboundSchema: z.ZodType<
  IntegrationsControllerSetIntegrationAsPrimaryResponse$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerSetIntegrationAsPrimaryResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.IntegrationResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerSetIntegrationAsPrimaryResponse$ {
  /** @deprecated use `IntegrationsControllerSetIntegrationAsPrimaryResponse$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerSetIntegrationAsPrimaryResponse$inboundSchema;
  /** @deprecated use `IntegrationsControllerSetIntegrationAsPrimaryResponse$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerSetIntegrationAsPrimaryResponse$outboundSchema;
  /** @deprecated use `IntegrationsControllerSetIntegrationAsPrimaryResponse$Outbound` instead. */
  export type Outbound = IntegrationsControllerSetIntegrationAsPrimaryResponse$Outbound;
}

export function integrationsControllerSetIntegrationAsPrimaryResponseToJSON(
  integrationsControllerSetIntegrationAsPrimaryResponse: IntegrationsControllerSetIntegrationAsPrimaryResponse
): string {
  return JSON.stringify(
    IntegrationsControllerSetIntegrationAsPrimaryResponse$outboundSchema.parse(
      integrationsControllerSetIntegrationAsPrimaryResponse
    )
  );
}

export function integrationsControllerSetIntegrationAsPrimaryResponseFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerSetIntegrationAsPrimaryResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerSetIntegrationAsPrimaryResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerSetIntegrationAsPrimaryResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsControllerSetIntegrationAsPrimaryRequestToJSON(integrationsControllerSetIntegrationAsPrimaryRequest: IntegrationsControllerSetIntegrationAsPrimaryRequest)
 - integrationsControllerSetIntegrationAsPrimaryRequestFromJSON(jsonString: string)
 - integrationsControllerSetIntegrationAsPrimaryResponseToJSON(integrationsControllerSetIntegrationAsPrimaryResponse: IntegrationsControllerSetIntegrationAsPrimaryResponse)
 - integrationsControllerSetIntegrationAsPrimaryResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(IntegrationsControllerSetIntegrationAsPrimaryRequest$Outbound;
}

export function integrationsContro...)
 - Outbound(IntegrationsControllerSetIntegrationAsPrimaryResponse$Outbound;
}

export function integrationsContr...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerSetIntegrationAsPrimaryRequestToJSON
- export function integrationsControllerSetIntegrationAsPrimaryRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerSetIntegrationAsPrimaryResponseToJSON
- export function integrationsControllerSetIntegrationAsPrimaryResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/integrationscontrollerupdateintegrationbyid.ts
Tamaño: 6498 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type IntegrationsControllerUpdateIntegrationByIdRequest = {
  integrationId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  updateIntegrationRequestDto: components.UpdateIntegrationRequestDto;
};

export type IntegrationsControllerUpdateIntegrationByIdResponse = {
  headers: { [k: string]: Array<string> };
  result: components.IntegrationResponseDto;
};

/** @internal */
export const IntegrationsControllerUpdateIntegrationByIdRequest$inboundSchema: z.ZodType<
  IntegrationsControllerUpdateIntegrationByIdRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    integrationId: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateIntegrationRequestDto: components.UpdateIntegrationRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateIntegrationRequestDto: 'updateIntegrationRequestDto',
    });
  });

/** @internal */
export type IntegrationsControllerUpdateIntegrationByIdRequest$Outbound = {
  integrationId: string;
  'idempotency-key'?: string | undefined;
  UpdateIntegrationRequestDto: components.UpdateIntegrationRequestDto$Outbound;
};

/** @internal */
export const IntegrationsControllerUpdateIntegrationByIdRequest$outboundSchema: z.ZodType<
  IntegrationsControllerUpdateIntegrationByIdRequest$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerUpdateIntegrationByIdRequest
> = z
  .object({
    integrationId: z.string(),
    idempotencyKey: z.string().optional(),
    updateIntegrationRequestDto: components.UpdateIntegrationRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateIntegrationRequestDto: 'UpdateIntegrationRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerUpdateIntegrationByIdRequest$ {
  /** @deprecated use `IntegrationsControllerUpdateIntegrationByIdRequest$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerUpdateIntegrationByIdRequest$inboundSchema;
  /** @deprecated use `IntegrationsControllerUpdateIntegrationByIdRequest$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerUpdateIntegrationByIdRequest$outboundSchema;
  /** @deprecated use `IntegrationsControllerUpdateIntegrationByIdRequest$Outbound` instead. */
  export type Outbound = IntegrationsControllerUpdateIntegrationByIdRequest$Outbound;
}

export function integrationsControllerUpdateIntegrationByIdRequestToJSON(
  integrationsControllerUpdateIntegrationByIdRequest: IntegrationsControllerUpdateIntegrationByIdRequest
): string {
  return JSON.stringify(
    IntegrationsControllerUpdateIntegrationByIdRequest$outboundSchema.parse(
      integrationsControllerUpdateIntegrationByIdRequest
    )
  );
}

export function integrationsControllerUpdateIntegrationByIdRequestFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerUpdateIntegrationByIdRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerUpdateIntegrationByIdRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerUpdateIntegrationByIdRequest' from JSON`
  );
}

/** @internal */
export const IntegrationsControllerUpdateIntegrationByIdResponse$inboundSchema: z.ZodType<
  IntegrationsControllerUpdateIntegrationByIdResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.IntegrationResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type IntegrationsControllerUpdateIntegrationByIdResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.IntegrationResponseDto$Outbound;
};

/** @internal */
export const IntegrationsControllerUpdateIntegrationByIdResponse$outboundSchema: z.ZodType<
  IntegrationsControllerUpdateIntegrationByIdResponse$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerUpdateIntegrationByIdResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.IntegrationResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerUpdateIntegrationByIdResponse$ {
  /** @deprecated use `IntegrationsControllerUpdateIntegrationByIdResponse$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerUpdateIntegrationByIdResponse$inboundSchema;
  /** @deprecated use `IntegrationsControllerUpdateIntegrationByIdResponse$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerUpdateIntegrationByIdResponse$outboundSchema;
  /** @deprecated use `IntegrationsControllerUpdateIntegrationByIdResponse$Outbound` instead. */
  export type Outbound = IntegrationsControllerUpdateIntegrationByIdResponse$Outbound;
}

export function integrationsControllerUpdateIntegrationByIdResponseToJSON(
  integrationsControllerUpdateIntegrationByIdResponse: IntegrationsControllerUpdateIntegrationByIdResponse
): string {
  return JSON.stringify(
    IntegrationsControllerUpdateIntegrationByIdResponse$outboundSchema.parse(
      integrationsControllerUpdateIntegrationByIdResponse
    )
  );
}

export function integrationsControllerUpdateIntegrationByIdResponseFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerUpdateIntegrationByIdResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerUpdateIntegrationByIdResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerUpdateIntegrationByIdResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsControllerUpdateIntegrationByIdRequestToJSON(integrationsControllerUpdateIntegrationByIdRequest: IntegrationsControllerUpdateIntegrationByIdRequest)
 - integrationsControllerUpdateIntegrationByIdRequestFromJSON(jsonString: string)
 - integrationsControllerUpdateIntegrationByIdResponseToJSON(integrationsControllerUpdateIntegrationByIdResponse: IntegrationsControllerUpdateIntegrationByIdResponse)
 - integrationsControllerUpdateIntegrationByIdResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(IntegrationsControllerUpdateIntegrationByIdRequest$Outbound;
}

export function integrationsControll...)
 - Outbound(IntegrationsControllerUpdateIntegrationByIdResponse$Outbound;
}

export function integrationsControl...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerUpdateIntegrationByIdRequestToJSON
- export function integrationsControllerUpdateIntegrationByIdRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerUpdateIntegrationByIdResponseToJSON
- export function integrationsControllerUpdateIntegrationByIdResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/layoutscontrollercreate.ts
Tamaño: 5303 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type LayoutsControllerCreateRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Layout creation details
   */
  createLayoutDto: components.CreateLayoutDto;
};

export type LayoutsControllerCreateResponse = {
  headers: { [k: string]: Array<string> };
  result: components.LayoutResponseDto;
};

/** @internal */
export const LayoutsControllerCreateRequest$inboundSchema: z.ZodType<
  LayoutsControllerCreateRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    CreateLayoutDto: components.CreateLayoutDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateLayoutDto: 'createLayoutDto',
    });
  });

/** @internal */
export type LayoutsControllerCreateRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  CreateLayoutDto: components.CreateLayoutDto$Outbound;
};

/** @internal */
export const LayoutsControllerCreateRequest$outboundSchema: z.ZodType<
  LayoutsControllerCreateRequest$Outbound,
  z.ZodTypeDef,
  LayoutsControllerCreateRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    createLayoutDto: components.CreateLayoutDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createLayoutDto: 'CreateLayoutDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerCreateRequest$ {
  /** @deprecated use `LayoutsControllerCreateRequest$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerCreateRequest$inboundSchema;
  /** @deprecated use `LayoutsControllerCreateRequest$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerCreateRequest$outboundSchema;
  /** @deprecated use `LayoutsControllerCreateRequest$Outbound` instead. */
  export type Outbound = LayoutsControllerCreateRequest$Outbound;
}

export function layoutsControllerCreateRequestToJSON(
  layoutsControllerCreateRequest: LayoutsControllerCreateRequest
): string {
  return JSON.stringify(LayoutsControllerCreateRequest$outboundSchema.parse(layoutsControllerCreateRequest));
}

export function layoutsControllerCreateRequestFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerCreateRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerCreateRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerCreateRequest' from JSON`
  );
}

/** @internal */
export const LayoutsControllerCreateResponse$inboundSchema: z.ZodType<
  LayoutsControllerCreateResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.LayoutResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type LayoutsControllerCreateResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.LayoutResponseDto$Outbound;
};

/** @internal */
export const LayoutsControllerCreateResponse$outboundSchema: z.ZodType<
  LayoutsControllerCreateResponse$Outbound,
  z.ZodTypeDef,
  LayoutsControllerCreateResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.LayoutResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerCreateResponse$ {
  /** @deprecated use `LayoutsControllerCreateResponse$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerCreateResponse$inboundSchema;
  /** @deprecated use `LayoutsControllerCreateResponse$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerCreateResponse$outboundSchema;
  /** @deprecated use `LayoutsControllerCreateResponse$Outbound` instead. */
  export type Outbound = LayoutsControllerCreateResponse$Outbound;
}

export function layoutsControllerCreateResponseToJSON(
  layoutsControllerCreateResponse: LayoutsControllerCreateResponse
): string {
  return JSON.stringify(LayoutsControllerCreateResponse$outboundSchema.parse(layoutsControllerCreateResponse));
}

export function layoutsControllerCreateResponseFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerCreateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerCreateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerCreateResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsControllerCreateRequestToJSON(layoutsControllerCreateRequest: LayoutsControllerCreateRequest)
 - layoutsControllerCreateRequestFromJSON(jsonString: string)
 - layoutsControllerCreateResponseToJSON(layoutsControllerCreateResponse: LayoutsControllerCreateResponse)
 - layoutsControllerCreateResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutsControllerCreateRequest$Outbound;
}

export function layoutsControllerCreateRequestToJSON(
  ...)
 - Outbound(LayoutsControllerCreateResponse$Outbound;
}

export function layoutsControllerCreateResponseToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerCreateRequestToJSON
- export function layoutsControllerCreateRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerCreateResponseToJSON
- export function layoutsControllerCreateResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/layoutscontrollerdelete.ts
Tamaño: 4789 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type LayoutsControllerDeleteRequest = {
  /**
   * The unique identifier of the layout
   */
  layoutId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type LayoutsControllerDeleteResponse = {
  headers: { [k: string]: Array<string> };
};

/** @internal */
export const LayoutsControllerDeleteRequest$inboundSchema: z.ZodType<
  LayoutsControllerDeleteRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    layoutId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type LayoutsControllerDeleteRequest$Outbound = {
  layoutId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const LayoutsControllerDeleteRequest$outboundSchema: z.ZodType<
  LayoutsControllerDeleteRequest$Outbound,
  z.ZodTypeDef,
  LayoutsControllerDeleteRequest
> = z
  .object({
    layoutId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerDeleteRequest$ {
  /** @deprecated use `LayoutsControllerDeleteRequest$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerDeleteRequest$inboundSchema;
  /** @deprecated use `LayoutsControllerDeleteRequest$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerDeleteRequest$outboundSchema;
  /** @deprecated use `LayoutsControllerDeleteRequest$Outbound` instead. */
  export type Outbound = LayoutsControllerDeleteRequest$Outbound;
}

export function layoutsControllerDeleteRequestToJSON(
  layoutsControllerDeleteRequest: LayoutsControllerDeleteRequest
): string {
  return JSON.stringify(LayoutsControllerDeleteRequest$outboundSchema.parse(layoutsControllerDeleteRequest));
}

export function layoutsControllerDeleteRequestFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerDeleteRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerDeleteRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerDeleteRequest' from JSON`
  );
}

/** @internal */
export const LayoutsControllerDeleteResponse$inboundSchema: z.ZodType<
  LayoutsControllerDeleteResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
    });
  });

/** @internal */
export type LayoutsControllerDeleteResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
};

/** @internal */
export const LayoutsControllerDeleteResponse$outboundSchema: z.ZodType<
  LayoutsControllerDeleteResponse$Outbound,
  z.ZodTypeDef,
  LayoutsControllerDeleteResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerDeleteResponse$ {
  /** @deprecated use `LayoutsControllerDeleteResponse$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerDeleteResponse$inboundSchema;
  /** @deprecated use `LayoutsControllerDeleteResponse$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerDeleteResponse$outboundSchema;
  /** @deprecated use `LayoutsControllerDeleteResponse$Outbound` instead. */
  export type Outbound = LayoutsControllerDeleteResponse$Outbound;
}

export function layoutsControllerDeleteResponseToJSON(
  layoutsControllerDeleteResponse: LayoutsControllerDeleteResponse
): string {
  return JSON.stringify(LayoutsControllerDeleteResponse$outboundSchema.parse(layoutsControllerDeleteResponse));
}

export function layoutsControllerDeleteResponseFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerDeleteResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerDeleteResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerDeleteResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsControllerDeleteRequestToJSON(layoutsControllerDeleteRequest: LayoutsControllerDeleteRequest)
 - layoutsControllerDeleteRequestFromJSON(jsonString: string)
 - layoutsControllerDeleteResponseToJSON(layoutsControllerDeleteResponse: LayoutsControllerDeleteResponse)
 - layoutsControllerDeleteResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutsControllerDeleteRequest$Outbound;
}

export function layoutsControllerDeleteRequestToJSON(
  ...)
 - Outbound(LayoutsControllerDeleteResponse$Outbound;
}

export function layoutsControllerDeleteResponseToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerDeleteRequestToJSON
- export function layoutsControllerDeleteRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerDeleteResponseToJSON
- export function layoutsControllerDeleteResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/layoutscontrollerduplicate.ts
Tamaño: 5528 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type LayoutsControllerDuplicateRequest = {
  layoutId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  duplicateLayoutDto: components.DuplicateLayoutDto;
};

export type LayoutsControllerDuplicateResponse = {
  headers: { [k: string]: Array<string> };
  result: components.LayoutResponseDto;
};

/** @internal */
export const LayoutsControllerDuplicateRequest$inboundSchema: z.ZodType<
  LayoutsControllerDuplicateRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    layoutId: z.string(),
    'idempotency-key': z.string().optional(),
    DuplicateLayoutDto: components.DuplicateLayoutDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      DuplicateLayoutDto: 'duplicateLayoutDto',
    });
  });

/** @internal */
export type LayoutsControllerDuplicateRequest$Outbound = {
  layoutId: string;
  'idempotency-key'?: string | undefined;
  DuplicateLayoutDto: components.DuplicateLayoutDto$Outbound;
};

/** @internal */
export const LayoutsControllerDuplicateRequest$outboundSchema: z.ZodType<
  LayoutsControllerDuplicateRequest$Outbound,
  z.ZodTypeDef,
  LayoutsControllerDuplicateRequest
> = z
  .object({
    layoutId: z.string(),
    idempotencyKey: z.string().optional(),
    duplicateLayoutDto: components.DuplicateLayoutDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      duplicateLayoutDto: 'DuplicateLayoutDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerDuplicateRequest$ {
  /** @deprecated use `LayoutsControllerDuplicateRequest$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerDuplicateRequest$inboundSchema;
  /** @deprecated use `LayoutsControllerDuplicateRequest$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerDuplicateRequest$outboundSchema;
  /** @deprecated use `LayoutsControllerDuplicateRequest$Outbound` instead. */
  export type Outbound = LayoutsControllerDuplicateRequest$Outbound;
}

export function layoutsControllerDuplicateRequestToJSON(
  layoutsControllerDuplicateRequest: LayoutsControllerDuplicateRequest
): string {
  return JSON.stringify(LayoutsControllerDuplicateRequest$outboundSchema.parse(layoutsControllerDuplicateRequest));
}

export function layoutsControllerDuplicateRequestFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerDuplicateRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerDuplicateRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerDuplicateRequest' from JSON`
  );
}

/** @internal */
export const LayoutsControllerDuplicateResponse$inboundSchema: z.ZodType<
  LayoutsControllerDuplicateResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.LayoutResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type LayoutsControllerDuplicateResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.LayoutResponseDto$Outbound;
};

/** @internal */
export const LayoutsControllerDuplicateResponse$outboundSchema: z.ZodType<
  LayoutsControllerDuplicateResponse$Outbound,
  z.ZodTypeDef,
  LayoutsControllerDuplicateResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.LayoutResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerDuplicateResponse$ {
  /** @deprecated use `LayoutsControllerDuplicateResponse$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerDuplicateResponse$inboundSchema;
  /** @deprecated use `LayoutsControllerDuplicateResponse$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerDuplicateResponse$outboundSchema;
  /** @deprecated use `LayoutsControllerDuplicateResponse$Outbound` instead. */
  export type Outbound = LayoutsControllerDuplicateResponse$Outbound;
}

export function layoutsControllerDuplicateResponseToJSON(
  layoutsControllerDuplicateResponse: LayoutsControllerDuplicateResponse
): string {
  return JSON.stringify(LayoutsControllerDuplicateResponse$outboundSchema.parse(layoutsControllerDuplicateResponse));
}

export function layoutsControllerDuplicateResponseFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerDuplicateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerDuplicateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerDuplicateResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsControllerDuplicateRequestToJSON(layoutsControllerDuplicateRequest: LayoutsControllerDuplicateRequest)
 - layoutsControllerDuplicateRequestFromJSON(jsonString: string)
 - layoutsControllerDuplicateResponseToJSON(layoutsControllerDuplicateResponse: LayoutsControllerDuplicateResponse)
 - layoutsControllerDuplicateResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutsControllerDuplicateRequest$Outbound;
}

export function layoutsControllerDuplicateRequestToJS...)
 - Outbound(LayoutsControllerDuplicateResponse$Outbound;
}

export function layoutsControllerDuplicateResponseTo...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerDuplicateRequestToJSON
- export function layoutsControllerDuplicateRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerDuplicateResponseToJSON
- export function layoutsControllerDuplicateResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/layoutscontrollergeneratepreview.ts
Tamaño: 5991 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type LayoutsControllerGeneratePreviewRequest = {
  layoutId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Layout preview generation details
   */
  layoutPreviewRequestDto: components.LayoutPreviewRequestDto;
};

export type LayoutsControllerGeneratePreviewResponse = {
  headers: { [k: string]: Array<string> };
  result: components.GenerateLayoutPreviewResponseDto;
};

/** @internal */
export const LayoutsControllerGeneratePreviewRequest$inboundSchema: z.ZodType<
  LayoutsControllerGeneratePreviewRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    layoutId: z.string(),
    'idempotency-key': z.string().optional(),
    LayoutPreviewRequestDto: components.LayoutPreviewRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      LayoutPreviewRequestDto: 'layoutPreviewRequestDto',
    });
  });

/** @internal */
export type LayoutsControllerGeneratePreviewRequest$Outbound = {
  layoutId: string;
  'idempotency-key'?: string | undefined;
  LayoutPreviewRequestDto: components.LayoutPreviewRequestDto$Outbound;
};

/** @internal */
export const LayoutsControllerGeneratePreviewRequest$outboundSchema: z.ZodType<
  LayoutsControllerGeneratePreviewRequest$Outbound,
  z.ZodTypeDef,
  LayoutsControllerGeneratePreviewRequest
> = z
  .object({
    layoutId: z.string(),
    idempotencyKey: z.string().optional(),
    layoutPreviewRequestDto: components.LayoutPreviewRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      layoutPreviewRequestDto: 'LayoutPreviewRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerGeneratePreviewRequest$ {
  /** @deprecated use `LayoutsControllerGeneratePreviewRequest$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerGeneratePreviewRequest$inboundSchema;
  /** @deprecated use `LayoutsControllerGeneratePreviewRequest$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerGeneratePreviewRequest$outboundSchema;
  /** @deprecated use `LayoutsControllerGeneratePreviewRequest$Outbound` instead. */
  export type Outbound = LayoutsControllerGeneratePreviewRequest$Outbound;
}

export function layoutsControllerGeneratePreviewRequestToJSON(
  layoutsControllerGeneratePreviewRequest: LayoutsControllerGeneratePreviewRequest
): string {
  return JSON.stringify(
    LayoutsControllerGeneratePreviewRequest$outboundSchema.parse(layoutsControllerGeneratePreviewRequest)
  );
}

export function layoutsControllerGeneratePreviewRequestFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerGeneratePreviewRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerGeneratePreviewRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerGeneratePreviewRequest' from JSON`
  );
}

/** @internal */
export const LayoutsControllerGeneratePreviewResponse$inboundSchema: z.ZodType<
  LayoutsControllerGeneratePreviewResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.GenerateLayoutPreviewResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type LayoutsControllerGeneratePreviewResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.GenerateLayoutPreviewResponseDto$Outbound;
};

/** @internal */
export const LayoutsControllerGeneratePreviewResponse$outboundSchema: z.ZodType<
  LayoutsControllerGeneratePreviewResponse$Outbound,
  z.ZodTypeDef,
  LayoutsControllerGeneratePreviewResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.GenerateLayoutPreviewResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerGeneratePreviewResponse$ {
  /** @deprecated use `LayoutsControllerGeneratePreviewResponse$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerGeneratePreviewResponse$inboundSchema;
  /** @deprecated use `LayoutsControllerGeneratePreviewResponse$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerGeneratePreviewResponse$outboundSchema;
  /** @deprecated use `LayoutsControllerGeneratePreviewResponse$Outbound` instead. */
  export type Outbound = LayoutsControllerGeneratePreviewResponse$Outbound;
}

export function layoutsControllerGeneratePreviewResponseToJSON(
  layoutsControllerGeneratePreviewResponse: LayoutsControllerGeneratePreviewResponse
): string {
  return JSON.stringify(
    LayoutsControllerGeneratePreviewResponse$outboundSchema.parse(layoutsControllerGeneratePreviewResponse)
  );
}

export function layoutsControllerGeneratePreviewResponseFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerGeneratePreviewResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerGeneratePreviewResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerGeneratePreviewResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsControllerGeneratePreviewRequestToJSON(layoutsControllerGeneratePreviewRequest: LayoutsControllerGeneratePreviewRequest)
 - layoutsControllerGeneratePreviewRequestFromJSON(jsonString: string)
 - layoutsControllerGeneratePreviewResponseToJSON(layoutsControllerGeneratePreviewResponse: LayoutsControllerGeneratePreviewResponse)
 - layoutsControllerGeneratePreviewResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutsControllerGeneratePreviewRequest$Outbound;
}

export function layoutsControllerGeneratePrevie...)
 - Outbound(LayoutsControllerGeneratePreviewResponse$Outbound;
}

export function layoutsControllerGeneratePrevi...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerGeneratePreviewRequestToJSON
- export function layoutsControllerGeneratePreviewRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerGeneratePreviewResponseToJSON
- export function layoutsControllerGeneratePreviewResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/layoutscontrollerget.ts
Tamaño: 4906 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type LayoutsControllerGetRequest = {
  layoutId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type LayoutsControllerGetResponse = {
  headers: { [k: string]: Array<string> };
  result: components.LayoutResponseDto;
};

/** @internal */
export const LayoutsControllerGetRequest$inboundSchema: z.ZodType<LayoutsControllerGetRequest, z.ZodTypeDef, unknown> =
  z
    .object({
      layoutId: z.string(),
      'idempotency-key': z.string().optional(),
    })
    .transform((v) => {
      return remap$(v, {
        'idempotency-key': 'idempotencyKey',
      });
    });

/** @internal */
export type LayoutsControllerGetRequest$Outbound = {
  layoutId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const LayoutsControllerGetRequest$outboundSchema: z.ZodType<
  LayoutsControllerGetRequest$Outbound,
  z.ZodTypeDef,
  LayoutsControllerGetRequest
> = z
  .object({
    layoutId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerGetRequest$ {
  /** @deprecated use `LayoutsControllerGetRequest$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerGetRequest$inboundSchema;
  /** @deprecated use `LayoutsControllerGetRequest$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerGetRequest$outboundSchema;
  /** @deprecated use `LayoutsControllerGetRequest$Outbound` instead. */
  export type Outbound = LayoutsControllerGetRequest$Outbound;
}

export function layoutsControllerGetRequestToJSON(layoutsControllerGetRequest: LayoutsControllerGetRequest): string {
  return JSON.stringify(LayoutsControllerGetRequest$outboundSchema.parse(layoutsControllerGetRequest));
}

export function layoutsControllerGetRequestFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerGetRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerGetRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerGetRequest' from JSON`
  );
}

/** @internal */
export const LayoutsControllerGetResponse$inboundSchema: z.ZodType<
  LayoutsControllerGetResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.LayoutResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type LayoutsControllerGetResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.LayoutResponseDto$Outbound;
};

/** @internal */
export const LayoutsControllerGetResponse$outboundSchema: z.ZodType<
  LayoutsControllerGetResponse$Outbound,
  z.ZodTypeDef,
  LayoutsControllerGetResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.LayoutResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerGetResponse$ {
  /** @deprecated use `LayoutsControllerGetResponse$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerGetResponse$inboundSchema;
  /** @deprecated use `LayoutsControllerGetResponse$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerGetResponse$outboundSchema;
  /** @deprecated use `LayoutsControllerGetResponse$Outbound` instead. */
  export type Outbound = LayoutsControllerGetResponse$Outbound;
}

export function layoutsControllerGetResponseToJSON(layoutsControllerGetResponse: LayoutsControllerGetResponse): string {
  return JSON.stringify(LayoutsControllerGetResponse$outboundSchema.parse(layoutsControllerGetResponse));
}

export function layoutsControllerGetResponseFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerGetResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerGetResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerGetResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsControllerGetRequestToJSON(layoutsControllerGetRequest: LayoutsControllerGetRequest)
 - layoutsControllerGetRequestFromJSON(jsonString: string)
 - layoutsControllerGetResponseToJSON(layoutsControllerGetResponse: LayoutsControllerGetResponse)
 - layoutsControllerGetResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutsControllerGetRequest$Outbound;
}

export function layoutsControllerGetRequestToJSON(layoutsCo...)
 - Outbound(LayoutsControllerGetResponse$Outbound;
}

export function layoutsControllerGetResponseToJSON(layouts...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerGetRequestToJSON
- export function layoutsControllerGetRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerGetResponseToJSON
- export function layoutsControllerGetResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/layoutscontrollergetusage.ts
Tamaño: 5164 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type LayoutsControllerGetUsageRequest = {
  layoutId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type LayoutsControllerGetUsageResponse = {
  headers: { [k: string]: Array<string> };
  result: components.GetLayoutUsageResponseDto;
};

/** @internal */
export const LayoutsControllerGetUsageRequest$inboundSchema: z.ZodType<
  LayoutsControllerGetUsageRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    layoutId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type LayoutsControllerGetUsageRequest$Outbound = {
  layoutId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const LayoutsControllerGetUsageRequest$outboundSchema: z.ZodType<
  LayoutsControllerGetUsageRequest$Outbound,
  z.ZodTypeDef,
  LayoutsControllerGetUsageRequest
> = z
  .object({
    layoutId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerGetUsageRequest$ {
  /** @deprecated use `LayoutsControllerGetUsageRequest$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerGetUsageRequest$inboundSchema;
  /** @deprecated use `LayoutsControllerGetUsageRequest$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerGetUsageRequest$outboundSchema;
  /** @deprecated use `LayoutsControllerGetUsageRequest$Outbound` instead. */
  export type Outbound = LayoutsControllerGetUsageRequest$Outbound;
}

export function layoutsControllerGetUsageRequestToJSON(
  layoutsControllerGetUsageRequest: LayoutsControllerGetUsageRequest
): string {
  return JSON.stringify(LayoutsControllerGetUsageRequest$outboundSchema.parse(layoutsControllerGetUsageRequest));
}

export function layoutsControllerGetUsageRequestFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerGetUsageRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerGetUsageRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerGetUsageRequest' from JSON`
  );
}

/** @internal */
export const LayoutsControllerGetUsageResponse$inboundSchema: z.ZodType<
  LayoutsControllerGetUsageResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.GetLayoutUsageResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type LayoutsControllerGetUsageResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.GetLayoutUsageResponseDto$Outbound;
};

/** @internal */
export const LayoutsControllerGetUsageResponse$outboundSchema: z.ZodType<
  LayoutsControllerGetUsageResponse$Outbound,
  z.ZodTypeDef,
  LayoutsControllerGetUsageResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.GetLayoutUsageResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerGetUsageResponse$ {
  /** @deprecated use `LayoutsControllerGetUsageResponse$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerGetUsageResponse$inboundSchema;
  /** @deprecated use `LayoutsControllerGetUsageResponse$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerGetUsageResponse$outboundSchema;
  /** @deprecated use `LayoutsControllerGetUsageResponse$Outbound` instead. */
  export type Outbound = LayoutsControllerGetUsageResponse$Outbound;
}

export function layoutsControllerGetUsageResponseToJSON(
  layoutsControllerGetUsageResponse: LayoutsControllerGetUsageResponse
): string {
  return JSON.stringify(LayoutsControllerGetUsageResponse$outboundSchema.parse(layoutsControllerGetUsageResponse));
}

export function layoutsControllerGetUsageResponseFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerGetUsageResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerGetUsageResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerGetUsageResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsControllerGetUsageRequestToJSON(layoutsControllerGetUsageRequest: LayoutsControllerGetUsageRequest)
 - layoutsControllerGetUsageRequestFromJSON(jsonString: string)
 - layoutsControllerGetUsageResponseToJSON(layoutsControllerGetUsageResponse: LayoutsControllerGetUsageResponse)
 - layoutsControllerGetUsageResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutsControllerGetUsageRequest$Outbound;
}

export function layoutsControllerGetUsageRequestToJSON...)
 - Outbound(LayoutsControllerGetUsageResponse$Outbound;
}

export function layoutsControllerGetUsageResponseToJS...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerGetUsageRequestToJSON
- export function layoutsControllerGetUsageRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerGetUsageResponseToJSON
- export function layoutsControllerGetUsageResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/layoutscontrollerlist.ts
Tamaño: 6004 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type LayoutsControllerListRequest = {
  /**
   * Number of items to return per page
   */
  limit?: number | undefined;
  /**
   * Number of items to skip before starting to return results
   */
  offset?: number | undefined;
  /**
   * Direction of sorting
   */
  orderDirection?: components.DirectionEnum | undefined;
  /**
   * Field to sort the results by
   */
  orderBy?: components.LayoutResponseDtoSortField | undefined;
  /**
   * Search query to filter layouts
   */
  query?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type LayoutsControllerListResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ListLayoutResponseDto;
};

/** @internal */
export const LayoutsControllerListRequest$inboundSchema: z.ZodType<
  LayoutsControllerListRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    limit: z.number().optional(),
    offset: z.number().optional(),
    orderDirection: components.DirectionEnum$inboundSchema.optional(),
    orderBy: components.LayoutResponseDtoSortField$inboundSchema.optional(),
    query: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type LayoutsControllerListRequest$Outbound = {
  limit?: number | undefined;
  offset?: number | undefined;
  orderDirection?: string | undefined;
  orderBy?: string | undefined;
  query?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const LayoutsControllerListRequest$outboundSchema: z.ZodType<
  LayoutsControllerListRequest$Outbound,
  z.ZodTypeDef,
  LayoutsControllerListRequest
> = z
  .object({
    limit: z.number().optional(),
    offset: z.number().optional(),
    orderDirection: components.DirectionEnum$outboundSchema.optional(),
    orderBy: components.LayoutResponseDtoSortField$outboundSchema.optional(),
    query: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerListRequest$ {
  /** @deprecated use `LayoutsControllerListRequest$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerListRequest$inboundSchema;
  /** @deprecated use `LayoutsControllerListRequest$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerListRequest$outboundSchema;
  /** @deprecated use `LayoutsControllerListRequest$Outbound` instead. */
  export type Outbound = LayoutsControllerListRequest$Outbound;
}

export function layoutsControllerListRequestToJSON(layoutsControllerListRequest: LayoutsControllerListRequest): string {
  return JSON.stringify(LayoutsControllerListRequest$outboundSchema.parse(layoutsControllerListRequest));
}

export function layoutsControllerListRequestFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerListRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerListRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerListRequest' from JSON`
  );
}

/** @internal */
export const LayoutsControllerListResponse$inboundSchema: z.ZodType<
  LayoutsControllerListResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ListLayoutResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type LayoutsControllerListResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ListLayoutResponseDto$Outbound;
};

/** @internal */
export const LayoutsControllerListResponse$outboundSchema: z.ZodType<
  LayoutsControllerListResponse$Outbound,
  z.ZodTypeDef,
  LayoutsControllerListResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ListLayoutResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerListResponse$ {
  /** @deprecated use `LayoutsControllerListResponse$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerListResponse$inboundSchema;
  /** @deprecated use `LayoutsControllerListResponse$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerListResponse$outboundSchema;
  /** @deprecated use `LayoutsControllerListResponse$Outbound` instead. */
  export type Outbound = LayoutsControllerListResponse$Outbound;
}

export function layoutsControllerListResponseToJSON(
  layoutsControllerListResponse: LayoutsControllerListResponse
): string {
  return JSON.stringify(LayoutsControllerListResponse$outboundSchema.parse(layoutsControllerListResponse));
}

export function layoutsControllerListResponseFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerListResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerListResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerListResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsControllerListRequestToJSON(layoutsControllerListRequest: LayoutsControllerListRequest)
 - layoutsControllerListRequestFromJSON(jsonString: string)
 - layoutsControllerListResponseToJSON(layoutsControllerListResponse: LayoutsControllerListResponse)
 - layoutsControllerListResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutsControllerListRequest$Outbound;
}

export function layoutsControllerListRequestToJSON(layouts...)
 - Outbound(LayoutsControllerListResponse$Outbound;
}

export function layoutsControllerListResponseToJSON(
  la...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerListRequestToJSON
- export function layoutsControllerListRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerListResponseToJSON
- export function layoutsControllerListResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/layoutscontrollerupdate.ts
Tamaño: 5393 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type LayoutsControllerUpdateRequest = {
  layoutId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Layout update details
   */
  updateLayoutDto: components.UpdateLayoutDto;
};

export type LayoutsControllerUpdateResponse = {
  headers: { [k: string]: Array<string> };
  result: components.LayoutResponseDto;
};

/** @internal */
export const LayoutsControllerUpdateRequest$inboundSchema: z.ZodType<
  LayoutsControllerUpdateRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    layoutId: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateLayoutDto: components.UpdateLayoutDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateLayoutDto: 'updateLayoutDto',
    });
  });

/** @internal */
export type LayoutsControllerUpdateRequest$Outbound = {
  layoutId: string;
  'idempotency-key'?: string | undefined;
  UpdateLayoutDto: components.UpdateLayoutDto$Outbound;
};

/** @internal */
export const LayoutsControllerUpdateRequest$outboundSchema: z.ZodType<
  LayoutsControllerUpdateRequest$Outbound,
  z.ZodTypeDef,
  LayoutsControllerUpdateRequest
> = z
  .object({
    layoutId: z.string(),
    idempotencyKey: z.string().optional(),
    updateLayoutDto: components.UpdateLayoutDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateLayoutDto: 'UpdateLayoutDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerUpdateRequest$ {
  /** @deprecated use `LayoutsControllerUpdateRequest$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerUpdateRequest$inboundSchema;
  /** @deprecated use `LayoutsControllerUpdateRequest$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerUpdateRequest$outboundSchema;
  /** @deprecated use `LayoutsControllerUpdateRequest$Outbound` instead. */
  export type Outbound = LayoutsControllerUpdateRequest$Outbound;
}

export function layoutsControllerUpdateRequestToJSON(
  layoutsControllerUpdateRequest: LayoutsControllerUpdateRequest
): string {
  return JSON.stringify(LayoutsControllerUpdateRequest$outboundSchema.parse(layoutsControllerUpdateRequest));
}

export function layoutsControllerUpdateRequestFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerUpdateRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerUpdateRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerUpdateRequest' from JSON`
  );
}

/** @internal */
export const LayoutsControllerUpdateResponse$inboundSchema: z.ZodType<
  LayoutsControllerUpdateResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.LayoutResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type LayoutsControllerUpdateResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.LayoutResponseDto$Outbound;
};

/** @internal */
export const LayoutsControllerUpdateResponse$outboundSchema: z.ZodType<
  LayoutsControllerUpdateResponse$Outbound,
  z.ZodTypeDef,
  LayoutsControllerUpdateResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.LayoutResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerUpdateResponse$ {
  /** @deprecated use `LayoutsControllerUpdateResponse$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerUpdateResponse$inboundSchema;
  /** @deprecated use `LayoutsControllerUpdateResponse$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerUpdateResponse$outboundSchema;
  /** @deprecated use `LayoutsControllerUpdateResponse$Outbound` instead. */
  export type Outbound = LayoutsControllerUpdateResponse$Outbound;
}

export function layoutsControllerUpdateResponseToJSON(
  layoutsControllerUpdateResponse: LayoutsControllerUpdateResponse
): string {
  return JSON.stringify(LayoutsControllerUpdateResponse$outboundSchema.parse(layoutsControllerUpdateResponse));
}

export function layoutsControllerUpdateResponseFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerUpdateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerUpdateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerUpdateResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsControllerUpdateRequestToJSON(layoutsControllerUpdateRequest: LayoutsControllerUpdateRequest)
 - layoutsControllerUpdateRequestFromJSON(jsonString: string)
 - layoutsControllerUpdateResponseToJSON(layoutsControllerUpdateResponse: LayoutsControllerUpdateResponse)
 - layoutsControllerUpdateResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutsControllerUpdateRequest$Outbound;
}

export function layoutsControllerUpdateRequestToJSON(
  ...)
 - Outbound(LayoutsControllerUpdateResponse$Outbound;
}

export function layoutsControllerUpdateResponseToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerUpdateRequestToJSON
- export function layoutsControllerUpdateRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerUpdateResponseToJSON
- export function layoutsControllerUpdateResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/messagescontrollerdeletemessage.ts
Tamaño: 5456 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type MessagesControllerDeleteMessageRequest = {
  messageId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type MessagesControllerDeleteMessageResponse = {
  headers: { [k: string]: Array<string> };
  result: components.DeleteMessageResponseDto;
};

/** @internal */
export const MessagesControllerDeleteMessageRequest$inboundSchema: z.ZodType<
  MessagesControllerDeleteMessageRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    messageId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type MessagesControllerDeleteMessageRequest$Outbound = {
  messageId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const MessagesControllerDeleteMessageRequest$outboundSchema: z.ZodType<
  MessagesControllerDeleteMessageRequest$Outbound,
  z.ZodTypeDef,
  MessagesControllerDeleteMessageRequest
> = z
  .object({
    messageId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesControllerDeleteMessageRequest$ {
  /** @deprecated use `MessagesControllerDeleteMessageRequest$inboundSchema` instead. */
  export const inboundSchema = MessagesControllerDeleteMessageRequest$inboundSchema;
  /** @deprecated use `MessagesControllerDeleteMessageRequest$outboundSchema` instead. */
  export const outboundSchema = MessagesControllerDeleteMessageRequest$outboundSchema;
  /** @deprecated use `MessagesControllerDeleteMessageRequest$Outbound` instead. */
  export type Outbound = MessagesControllerDeleteMessageRequest$Outbound;
}

export function messagesControllerDeleteMessageRequestToJSON(
  messagesControllerDeleteMessageRequest: MessagesControllerDeleteMessageRequest
): string {
  return JSON.stringify(
    MessagesControllerDeleteMessageRequest$outboundSchema.parse(messagesControllerDeleteMessageRequest)
  );
}

export function messagesControllerDeleteMessageRequestFromJSON(
  jsonString: string
): SafeParseResult<MessagesControllerDeleteMessageRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesControllerDeleteMessageRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesControllerDeleteMessageRequest' from JSON`
  );
}

/** @internal */
export const MessagesControllerDeleteMessageResponse$inboundSchema: z.ZodType<
  MessagesControllerDeleteMessageResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.DeleteMessageResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type MessagesControllerDeleteMessageResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.DeleteMessageResponseDto$Outbound;
};

/** @internal */
export const MessagesControllerDeleteMessageResponse$outboundSchema: z.ZodType<
  MessagesControllerDeleteMessageResponse$Outbound,
  z.ZodTypeDef,
  MessagesControllerDeleteMessageResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.DeleteMessageResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesControllerDeleteMessageResponse$ {
  /** @deprecated use `MessagesControllerDeleteMessageResponse$inboundSchema` instead. */
  export const inboundSchema = MessagesControllerDeleteMessageResponse$inboundSchema;
  /** @deprecated use `MessagesControllerDeleteMessageResponse$outboundSchema` instead. */
  export const outboundSchema = MessagesControllerDeleteMessageResponse$outboundSchema;
  /** @deprecated use `MessagesControllerDeleteMessageResponse$Outbound` instead. */
  export type Outbound = MessagesControllerDeleteMessageResponse$Outbound;
}

export function messagesControllerDeleteMessageResponseToJSON(
  messagesControllerDeleteMessageResponse: MessagesControllerDeleteMessageResponse
): string {
  return JSON.stringify(
    MessagesControllerDeleteMessageResponse$outboundSchema.parse(messagesControllerDeleteMessageResponse)
  );
}

export function messagesControllerDeleteMessageResponseFromJSON(
  jsonString: string
): SafeParseResult<MessagesControllerDeleteMessageResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesControllerDeleteMessageResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesControllerDeleteMessageResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messagesControllerDeleteMessageRequestToJSON(messagesControllerDeleteMessageRequest: MessagesControllerDeleteMessageRequest)
 - messagesControllerDeleteMessageRequestFromJSON(jsonString: string)
 - messagesControllerDeleteMessageResponseToJSON(messagesControllerDeleteMessageResponse: MessagesControllerDeleteMessageResponse)
 - messagesControllerDeleteMessageResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessagesControllerDeleteMessageRequest$Outbound;
}

export function messagesControllerDeleteMessageR...)
 - Outbound(MessagesControllerDeleteMessageResponse$Outbound;
}

export function messagesControllerDeleteMessage...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagesControllerDeleteMessageRequestToJSON
- export function messagesControllerDeleteMessageRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagesControllerDeleteMessageResponseToJSON
- export function messagesControllerDeleteMessageResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/messagescontrollerdeletemessagesbytransactionid.ts
Tamaño: 7079 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * The channel of the message to be deleted
 */
export const Channel = {
  InApp: 'in_app',
  Email: 'email',
  Sms: 'sms',
  Chat: 'chat',
  Push: 'push',
} as const;
/**
 * The channel of the message to be deleted
 */
export type Channel = ClosedEnum<typeof Channel>;

export type MessagesControllerDeleteMessagesByTransactionIdRequest = {
  /**
   * The channel of the message to be deleted
   */
  channel?: Channel | undefined;
  transactionId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type MessagesControllerDeleteMessagesByTransactionIdResponse = {
  headers: { [k: string]: Array<string> };
};

/** @internal */
export const Channel$inboundSchema: z.ZodNativeEnum<typeof Channel> = z.nativeEnum(Channel);

/** @internal */
export const Channel$outboundSchema: z.ZodNativeEnum<typeof Channel> = Channel$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Channel$ {
  /** @deprecated use `Channel$inboundSchema` instead. */
  export const inboundSchema = Channel$inboundSchema;
  /** @deprecated use `Channel$outboundSchema` instead. */
  export const outboundSchema = Channel$outboundSchema;
}

/** @internal */
export const MessagesControllerDeleteMessagesByTransactionIdRequest$inboundSchema: z.ZodType<
  MessagesControllerDeleteMessagesByTransactionIdRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    channel: Channel$inboundSchema.optional(),
    transactionId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type MessagesControllerDeleteMessagesByTransactionIdRequest$Outbound = {
  channel?: string | undefined;
  transactionId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const MessagesControllerDeleteMessagesByTransactionIdRequest$outboundSchema: z.ZodType<
  MessagesControllerDeleteMessagesByTransactionIdRequest$Outbound,
  z.ZodTypeDef,
  MessagesControllerDeleteMessagesByTransactionIdRequest
> = z
  .object({
    channel: Channel$outboundSchema.optional(),
    transactionId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesControllerDeleteMessagesByTransactionIdRequest$ {
  /** @deprecated use `MessagesControllerDeleteMessagesByTransactionIdRequest$inboundSchema` instead. */
  export const inboundSchema = MessagesControllerDeleteMessagesByTransactionIdRequest$inboundSchema;
  /** @deprecated use `MessagesControllerDeleteMessagesByTransactionIdRequest$outboundSchema` instead. */
  export const outboundSchema = MessagesControllerDeleteMessagesByTransactionIdRequest$outboundSchema;
  /** @deprecated use `MessagesControllerDeleteMessagesByTransactionIdRequest$Outbound` instead. */
  export type Outbound = MessagesControllerDeleteMessagesByTransactionIdRequest$Outbound;
}

export function messagesControllerDeleteMessagesByTransactionIdRequestToJSON(
  messagesControllerDeleteMessagesByTransactionIdRequest: MessagesControllerDeleteMessagesByTransactionIdRequest
): string {
  return JSON.stringify(
    MessagesControllerDeleteMessagesByTransactionIdRequest$outboundSchema.parse(
      messagesControllerDeleteMessagesByTransactionIdRequest
    )
  );
}

export function messagesControllerDeleteMessagesByTransactionIdRequestFromJSON(
  jsonString: string
): SafeParseResult<MessagesControllerDeleteMessagesByTransactionIdRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesControllerDeleteMessagesByTransactionIdRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesControllerDeleteMessagesByTransactionIdRequest' from JSON`
  );
}

/** @internal */
export const MessagesControllerDeleteMessagesByTransactionIdResponse$inboundSchema: z.ZodType<
  MessagesControllerDeleteMessagesByTransactionIdResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
    });
  });

/** @internal */
export type MessagesControllerDeleteMessagesByTransactionIdResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
};

/** @internal */
export const MessagesControllerDeleteMessagesByTransactionIdResponse$outboundSchema: z.ZodType<
  MessagesControllerDeleteMessagesByTransactionIdResponse$Outbound,
  z.ZodTypeDef,
  MessagesControllerDeleteMessagesByTransactionIdResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesControllerDeleteMessagesByTransactionIdResponse$ {
  /** @deprecated use `MessagesControllerDeleteMessagesByTransactionIdResponse$inboundSchema` instead. */
  export const inboundSchema = MessagesControllerDeleteMessagesByTransactionIdResponse$inboundSchema;
  /** @deprecated use `MessagesControllerDeleteMessagesByTransactionIdResponse$outboundSchema` instead. */
  export const outboundSchema = MessagesControllerDeleteMessagesByTransactionIdResponse$outboundSchema;
  /** @deprecated use `MessagesControllerDeleteMessagesByTransactionIdResponse$Outbound` instead. */
  export type Outbound = MessagesControllerDeleteMessagesByTransactionIdResponse$Outbound;
}

export function messagesControllerDeleteMessagesByTransactionIdResponseToJSON(
  messagesControllerDeleteMessagesByTransactionIdResponse: MessagesControllerDeleteMessagesByTransactionIdResponse
): string {
  return JSON.stringify(
    MessagesControllerDeleteMessagesByTransactionIdResponse$outboundSchema.parse(
      messagesControllerDeleteMessagesByTransactionIdResponse
    )
  );
}

export function messagesControllerDeleteMessagesByTransactionIdResponseFromJSON(
  jsonString: string
): SafeParseResult<MessagesControllerDeleteMessagesByTransactionIdResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesControllerDeleteMessagesByTransactionIdResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesControllerDeleteMessagesByTransactionIdResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messagesControllerDeleteMessagesByTransactionIdRequestToJSON(messagesControllerDeleteMessagesByTransactionIdRequest: MessagesControllerDeleteMessagesByTransactionIdRequest)
 - messagesControllerDeleteMessagesByTransactionIdRequestFromJSON(jsonString: string)
 - messagesControllerDeleteMessagesByTransactionIdResponseToJSON(messagesControllerDeleteMessagesByTransactionIdResponse: MessagesControllerDeleteMessagesByTransactionIdResponse)
 - messagesControllerDeleteMessagesByTransactionIdResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessagesControllerDeleteMessagesByTransactionIdRequest$Outbound;
}

export function messagesControll...)
 - Outbound(MessagesControllerDeleteMessagesByTransactionIdResponse$Outbound;
}

export function messagesControl...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagesControllerDeleteMessagesByTransactionIdRequestToJSON
- export function messagesControllerDeleteMessagesByTransactionIdRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagesControllerDeleteMessagesByTransactionIdResponseToJSON
- export function messagesControllerDeleteMessagesByTransactionIdResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/messagescontrollergetmessages.ts
Tamaño: 6355 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type MessagesControllerGetMessagesRequest = {
  /**
   * Channel type through which the message is sent
   */
  channel?: components.ChannelTypeEnum | undefined;
  subscriberId?: string | undefined;
  transactionId?: Array<string> | undefined;
  /**
   * Filter by exact context keys (format: "type:id")
   */
  contextKeys?: Array<string> | undefined;
  page?: number | undefined;
  limit?: number | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type MessagesControllerGetMessagesResponse = {
  headers: { [k: string]: Array<string> };
  result: components.MessagesResponseDto;
};

/** @internal */
export const MessagesControllerGetMessagesRequest$inboundSchema: z.ZodType<
  MessagesControllerGetMessagesRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    channel: components.ChannelTypeEnum$inboundSchema.optional(),
    subscriberId: z.string().optional(),
    transactionId: z.array(z.string()).optional(),
    contextKeys: z.array(z.string()).optional(),
    page: z.number().default(0),
    limit: z.number().default(10),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type MessagesControllerGetMessagesRequest$Outbound = {
  channel?: string | undefined;
  subscriberId?: string | undefined;
  transactionId?: Array<string> | undefined;
  contextKeys?: Array<string> | undefined;
  page: number;
  limit: number;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const MessagesControllerGetMessagesRequest$outboundSchema: z.ZodType<
  MessagesControllerGetMessagesRequest$Outbound,
  z.ZodTypeDef,
  MessagesControllerGetMessagesRequest
> = z
  .object({
    channel: components.ChannelTypeEnum$outboundSchema.optional(),
    subscriberId: z.string().optional(),
    transactionId: z.array(z.string()).optional(),
    contextKeys: z.array(z.string()).optional(),
    page: z.number().default(0),
    limit: z.number().default(10),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesControllerGetMessagesRequest$ {
  /** @deprecated use `MessagesControllerGetMessagesRequest$inboundSchema` instead. */
  export const inboundSchema = MessagesControllerGetMessagesRequest$inboundSchema;
  /** @deprecated use `MessagesControllerGetMessagesRequest$outboundSchema` instead. */
  export const outboundSchema = MessagesControllerGetMessagesRequest$outboundSchema;
  /** @deprecated use `MessagesControllerGetMessagesRequest$Outbound` instead. */
  export type Outbound = MessagesControllerGetMessagesRequest$Outbound;
}

export function messagesControllerGetMessagesRequestToJSON(
  messagesControllerGetMessagesRequest: MessagesControllerGetMessagesRequest
): string {
  return JSON.stringify(
    MessagesControllerGetMessagesRequest$outboundSchema.parse(messagesControllerGetMessagesRequest)
  );
}

export function messagesControllerGetMessagesRequestFromJSON(
  jsonString: string
): SafeParseResult<MessagesControllerGetMessagesRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesControllerGetMessagesRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesControllerGetMessagesRequest' from JSON`
  );
}

/** @internal */
export const MessagesControllerGetMessagesResponse$inboundSchema: z.ZodType<
  MessagesControllerGetMessagesResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.MessagesResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type MessagesControllerGetMessagesResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.MessagesResponseDto$Outbound;
};

/** @internal */
export const MessagesControllerGetMessagesResponse$outboundSchema: z.ZodType<
  MessagesControllerGetMessagesResponse$Outbound,
  z.ZodTypeDef,
  MessagesControllerGetMessagesResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.MessagesResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesControllerGetMessagesResponse$ {
  /** @deprecated use `MessagesControllerGetMessagesResponse$inboundSchema` instead. */
  export const inboundSchema = MessagesControllerGetMessagesResponse$inboundSchema;
  /** @deprecated use `MessagesControllerGetMessagesResponse$outboundSchema` instead. */
  export const outboundSchema = MessagesControllerGetMessagesResponse$outboundSchema;
  /** @deprecated use `MessagesControllerGetMessagesResponse$Outbound` instead. */
  export type Outbound = MessagesControllerGetMessagesResponse$Outbound;
}

export function messagesControllerGetMessagesResponseToJSON(
  messagesControllerGetMessagesResponse: MessagesControllerGetMessagesResponse
): string {
  return JSON.stringify(
    MessagesControllerGetMessagesResponse$outboundSchema.parse(messagesControllerGetMessagesResponse)
  );
}

export function messagesControllerGetMessagesResponseFromJSON(
  jsonString: string
): SafeParseResult<MessagesControllerGetMessagesResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesControllerGetMessagesResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesControllerGetMessagesResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messagesControllerGetMessagesRequestToJSON(messagesControllerGetMessagesRequest: MessagesControllerGetMessagesRequest)
 - messagesControllerGetMessagesRequestFromJSON(jsonString: string)
 - messagesControllerGetMessagesResponseToJSON(messagesControllerGetMessagesResponse: MessagesControllerGetMessagesResponse)
 - messagesControllerGetMessagesResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessagesControllerGetMessagesRequest$Outbound;
}

export function messagesControllerGetMessagesReque...)
 - Outbound(MessagesControllerGetMessagesResponse$Outbound;
}

export function messagesControllerGetMessagesResp...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagesControllerGetMessagesRequestToJSON
- export function messagesControllerGetMessagesRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagesControllerGetMessagesResponseToJSON
- export function messagesControllerGetMessagesResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/notificationscontrollergetnotification.ts
Tamaño: 5826 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type NotificationsControllerGetNotificationRequest = {
  notificationId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type NotificationsControllerGetNotificationResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ActivityNotificationResponseDto;
};

/** @internal */
export const NotificationsControllerGetNotificationRequest$inboundSchema: z.ZodType<
  NotificationsControllerGetNotificationRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    notificationId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type NotificationsControllerGetNotificationRequest$Outbound = {
  notificationId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const NotificationsControllerGetNotificationRequest$outboundSchema: z.ZodType<
  NotificationsControllerGetNotificationRequest$Outbound,
  z.ZodTypeDef,
  NotificationsControllerGetNotificationRequest
> = z
  .object({
    notificationId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationsControllerGetNotificationRequest$ {
  /** @deprecated use `NotificationsControllerGetNotificationRequest$inboundSchema` instead. */
  export const inboundSchema = NotificationsControllerGetNotificationRequest$inboundSchema;
  /** @deprecated use `NotificationsControllerGetNotificationRequest$outboundSchema` instead. */
  export const outboundSchema = NotificationsControllerGetNotificationRequest$outboundSchema;
  /** @deprecated use `NotificationsControllerGetNotificationRequest$Outbound` instead. */
  export type Outbound = NotificationsControllerGetNotificationRequest$Outbound;
}

export function notificationsControllerGetNotificationRequestToJSON(
  notificationsControllerGetNotificationRequest: NotificationsControllerGetNotificationRequest
): string {
  return JSON.stringify(
    NotificationsControllerGetNotificationRequest$outboundSchema.parse(notificationsControllerGetNotificationRequest)
  );
}

export function notificationsControllerGetNotificationRequestFromJSON(
  jsonString: string
): SafeParseResult<NotificationsControllerGetNotificationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationsControllerGetNotificationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationsControllerGetNotificationRequest' from JSON`
  );
}

/** @internal */
export const NotificationsControllerGetNotificationResponse$inboundSchema: z.ZodType<
  NotificationsControllerGetNotificationResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ActivityNotificationResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type NotificationsControllerGetNotificationResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ActivityNotificationResponseDto$Outbound;
};

/** @internal */
export const NotificationsControllerGetNotificationResponse$outboundSchema: z.ZodType<
  NotificationsControllerGetNotificationResponse$Outbound,
  z.ZodTypeDef,
  NotificationsControllerGetNotificationResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ActivityNotificationResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationsControllerGetNotificationResponse$ {
  /** @deprecated use `NotificationsControllerGetNotificationResponse$inboundSchema` instead. */
  export const inboundSchema = NotificationsControllerGetNotificationResponse$inboundSchema;
  /** @deprecated use `NotificationsControllerGetNotificationResponse$outboundSchema` instead. */
  export const outboundSchema = NotificationsControllerGetNotificationResponse$outboundSchema;
  /** @deprecated use `NotificationsControllerGetNotificationResponse$Outbound` instead. */
  export type Outbound = NotificationsControllerGetNotificationResponse$Outbound;
}

export function notificationsControllerGetNotificationResponseToJSON(
  notificationsControllerGetNotificationResponse: NotificationsControllerGetNotificationResponse
): string {
  return JSON.stringify(
    NotificationsControllerGetNotificationResponse$outboundSchema.parse(notificationsControllerGetNotificationResponse)
  );
}

export function notificationsControllerGetNotificationResponseFromJSON(
  jsonString: string
): SafeParseResult<NotificationsControllerGetNotificationResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationsControllerGetNotificationResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationsControllerGetNotificationResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationsControllerGetNotificationRequestToJSON(notificationsControllerGetNotificationRequest: NotificationsControllerGetNotificationRequest)
 - notificationsControllerGetNotificationRequestFromJSON(jsonString: string)
 - notificationsControllerGetNotificationResponseToJSON(notificationsControllerGetNotificationResponse: NotificationsControllerGetNotificationResponse)
 - notificationsControllerGetNotificationResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(NotificationsControllerGetNotificationRequest$Outbound;
}

export function notificationsControllerGe...)
 - Outbound(NotificationsControllerGetNotificationResponse$Outbound;
}

export function notificationsControllerG...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationsControllerGetNotificationRequestToJSON
- export function notificationsControllerGetNotificationRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationsControllerGetNotificationResponseToJSON
- export function notificationsControllerGetNotificationResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/notificationscontrollerlistnotifications.ts
Tamaño: 8801 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type NotificationsControllerListNotificationsRequest = {
  /**
   * Array of channel types
   */
  channels?: Array<components.ChannelTypeEnum> | undefined;
  /**
   * Array of template IDs or a single template ID
   */
  templates?: Array<string> | undefined;
  /**
   * Array of email addresses or a single email address
   */
  emails?: Array<string> | undefined;
  /**
   * Search term (deprecated)
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  search?: string | undefined;
  /**
   * Array of subscriber IDs or a single subscriber ID
   */
  subscriberIds?: Array<string> | undefined;
  /**
   * Array of severity levels or a single severity level
   */
  severity?: Array<string> | undefined;
  /**
   * Page number for pagination
   */
  page?: number | undefined;
  /**
   * Limit for pagination
   */
  limit?: number | undefined;
  /**
   * The transaction ID to filter by
   */
  transactionId?: string | undefined;
  /**
   * Topic Key for filtering notifications by topic
   */
  topicKey?: string | undefined;
  /**
   * Filter by exact context keys (format: "type:id")
   */
  contextKeys?: Array<string> | undefined;
  /**
   * Date filter for records after this timestamp. Defaults to earliest date allowed by subscription plan
   */
  after?: string | undefined;
  /**
   * Date filter for records before this timestamp. Defaults to current time of request (now)
   */
  before?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type NotificationsControllerListNotificationsResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ActivitiesResponseDto;
};

/** @internal */
export const NotificationsControllerListNotificationsRequest$inboundSchema: z.ZodType<
  NotificationsControllerListNotificationsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    channels: z.array(components.ChannelTypeEnum$inboundSchema).optional(),
    templates: z.array(z.string()).optional(),
    emails: z.array(z.string()).optional(),
    search: z.string().optional(),
    subscriberIds: z.array(z.string()).optional(),
    severity: z.array(z.string()).optional(),
    page: z.number().default(0),
    limit: z.number().default(10),
    transactionId: z.string().optional(),
    topicKey: z.string().optional(),
    contextKeys: z.array(z.string()).optional(),
    after: z.string().optional(),
    before: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type NotificationsControllerListNotificationsRequest$Outbound = {
  channels?: Array<string> | undefined;
  templates?: Array<string> | undefined;
  emails?: Array<string> | undefined;
  search?: string | undefined;
  subscriberIds?: Array<string> | undefined;
  severity?: Array<string> | undefined;
  page: number;
  limit: number;
  transactionId?: string | undefined;
  topicKey?: string | undefined;
  contextKeys?: Array<string> | undefined;
  after?: string | undefined;
  before?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const NotificationsControllerListNotificationsRequest$outboundSchema: z.ZodType<
  NotificationsControllerListNotificationsRequest$Outbound,
  z.ZodTypeDef,
  NotificationsControllerListNotificationsRequest
> = z
  .object({
    channels: z.array(components.ChannelTypeEnum$outboundSchema).optional(),
    templates: z.array(z.string()).optional(),
    emails: z.array(z.string()).optional(),
    search: z.string().optional(),
    subscriberIds: z.array(z.string()).optional(),
    severity: z.array(z.string()).optional(),
    page: z.number().default(0),
    limit: z.number().default(10),
    transactionId: z.string().optional(),
    topicKey: z.string().optional(),
    contextKeys: z.array(z.string()).optional(),
    after: z.string().optional(),
    before: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationsControllerListNotificationsRequest$ {
  /** @deprecated use `NotificationsControllerListNotificationsRequest$inboundSchema` instead. */
  export const inboundSchema = NotificationsControllerListNotificationsRequest$inboundSchema;
  /** @deprecated use `NotificationsControllerListNotificationsRequest$outboundSchema` instead. */
  export const outboundSchema = NotificationsControllerListNotificationsRequest$outboundSchema;
  /** @deprecated use `NotificationsControllerListNotificationsRequest$Outbound` instead. */
  export type Outbound = NotificationsControllerListNotificationsRequest$Outbound;
}

export function notificationsControllerListNotificationsRequestToJSON(
  notificationsControllerListNotificationsRequest: NotificationsControllerListNotificationsRequest
): string {
  return JSON.stringify(
    NotificationsControllerListNotificationsRequest$outboundSchema.parse(
      notificationsControllerListNotificationsRequest
    )
  );
}

export function notificationsControllerListNotificationsRequestFromJSON(
  jsonString: string
): SafeParseResult<NotificationsControllerListNotificationsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationsControllerListNotificationsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationsControllerListNotificationsRequest' from JSON`
  );
}

/** @internal */
export const NotificationsControllerListNotificationsResponse$inboundSchema: z.ZodType<
  NotificationsControllerListNotificationsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ActivitiesResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type NotificationsControllerListNotificationsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ActivitiesResponseDto$Outbound;
};

/** @internal */
export const NotificationsControllerListNotificationsResponse$outboundSchema: z.ZodType<
  NotificationsControllerListNotificationsResponse$Outbound,
  z.ZodTypeDef,
  NotificationsControllerListNotificationsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ActivitiesResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationsControllerListNotificationsResponse$ {
  /** @deprecated use `NotificationsControllerListNotificationsResponse$inboundSchema` instead. */
  export const inboundSchema = NotificationsControllerListNotificationsResponse$inboundSchema;
  /** @deprecated use `NotificationsControllerListNotificationsResponse$outboundSchema` instead. */
  export const outboundSchema = NotificationsControllerListNotificationsResponse$outboundSchema;
  /** @deprecated use `NotificationsControllerListNotificationsResponse$Outbound` instead. */
  export type Outbound = NotificationsControllerListNotificationsResponse$Outbound;
}

export function notificationsControllerListNotificationsResponseToJSON(
  notificationsControllerListNotificationsResponse: NotificationsControllerListNotificationsResponse
): string {
  return JSON.stringify(
    NotificationsControllerListNotificationsResponse$outboundSchema.parse(
      notificationsControllerListNotificationsResponse
    )
  );
}

export function notificationsControllerListNotificationsResponseFromJSON(
  jsonString: string
): SafeParseResult<NotificationsControllerListNotificationsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationsControllerListNotificationsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationsControllerListNotificationsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationsControllerListNotificationsRequestToJSON(notificationsControllerListNotificationsRequest: NotificationsControllerListNotificationsRequest)
 - notificationsControllerListNotificationsRequestFromJSON(jsonString: string)
 - notificationsControllerListNotificationsResponseToJSON(notificationsControllerListNotificationsResponse: NotificationsControllerListNotificationsResponse)
 - notificationsControllerListNotificationsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(NotificationsControllerListNotificationsRequest$Outbound;
}

export function notificationsController...)
 - Outbound(NotificationsControllerListNotificationsResponse$Outbound;
}

export function notificationsControlle...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationsControllerListNotificationsRequestToJSON
- export function notificationsControllerListNotificationsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationsControllerListNotificationsResponseToJSON
- export function notificationsControllerListNotificationsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollerbulkupdatesubscriberpreferences.ts
Tamaño: 7036 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersControllerBulkUpdateSubscriberPreferencesRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  bulkUpdateSubscriberPreferencesDto: components.BulkUpdateSubscriberPreferencesDto;
};

export type SubscribersControllerBulkUpdateSubscriberPreferencesResponse = {
  headers: { [k: string]: Array<string> };
  result: Array<components.GetPreferencesResponseDto>;
};

/** @internal */
export const SubscribersControllerBulkUpdateSubscriberPreferencesRequest$inboundSchema: z.ZodType<
  SubscribersControllerBulkUpdateSubscriberPreferencesRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    BulkUpdateSubscriberPreferencesDto: components.BulkUpdateSubscriberPreferencesDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      BulkUpdateSubscriberPreferencesDto: 'bulkUpdateSubscriberPreferencesDto',
    });
  });

/** @internal */
export type SubscribersControllerBulkUpdateSubscriberPreferencesRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  BulkUpdateSubscriberPreferencesDto: components.BulkUpdateSubscriberPreferencesDto$Outbound;
};

/** @internal */
export const SubscribersControllerBulkUpdateSubscriberPreferencesRequest$outboundSchema: z.ZodType<
  SubscribersControllerBulkUpdateSubscriberPreferencesRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerBulkUpdateSubscriberPreferencesRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    bulkUpdateSubscriberPreferencesDto: components.BulkUpdateSubscriberPreferencesDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      bulkUpdateSubscriberPreferencesDto: 'BulkUpdateSubscriberPreferencesDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerBulkUpdateSubscriberPreferencesRequest$ {
  /** @deprecated use `SubscribersControllerBulkUpdateSubscriberPreferencesRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerBulkUpdateSubscriberPreferencesRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerBulkUpdateSubscriberPreferencesRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerBulkUpdateSubscriberPreferencesRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerBulkUpdateSubscriberPreferencesRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerBulkUpdateSubscriberPreferencesRequest$Outbound;
}

export function subscribersControllerBulkUpdateSubscriberPreferencesRequestToJSON(
  subscribersControllerBulkUpdateSubscriberPreferencesRequest: SubscribersControllerBulkUpdateSubscriberPreferencesRequest
): string {
  return JSON.stringify(
    SubscribersControllerBulkUpdateSubscriberPreferencesRequest$outboundSchema.parse(
      subscribersControllerBulkUpdateSubscriberPreferencesRequest
    )
  );
}

export function subscribersControllerBulkUpdateSubscriberPreferencesRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerBulkUpdateSubscriberPreferencesRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerBulkUpdateSubscriberPreferencesRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerBulkUpdateSubscriberPreferencesRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerBulkUpdateSubscriberPreferencesResponse$inboundSchema: z.ZodType<
  SubscribersControllerBulkUpdateSubscriberPreferencesResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.array(components.GetPreferencesResponseDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerBulkUpdateSubscriberPreferencesResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: Array<components.GetPreferencesResponseDto$Outbound>;
};

/** @internal */
export const SubscribersControllerBulkUpdateSubscriberPreferencesResponse$outboundSchema: z.ZodType<
  SubscribersControllerBulkUpdateSubscriberPreferencesResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerBulkUpdateSubscriberPreferencesResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.array(components.GetPreferencesResponseDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerBulkUpdateSubscriberPreferencesResponse$ {
  /** @deprecated use `SubscribersControllerBulkUpdateSubscriberPreferencesResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerBulkUpdateSubscriberPreferencesResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerBulkUpdateSubscriberPreferencesResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerBulkUpdateSubscriberPreferencesResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerBulkUpdateSubscriberPreferencesResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerBulkUpdateSubscriberPreferencesResponse$Outbound;
}

export function subscribersControllerBulkUpdateSubscriberPreferencesResponseToJSON(
  subscribersControllerBulkUpdateSubscriberPreferencesResponse: SubscribersControllerBulkUpdateSubscriberPreferencesResponse
): string {
  return JSON.stringify(
    SubscribersControllerBulkUpdateSubscriberPreferencesResponse$outboundSchema.parse(
      subscribersControllerBulkUpdateSubscriberPreferencesResponse
    )
  );
}

export function subscribersControllerBulkUpdateSubscriberPreferencesResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerBulkUpdateSubscriberPreferencesResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerBulkUpdateSubscriberPreferencesResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerBulkUpdateSubscriberPreferencesResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerBulkUpdateSubscriberPreferencesRequestToJSON(subscribersControllerBulkUpdateSubscriberPreferencesRequest: SubscribersControllerBulkUpdateSubscriberPreferencesRequest)
 - subscribersControllerBulkUpdateSubscriberPreferencesRequestFromJSON(jsonString: string)
 - subscribersControllerBulkUpdateSubscriberPreferencesResponseToJSON(subscribersControllerBulkUpdateSubscriberPreferencesResponse: SubscribersControllerBulkUpdateSubscriberPreferencesResponse)
 - subscribersControllerBulkUpdateSubscriberPreferencesResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerBulkUpdateSubscriberPreferencesRequest$Outbound;
}

export function subscribers...)
 - Outbound(SubscribersControllerBulkUpdateSubscriberPreferencesResponse$Outbound;
}

export function subscriber...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerBulkUpdateSubscriberPreferencesRequestToJSON
- export function subscribersControllerBulkUpdateSubscriberPreferencesRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerBulkUpdateSubscriberPreferencesResponseToJSON
- export function subscribersControllerBulkUpdateSubscriberPreferencesResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollercreatesubscriber.ts
Tamaño: 6336 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersControllerCreateSubscriberRequest = {
  /**
   * If true, the request will fail if a subscriber with the same subscriberId already exists
   */
  failIfExists?: boolean | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  createSubscriberRequestDto: components.CreateSubscriberRequestDto;
};

export type SubscribersControllerCreateSubscriberResponse = {
  headers: { [k: string]: Array<string> };
  result: components.SubscriberResponseDto;
};

/** @internal */
export const SubscribersControllerCreateSubscriberRequest$inboundSchema: z.ZodType<
  SubscribersControllerCreateSubscriberRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    failIfExists: z.boolean().optional(),
    'idempotency-key': z.string().optional(),
    CreateSubscriberRequestDto: components.CreateSubscriberRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateSubscriberRequestDto: 'createSubscriberRequestDto',
    });
  });

/** @internal */
export type SubscribersControllerCreateSubscriberRequest$Outbound = {
  failIfExists?: boolean | undefined;
  'idempotency-key'?: string | undefined;
  CreateSubscriberRequestDto: components.CreateSubscriberRequestDto$Outbound;
};

/** @internal */
export const SubscribersControllerCreateSubscriberRequest$outboundSchema: z.ZodType<
  SubscribersControllerCreateSubscriberRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerCreateSubscriberRequest
> = z
  .object({
    failIfExists: z.boolean().optional(),
    idempotencyKey: z.string().optional(),
    createSubscriberRequestDto: components.CreateSubscriberRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createSubscriberRequestDto: 'CreateSubscriberRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerCreateSubscriberRequest$ {
  /** @deprecated use `SubscribersControllerCreateSubscriberRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerCreateSubscriberRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerCreateSubscriberRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerCreateSubscriberRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerCreateSubscriberRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerCreateSubscriberRequest$Outbound;
}

export function subscribersControllerCreateSubscriberRequestToJSON(
  subscribersControllerCreateSubscriberRequest: SubscribersControllerCreateSubscriberRequest
): string {
  return JSON.stringify(
    SubscribersControllerCreateSubscriberRequest$outboundSchema.parse(subscribersControllerCreateSubscriberRequest)
  );
}

export function subscribersControllerCreateSubscriberRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerCreateSubscriberRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerCreateSubscriberRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerCreateSubscriberRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerCreateSubscriberResponse$inboundSchema: z.ZodType<
  SubscribersControllerCreateSubscriberResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.SubscriberResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerCreateSubscriberResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.SubscriberResponseDto$Outbound;
};

/** @internal */
export const SubscribersControllerCreateSubscriberResponse$outboundSchema: z.ZodType<
  SubscribersControllerCreateSubscriberResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerCreateSubscriberResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.SubscriberResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerCreateSubscriberResponse$ {
  /** @deprecated use `SubscribersControllerCreateSubscriberResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerCreateSubscriberResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerCreateSubscriberResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerCreateSubscriberResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerCreateSubscriberResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerCreateSubscriberResponse$Outbound;
}

export function subscribersControllerCreateSubscriberResponseToJSON(
  subscribersControllerCreateSubscriberResponse: SubscribersControllerCreateSubscriberResponse
): string {
  return JSON.stringify(
    SubscribersControllerCreateSubscriberResponse$outboundSchema.parse(subscribersControllerCreateSubscriberResponse)
  );
}

export function subscribersControllerCreateSubscriberResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerCreateSubscriberResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerCreateSubscriberResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerCreateSubscriberResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerCreateSubscriberRequestToJSON(subscribersControllerCreateSubscriberRequest: SubscribersControllerCreateSubscriberRequest)
 - subscribersControllerCreateSubscriberRequestFromJSON(jsonString: string)
 - subscribersControllerCreateSubscriberResponseToJSON(subscribersControllerCreateSubscriberResponse: SubscribersControllerCreateSubscriberResponse)
 - subscribersControllerCreateSubscriberResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerCreateSubscriberRequest$Outbound;
}

export function subscribersControllerCreat...)
 - Outbound(SubscribersControllerCreateSubscriberResponse$Outbound;
}

export function subscribersControllerCrea...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerCreateSubscriberRequestToJSON
- export function subscribersControllerCreateSubscriberRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerCreateSubscriberResponseToJSON
- export function subscribersControllerCreateSubscriberResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollergetsubscriber.ts
Tamaño: 5594 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersControllerGetSubscriberRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type SubscribersControllerGetSubscriberResponse = {
  headers: { [k: string]: Array<string> };
  result: components.SubscriberResponseDto;
};

/** @internal */
export const SubscribersControllerGetSubscriberRequest$inboundSchema: z.ZodType<
  SubscribersControllerGetSubscriberRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type SubscribersControllerGetSubscriberRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const SubscribersControllerGetSubscriberRequest$outboundSchema: z.ZodType<
  SubscribersControllerGetSubscriberRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerGetSubscriberRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerGetSubscriberRequest$ {
  /** @deprecated use `SubscribersControllerGetSubscriberRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerGetSubscriberRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerGetSubscriberRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerGetSubscriberRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerGetSubscriberRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerGetSubscriberRequest$Outbound;
}

export function subscribersControllerGetSubscriberRequestToJSON(
  subscribersControllerGetSubscriberRequest: SubscribersControllerGetSubscriberRequest
): string {
  return JSON.stringify(
    SubscribersControllerGetSubscriberRequest$outboundSchema.parse(subscribersControllerGetSubscriberRequest)
  );
}

export function subscribersControllerGetSubscriberRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerGetSubscriberRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerGetSubscriberRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerGetSubscriberRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerGetSubscriberResponse$inboundSchema: z.ZodType<
  SubscribersControllerGetSubscriberResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.SubscriberResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerGetSubscriberResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.SubscriberResponseDto$Outbound;
};

/** @internal */
export const SubscribersControllerGetSubscriberResponse$outboundSchema: z.ZodType<
  SubscribersControllerGetSubscriberResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerGetSubscriberResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.SubscriberResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerGetSubscriberResponse$ {
  /** @deprecated use `SubscribersControllerGetSubscriberResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerGetSubscriberResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerGetSubscriberResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerGetSubscriberResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerGetSubscriberResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerGetSubscriberResponse$Outbound;
}

export function subscribersControllerGetSubscriberResponseToJSON(
  subscribersControllerGetSubscriberResponse: SubscribersControllerGetSubscriberResponse
): string {
  return JSON.stringify(
    SubscribersControllerGetSubscriberResponse$outboundSchema.parse(subscribersControllerGetSubscriberResponse)
  );
}

export function subscribersControllerGetSubscriberResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerGetSubscriberResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerGetSubscriberResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerGetSubscriberResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerGetSubscriberRequestToJSON(subscribersControllerGetSubscriberRequest: SubscribersControllerGetSubscriberRequest)
 - subscribersControllerGetSubscriberRequestFromJSON(jsonString: string)
 - subscribersControllerGetSubscriberResponseToJSON(subscribersControllerGetSubscriberResponse: SubscribersControllerGetSubscriberResponse)
 - subscribersControllerGetSubscriberResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerGetSubscriberRequest$Outbound;
}

export function subscribersControllerGetSubsc...)
 - Outbound(SubscribersControllerGetSubscriberResponse$Outbound;
}

export function subscribersControllerGetSubs...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerGetSubscriberRequestToJSON
- export function subscribersControllerGetSubscriberRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerGetSubscriberResponseToJSON
- export function subscribersControllerGetSubscriberResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollergetsubscriberpreferences.ts
Tamaño: 7245 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export const Criticality = {
  Critical: 'critical',
  NonCritical: 'nonCritical',
  All: 'all',
} as const;
export type Criticality = ClosedEnum<typeof Criticality>;

export type SubscribersControllerGetSubscriberPreferencesRequest = {
  subscriberId: string;
  criticality?: Criticality | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type SubscribersControllerGetSubscriberPreferencesResponse = {
  headers: { [k: string]: Array<string> };
  result: components.GetSubscriberPreferencesDto;
};

/** @internal */
export const Criticality$inboundSchema: z.ZodNativeEnum<typeof Criticality> = z.nativeEnum(Criticality);

/** @internal */
export const Criticality$outboundSchema: z.ZodNativeEnum<typeof Criticality> = Criticality$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Criticality$ {
  /** @deprecated use `Criticality$inboundSchema` instead. */
  export const inboundSchema = Criticality$inboundSchema;
  /** @deprecated use `Criticality$outboundSchema` instead. */
  export const outboundSchema = Criticality$outboundSchema;
}

/** @internal */
export const SubscribersControllerGetSubscriberPreferencesRequest$inboundSchema: z.ZodType<
  SubscribersControllerGetSubscriberPreferencesRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    criticality: Criticality$inboundSchema.default('nonCritical'),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type SubscribersControllerGetSubscriberPreferencesRequest$Outbound = {
  subscriberId: string;
  criticality: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const SubscribersControllerGetSubscriberPreferencesRequest$outboundSchema: z.ZodType<
  SubscribersControllerGetSubscriberPreferencesRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerGetSubscriberPreferencesRequest
> = z
  .object({
    subscriberId: z.string(),
    criticality: Criticality$outboundSchema.default('nonCritical'),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerGetSubscriberPreferencesRequest$ {
  /** @deprecated use `SubscribersControllerGetSubscriberPreferencesRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerGetSubscriberPreferencesRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerGetSubscriberPreferencesRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerGetSubscriberPreferencesRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerGetSubscriberPreferencesRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerGetSubscriberPreferencesRequest$Outbound;
}

export function subscribersControllerGetSubscriberPreferencesRequestToJSON(
  subscribersControllerGetSubscriberPreferencesRequest: SubscribersControllerGetSubscriberPreferencesRequest
): string {
  return JSON.stringify(
    SubscribersControllerGetSubscriberPreferencesRequest$outboundSchema.parse(
      subscribersControllerGetSubscriberPreferencesRequest
    )
  );
}

export function subscribersControllerGetSubscriberPreferencesRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerGetSubscriberPreferencesRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerGetSubscriberPreferencesRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerGetSubscriberPreferencesRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerGetSubscriberPreferencesResponse$inboundSchema: z.ZodType<
  SubscribersControllerGetSubscriberPreferencesResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.GetSubscriberPreferencesDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerGetSubscriberPreferencesResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.GetSubscriberPreferencesDto$Outbound;
};

/** @internal */
export const SubscribersControllerGetSubscriberPreferencesResponse$outboundSchema: z.ZodType<
  SubscribersControllerGetSubscriberPreferencesResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerGetSubscriberPreferencesResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.GetSubscriberPreferencesDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerGetSubscriberPreferencesResponse$ {
  /** @deprecated use `SubscribersControllerGetSubscriberPreferencesResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerGetSubscriberPreferencesResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerGetSubscriberPreferencesResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerGetSubscriberPreferencesResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerGetSubscriberPreferencesResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerGetSubscriberPreferencesResponse$Outbound;
}

export function subscribersControllerGetSubscriberPreferencesResponseToJSON(
  subscribersControllerGetSubscriberPreferencesResponse: SubscribersControllerGetSubscriberPreferencesResponse
): string {
  return JSON.stringify(
    SubscribersControllerGetSubscriberPreferencesResponse$outboundSchema.parse(
      subscribersControllerGetSubscriberPreferencesResponse
    )
  );
}

export function subscribersControllerGetSubscriberPreferencesResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerGetSubscriberPreferencesResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerGetSubscriberPreferencesResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerGetSubscriberPreferencesResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerGetSubscriberPreferencesRequestToJSON(subscribersControllerGetSubscriberPreferencesRequest: SubscribersControllerGetSubscriberPreferencesRequest)
 - subscribersControllerGetSubscriberPreferencesRequestFromJSON(jsonString: string)
 - subscribersControllerGetSubscriberPreferencesResponseToJSON(subscribersControllerGetSubscriberPreferencesResponse: SubscribersControllerGetSubscriberPreferencesResponse)
 - subscribersControllerGetSubscriberPreferencesResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerGetSubscriberPreferencesRequest$Outbound;
}

export function subscribersControl...)
 - Outbound(SubscribersControllerGetSubscriberPreferencesResponse$Outbound;
}

export function subscribersContro...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerGetSubscriberPreferencesRequestToJSON
- export function subscribersControllerGetSubscriberPreferencesRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerGetSubscriberPreferencesResponseToJSON
- export function subscribersControllerGetSubscriberPreferencesResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollerlistsubscribertopics.ts
Tamaño: 9319 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Direction of sorting
 */
export const SubscribersControllerListSubscriberTopicsQueryParamOrderDirection = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;
/**
 * Direction of sorting
 */
export type SubscribersControllerListSubscriberTopicsQueryParamOrderDirection = ClosedEnum<
  typeof SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
>;

export type SubscribersControllerListSubscriberTopicsRequest = {
  /**
   * The identifier of the subscriber
   */
  subscriberId: string;
  /**
   * Cursor for pagination indicating the starting point after which to fetch results.
   */
  after?: string | undefined;
  /**
   * Cursor for pagination indicating the ending point before which to fetch results.
   */
  before?: string | undefined;
  /**
   * Limit the number of items to return (max 100)
   */
  limit?: number | undefined;
  /**
   * Direction of sorting
   */
  orderDirection?: SubscribersControllerListSubscriberTopicsQueryParamOrderDirection | undefined;
  /**
   * Field to order by
   */
  orderBy?: string | undefined;
  /**
   * Include cursor item in response
   */
  includeCursor?: boolean | undefined;
  /**
   * Filter by topic key
   */
  key?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type SubscribersControllerListSubscriberTopicsResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ListTopicSubscriptionsResponseDto;
};

/** @internal */
export const SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$inboundSchema: z.ZodNativeEnum<
  typeof SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
> = z.nativeEnum(SubscribersControllerListSubscriberTopicsQueryParamOrderDirection);

/** @internal */
export const SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$outboundSchema: z.ZodNativeEnum<
  typeof SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
> = SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$ {
  /** @deprecated use `SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$inboundSchema;
  /** @deprecated use `SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$outboundSchema;
}

/** @internal */
export const SubscribersControllerListSubscriberTopicsRequest$inboundSchema: z.ZodType<
  SubscribersControllerListSubscriberTopicsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$inboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    key: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type SubscribersControllerListSubscriberTopicsRequest$Outbound = {
  subscriberId: string;
  after?: string | undefined;
  before?: string | undefined;
  limit?: number | undefined;
  orderDirection?: string | undefined;
  orderBy?: string | undefined;
  includeCursor?: boolean | undefined;
  key?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const SubscribersControllerListSubscriberTopicsRequest$outboundSchema: z.ZodType<
  SubscribersControllerListSubscriberTopicsRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerListSubscriberTopicsRequest
> = z
  .object({
    subscriberId: z.string(),
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$outboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    key: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerListSubscriberTopicsRequest$ {
  /** @deprecated use `SubscribersControllerListSubscriberTopicsRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerListSubscriberTopicsRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerListSubscriberTopicsRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerListSubscriberTopicsRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerListSubscriberTopicsRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerListSubscriberTopicsRequest$Outbound;
}

export function subscribersControllerListSubscriberTopicsRequestToJSON(
  subscribersControllerListSubscriberTopicsRequest: SubscribersControllerListSubscriberTopicsRequest
): string {
  return JSON.stringify(
    SubscribersControllerListSubscriberTopicsRequest$outboundSchema.parse(
      subscribersControllerListSubscriberTopicsRequest
    )
  );
}

export function subscribersControllerListSubscriberTopicsRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerListSubscriberTopicsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerListSubscriberTopicsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerListSubscriberTopicsRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerListSubscriberTopicsResponse$inboundSchema: z.ZodType<
  SubscribersControllerListSubscriberTopicsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ListTopicSubscriptionsResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerListSubscriberTopicsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ListTopicSubscriptionsResponseDto$Outbound;
};

/** @internal */
export const SubscribersControllerListSubscriberTopicsResponse$outboundSchema: z.ZodType<
  SubscribersControllerListSubscriberTopicsResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerListSubscriberTopicsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ListTopicSubscriptionsResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerListSubscriberTopicsResponse$ {
  /** @deprecated use `SubscribersControllerListSubscriberTopicsResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerListSubscriberTopicsResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerListSubscriberTopicsResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerListSubscriberTopicsResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerListSubscriberTopicsResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerListSubscriberTopicsResponse$Outbound;
}

export function subscribersControllerListSubscriberTopicsResponseToJSON(
  subscribersControllerListSubscriberTopicsResponse: SubscribersControllerListSubscriberTopicsResponse
): string {
  return JSON.stringify(
    SubscribersControllerListSubscriberTopicsResponse$outboundSchema.parse(
      subscribersControllerListSubscriberTopicsResponse
    )
  );
}

export function subscribersControllerListSubscriberTopicsResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerListSubscriberTopicsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerListSubscriberTopicsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerListSubscriberTopicsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerListSubscriberTopicsRequestToJSON(subscribersControllerListSubscriberTopicsRequest: SubscribersControllerListSubscriberTopicsRequest)
 - subscribersControllerListSubscriberTopicsRequestFromJSON(jsonString: string)
 - subscribersControllerListSubscriberTopicsResponseToJSON(subscribersControllerListSubscriberTopicsResponse: SubscribersControllerListSubscriberTopicsResponse)
 - subscribersControllerListSubscriberTopicsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerListSubscriberTopicsRequest$Outbound;
}

export function subscribersControllerL...)
 - Outbound(SubscribersControllerListSubscriberTopicsResponse$Outbound;
}

export function subscribersController...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerListSubscriberTopicsRequestToJSON
- export function subscribersControllerListSubscriberTopicsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerListSubscriberTopicsResponseToJSON
- export function subscribersControllerListSubscriberTopicsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollerpatchsubscriber.ts
Tamaño: 6120 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersControllerPatchSubscriberRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  patchSubscriberRequestDto: components.PatchSubscriberRequestDto;
};

export type SubscribersControllerPatchSubscriberResponse = {
  headers: { [k: string]: Array<string> };
  result: components.SubscriberResponseDto;
};

/** @internal */
export const SubscribersControllerPatchSubscriberRequest$inboundSchema: z.ZodType<
  SubscribersControllerPatchSubscriberRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    PatchSubscriberRequestDto: components.PatchSubscriberRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      PatchSubscriberRequestDto: 'patchSubscriberRequestDto',
    });
  });

/** @internal */
export type SubscribersControllerPatchSubscriberRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  PatchSubscriberRequestDto: components.PatchSubscriberRequestDto$Outbound;
};

/** @internal */
export const SubscribersControllerPatchSubscriberRequest$outboundSchema: z.ZodType<
  SubscribersControllerPatchSubscriberRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerPatchSubscriberRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    patchSubscriberRequestDto: components.PatchSubscriberRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      patchSubscriberRequestDto: 'PatchSubscriberRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerPatchSubscriberRequest$ {
  /** @deprecated use `SubscribersControllerPatchSubscriberRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerPatchSubscriberRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerPatchSubscriberRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerPatchSubscriberRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerPatchSubscriberRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerPatchSubscriberRequest$Outbound;
}

export function subscribersControllerPatchSubscriberRequestToJSON(
  subscribersControllerPatchSubscriberRequest: SubscribersControllerPatchSubscriberRequest
): string {
  return JSON.stringify(
    SubscribersControllerPatchSubscriberRequest$outboundSchema.parse(subscribersControllerPatchSubscriberRequest)
  );
}

export function subscribersControllerPatchSubscriberRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerPatchSubscriberRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerPatchSubscriberRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerPatchSubscriberRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerPatchSubscriberResponse$inboundSchema: z.ZodType<
  SubscribersControllerPatchSubscriberResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.SubscriberResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerPatchSubscriberResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.SubscriberResponseDto$Outbound;
};

/** @internal */
export const SubscribersControllerPatchSubscriberResponse$outboundSchema: z.ZodType<
  SubscribersControllerPatchSubscriberResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerPatchSubscriberResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.SubscriberResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerPatchSubscriberResponse$ {
  /** @deprecated use `SubscribersControllerPatchSubscriberResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerPatchSubscriberResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerPatchSubscriberResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerPatchSubscriberResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerPatchSubscriberResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerPatchSubscriberResponse$Outbound;
}

export function subscribersControllerPatchSubscriberResponseToJSON(
  subscribersControllerPatchSubscriberResponse: SubscribersControllerPatchSubscriberResponse
): string {
  return JSON.stringify(
    SubscribersControllerPatchSubscriberResponse$outboundSchema.parse(subscribersControllerPatchSubscriberResponse)
  );
}

export function subscribersControllerPatchSubscriberResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerPatchSubscriberResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerPatchSubscriberResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerPatchSubscriberResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerPatchSubscriberRequestToJSON(subscribersControllerPatchSubscriberRequest: SubscribersControllerPatchSubscriberRequest)
 - subscribersControllerPatchSubscriberRequestFromJSON(jsonString: string)
 - subscribersControllerPatchSubscriberResponseToJSON(subscribersControllerPatchSubscriberResponse: SubscribersControllerPatchSubscriberResponse)
 - subscribersControllerPatchSubscriberResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerPatchSubscriberRequest$Outbound;
}

export function subscribersControllerPatchS...)
 - Outbound(SubscribersControllerPatchSubscriberResponse$Outbound;
}

export function subscribersControllerPatch...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerPatchSubscriberRequestToJSON
- export function subscribersControllerPatchSubscriberRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerPatchSubscriberResponseToJSON
- export function subscribersControllerPatchSubscriberResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollerremovesubscriber.ts
Tamaño: 5756 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersControllerRemoveSubscriberRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type SubscribersControllerRemoveSubscriberResponse = {
  headers: { [k: string]: Array<string> };
  result: components.RemoveSubscriberResponseDto;
};

/** @internal */
export const SubscribersControllerRemoveSubscriberRequest$inboundSchema: z.ZodType<
  SubscribersControllerRemoveSubscriberRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type SubscribersControllerRemoveSubscriberRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const SubscribersControllerRemoveSubscriberRequest$outboundSchema: z.ZodType<
  SubscribersControllerRemoveSubscriberRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerRemoveSubscriberRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerRemoveSubscriberRequest$ {
  /** @deprecated use `SubscribersControllerRemoveSubscriberRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerRemoveSubscriberRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerRemoveSubscriberRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerRemoveSubscriberRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerRemoveSubscriberRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerRemoveSubscriberRequest$Outbound;
}

export function subscribersControllerRemoveSubscriberRequestToJSON(
  subscribersControllerRemoveSubscriberRequest: SubscribersControllerRemoveSubscriberRequest
): string {
  return JSON.stringify(
    SubscribersControllerRemoveSubscriberRequest$outboundSchema.parse(subscribersControllerRemoveSubscriberRequest)
  );
}

export function subscribersControllerRemoveSubscriberRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerRemoveSubscriberRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerRemoveSubscriberRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerRemoveSubscriberRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerRemoveSubscriberResponse$inboundSchema: z.ZodType<
  SubscribersControllerRemoveSubscriberResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.RemoveSubscriberResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerRemoveSubscriberResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.RemoveSubscriberResponseDto$Outbound;
};

/** @internal */
export const SubscribersControllerRemoveSubscriberResponse$outboundSchema: z.ZodType<
  SubscribersControllerRemoveSubscriberResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerRemoveSubscriberResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.RemoveSubscriberResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerRemoveSubscriberResponse$ {
  /** @deprecated use `SubscribersControllerRemoveSubscriberResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerRemoveSubscriberResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerRemoveSubscriberResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerRemoveSubscriberResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerRemoveSubscriberResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerRemoveSubscriberResponse$Outbound;
}

export function subscribersControllerRemoveSubscriberResponseToJSON(
  subscribersControllerRemoveSubscriberResponse: SubscribersControllerRemoveSubscriberResponse
): string {
  return JSON.stringify(
    SubscribersControllerRemoveSubscriberResponse$outboundSchema.parse(subscribersControllerRemoveSubscriberResponse)
  );
}

export function subscribersControllerRemoveSubscriberResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerRemoveSubscriberResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerRemoveSubscriberResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerRemoveSubscriberResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerRemoveSubscriberRequestToJSON(subscribersControllerRemoveSubscriberRequest: SubscribersControllerRemoveSubscriberRequest)
 - subscribersControllerRemoveSubscriberRequestFromJSON(jsonString: string)
 - subscribersControllerRemoveSubscriberResponseToJSON(subscribersControllerRemoveSubscriberResponse: SubscribersControllerRemoveSubscriberResponse)
 - subscribersControllerRemoveSubscriberResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerRemoveSubscriberRequest$Outbound;
}

export function subscribersControllerRemov...)
 - Outbound(SubscribersControllerRemoveSubscriberResponse$Outbound;
}

export function subscribersControllerRemo...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerRemoveSubscriberRequestToJSON
- export function subscribersControllerRemoveSubscriberRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerRemoveSubscriberResponseToJSON
- export function subscribersControllerRemoveSubscriberResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollersearchsubscribers.ts
Tamaño: 8901 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Direction of sorting
 */
export const QueryParamOrderDirection = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;
/**
 * Direction of sorting
 */
export type QueryParamOrderDirection = ClosedEnum<typeof QueryParamOrderDirection>;

export type SubscribersControllerSearchSubscribersRequest = {
  /**
   * Cursor for pagination indicating the starting point after which to fetch results.
   */
  after?: string | undefined;
  /**
   * Cursor for pagination indicating the ending point before which to fetch results.
   */
  before?: string | undefined;
  /**
   * Limit the number of items to return
   */
  limit?: number | undefined;
  /**
   * Direction of sorting
   */
  orderDirection?: QueryParamOrderDirection | undefined;
  /**
   * Field to order by
   */
  orderBy?: string | undefined;
  /**
   * Include cursor item in response
   */
  includeCursor?: boolean | undefined;
  /**
   * Email address of the subscriber to filter results.
   */
  email?: string | undefined;
  /**
   * Name of the subscriber to filter results.
   */
  name?: string | undefined;
  /**
   * Phone number of the subscriber to filter results.
   */
  phone?: string | undefined;
  /**
   * Unique identifier of the subscriber to filter results.
   */
  subscriberId?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type SubscribersControllerSearchSubscribersResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ListSubscribersResponseDto;
};

/** @internal */
export const QueryParamOrderDirection$inboundSchema: z.ZodNativeEnum<typeof QueryParamOrderDirection> =
  z.nativeEnum(QueryParamOrderDirection);

/** @internal */
export const QueryParamOrderDirection$outboundSchema: z.ZodNativeEnum<typeof QueryParamOrderDirection> =
  QueryParamOrderDirection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueryParamOrderDirection$ {
  /** @deprecated use `QueryParamOrderDirection$inboundSchema` instead. */
  export const inboundSchema = QueryParamOrderDirection$inboundSchema;
  /** @deprecated use `QueryParamOrderDirection$outboundSchema` instead. */
  export const outboundSchema = QueryParamOrderDirection$outboundSchema;
}

/** @internal */
export const SubscribersControllerSearchSubscribersRequest$inboundSchema: z.ZodType<
  SubscribersControllerSearchSubscribersRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: QueryParamOrderDirection$inboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    email: z.string().optional(),
    name: z.string().optional(),
    phone: z.string().optional(),
    subscriberId: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type SubscribersControllerSearchSubscribersRequest$Outbound = {
  after?: string | undefined;
  before?: string | undefined;
  limit?: number | undefined;
  orderDirection?: string | undefined;
  orderBy?: string | undefined;
  includeCursor?: boolean | undefined;
  email?: string | undefined;
  name?: string | undefined;
  phone?: string | undefined;
  subscriberId?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const SubscribersControllerSearchSubscribersRequest$outboundSchema: z.ZodType<
  SubscribersControllerSearchSubscribersRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerSearchSubscribersRequest
> = z
  .object({
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: QueryParamOrderDirection$outboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    email: z.string().optional(),
    name: z.string().optional(),
    phone: z.string().optional(),
    subscriberId: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerSearchSubscribersRequest$ {
  /** @deprecated use `SubscribersControllerSearchSubscribersRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerSearchSubscribersRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerSearchSubscribersRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerSearchSubscribersRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerSearchSubscribersRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerSearchSubscribersRequest$Outbound;
}

export function subscribersControllerSearchSubscribersRequestToJSON(
  subscribersControllerSearchSubscribersRequest: SubscribersControllerSearchSubscribersRequest
): string {
  return JSON.stringify(
    SubscribersControllerSearchSubscribersRequest$outboundSchema.parse(subscribersControllerSearchSubscribersRequest)
  );
}

export function subscribersControllerSearchSubscribersRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerSearchSubscribersRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerSearchSubscribersRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerSearchSubscribersRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerSearchSubscribersResponse$inboundSchema: z.ZodType<
  SubscribersControllerSearchSubscribersResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ListSubscribersResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerSearchSubscribersResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ListSubscribersResponseDto$Outbound;
};

/** @internal */
export const SubscribersControllerSearchSubscribersResponse$outboundSchema: z.ZodType<
  SubscribersControllerSearchSubscribersResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerSearchSubscribersResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ListSubscribersResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerSearchSubscribersResponse$ {
  /** @deprecated use `SubscribersControllerSearchSubscribersResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerSearchSubscribersResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerSearchSubscribersResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerSearchSubscribersResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerSearchSubscribersResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerSearchSubscribersResponse$Outbound;
}

export function subscribersControllerSearchSubscribersResponseToJSON(
  subscribersControllerSearchSubscribersResponse: SubscribersControllerSearchSubscribersResponse
): string {
  return JSON.stringify(
    SubscribersControllerSearchSubscribersResponse$outboundSchema.parse(subscribersControllerSearchSubscribersResponse)
  );
}

export function subscribersControllerSearchSubscribersResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerSearchSubscribersResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerSearchSubscribersResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerSearchSubscribersResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerSearchSubscribersRequestToJSON(subscribersControllerSearchSubscribersRequest: SubscribersControllerSearchSubscribersRequest)
 - subscribersControllerSearchSubscribersRequestFromJSON(jsonString: string)
 - subscribersControllerSearchSubscribersResponseToJSON(subscribersControllerSearchSubscribersResponse: SubscribersControllerSearchSubscribersResponse)
 - subscribersControllerSearchSubscribersResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerSearchSubscribersRequest$Outbound;
}

export function subscribersControllerSear...)
 - Outbound(SubscribersControllerSearchSubscribersResponse$Outbound;
}

export function subscribersControllerSea...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerSearchSubscribersRequestToJSON
- export function subscribersControllerSearchSubscribersRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerSearchSubscribersResponseToJSON
- export function subscribersControllerSearchSubscribersResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollerupdatesubscriberpreferences.ts
Tamaño: 6768 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersControllerUpdateSubscriberPreferencesRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  patchSubscriberPreferencesDto: components.PatchSubscriberPreferencesDto;
};

export type SubscribersControllerUpdateSubscriberPreferencesResponse = {
  headers: { [k: string]: Array<string> };
  result: components.GetSubscriberPreferencesDto;
};

/** @internal */
export const SubscribersControllerUpdateSubscriberPreferencesRequest$inboundSchema: z.ZodType<
  SubscribersControllerUpdateSubscriberPreferencesRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    PatchSubscriberPreferencesDto: components.PatchSubscriberPreferencesDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      PatchSubscriberPreferencesDto: 'patchSubscriberPreferencesDto',
    });
  });

/** @internal */
export type SubscribersControllerUpdateSubscriberPreferencesRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  PatchSubscriberPreferencesDto: components.PatchSubscriberPreferencesDto$Outbound;
};

/** @internal */
export const SubscribersControllerUpdateSubscriberPreferencesRequest$outboundSchema: z.ZodType<
  SubscribersControllerUpdateSubscriberPreferencesRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerUpdateSubscriberPreferencesRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    patchSubscriberPreferencesDto: components.PatchSubscriberPreferencesDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      patchSubscriberPreferencesDto: 'PatchSubscriberPreferencesDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerUpdateSubscriberPreferencesRequest$ {
  /** @deprecated use `SubscribersControllerUpdateSubscriberPreferencesRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerUpdateSubscriberPreferencesRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerUpdateSubscriberPreferencesRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerUpdateSubscriberPreferencesRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerUpdateSubscriberPreferencesRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerUpdateSubscriberPreferencesRequest$Outbound;
}

export function subscribersControllerUpdateSubscriberPreferencesRequestToJSON(
  subscribersControllerUpdateSubscriberPreferencesRequest: SubscribersControllerUpdateSubscriberPreferencesRequest
): string {
  return JSON.stringify(
    SubscribersControllerUpdateSubscriberPreferencesRequest$outboundSchema.parse(
      subscribersControllerUpdateSubscriberPreferencesRequest
    )
  );
}

export function subscribersControllerUpdateSubscriberPreferencesRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerUpdateSubscriberPreferencesRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerUpdateSubscriberPreferencesRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerUpdateSubscriberPreferencesRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerUpdateSubscriberPreferencesResponse$inboundSchema: z.ZodType<
  SubscribersControllerUpdateSubscriberPreferencesResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.GetSubscriberPreferencesDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerUpdateSubscriberPreferencesResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.GetSubscriberPreferencesDto$Outbound;
};

/** @internal */
export const SubscribersControllerUpdateSubscriberPreferencesResponse$outboundSchema: z.ZodType<
  SubscribersControllerUpdateSubscriberPreferencesResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerUpdateSubscriberPreferencesResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.GetSubscriberPreferencesDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerUpdateSubscriberPreferencesResponse$ {
  /** @deprecated use `SubscribersControllerUpdateSubscriberPreferencesResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerUpdateSubscriberPreferencesResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerUpdateSubscriberPreferencesResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerUpdateSubscriberPreferencesResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerUpdateSubscriberPreferencesResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerUpdateSubscriberPreferencesResponse$Outbound;
}

export function subscribersControllerUpdateSubscriberPreferencesResponseToJSON(
  subscribersControllerUpdateSubscriberPreferencesResponse: SubscribersControllerUpdateSubscriberPreferencesResponse
): string {
  return JSON.stringify(
    SubscribersControllerUpdateSubscriberPreferencesResponse$outboundSchema.parse(
      subscribersControllerUpdateSubscriberPreferencesResponse
    )
  );
}

export function subscribersControllerUpdateSubscriberPreferencesResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerUpdateSubscriberPreferencesResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerUpdateSubscriberPreferencesResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerUpdateSubscriberPreferencesResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerUpdateSubscriberPreferencesRequestToJSON(subscribersControllerUpdateSubscriberPreferencesRequest: SubscribersControllerUpdateSubscriberPreferencesRequest)
 - subscribersControllerUpdateSubscriberPreferencesRequestFromJSON(jsonString: string)
 - subscribersControllerUpdateSubscriberPreferencesResponseToJSON(subscribersControllerUpdateSubscriberPreferencesResponse: SubscribersControllerUpdateSubscriberPreferencesResponse)
 - subscribersControllerUpdateSubscriberPreferencesResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerUpdateSubscriberPreferencesRequest$Outbound;
}

export function subscribersCont...)
 - Outbound(SubscribersControllerUpdateSubscriberPreferencesResponse$Outbound;
}

export function subscribersCon...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerUpdateSubscriberPreferencesRequestToJSON
- export function subscribersControllerUpdateSubscriberPreferencesRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerUpdateSubscriberPreferencesResponseToJSON
- export function subscribersControllerUpdateSubscriberPreferencesResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllerbulkcreatesubscribers.ts
Tamaño: 6420 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerBulkCreateSubscribersRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  bulkSubscriberCreateDto: components.BulkSubscriberCreateDto;
};

export type SubscribersV1ControllerBulkCreateSubscribersResponse = {
  headers: { [k: string]: Array<string> };
  result: components.BulkCreateSubscriberResponseDto;
};

/** @internal */
export const SubscribersV1ControllerBulkCreateSubscribersRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerBulkCreateSubscribersRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    BulkSubscriberCreateDto: components.BulkSubscriberCreateDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      BulkSubscriberCreateDto: 'bulkSubscriberCreateDto',
    });
  });

/** @internal */
export type SubscribersV1ControllerBulkCreateSubscribersRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  BulkSubscriberCreateDto: components.BulkSubscriberCreateDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerBulkCreateSubscribersRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerBulkCreateSubscribersRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerBulkCreateSubscribersRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    bulkSubscriberCreateDto: components.BulkSubscriberCreateDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      bulkSubscriberCreateDto: 'BulkSubscriberCreateDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerBulkCreateSubscribersRequest$ {
  /** @deprecated use `SubscribersV1ControllerBulkCreateSubscribersRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerBulkCreateSubscribersRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerBulkCreateSubscribersRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerBulkCreateSubscribersRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerBulkCreateSubscribersRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerBulkCreateSubscribersRequest$Outbound;
}

export function subscribersV1ControllerBulkCreateSubscribersRequestToJSON(
  subscribersV1ControllerBulkCreateSubscribersRequest: SubscribersV1ControllerBulkCreateSubscribersRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerBulkCreateSubscribersRequest$outboundSchema.parse(
      subscribersV1ControllerBulkCreateSubscribersRequest
    )
  );
}

export function subscribersV1ControllerBulkCreateSubscribersRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerBulkCreateSubscribersRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerBulkCreateSubscribersRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerBulkCreateSubscribersRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerBulkCreateSubscribersResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerBulkCreateSubscribersResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.BulkCreateSubscriberResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerBulkCreateSubscribersResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.BulkCreateSubscriberResponseDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerBulkCreateSubscribersResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerBulkCreateSubscribersResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerBulkCreateSubscribersResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.BulkCreateSubscriberResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerBulkCreateSubscribersResponse$ {
  /** @deprecated use `SubscribersV1ControllerBulkCreateSubscribersResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerBulkCreateSubscribersResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerBulkCreateSubscribersResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerBulkCreateSubscribersResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerBulkCreateSubscribersResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerBulkCreateSubscribersResponse$Outbound;
}

export function subscribersV1ControllerBulkCreateSubscribersResponseToJSON(
  subscribersV1ControllerBulkCreateSubscribersResponse: SubscribersV1ControllerBulkCreateSubscribersResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerBulkCreateSubscribersResponse$outboundSchema.parse(
      subscribersV1ControllerBulkCreateSubscribersResponse
    )
  );
}

export function subscribersV1ControllerBulkCreateSubscribersResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerBulkCreateSubscribersResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerBulkCreateSubscribersResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerBulkCreateSubscribersResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerBulkCreateSubscribersRequestToJSON(subscribersV1ControllerBulkCreateSubscribersRequest: SubscribersV1ControllerBulkCreateSubscribersRequest)
 - subscribersV1ControllerBulkCreateSubscribersRequestFromJSON(jsonString: string)
 - subscribersV1ControllerBulkCreateSubscribersResponseToJSON(subscribersV1ControllerBulkCreateSubscribersResponse: SubscribersV1ControllerBulkCreateSubscribersResponse)
 - subscribersV1ControllerBulkCreateSubscribersResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerBulkCreateSubscribersRequest$Outbound;
}

export function subscribersV1Contro...)
 - Outbound(SubscribersV1ControllerBulkCreateSubscribersResponse$Outbound;
}

export function subscribersV1Contr...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerBulkCreateSubscribersRequestToJSON
- export function subscribersV1ControllerBulkCreateSubscribersRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerBulkCreateSubscribersResponseToJSON
- export function subscribersV1ControllerBulkCreateSubscribersResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllerdeletesubscribercredentials.ts
Tamaño: 6134 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerDeleteSubscriberCredentialsRequest = {
  subscriberId: string;
  providerId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type SubscribersV1ControllerDeleteSubscriberCredentialsResponse = {
  headers: { [k: string]: Array<string> };
};

/** @internal */
export const SubscribersV1ControllerDeleteSubscriberCredentialsRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerDeleteSubscriberCredentialsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    providerId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type SubscribersV1ControllerDeleteSubscriberCredentialsRequest$Outbound = {
  subscriberId: string;
  providerId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const SubscribersV1ControllerDeleteSubscriberCredentialsRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerDeleteSubscriberCredentialsRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerDeleteSubscriberCredentialsRequest
> = z
  .object({
    subscriberId: z.string(),
    providerId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerDeleteSubscriberCredentialsRequest$ {
  /** @deprecated use `SubscribersV1ControllerDeleteSubscriberCredentialsRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerDeleteSubscriberCredentialsRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerDeleteSubscriberCredentialsRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerDeleteSubscriberCredentialsRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerDeleteSubscriberCredentialsRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerDeleteSubscriberCredentialsRequest$Outbound;
}

export function subscribersV1ControllerDeleteSubscriberCredentialsRequestToJSON(
  subscribersV1ControllerDeleteSubscriberCredentialsRequest: SubscribersV1ControllerDeleteSubscriberCredentialsRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerDeleteSubscriberCredentialsRequest$outboundSchema.parse(
      subscribersV1ControllerDeleteSubscriberCredentialsRequest
    )
  );
}

export function subscribersV1ControllerDeleteSubscriberCredentialsRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerDeleteSubscriberCredentialsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerDeleteSubscriberCredentialsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerDeleteSubscriberCredentialsRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerDeleteSubscriberCredentialsResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerDeleteSubscriberCredentialsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
    });
  });

/** @internal */
export type SubscribersV1ControllerDeleteSubscriberCredentialsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
};

/** @internal */
export const SubscribersV1ControllerDeleteSubscriberCredentialsResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerDeleteSubscriberCredentialsResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerDeleteSubscriberCredentialsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerDeleteSubscriberCredentialsResponse$ {
  /** @deprecated use `SubscribersV1ControllerDeleteSubscriberCredentialsResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerDeleteSubscriberCredentialsResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerDeleteSubscriberCredentialsResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerDeleteSubscriberCredentialsResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerDeleteSubscriberCredentialsResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerDeleteSubscriberCredentialsResponse$Outbound;
}

export function subscribersV1ControllerDeleteSubscriberCredentialsResponseToJSON(
  subscribersV1ControllerDeleteSubscriberCredentialsResponse: SubscribersV1ControllerDeleteSubscriberCredentialsResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerDeleteSubscriberCredentialsResponse$outboundSchema.parse(
      subscribersV1ControllerDeleteSubscriberCredentialsResponse
    )
  );
}

export function subscribersV1ControllerDeleteSubscriberCredentialsResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerDeleteSubscriberCredentialsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerDeleteSubscriberCredentialsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerDeleteSubscriberCredentialsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerDeleteSubscriberCredentialsRequestToJSON(subscribersV1ControllerDeleteSubscriberCredentialsRequest: SubscribersV1ControllerDeleteSubscriberCredentialsRequest)
 - subscribersV1ControllerDeleteSubscriberCredentialsRequestFromJSON(jsonString: string)
 - subscribersV1ControllerDeleteSubscriberCredentialsResponseToJSON(subscribersV1ControllerDeleteSubscriberCredentialsResponse: SubscribersV1ControllerDeleteSubscriberCredentialsResponse)
 - subscribersV1ControllerDeleteSubscriberCredentialsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerDeleteSubscriberCredentialsRequest$Outbound;
}

export function subscribersV1...)
 - Outbound(SubscribersV1ControllerDeleteSubscriberCredentialsResponse$Outbound;
}

export function subscribersV...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerDeleteSubscriberCredentialsRequestToJSON
- export function subscribersV1ControllerDeleteSubscriberCredentialsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerDeleteSubscriberCredentialsResponseToJSON
- export function subscribersV1ControllerDeleteSubscriberCredentialsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllergetnotificationsfeed.ts
Tamaño: 6715 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerGetNotificationsFeedRequest = {
  subscriberId: string;
  page?: number | undefined;
  limit?: number | undefined;
  read?: boolean | undefined;
  seen?: boolean | undefined;
  /**
   * Base64 encoded string of the partial payload JSON object
   */
  payload?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type SubscribersV1ControllerGetNotificationsFeedResponse = {
  headers: { [k: string]: Array<string> };
  result: components.FeedResponseDto;
};

/** @internal */
export const SubscribersV1ControllerGetNotificationsFeedRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerGetNotificationsFeedRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    page: z.number().optional(),
    limit: z.number().default(10),
    read: z.boolean().optional(),
    seen: z.boolean().optional(),
    payload: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type SubscribersV1ControllerGetNotificationsFeedRequest$Outbound = {
  subscriberId: string;
  page?: number | undefined;
  limit: number;
  read?: boolean | undefined;
  seen?: boolean | undefined;
  payload?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const SubscribersV1ControllerGetNotificationsFeedRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerGetNotificationsFeedRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerGetNotificationsFeedRequest
> = z
  .object({
    subscriberId: z.string(),
    page: z.number().optional(),
    limit: z.number().default(10),
    read: z.boolean().optional(),
    seen: z.boolean().optional(),
    payload: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerGetNotificationsFeedRequest$ {
  /** @deprecated use `SubscribersV1ControllerGetNotificationsFeedRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerGetNotificationsFeedRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerGetNotificationsFeedRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerGetNotificationsFeedRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerGetNotificationsFeedRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerGetNotificationsFeedRequest$Outbound;
}

export function subscribersV1ControllerGetNotificationsFeedRequestToJSON(
  subscribersV1ControllerGetNotificationsFeedRequest: SubscribersV1ControllerGetNotificationsFeedRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerGetNotificationsFeedRequest$outboundSchema.parse(
      subscribersV1ControllerGetNotificationsFeedRequest
    )
  );
}

export function subscribersV1ControllerGetNotificationsFeedRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerGetNotificationsFeedRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerGetNotificationsFeedRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerGetNotificationsFeedRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerGetNotificationsFeedResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerGetNotificationsFeedResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.FeedResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerGetNotificationsFeedResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.FeedResponseDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerGetNotificationsFeedResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerGetNotificationsFeedResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerGetNotificationsFeedResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.FeedResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerGetNotificationsFeedResponse$ {
  /** @deprecated use `SubscribersV1ControllerGetNotificationsFeedResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerGetNotificationsFeedResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerGetNotificationsFeedResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerGetNotificationsFeedResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerGetNotificationsFeedResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerGetNotificationsFeedResponse$Outbound;
}

export function subscribersV1ControllerGetNotificationsFeedResponseToJSON(
  subscribersV1ControllerGetNotificationsFeedResponse: SubscribersV1ControllerGetNotificationsFeedResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerGetNotificationsFeedResponse$outboundSchema.parse(
      subscribersV1ControllerGetNotificationsFeedResponse
    )
  );
}

export function subscribersV1ControllerGetNotificationsFeedResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerGetNotificationsFeedResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerGetNotificationsFeedResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerGetNotificationsFeedResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerGetNotificationsFeedRequestToJSON(subscribersV1ControllerGetNotificationsFeedRequest: SubscribersV1ControllerGetNotificationsFeedRequest)
 - subscribersV1ControllerGetNotificationsFeedRequestFromJSON(jsonString: string)
 - subscribersV1ControllerGetNotificationsFeedResponseToJSON(subscribersV1ControllerGetNotificationsFeedResponse: SubscribersV1ControllerGetNotificationsFeedResponse)
 - subscribersV1ControllerGetNotificationsFeedResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerGetNotificationsFeedRequest$Outbound;
}

export function subscribersV1Control...)
 - Outbound(SubscribersV1ControllerGetNotificationsFeedResponse$Outbound;
}

export function subscribersV1Contro...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerGetNotificationsFeedRequestToJSON
- export function subscribersV1ControllerGetNotificationsFeedRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerGetNotificationsFeedResponseToJSON
- export function subscribersV1ControllerGetNotificationsFeedResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllergetunseencount.ts
Tamaño: 6094 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerGetUnseenCountRequest = {
  subscriberId: string;
  /**
   * Indicates whether to count seen notifications.
   */
  seen?: boolean | undefined;
  /**
   * The maximum number of notifications to return.
   */
  limit?: number | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type SubscribersV1ControllerGetUnseenCountResponse = {
  headers: { [k: string]: Array<string> };
  result: components.UnseenCountResponse;
};

/** @internal */
export const SubscribersV1ControllerGetUnseenCountRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerGetUnseenCountRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    seen: z.boolean().default(false),
    limit: z.number().default(100),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type SubscribersV1ControllerGetUnseenCountRequest$Outbound = {
  subscriberId: string;
  seen: boolean;
  limit: number;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const SubscribersV1ControllerGetUnseenCountRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerGetUnseenCountRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerGetUnseenCountRequest
> = z
  .object({
    subscriberId: z.string(),
    seen: z.boolean().default(false),
    limit: z.number().default(100),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerGetUnseenCountRequest$ {
  /** @deprecated use `SubscribersV1ControllerGetUnseenCountRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerGetUnseenCountRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerGetUnseenCountRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerGetUnseenCountRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerGetUnseenCountRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerGetUnseenCountRequest$Outbound;
}

export function subscribersV1ControllerGetUnseenCountRequestToJSON(
  subscribersV1ControllerGetUnseenCountRequest: SubscribersV1ControllerGetUnseenCountRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerGetUnseenCountRequest$outboundSchema.parse(subscribersV1ControllerGetUnseenCountRequest)
  );
}

export function subscribersV1ControllerGetUnseenCountRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerGetUnseenCountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerGetUnseenCountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerGetUnseenCountRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerGetUnseenCountResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerGetUnseenCountResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.UnseenCountResponse$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerGetUnseenCountResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.UnseenCountResponse$Outbound;
};

/** @internal */
export const SubscribersV1ControllerGetUnseenCountResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerGetUnseenCountResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerGetUnseenCountResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.UnseenCountResponse$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerGetUnseenCountResponse$ {
  /** @deprecated use `SubscribersV1ControllerGetUnseenCountResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerGetUnseenCountResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerGetUnseenCountResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerGetUnseenCountResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerGetUnseenCountResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerGetUnseenCountResponse$Outbound;
}

export function subscribersV1ControllerGetUnseenCountResponseToJSON(
  subscribersV1ControllerGetUnseenCountResponse: SubscribersV1ControllerGetUnseenCountResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerGetUnseenCountResponse$outboundSchema.parse(subscribersV1ControllerGetUnseenCountResponse)
  );
}

export function subscribersV1ControllerGetUnseenCountResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerGetUnseenCountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerGetUnseenCountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerGetUnseenCountResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerGetUnseenCountRequestToJSON(subscribersV1ControllerGetUnseenCountRequest: SubscribersV1ControllerGetUnseenCountRequest)
 - subscribersV1ControllerGetUnseenCountRequestFromJSON(jsonString: string)
 - subscribersV1ControllerGetUnseenCountResponseToJSON(subscribersV1ControllerGetUnseenCountResponse: SubscribersV1ControllerGetUnseenCountResponse)
 - subscribersV1ControllerGetUnseenCountResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerGetUnseenCountRequest$Outbound;
}

export function subscribersV1ControllerGet...)
 - Outbound(SubscribersV1ControllerGetUnseenCountResponse$Outbound;
}

export function subscribersV1ControllerGe...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerGetUnseenCountRequestToJSON
- export function subscribersV1ControllerGetUnseenCountRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerGetUnseenCountResponseToJSON
- export function subscribersV1ControllerGetUnseenCountResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllermarkactionasseen.ts
Tamaño: 6442 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerMarkActionAsSeenRequest = {
  messageId: string;
  type: string;
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  markMessageActionAsSeenDto: components.MarkMessageActionAsSeenDto;
};

export type SubscribersV1ControllerMarkActionAsSeenResponse = {
  headers: { [k: string]: Array<string> };
  result: components.MessageResponseDto;
};

/** @internal */
export const SubscribersV1ControllerMarkActionAsSeenRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerMarkActionAsSeenRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    messageId: z.string(),
    type: z.string(),
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    MarkMessageActionAsSeenDto: components.MarkMessageActionAsSeenDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      MarkMessageActionAsSeenDto: 'markMessageActionAsSeenDto',
    });
  });

/** @internal */
export type SubscribersV1ControllerMarkActionAsSeenRequest$Outbound = {
  messageId: string;
  type: string;
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  MarkMessageActionAsSeenDto: components.MarkMessageActionAsSeenDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerMarkActionAsSeenRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerMarkActionAsSeenRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerMarkActionAsSeenRequest
> = z
  .object({
    messageId: z.string(),
    type: z.string(),
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    markMessageActionAsSeenDto: components.MarkMessageActionAsSeenDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      markMessageActionAsSeenDto: 'MarkMessageActionAsSeenDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerMarkActionAsSeenRequest$ {
  /** @deprecated use `SubscribersV1ControllerMarkActionAsSeenRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerMarkActionAsSeenRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkActionAsSeenRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerMarkActionAsSeenRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkActionAsSeenRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerMarkActionAsSeenRequest$Outbound;
}

export function subscribersV1ControllerMarkActionAsSeenRequestToJSON(
  subscribersV1ControllerMarkActionAsSeenRequest: SubscribersV1ControllerMarkActionAsSeenRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerMarkActionAsSeenRequest$outboundSchema.parse(subscribersV1ControllerMarkActionAsSeenRequest)
  );
}

export function subscribersV1ControllerMarkActionAsSeenRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerMarkActionAsSeenRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerMarkActionAsSeenRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerMarkActionAsSeenRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerMarkActionAsSeenResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerMarkActionAsSeenResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.MessageResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerMarkActionAsSeenResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.MessageResponseDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerMarkActionAsSeenResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerMarkActionAsSeenResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerMarkActionAsSeenResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.MessageResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerMarkActionAsSeenResponse$ {
  /** @deprecated use `SubscribersV1ControllerMarkActionAsSeenResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerMarkActionAsSeenResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkActionAsSeenResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerMarkActionAsSeenResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkActionAsSeenResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerMarkActionAsSeenResponse$Outbound;
}

export function subscribersV1ControllerMarkActionAsSeenResponseToJSON(
  subscribersV1ControllerMarkActionAsSeenResponse: SubscribersV1ControllerMarkActionAsSeenResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerMarkActionAsSeenResponse$outboundSchema.parse(
      subscribersV1ControllerMarkActionAsSeenResponse
    )
  );
}

export function subscribersV1ControllerMarkActionAsSeenResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerMarkActionAsSeenResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerMarkActionAsSeenResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerMarkActionAsSeenResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerMarkActionAsSeenRequestToJSON(subscribersV1ControllerMarkActionAsSeenRequest: SubscribersV1ControllerMarkActionAsSeenRequest)
 - subscribersV1ControllerMarkActionAsSeenRequestFromJSON(jsonString: string)
 - subscribersV1ControllerMarkActionAsSeenResponseToJSON(subscribersV1ControllerMarkActionAsSeenResponse: SubscribersV1ControllerMarkActionAsSeenResponse)
 - subscribersV1ControllerMarkActionAsSeenResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerMarkActionAsSeenRequest$Outbound;
}

export function subscribersV1ControllerM...)
 - Outbound(SubscribersV1ControllerMarkActionAsSeenResponse$Outbound;
}

export function subscribersV1Controller...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerMarkActionAsSeenRequestToJSON
- export function subscribersV1ControllerMarkActionAsSeenRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerMarkActionAsSeenResponseToJSON
- export function subscribersV1ControllerMarkActionAsSeenResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllermarkallunreadasread.ts
Tamaño: 6298 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerMarkAllUnreadAsReadRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  markAllMessageAsRequestDto: components.MarkAllMessageAsRequestDto;
};

export type SubscribersV1ControllerMarkAllUnreadAsReadResponse = {
  headers: { [k: string]: Array<string> };
  result: number;
};

/** @internal */
export const SubscribersV1ControllerMarkAllUnreadAsReadRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerMarkAllUnreadAsReadRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    MarkAllMessageAsRequestDto: components.MarkAllMessageAsRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      MarkAllMessageAsRequestDto: 'markAllMessageAsRequestDto',
    });
  });

/** @internal */
export type SubscribersV1ControllerMarkAllUnreadAsReadRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  MarkAllMessageAsRequestDto: components.MarkAllMessageAsRequestDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerMarkAllUnreadAsReadRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerMarkAllUnreadAsReadRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerMarkAllUnreadAsReadRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    markAllMessageAsRequestDto: components.MarkAllMessageAsRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      markAllMessageAsRequestDto: 'MarkAllMessageAsRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerMarkAllUnreadAsReadRequest$ {
  /** @deprecated use `SubscribersV1ControllerMarkAllUnreadAsReadRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerMarkAllUnreadAsReadRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkAllUnreadAsReadRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerMarkAllUnreadAsReadRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkAllUnreadAsReadRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerMarkAllUnreadAsReadRequest$Outbound;
}

export function subscribersV1ControllerMarkAllUnreadAsReadRequestToJSON(
  subscribersV1ControllerMarkAllUnreadAsReadRequest: SubscribersV1ControllerMarkAllUnreadAsReadRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerMarkAllUnreadAsReadRequest$outboundSchema.parse(
      subscribersV1ControllerMarkAllUnreadAsReadRequest
    )
  );
}

export function subscribersV1ControllerMarkAllUnreadAsReadRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerMarkAllUnreadAsReadRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerMarkAllUnreadAsReadRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerMarkAllUnreadAsReadRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerMarkAllUnreadAsReadResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerMarkAllUnreadAsReadResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.number(),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerMarkAllUnreadAsReadResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: number;
};

/** @internal */
export const SubscribersV1ControllerMarkAllUnreadAsReadResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerMarkAllUnreadAsReadResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerMarkAllUnreadAsReadResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.number(),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerMarkAllUnreadAsReadResponse$ {
  /** @deprecated use `SubscribersV1ControllerMarkAllUnreadAsReadResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerMarkAllUnreadAsReadResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkAllUnreadAsReadResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerMarkAllUnreadAsReadResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkAllUnreadAsReadResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerMarkAllUnreadAsReadResponse$Outbound;
}

export function subscribersV1ControllerMarkAllUnreadAsReadResponseToJSON(
  subscribersV1ControllerMarkAllUnreadAsReadResponse: SubscribersV1ControllerMarkAllUnreadAsReadResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerMarkAllUnreadAsReadResponse$outboundSchema.parse(
      subscribersV1ControllerMarkAllUnreadAsReadResponse
    )
  );
}

export function subscribersV1ControllerMarkAllUnreadAsReadResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerMarkAllUnreadAsReadResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerMarkAllUnreadAsReadResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerMarkAllUnreadAsReadResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerMarkAllUnreadAsReadRequestToJSON(subscribersV1ControllerMarkAllUnreadAsReadRequest: SubscribersV1ControllerMarkAllUnreadAsReadRequest)
 - subscribersV1ControllerMarkAllUnreadAsReadRequestFromJSON(jsonString: string)
 - subscribersV1ControllerMarkAllUnreadAsReadResponseToJSON(subscribersV1ControllerMarkAllUnreadAsReadResponse: SubscribersV1ControllerMarkAllUnreadAsReadResponse)
 - subscribersV1ControllerMarkAllUnreadAsReadResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerMarkAllUnreadAsReadRequest$Outbound;
}

export function subscribersV1Controll...)
 - Outbound(SubscribersV1ControllerMarkAllUnreadAsReadResponse$Outbound;
}

export function subscribersV1Control...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerMarkAllUnreadAsReadRequestToJSON
- export function subscribersV1ControllerMarkAllUnreadAsReadRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerMarkAllUnreadAsReadResponseToJSON
- export function subscribersV1ControllerMarkAllUnreadAsReadResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllermarkmessagesas.ts
Tamaño: 6162 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerMarkMessagesAsRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  messageMarkAsRequestDto: components.MessageMarkAsRequestDto;
};

export type SubscribersV1ControllerMarkMessagesAsResponse = {
  headers: { [k: string]: Array<string> };
  result: Array<components.MessageResponseDto>;
};

/** @internal */
export const SubscribersV1ControllerMarkMessagesAsRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerMarkMessagesAsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    MessageMarkAsRequestDto: components.MessageMarkAsRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      MessageMarkAsRequestDto: 'messageMarkAsRequestDto',
    });
  });

/** @internal */
export type SubscribersV1ControllerMarkMessagesAsRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  MessageMarkAsRequestDto: components.MessageMarkAsRequestDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerMarkMessagesAsRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerMarkMessagesAsRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerMarkMessagesAsRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    messageMarkAsRequestDto: components.MessageMarkAsRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      messageMarkAsRequestDto: 'MessageMarkAsRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerMarkMessagesAsRequest$ {
  /** @deprecated use `SubscribersV1ControllerMarkMessagesAsRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerMarkMessagesAsRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkMessagesAsRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerMarkMessagesAsRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkMessagesAsRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerMarkMessagesAsRequest$Outbound;
}

export function subscribersV1ControllerMarkMessagesAsRequestToJSON(
  subscribersV1ControllerMarkMessagesAsRequest: SubscribersV1ControllerMarkMessagesAsRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerMarkMessagesAsRequest$outboundSchema.parse(subscribersV1ControllerMarkMessagesAsRequest)
  );
}

export function subscribersV1ControllerMarkMessagesAsRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerMarkMessagesAsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerMarkMessagesAsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerMarkMessagesAsRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerMarkMessagesAsResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerMarkMessagesAsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.array(components.MessageResponseDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerMarkMessagesAsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: Array<components.MessageResponseDto$Outbound>;
};

/** @internal */
export const SubscribersV1ControllerMarkMessagesAsResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerMarkMessagesAsResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerMarkMessagesAsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.array(components.MessageResponseDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerMarkMessagesAsResponse$ {
  /** @deprecated use `SubscribersV1ControllerMarkMessagesAsResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerMarkMessagesAsResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkMessagesAsResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerMarkMessagesAsResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkMessagesAsResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerMarkMessagesAsResponse$Outbound;
}

export function subscribersV1ControllerMarkMessagesAsResponseToJSON(
  subscribersV1ControllerMarkMessagesAsResponse: SubscribersV1ControllerMarkMessagesAsResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerMarkMessagesAsResponse$outboundSchema.parse(subscribersV1ControllerMarkMessagesAsResponse)
  );
}

export function subscribersV1ControllerMarkMessagesAsResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerMarkMessagesAsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerMarkMessagesAsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerMarkMessagesAsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerMarkMessagesAsRequestToJSON(subscribersV1ControllerMarkMessagesAsRequest: SubscribersV1ControllerMarkMessagesAsRequest)
 - subscribersV1ControllerMarkMessagesAsRequestFromJSON(jsonString: string)
 - subscribersV1ControllerMarkMessagesAsResponseToJSON(subscribersV1ControllerMarkMessagesAsResponse: SubscribersV1ControllerMarkMessagesAsResponse)
 - subscribersV1ControllerMarkMessagesAsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerMarkMessagesAsRequest$Outbound;
}

export function subscribersV1ControllerMar...)
 - Outbound(SubscribersV1ControllerMarkMessagesAsResponse$Outbound;
}

export function subscribersV1ControllerMa...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerMarkMessagesAsRequestToJSON
- export function subscribersV1ControllerMarkMessagesAsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerMarkMessagesAsResponseToJSON
- export function subscribersV1ControllerMarkMessagesAsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllermodifysubscriberchannel.ts
Tamaño: 6700 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerModifySubscriberChannelRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  updateSubscriberChannelRequestDto: components.UpdateSubscriberChannelRequestDto;
};

export type SubscribersV1ControllerModifySubscriberChannelResponse = {
  headers: { [k: string]: Array<string> };
  result: components.SubscriberResponseDto;
};

/** @internal */
export const SubscribersV1ControllerModifySubscriberChannelRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerModifySubscriberChannelRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateSubscriberChannelRequestDto: components.UpdateSubscriberChannelRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateSubscriberChannelRequestDto: 'updateSubscriberChannelRequestDto',
    });
  });

/** @internal */
export type SubscribersV1ControllerModifySubscriberChannelRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  UpdateSubscriberChannelRequestDto: components.UpdateSubscriberChannelRequestDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerModifySubscriberChannelRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerModifySubscriberChannelRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerModifySubscriberChannelRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    updateSubscriberChannelRequestDto: components.UpdateSubscriberChannelRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateSubscriberChannelRequestDto: 'UpdateSubscriberChannelRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerModifySubscriberChannelRequest$ {
  /** @deprecated use `SubscribersV1ControllerModifySubscriberChannelRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerModifySubscriberChannelRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerModifySubscriberChannelRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerModifySubscriberChannelRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerModifySubscriberChannelRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerModifySubscriberChannelRequest$Outbound;
}

export function subscribersV1ControllerModifySubscriberChannelRequestToJSON(
  subscribersV1ControllerModifySubscriberChannelRequest: SubscribersV1ControllerModifySubscriberChannelRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerModifySubscriberChannelRequest$outboundSchema.parse(
      subscribersV1ControllerModifySubscriberChannelRequest
    )
  );
}

export function subscribersV1ControllerModifySubscriberChannelRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerModifySubscriberChannelRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerModifySubscriberChannelRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerModifySubscriberChannelRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerModifySubscriberChannelResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerModifySubscriberChannelResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.SubscriberResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerModifySubscriberChannelResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.SubscriberResponseDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerModifySubscriberChannelResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerModifySubscriberChannelResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerModifySubscriberChannelResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.SubscriberResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerModifySubscriberChannelResponse$ {
  /** @deprecated use `SubscribersV1ControllerModifySubscriberChannelResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerModifySubscriberChannelResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerModifySubscriberChannelResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerModifySubscriberChannelResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerModifySubscriberChannelResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerModifySubscriberChannelResponse$Outbound;
}

export function subscribersV1ControllerModifySubscriberChannelResponseToJSON(
  subscribersV1ControllerModifySubscriberChannelResponse: SubscribersV1ControllerModifySubscriberChannelResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerModifySubscriberChannelResponse$outboundSchema.parse(
      subscribersV1ControllerModifySubscriberChannelResponse
    )
  );
}

export function subscribersV1ControllerModifySubscriberChannelResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerModifySubscriberChannelResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerModifySubscriberChannelResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerModifySubscriberChannelResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerModifySubscriberChannelRequestToJSON(subscribersV1ControllerModifySubscriberChannelRequest: SubscribersV1ControllerModifySubscriberChannelRequest)
 - subscribersV1ControllerModifySubscriberChannelRequestFromJSON(jsonString: string)
 - subscribersV1ControllerModifySubscriberChannelResponseToJSON(subscribersV1ControllerModifySubscriberChannelResponse: SubscribersV1ControllerModifySubscriberChannelResponse)
 - subscribersV1ControllerModifySubscriberChannelResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerModifySubscriberChannelRequest$Outbound;
}

export function subscribersV1Cont...)
 - Outbound(SubscribersV1ControllerModifySubscriberChannelResponse$Outbound;
}

export function subscribersV1Con...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerModifySubscriberChannelRequestToJSON
- export function subscribersV1ControllerModifySubscriberChannelRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerModifySubscriberChannelResponseToJSON
- export function subscribersV1ControllerModifySubscriberChannelResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllerupdatesubscriberchannel.ts
Tamaño: 6700 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerUpdateSubscriberChannelRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  updateSubscriberChannelRequestDto: components.UpdateSubscriberChannelRequestDto;
};

export type SubscribersV1ControllerUpdateSubscriberChannelResponse = {
  headers: { [k: string]: Array<string> };
  result: components.SubscriberResponseDto;
};

/** @internal */
export const SubscribersV1ControllerUpdateSubscriberChannelRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerUpdateSubscriberChannelRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateSubscriberChannelRequestDto: components.UpdateSubscriberChannelRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateSubscriberChannelRequestDto: 'updateSubscriberChannelRequestDto',
    });
  });

/** @internal */
export type SubscribersV1ControllerUpdateSubscriberChannelRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  UpdateSubscriberChannelRequestDto: components.UpdateSubscriberChannelRequestDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerUpdateSubscriberChannelRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerUpdateSubscriberChannelRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerUpdateSubscriberChannelRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    updateSubscriberChannelRequestDto: components.UpdateSubscriberChannelRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateSubscriberChannelRequestDto: 'UpdateSubscriberChannelRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerUpdateSubscriberChannelRequest$ {
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberChannelRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerUpdateSubscriberChannelRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberChannelRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerUpdateSubscriberChannelRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberChannelRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerUpdateSubscriberChannelRequest$Outbound;
}

export function subscribersV1ControllerUpdateSubscriberChannelRequestToJSON(
  subscribersV1ControllerUpdateSubscriberChannelRequest: SubscribersV1ControllerUpdateSubscriberChannelRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerUpdateSubscriberChannelRequest$outboundSchema.parse(
      subscribersV1ControllerUpdateSubscriberChannelRequest
    )
  );
}

export function subscribersV1ControllerUpdateSubscriberChannelRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerUpdateSubscriberChannelRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerUpdateSubscriberChannelRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerUpdateSubscriberChannelRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerUpdateSubscriberChannelResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerUpdateSubscriberChannelResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.SubscriberResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerUpdateSubscriberChannelResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.SubscriberResponseDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerUpdateSubscriberChannelResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerUpdateSubscriberChannelResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerUpdateSubscriberChannelResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.SubscriberResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerUpdateSubscriberChannelResponse$ {
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberChannelResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerUpdateSubscriberChannelResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberChannelResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerUpdateSubscriberChannelResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberChannelResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerUpdateSubscriberChannelResponse$Outbound;
}

export function subscribersV1ControllerUpdateSubscriberChannelResponseToJSON(
  subscribersV1ControllerUpdateSubscriberChannelResponse: SubscribersV1ControllerUpdateSubscriberChannelResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerUpdateSubscriberChannelResponse$outboundSchema.parse(
      subscribersV1ControllerUpdateSubscriberChannelResponse
    )
  );
}

export function subscribersV1ControllerUpdateSubscriberChannelResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerUpdateSubscriberChannelResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerUpdateSubscriberChannelResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerUpdateSubscriberChannelResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerUpdateSubscriberChannelRequestToJSON(subscribersV1ControllerUpdateSubscriberChannelRequest: SubscribersV1ControllerUpdateSubscriberChannelRequest)
 - subscribersV1ControllerUpdateSubscriberChannelRequestFromJSON(jsonString: string)
 - subscribersV1ControllerUpdateSubscriberChannelResponseToJSON(subscribersV1ControllerUpdateSubscriberChannelResponse: SubscribersV1ControllerUpdateSubscriberChannelResponse)
 - subscribersV1ControllerUpdateSubscriberChannelResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerUpdateSubscriberChannelRequest$Outbound;
}

export function subscribersV1Cont...)
 - Outbound(SubscribersV1ControllerUpdateSubscriberChannelResponse$Outbound;
}

export function subscribersV1Con...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerUpdateSubscriberChannelRequestToJSON
- export function subscribersV1ControllerUpdateSubscriberChannelRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerUpdateSubscriberChannelResponseToJSON
- export function subscribersV1ControllerUpdateSubscriberChannelResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllerupdatesubscriberonlineflag.ts
Tamaño: 6874 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  updateSubscriberOnlineFlagRequestDto: components.UpdateSubscriberOnlineFlagRequestDto;
};

export type SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse = {
  headers: { [k: string]: Array<string> };
  result: components.SubscriberResponseDto;
};

/** @internal */
export const SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateSubscriberOnlineFlagRequestDto: components.UpdateSubscriberOnlineFlagRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateSubscriberOnlineFlagRequestDto: 'updateSubscriberOnlineFlagRequestDto',
    });
  });

/** @internal */
export type SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  UpdateSubscriberOnlineFlagRequestDto: components.UpdateSubscriberOnlineFlagRequestDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    updateSubscriberOnlineFlagRequestDto: components.UpdateSubscriberOnlineFlagRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateSubscriberOnlineFlagRequestDto: 'UpdateSubscriberOnlineFlagRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$ {
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$Outbound;
}

export function subscribersV1ControllerUpdateSubscriberOnlineFlagRequestToJSON(
  subscribersV1ControllerUpdateSubscriberOnlineFlagRequest: SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$outboundSchema.parse(
      subscribersV1ControllerUpdateSubscriberOnlineFlagRequest
    )
  );
}

export function subscribersV1ControllerUpdateSubscriberOnlineFlagRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.SubscriberResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.SubscriberResponseDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.SubscriberResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$ {
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$Outbound;
}

export function subscribersV1ControllerUpdateSubscriberOnlineFlagResponseToJSON(
  subscribersV1ControllerUpdateSubscriberOnlineFlagResponse: SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$outboundSchema.parse(
      subscribersV1ControllerUpdateSubscriberOnlineFlagResponse
    )
  );
}

export function subscribersV1ControllerUpdateSubscriberOnlineFlagResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerUpdateSubscriberOnlineFlagRequestToJSON(subscribersV1ControllerUpdateSubscriberOnlineFlagRequest: SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest)
 - subscribersV1ControllerUpdateSubscriberOnlineFlagRequestFromJSON(jsonString: string)
 - subscribersV1ControllerUpdateSubscriberOnlineFlagResponseToJSON(subscribersV1ControllerUpdateSubscriberOnlineFlagResponse: SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse)
 - subscribersV1ControllerUpdateSubscriberOnlineFlagResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$Outbound;
}

export function subscribersV1C...)
 - Outbound(SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$Outbound;
}

export function subscribersV1...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerUpdateSubscriberOnlineFlagRequestToJSON
- export function subscribersV1ControllerUpdateSubscriberOnlineFlagRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerUpdateSubscriberOnlineFlagResponseToJSON
- export function subscribersV1ControllerUpdateSubscriberOnlineFlagResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicscontrollercreatetopicsubscriptions.ts
Tamaño: 6525 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicsControllerCreateTopicSubscriptionsRequest = {
  /**
   * The key identifier of the topic
   */
  topicKey: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  createTopicSubscriptionsRequestDto: components.CreateTopicSubscriptionsRequestDto;
};

export type TopicsControllerCreateTopicSubscriptionsResponse = {
  headers: { [k: string]: Array<string> };
  result: components.CreateTopicSubscriptionsResponseDto;
};

/** @internal */
export const TopicsControllerCreateTopicSubscriptionsRequest$inboundSchema: z.ZodType<
  TopicsControllerCreateTopicSubscriptionsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    topicKey: z.string(),
    'idempotency-key': z.string().optional(),
    CreateTopicSubscriptionsRequestDto: components.CreateTopicSubscriptionsRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateTopicSubscriptionsRequestDto: 'createTopicSubscriptionsRequestDto',
    });
  });

/** @internal */
export type TopicsControllerCreateTopicSubscriptionsRequest$Outbound = {
  topicKey: string;
  'idempotency-key'?: string | undefined;
  CreateTopicSubscriptionsRequestDto: components.CreateTopicSubscriptionsRequestDto$Outbound;
};

/** @internal */
export const TopicsControllerCreateTopicSubscriptionsRequest$outboundSchema: z.ZodType<
  TopicsControllerCreateTopicSubscriptionsRequest$Outbound,
  z.ZodTypeDef,
  TopicsControllerCreateTopicSubscriptionsRequest
> = z
  .object({
    topicKey: z.string(),
    idempotencyKey: z.string().optional(),
    createTopicSubscriptionsRequestDto: components.CreateTopicSubscriptionsRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createTopicSubscriptionsRequestDto: 'CreateTopicSubscriptionsRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerCreateTopicSubscriptionsRequest$ {
  /** @deprecated use `TopicsControllerCreateTopicSubscriptionsRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerCreateTopicSubscriptionsRequest$inboundSchema;
  /** @deprecated use `TopicsControllerCreateTopicSubscriptionsRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerCreateTopicSubscriptionsRequest$outboundSchema;
  /** @deprecated use `TopicsControllerCreateTopicSubscriptionsRequest$Outbound` instead. */
  export type Outbound = TopicsControllerCreateTopicSubscriptionsRequest$Outbound;
}

export function topicsControllerCreateTopicSubscriptionsRequestToJSON(
  topicsControllerCreateTopicSubscriptionsRequest: TopicsControllerCreateTopicSubscriptionsRequest
): string {
  return JSON.stringify(
    TopicsControllerCreateTopicSubscriptionsRequest$outboundSchema.parse(
      topicsControllerCreateTopicSubscriptionsRequest
    )
  );
}

export function topicsControllerCreateTopicSubscriptionsRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerCreateTopicSubscriptionsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerCreateTopicSubscriptionsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerCreateTopicSubscriptionsRequest' from JSON`
  );
}

/** @internal */
export const TopicsControllerCreateTopicSubscriptionsResponse$inboundSchema: z.ZodType<
  TopicsControllerCreateTopicSubscriptionsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.CreateTopicSubscriptionsResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsControllerCreateTopicSubscriptionsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.CreateTopicSubscriptionsResponseDto$Outbound;
};

/** @internal */
export const TopicsControllerCreateTopicSubscriptionsResponse$outboundSchema: z.ZodType<
  TopicsControllerCreateTopicSubscriptionsResponse$Outbound,
  z.ZodTypeDef,
  TopicsControllerCreateTopicSubscriptionsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.CreateTopicSubscriptionsResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerCreateTopicSubscriptionsResponse$ {
  /** @deprecated use `TopicsControllerCreateTopicSubscriptionsResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerCreateTopicSubscriptionsResponse$inboundSchema;
  /** @deprecated use `TopicsControllerCreateTopicSubscriptionsResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerCreateTopicSubscriptionsResponse$outboundSchema;
  /** @deprecated use `TopicsControllerCreateTopicSubscriptionsResponse$Outbound` instead. */
  export type Outbound = TopicsControllerCreateTopicSubscriptionsResponse$Outbound;
}

export function topicsControllerCreateTopicSubscriptionsResponseToJSON(
  topicsControllerCreateTopicSubscriptionsResponse: TopicsControllerCreateTopicSubscriptionsResponse
): string {
  return JSON.stringify(
    TopicsControllerCreateTopicSubscriptionsResponse$outboundSchema.parse(
      topicsControllerCreateTopicSubscriptionsResponse
    )
  );
}

export function topicsControllerCreateTopicSubscriptionsResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerCreateTopicSubscriptionsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerCreateTopicSubscriptionsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerCreateTopicSubscriptionsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsControllerCreateTopicSubscriptionsRequestToJSON(topicsControllerCreateTopicSubscriptionsRequest: TopicsControllerCreateTopicSubscriptionsRequest)
 - topicsControllerCreateTopicSubscriptionsRequestFromJSON(jsonString: string)
 - topicsControllerCreateTopicSubscriptionsResponseToJSON(topicsControllerCreateTopicSubscriptionsResponse: TopicsControllerCreateTopicSubscriptionsResponse)
 - topicsControllerCreateTopicSubscriptionsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsControllerCreateTopicSubscriptionsRequest$Outbound;
}

export function topicsControllerCreateT...)
 - Outbound(TopicsControllerCreateTopicSubscriptionsResponse$Outbound;
}

export function topicsControllerCreate...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerCreateTopicSubscriptionsRequestToJSON
- export function topicsControllerCreateTopicSubscriptionsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerCreateTopicSubscriptionsResponseToJSON
- export function topicsControllerCreateTopicSubscriptionsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicscontrollerdeletetopic.ts
Tamaño: 5293 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicsControllerDeleteTopicRequest = {
  /**
   * The key identifier of the topic
   */
  topicKey: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type TopicsControllerDeleteTopicResponse = {
  headers: { [k: string]: Array<string> };
  result: components.DeleteTopicResponseDto;
};

/** @internal */
export const TopicsControllerDeleteTopicRequest$inboundSchema: z.ZodType<
  TopicsControllerDeleteTopicRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    topicKey: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TopicsControllerDeleteTopicRequest$Outbound = {
  topicKey: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TopicsControllerDeleteTopicRequest$outboundSchema: z.ZodType<
  TopicsControllerDeleteTopicRequest$Outbound,
  z.ZodTypeDef,
  TopicsControllerDeleteTopicRequest
> = z
  .object({
    topicKey: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerDeleteTopicRequest$ {
  /** @deprecated use `TopicsControllerDeleteTopicRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerDeleteTopicRequest$inboundSchema;
  /** @deprecated use `TopicsControllerDeleteTopicRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerDeleteTopicRequest$outboundSchema;
  /** @deprecated use `TopicsControllerDeleteTopicRequest$Outbound` instead. */
  export type Outbound = TopicsControllerDeleteTopicRequest$Outbound;
}

export function topicsControllerDeleteTopicRequestToJSON(
  topicsControllerDeleteTopicRequest: TopicsControllerDeleteTopicRequest
): string {
  return JSON.stringify(TopicsControllerDeleteTopicRequest$outboundSchema.parse(topicsControllerDeleteTopicRequest));
}

export function topicsControllerDeleteTopicRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerDeleteTopicRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerDeleteTopicRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerDeleteTopicRequest' from JSON`
  );
}

/** @internal */
export const TopicsControllerDeleteTopicResponse$inboundSchema: z.ZodType<
  TopicsControllerDeleteTopicResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.DeleteTopicResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsControllerDeleteTopicResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.DeleteTopicResponseDto$Outbound;
};

/** @internal */
export const TopicsControllerDeleteTopicResponse$outboundSchema: z.ZodType<
  TopicsControllerDeleteTopicResponse$Outbound,
  z.ZodTypeDef,
  TopicsControllerDeleteTopicResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.DeleteTopicResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerDeleteTopicResponse$ {
  /** @deprecated use `TopicsControllerDeleteTopicResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerDeleteTopicResponse$inboundSchema;
  /** @deprecated use `TopicsControllerDeleteTopicResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerDeleteTopicResponse$outboundSchema;
  /** @deprecated use `TopicsControllerDeleteTopicResponse$Outbound` instead. */
  export type Outbound = TopicsControllerDeleteTopicResponse$Outbound;
}

export function topicsControllerDeleteTopicResponseToJSON(
  topicsControllerDeleteTopicResponse: TopicsControllerDeleteTopicResponse
): string {
  return JSON.stringify(TopicsControllerDeleteTopicResponse$outboundSchema.parse(topicsControllerDeleteTopicResponse));
}

export function topicsControllerDeleteTopicResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerDeleteTopicResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerDeleteTopicResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerDeleteTopicResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsControllerDeleteTopicRequestToJSON(topicsControllerDeleteTopicRequest: TopicsControllerDeleteTopicRequest)
 - topicsControllerDeleteTopicRequestFromJSON(jsonString: string)
 - topicsControllerDeleteTopicResponseToJSON(topicsControllerDeleteTopicResponse: TopicsControllerDeleteTopicResponse)
 - topicsControllerDeleteTopicResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsControllerDeleteTopicRequest$Outbound;
}

export function topicsControllerDeleteTopicRequestTo...)
 - Outbound(TopicsControllerDeleteTopicResponse$Outbound;
}

export function topicsControllerDeleteTopicResponse...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerDeleteTopicRequestToJSON
- export function topicsControllerDeleteTopicRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerDeleteTopicResponseToJSON
- export function topicsControllerDeleteTopicResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicscontrollerdeletetopicsubscriptions.ts
Tamaño: 6525 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicsControllerDeleteTopicSubscriptionsRequest = {
  /**
   * The key identifier of the topic
   */
  topicKey: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  deleteTopicSubscriptionsRequestDto: components.DeleteTopicSubscriptionsRequestDto;
};

export type TopicsControllerDeleteTopicSubscriptionsResponse = {
  headers: { [k: string]: Array<string> };
  result: components.DeleteTopicSubscriptionsResponseDto;
};

/** @internal */
export const TopicsControllerDeleteTopicSubscriptionsRequest$inboundSchema: z.ZodType<
  TopicsControllerDeleteTopicSubscriptionsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    topicKey: z.string(),
    'idempotency-key': z.string().optional(),
    DeleteTopicSubscriptionsRequestDto: components.DeleteTopicSubscriptionsRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      DeleteTopicSubscriptionsRequestDto: 'deleteTopicSubscriptionsRequestDto',
    });
  });

/** @internal */
export type TopicsControllerDeleteTopicSubscriptionsRequest$Outbound = {
  topicKey: string;
  'idempotency-key'?: string | undefined;
  DeleteTopicSubscriptionsRequestDto: components.DeleteTopicSubscriptionsRequestDto$Outbound;
};

/** @internal */
export const TopicsControllerDeleteTopicSubscriptionsRequest$outboundSchema: z.ZodType<
  TopicsControllerDeleteTopicSubscriptionsRequest$Outbound,
  z.ZodTypeDef,
  TopicsControllerDeleteTopicSubscriptionsRequest
> = z
  .object({
    topicKey: z.string(),
    idempotencyKey: z.string().optional(),
    deleteTopicSubscriptionsRequestDto: components.DeleteTopicSubscriptionsRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      deleteTopicSubscriptionsRequestDto: 'DeleteTopicSubscriptionsRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerDeleteTopicSubscriptionsRequest$ {
  /** @deprecated use `TopicsControllerDeleteTopicSubscriptionsRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerDeleteTopicSubscriptionsRequest$inboundSchema;
  /** @deprecated use `TopicsControllerDeleteTopicSubscriptionsRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerDeleteTopicSubscriptionsRequest$outboundSchema;
  /** @deprecated use `TopicsControllerDeleteTopicSubscriptionsRequest$Outbound` instead. */
  export type Outbound = TopicsControllerDeleteTopicSubscriptionsRequest$Outbound;
}

export function topicsControllerDeleteTopicSubscriptionsRequestToJSON(
  topicsControllerDeleteTopicSubscriptionsRequest: TopicsControllerDeleteTopicSubscriptionsRequest
): string {
  return JSON.stringify(
    TopicsControllerDeleteTopicSubscriptionsRequest$outboundSchema.parse(
      topicsControllerDeleteTopicSubscriptionsRequest
    )
  );
}

export function topicsControllerDeleteTopicSubscriptionsRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerDeleteTopicSubscriptionsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerDeleteTopicSubscriptionsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerDeleteTopicSubscriptionsRequest' from JSON`
  );
}

/** @internal */
export const TopicsControllerDeleteTopicSubscriptionsResponse$inboundSchema: z.ZodType<
  TopicsControllerDeleteTopicSubscriptionsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.DeleteTopicSubscriptionsResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsControllerDeleteTopicSubscriptionsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.DeleteTopicSubscriptionsResponseDto$Outbound;
};

/** @internal */
export const TopicsControllerDeleteTopicSubscriptionsResponse$outboundSchema: z.ZodType<
  TopicsControllerDeleteTopicSubscriptionsResponse$Outbound,
  z.ZodTypeDef,
  TopicsControllerDeleteTopicSubscriptionsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.DeleteTopicSubscriptionsResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerDeleteTopicSubscriptionsResponse$ {
  /** @deprecated use `TopicsControllerDeleteTopicSubscriptionsResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerDeleteTopicSubscriptionsResponse$inboundSchema;
  /** @deprecated use `TopicsControllerDeleteTopicSubscriptionsResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerDeleteTopicSubscriptionsResponse$outboundSchema;
  /** @deprecated use `TopicsControllerDeleteTopicSubscriptionsResponse$Outbound` instead. */
  export type Outbound = TopicsControllerDeleteTopicSubscriptionsResponse$Outbound;
}

export function topicsControllerDeleteTopicSubscriptionsResponseToJSON(
  topicsControllerDeleteTopicSubscriptionsResponse: TopicsControllerDeleteTopicSubscriptionsResponse
): string {
  return JSON.stringify(
    TopicsControllerDeleteTopicSubscriptionsResponse$outboundSchema.parse(
      topicsControllerDeleteTopicSubscriptionsResponse
    )
  );
}

export function topicsControllerDeleteTopicSubscriptionsResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerDeleteTopicSubscriptionsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerDeleteTopicSubscriptionsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerDeleteTopicSubscriptionsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsControllerDeleteTopicSubscriptionsRequestToJSON(topicsControllerDeleteTopicSubscriptionsRequest: TopicsControllerDeleteTopicSubscriptionsRequest)
 - topicsControllerDeleteTopicSubscriptionsRequestFromJSON(jsonString: string)
 - topicsControllerDeleteTopicSubscriptionsResponseToJSON(topicsControllerDeleteTopicSubscriptionsResponse: TopicsControllerDeleteTopicSubscriptionsResponse)
 - topicsControllerDeleteTopicSubscriptionsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsControllerDeleteTopicSubscriptionsRequest$Outbound;
}

export function topicsControllerDeleteT...)
 - Outbound(TopicsControllerDeleteTopicSubscriptionsResponse$Outbound;
}

export function topicsControllerDelete...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerDeleteTopicSubscriptionsRequestToJSON
- export function topicsControllerDeleteTopicSubscriptionsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerDeleteTopicSubscriptionsResponseToJSON
- export function topicsControllerDeleteTopicSubscriptionsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicscontrollergettopic.ts
Tamaño: 5131 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicsControllerGetTopicRequest = {
  /**
   * The key identifier of the topic
   */
  topicKey: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type TopicsControllerGetTopicResponse = {
  headers: { [k: string]: Array<string> };
  result: components.TopicResponseDto;
};

/** @internal */
export const TopicsControllerGetTopicRequest$inboundSchema: z.ZodType<
  TopicsControllerGetTopicRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    topicKey: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TopicsControllerGetTopicRequest$Outbound = {
  topicKey: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TopicsControllerGetTopicRequest$outboundSchema: z.ZodType<
  TopicsControllerGetTopicRequest$Outbound,
  z.ZodTypeDef,
  TopicsControllerGetTopicRequest
> = z
  .object({
    topicKey: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerGetTopicRequest$ {
  /** @deprecated use `TopicsControllerGetTopicRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerGetTopicRequest$inboundSchema;
  /** @deprecated use `TopicsControllerGetTopicRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerGetTopicRequest$outboundSchema;
  /** @deprecated use `TopicsControllerGetTopicRequest$Outbound` instead. */
  export type Outbound = TopicsControllerGetTopicRequest$Outbound;
}

export function topicsControllerGetTopicRequestToJSON(
  topicsControllerGetTopicRequest: TopicsControllerGetTopicRequest
): string {
  return JSON.stringify(TopicsControllerGetTopicRequest$outboundSchema.parse(topicsControllerGetTopicRequest));
}

export function topicsControllerGetTopicRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerGetTopicRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerGetTopicRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerGetTopicRequest' from JSON`
  );
}

/** @internal */
export const TopicsControllerGetTopicResponse$inboundSchema: z.ZodType<
  TopicsControllerGetTopicResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.TopicResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsControllerGetTopicResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.TopicResponseDto$Outbound;
};

/** @internal */
export const TopicsControllerGetTopicResponse$outboundSchema: z.ZodType<
  TopicsControllerGetTopicResponse$Outbound,
  z.ZodTypeDef,
  TopicsControllerGetTopicResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.TopicResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerGetTopicResponse$ {
  /** @deprecated use `TopicsControllerGetTopicResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerGetTopicResponse$inboundSchema;
  /** @deprecated use `TopicsControllerGetTopicResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerGetTopicResponse$outboundSchema;
  /** @deprecated use `TopicsControllerGetTopicResponse$Outbound` instead. */
  export type Outbound = TopicsControllerGetTopicResponse$Outbound;
}

export function topicsControllerGetTopicResponseToJSON(
  topicsControllerGetTopicResponse: TopicsControllerGetTopicResponse
): string {
  return JSON.stringify(TopicsControllerGetTopicResponse$outboundSchema.parse(topicsControllerGetTopicResponse));
}

export function topicsControllerGetTopicResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerGetTopicResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerGetTopicResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerGetTopicResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsControllerGetTopicRequestToJSON(topicsControllerGetTopicRequest: TopicsControllerGetTopicRequest)
 - topicsControllerGetTopicRequestFromJSON(jsonString: string)
 - topicsControllerGetTopicResponseToJSON(topicsControllerGetTopicResponse: TopicsControllerGetTopicResponse)
 - topicsControllerGetTopicResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsControllerGetTopicRequest$Outbound;
}

export function topicsControllerGetTopicRequestToJSON(
...)
 - Outbound(TopicsControllerGetTopicResponse$Outbound;
}

export function topicsControllerGetTopicResponseToJSON...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerGetTopicRequestToJSON
- export function topicsControllerGetTopicRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerGetTopicResponseToJSON
- export function topicsControllerGetTopicResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicscontrollerlisttopics.ts
Tamaño: 8322 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Direction of sorting
 */
export const TopicsControllerListTopicsQueryParamOrderDirection = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;
/**
 * Direction of sorting
 */
export type TopicsControllerListTopicsQueryParamOrderDirection = ClosedEnum<
  typeof TopicsControllerListTopicsQueryParamOrderDirection
>;

export type TopicsControllerListTopicsRequest = {
  /**
   * Cursor for pagination indicating the starting point after which to fetch results.
   */
  after?: string | undefined;
  /**
   * Cursor for pagination indicating the ending point before which to fetch results.
   */
  before?: string | undefined;
  /**
   * Limit the number of items to return (max 100)
   */
  limit?: number | undefined;
  /**
   * Direction of sorting
   */
  orderDirection?: TopicsControllerListTopicsQueryParamOrderDirection | undefined;
  /**
   * Field to order by
   */
  orderBy?: string | undefined;
  /**
   * Include cursor item in response
   */
  includeCursor?: boolean | undefined;
  /**
   * Key of the topic to filter results.
   */
  key?: string | undefined;
  /**
   * Name of the topic to filter results.
   */
  name?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type TopicsControllerListTopicsResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ListTopicsResponseDto;
};

/** @internal */
export const TopicsControllerListTopicsQueryParamOrderDirection$inboundSchema: z.ZodNativeEnum<
  typeof TopicsControllerListTopicsQueryParamOrderDirection
> = z.nativeEnum(TopicsControllerListTopicsQueryParamOrderDirection);

/** @internal */
export const TopicsControllerListTopicsQueryParamOrderDirection$outboundSchema: z.ZodNativeEnum<
  typeof TopicsControllerListTopicsQueryParamOrderDirection
> = TopicsControllerListTopicsQueryParamOrderDirection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerListTopicsQueryParamOrderDirection$ {
  /** @deprecated use `TopicsControllerListTopicsQueryParamOrderDirection$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerListTopicsQueryParamOrderDirection$inboundSchema;
  /** @deprecated use `TopicsControllerListTopicsQueryParamOrderDirection$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerListTopicsQueryParamOrderDirection$outboundSchema;
}

/** @internal */
export const TopicsControllerListTopicsRequest$inboundSchema: z.ZodType<
  TopicsControllerListTopicsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: TopicsControllerListTopicsQueryParamOrderDirection$inboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    key: z.string().optional(),
    name: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TopicsControllerListTopicsRequest$Outbound = {
  after?: string | undefined;
  before?: string | undefined;
  limit?: number | undefined;
  orderDirection?: string | undefined;
  orderBy?: string | undefined;
  includeCursor?: boolean | undefined;
  key?: string | undefined;
  name?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TopicsControllerListTopicsRequest$outboundSchema: z.ZodType<
  TopicsControllerListTopicsRequest$Outbound,
  z.ZodTypeDef,
  TopicsControllerListTopicsRequest
> = z
  .object({
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: TopicsControllerListTopicsQueryParamOrderDirection$outboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    key: z.string().optional(),
    name: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerListTopicsRequest$ {
  /** @deprecated use `TopicsControllerListTopicsRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerListTopicsRequest$inboundSchema;
  /** @deprecated use `TopicsControllerListTopicsRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerListTopicsRequest$outboundSchema;
  /** @deprecated use `TopicsControllerListTopicsRequest$Outbound` instead. */
  export type Outbound = TopicsControllerListTopicsRequest$Outbound;
}

export function topicsControllerListTopicsRequestToJSON(
  topicsControllerListTopicsRequest: TopicsControllerListTopicsRequest
): string {
  return JSON.stringify(TopicsControllerListTopicsRequest$outboundSchema.parse(topicsControllerListTopicsRequest));
}

export function topicsControllerListTopicsRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerListTopicsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerListTopicsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerListTopicsRequest' from JSON`
  );
}

/** @internal */
export const TopicsControllerListTopicsResponse$inboundSchema: z.ZodType<
  TopicsControllerListTopicsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ListTopicsResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsControllerListTopicsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ListTopicsResponseDto$Outbound;
};

/** @internal */
export const TopicsControllerListTopicsResponse$outboundSchema: z.ZodType<
  TopicsControllerListTopicsResponse$Outbound,
  z.ZodTypeDef,
  TopicsControllerListTopicsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ListTopicsResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerListTopicsResponse$ {
  /** @deprecated use `TopicsControllerListTopicsResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerListTopicsResponse$inboundSchema;
  /** @deprecated use `TopicsControllerListTopicsResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerListTopicsResponse$outboundSchema;
  /** @deprecated use `TopicsControllerListTopicsResponse$Outbound` instead. */
  export type Outbound = TopicsControllerListTopicsResponse$Outbound;
}

export function topicsControllerListTopicsResponseToJSON(
  topicsControllerListTopicsResponse: TopicsControllerListTopicsResponse
): string {
  return JSON.stringify(TopicsControllerListTopicsResponse$outboundSchema.parse(topicsControllerListTopicsResponse));
}

export function topicsControllerListTopicsResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerListTopicsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerListTopicsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerListTopicsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsControllerListTopicsRequestToJSON(topicsControllerListTopicsRequest: TopicsControllerListTopicsRequest)
 - topicsControllerListTopicsRequestFromJSON(jsonString: string)
 - topicsControllerListTopicsResponseToJSON(topicsControllerListTopicsResponse: TopicsControllerListTopicsResponse)
 - topicsControllerListTopicsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsControllerListTopicsRequest$Outbound;
}

export function topicsControllerListTopicsRequestToJS...)
 - Outbound(TopicsControllerListTopicsResponse$Outbound;
}

export function topicsControllerListTopicsResponseTo...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerListTopicsRequestToJSON
- export function topicsControllerListTopicsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerListTopicsResponseToJSON
- export function topicsControllerListTopicsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicscontrollerlisttopicsubscriptions.ts
Tamaño: 9129 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Direction of sorting
 */
export const TopicsControllerListTopicSubscriptionsQueryParamOrderDirection = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;
/**
 * Direction of sorting
 */
export type TopicsControllerListTopicSubscriptionsQueryParamOrderDirection = ClosedEnum<
  typeof TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
>;

export type TopicsControllerListTopicSubscriptionsRequest = {
  /**
   * The key identifier of the topic
   */
  topicKey: string;
  /**
   * Cursor for pagination indicating the starting point after which to fetch results.
   */
  after?: string | undefined;
  /**
   * Cursor for pagination indicating the ending point before which to fetch results.
   */
  before?: string | undefined;
  /**
   * Limit the number of items to return (max 100)
   */
  limit?: number | undefined;
  /**
   * Direction of sorting
   */
  orderDirection?: TopicsControllerListTopicSubscriptionsQueryParamOrderDirection | undefined;
  /**
   * Field to order by
   */
  orderBy?: string | undefined;
  /**
   * Include cursor item in response
   */
  includeCursor?: boolean | undefined;
  /**
   * Filter by subscriber ID
   */
  subscriberId?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type TopicsControllerListTopicSubscriptionsResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ListTopicSubscriptionsResponseDto;
};

/** @internal */
export const TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$inboundSchema: z.ZodNativeEnum<
  typeof TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
> = z.nativeEnum(TopicsControllerListTopicSubscriptionsQueryParamOrderDirection);

/** @internal */
export const TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$outboundSchema: z.ZodNativeEnum<
  typeof TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
> = TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$ {
  /** @deprecated use `TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$inboundSchema;
  /** @deprecated use `TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$outboundSchema;
}

/** @internal */
export const TopicsControllerListTopicSubscriptionsRequest$inboundSchema: z.ZodType<
  TopicsControllerListTopicSubscriptionsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    topicKey: z.string(),
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$inboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    subscriberId: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TopicsControllerListTopicSubscriptionsRequest$Outbound = {
  topicKey: string;
  after?: string | undefined;
  before?: string | undefined;
  limit?: number | undefined;
  orderDirection?: string | undefined;
  orderBy?: string | undefined;
  includeCursor?: boolean | undefined;
  subscriberId?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TopicsControllerListTopicSubscriptionsRequest$outboundSchema: z.ZodType<
  TopicsControllerListTopicSubscriptionsRequest$Outbound,
  z.ZodTypeDef,
  TopicsControllerListTopicSubscriptionsRequest
> = z
  .object({
    topicKey: z.string(),
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$outboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    subscriberId: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerListTopicSubscriptionsRequest$ {
  /** @deprecated use `TopicsControllerListTopicSubscriptionsRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerListTopicSubscriptionsRequest$inboundSchema;
  /** @deprecated use `TopicsControllerListTopicSubscriptionsRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerListTopicSubscriptionsRequest$outboundSchema;
  /** @deprecated use `TopicsControllerListTopicSubscriptionsRequest$Outbound` instead. */
  export type Outbound = TopicsControllerListTopicSubscriptionsRequest$Outbound;
}

export function topicsControllerListTopicSubscriptionsRequestToJSON(
  topicsControllerListTopicSubscriptionsRequest: TopicsControllerListTopicSubscriptionsRequest
): string {
  return JSON.stringify(
    TopicsControllerListTopicSubscriptionsRequest$outboundSchema.parse(topicsControllerListTopicSubscriptionsRequest)
  );
}

export function topicsControllerListTopicSubscriptionsRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerListTopicSubscriptionsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerListTopicSubscriptionsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerListTopicSubscriptionsRequest' from JSON`
  );
}

/** @internal */
export const TopicsControllerListTopicSubscriptionsResponse$inboundSchema: z.ZodType<
  TopicsControllerListTopicSubscriptionsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ListTopicSubscriptionsResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsControllerListTopicSubscriptionsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ListTopicSubscriptionsResponseDto$Outbound;
};

/** @internal */
export const TopicsControllerListTopicSubscriptionsResponse$outboundSchema: z.ZodType<
  TopicsControllerListTopicSubscriptionsResponse$Outbound,
  z.ZodTypeDef,
  TopicsControllerListTopicSubscriptionsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ListTopicSubscriptionsResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerListTopicSubscriptionsResponse$ {
  /** @deprecated use `TopicsControllerListTopicSubscriptionsResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerListTopicSubscriptionsResponse$inboundSchema;
  /** @deprecated use `TopicsControllerListTopicSubscriptionsResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerListTopicSubscriptionsResponse$outboundSchema;
  /** @deprecated use `TopicsControllerListTopicSubscriptionsResponse$Outbound` instead. */
  export type Outbound = TopicsControllerListTopicSubscriptionsResponse$Outbound;
}

export function topicsControllerListTopicSubscriptionsResponseToJSON(
  topicsControllerListTopicSubscriptionsResponse: TopicsControllerListTopicSubscriptionsResponse
): string {
  return JSON.stringify(
    TopicsControllerListTopicSubscriptionsResponse$outboundSchema.parse(topicsControllerListTopicSubscriptionsResponse)
  );
}

export function topicsControllerListTopicSubscriptionsResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerListTopicSubscriptionsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerListTopicSubscriptionsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerListTopicSubscriptionsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsControllerListTopicSubscriptionsRequestToJSON(topicsControllerListTopicSubscriptionsRequest: TopicsControllerListTopicSubscriptionsRequest)
 - topicsControllerListTopicSubscriptionsRequestFromJSON(jsonString: string)
 - topicsControllerListTopicSubscriptionsResponseToJSON(topicsControllerListTopicSubscriptionsResponse: TopicsControllerListTopicSubscriptionsResponse)
 - topicsControllerListTopicSubscriptionsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsControllerListTopicSubscriptionsRequest$Outbound;
}

export function topicsControllerListTopic...)
 - Outbound(TopicsControllerListTopicSubscriptionsResponse$Outbound;
}

export function topicsControllerListTopi...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerListTopicSubscriptionsRequestToJSON
- export function topicsControllerListTopicSubscriptionsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerListTopicSubscriptionsResponseToJSON
- export function topicsControllerListTopicSubscriptionsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicscontrollerupdatetopic.ts
Tamaño: 5655 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicsControllerUpdateTopicRequest = {
  /**
   * The key identifier of the topic
   */
  topicKey: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  updateTopicRequestDto: components.UpdateTopicRequestDto;
};

export type TopicsControllerUpdateTopicResponse = {
  headers: { [k: string]: Array<string> };
  result: components.TopicResponseDto;
};

/** @internal */
export const TopicsControllerUpdateTopicRequest$inboundSchema: z.ZodType<
  TopicsControllerUpdateTopicRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    topicKey: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateTopicRequestDto: components.UpdateTopicRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateTopicRequestDto: 'updateTopicRequestDto',
    });
  });

/** @internal */
export type TopicsControllerUpdateTopicRequest$Outbound = {
  topicKey: string;
  'idempotency-key'?: string | undefined;
  UpdateTopicRequestDto: components.UpdateTopicRequestDto$Outbound;
};

/** @internal */
export const TopicsControllerUpdateTopicRequest$outboundSchema: z.ZodType<
  TopicsControllerUpdateTopicRequest$Outbound,
  z.ZodTypeDef,
  TopicsControllerUpdateTopicRequest
> = z
  .object({
    topicKey: z.string(),
    idempotencyKey: z.string().optional(),
    updateTopicRequestDto: components.UpdateTopicRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateTopicRequestDto: 'UpdateTopicRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerUpdateTopicRequest$ {
  /** @deprecated use `TopicsControllerUpdateTopicRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerUpdateTopicRequest$inboundSchema;
  /** @deprecated use `TopicsControllerUpdateTopicRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerUpdateTopicRequest$outboundSchema;
  /** @deprecated use `TopicsControllerUpdateTopicRequest$Outbound` instead. */
  export type Outbound = TopicsControllerUpdateTopicRequest$Outbound;
}

export function topicsControllerUpdateTopicRequestToJSON(
  topicsControllerUpdateTopicRequest: TopicsControllerUpdateTopicRequest
): string {
  return JSON.stringify(TopicsControllerUpdateTopicRequest$outboundSchema.parse(topicsControllerUpdateTopicRequest));
}

export function topicsControllerUpdateTopicRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerUpdateTopicRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerUpdateTopicRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerUpdateTopicRequest' from JSON`
  );
}

/** @internal */
export const TopicsControllerUpdateTopicResponse$inboundSchema: z.ZodType<
  TopicsControllerUpdateTopicResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.TopicResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsControllerUpdateTopicResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.TopicResponseDto$Outbound;
};

/** @internal */
export const TopicsControllerUpdateTopicResponse$outboundSchema: z.ZodType<
  TopicsControllerUpdateTopicResponse$Outbound,
  z.ZodTypeDef,
  TopicsControllerUpdateTopicResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.TopicResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerUpdateTopicResponse$ {
  /** @deprecated use `TopicsControllerUpdateTopicResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerUpdateTopicResponse$inboundSchema;
  /** @deprecated use `TopicsControllerUpdateTopicResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerUpdateTopicResponse$outboundSchema;
  /** @deprecated use `TopicsControllerUpdateTopicResponse$Outbound` instead. */
  export type Outbound = TopicsControllerUpdateTopicResponse$Outbound;
}

export function topicsControllerUpdateTopicResponseToJSON(
  topicsControllerUpdateTopicResponse: TopicsControllerUpdateTopicResponse
): string {
  return JSON.stringify(TopicsControllerUpdateTopicResponse$outboundSchema.parse(topicsControllerUpdateTopicResponse));
}

export function topicsControllerUpdateTopicResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerUpdateTopicResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerUpdateTopicResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerUpdateTopicResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsControllerUpdateTopicRequestToJSON(topicsControllerUpdateTopicRequest: TopicsControllerUpdateTopicRequest)
 - topicsControllerUpdateTopicRequestFromJSON(jsonString: string)
 - topicsControllerUpdateTopicResponseToJSON(topicsControllerUpdateTopicResponse: TopicsControllerUpdateTopicResponse)
 - topicsControllerUpdateTopicResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsControllerUpdateTopicRequest$Outbound;
}

export function topicsControllerUpdateTopicRequestTo...)
 - Outbound(TopicsControllerUpdateTopicResponse$Outbound;
}

export function topicsControllerUpdateTopicResponse...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerUpdateTopicRequestToJSON
- export function topicsControllerUpdateTopicRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerUpdateTopicResponseToJSON
- export function topicsControllerUpdateTopicResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicscontrollerupserttopic.ts
Tamaño: 5838 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicsControllerUpsertTopicRequest = {
  /**
   * If true, the request will fail if a topic with the same key already exists
   */
  failIfExists?: boolean | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  createUpdateTopicRequestDto: components.CreateUpdateTopicRequestDto;
};

export type TopicsControllerUpsertTopicResponse = {
  headers: { [k: string]: Array<string> };
  result: components.TopicResponseDto;
};

/** @internal */
export const TopicsControllerUpsertTopicRequest$inboundSchema: z.ZodType<
  TopicsControllerUpsertTopicRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    failIfExists: z.boolean().optional(),
    'idempotency-key': z.string().optional(),
    CreateUpdateTopicRequestDto: components.CreateUpdateTopicRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateUpdateTopicRequestDto: 'createUpdateTopicRequestDto',
    });
  });

/** @internal */
export type TopicsControllerUpsertTopicRequest$Outbound = {
  failIfExists?: boolean | undefined;
  'idempotency-key'?: string | undefined;
  CreateUpdateTopicRequestDto: components.CreateUpdateTopicRequestDto$Outbound;
};

/** @internal */
export const TopicsControllerUpsertTopicRequest$outboundSchema: z.ZodType<
  TopicsControllerUpsertTopicRequest$Outbound,
  z.ZodTypeDef,
  TopicsControllerUpsertTopicRequest
> = z
  .object({
    failIfExists: z.boolean().optional(),
    idempotencyKey: z.string().optional(),
    createUpdateTopicRequestDto: components.CreateUpdateTopicRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createUpdateTopicRequestDto: 'CreateUpdateTopicRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerUpsertTopicRequest$ {
  /** @deprecated use `TopicsControllerUpsertTopicRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerUpsertTopicRequest$inboundSchema;
  /** @deprecated use `TopicsControllerUpsertTopicRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerUpsertTopicRequest$outboundSchema;
  /** @deprecated use `TopicsControllerUpsertTopicRequest$Outbound` instead. */
  export type Outbound = TopicsControllerUpsertTopicRequest$Outbound;
}

export function topicsControllerUpsertTopicRequestToJSON(
  topicsControllerUpsertTopicRequest: TopicsControllerUpsertTopicRequest
): string {
  return JSON.stringify(TopicsControllerUpsertTopicRequest$outboundSchema.parse(topicsControllerUpsertTopicRequest));
}

export function topicsControllerUpsertTopicRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerUpsertTopicRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerUpsertTopicRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerUpsertTopicRequest' from JSON`
  );
}

/** @internal */
export const TopicsControllerUpsertTopicResponse$inboundSchema: z.ZodType<
  TopicsControllerUpsertTopicResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.TopicResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsControllerUpsertTopicResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.TopicResponseDto$Outbound;
};

/** @internal */
export const TopicsControllerUpsertTopicResponse$outboundSchema: z.ZodType<
  TopicsControllerUpsertTopicResponse$Outbound,
  z.ZodTypeDef,
  TopicsControllerUpsertTopicResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.TopicResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerUpsertTopicResponse$ {
  /** @deprecated use `TopicsControllerUpsertTopicResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerUpsertTopicResponse$inboundSchema;
  /** @deprecated use `TopicsControllerUpsertTopicResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerUpsertTopicResponse$outboundSchema;
  /** @deprecated use `TopicsControllerUpsertTopicResponse$Outbound` instead. */
  export type Outbound = TopicsControllerUpsertTopicResponse$Outbound;
}

export function topicsControllerUpsertTopicResponseToJSON(
  topicsControllerUpsertTopicResponse: TopicsControllerUpsertTopicResponse
): string {
  return JSON.stringify(TopicsControllerUpsertTopicResponse$outboundSchema.parse(topicsControllerUpsertTopicResponse));
}

export function topicsControllerUpsertTopicResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerUpsertTopicResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerUpsertTopicResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerUpsertTopicResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsControllerUpsertTopicRequestToJSON(topicsControllerUpsertTopicRequest: TopicsControllerUpsertTopicRequest)
 - topicsControllerUpsertTopicRequestFromJSON(jsonString: string)
 - topicsControllerUpsertTopicResponseToJSON(topicsControllerUpsertTopicResponse: TopicsControllerUpsertTopicResponse)
 - topicsControllerUpsertTopicResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsControllerUpsertTopicRequest$Outbound;
}

export function topicsControllerUpsertTopicRequestTo...)
 - Outbound(TopicsControllerUpsertTopicResponse$Outbound;
}

export function topicsControllerUpsertTopicResponse...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerUpsertTopicRequestToJSON
- export function topicsControllerUpsertTopicRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerUpsertTopicResponseToJSON
- export function topicsControllerUpsertTopicResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicsv1controllergettopicsubscriber.ts
Tamaño: 5873 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicsV1ControllerGetTopicSubscriberRequest = {
  /**
   * The topic key
   */
  topicKey: string;
  /**
   * The external subscriber id
   */
  externalSubscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type TopicsV1ControllerGetTopicSubscriberResponse = {
  headers: { [k: string]: Array<string> };
  result: components.TopicSubscriberDto;
};

/** @internal */
export const TopicsV1ControllerGetTopicSubscriberRequest$inboundSchema: z.ZodType<
  TopicsV1ControllerGetTopicSubscriberRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    topicKey: z.string(),
    externalSubscriberId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TopicsV1ControllerGetTopicSubscriberRequest$Outbound = {
  topicKey: string;
  externalSubscriberId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TopicsV1ControllerGetTopicSubscriberRequest$outboundSchema: z.ZodType<
  TopicsV1ControllerGetTopicSubscriberRequest$Outbound,
  z.ZodTypeDef,
  TopicsV1ControllerGetTopicSubscriberRequest
> = z
  .object({
    topicKey: z.string(),
    externalSubscriberId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsV1ControllerGetTopicSubscriberRequest$ {
  /** @deprecated use `TopicsV1ControllerGetTopicSubscriberRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsV1ControllerGetTopicSubscriberRequest$inboundSchema;
  /** @deprecated use `TopicsV1ControllerGetTopicSubscriberRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsV1ControllerGetTopicSubscriberRequest$outboundSchema;
  /** @deprecated use `TopicsV1ControllerGetTopicSubscriberRequest$Outbound` instead. */
  export type Outbound = TopicsV1ControllerGetTopicSubscriberRequest$Outbound;
}

export function topicsV1ControllerGetTopicSubscriberRequestToJSON(
  topicsV1ControllerGetTopicSubscriberRequest: TopicsV1ControllerGetTopicSubscriberRequest
): string {
  return JSON.stringify(
    TopicsV1ControllerGetTopicSubscriberRequest$outboundSchema.parse(topicsV1ControllerGetTopicSubscriberRequest)
  );
}

export function topicsV1ControllerGetTopicSubscriberRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsV1ControllerGetTopicSubscriberRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsV1ControllerGetTopicSubscriberRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsV1ControllerGetTopicSubscriberRequest' from JSON`
  );
}

/** @internal */
export const TopicsV1ControllerGetTopicSubscriberResponse$inboundSchema: z.ZodType<
  TopicsV1ControllerGetTopicSubscriberResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.TopicSubscriberDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsV1ControllerGetTopicSubscriberResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.TopicSubscriberDto$Outbound;
};

/** @internal */
export const TopicsV1ControllerGetTopicSubscriberResponse$outboundSchema: z.ZodType<
  TopicsV1ControllerGetTopicSubscriberResponse$Outbound,
  z.ZodTypeDef,
  TopicsV1ControllerGetTopicSubscriberResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.TopicSubscriberDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsV1ControllerGetTopicSubscriberResponse$ {
  /** @deprecated use `TopicsV1ControllerGetTopicSubscriberResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsV1ControllerGetTopicSubscriberResponse$inboundSchema;
  /** @deprecated use `TopicsV1ControllerGetTopicSubscriberResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsV1ControllerGetTopicSubscriberResponse$outboundSchema;
  /** @deprecated use `TopicsV1ControllerGetTopicSubscriberResponse$Outbound` instead. */
  export type Outbound = TopicsV1ControllerGetTopicSubscriberResponse$Outbound;
}

export function topicsV1ControllerGetTopicSubscriberResponseToJSON(
  topicsV1ControllerGetTopicSubscriberResponse: TopicsV1ControllerGetTopicSubscriberResponse
): string {
  return JSON.stringify(
    TopicsV1ControllerGetTopicSubscriberResponse$outboundSchema.parse(topicsV1ControllerGetTopicSubscriberResponse)
  );
}

export function topicsV1ControllerGetTopicSubscriberResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsV1ControllerGetTopicSubscriberResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsV1ControllerGetTopicSubscriberResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsV1ControllerGetTopicSubscriberResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsV1ControllerGetTopicSubscriberRequestToJSON(topicsV1ControllerGetTopicSubscriberRequest: TopicsV1ControllerGetTopicSubscriberRequest)
 - topicsV1ControllerGetTopicSubscriberRequestFromJSON(jsonString: string)
 - topicsV1ControllerGetTopicSubscriberResponseToJSON(topicsV1ControllerGetTopicSubscriberResponse: TopicsV1ControllerGetTopicSubscriberResponse)
 - topicsV1ControllerGetTopicSubscriberResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsV1ControllerGetTopicSubscriberRequest$Outbound;
}

export function topicsV1ControllerGetTopicS...)
 - Outbound(TopicsV1ControllerGetTopicSubscriberResponse$Outbound;
}

export function topicsV1ControllerGetTopic...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsV1ControllerGetTopicSubscriberRequestToJSON
- export function topicsV1ControllerGetTopicSubscriberRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsV1ControllerGetTopicSubscriberResponseToJSON
- export function topicsV1ControllerGetTopicSubscriberResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrollercreatetranslationendpoint.ts
Tamaño: 3585 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TranslationControllerCreateTranslationEndpointRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  createTranslationRequestDto: components.CreateTranslationRequestDto;
};

/** @internal */
export const TranslationControllerCreateTranslationEndpointRequest$inboundSchema: z.ZodType<
  TranslationControllerCreateTranslationEndpointRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    CreateTranslationRequestDto: components.CreateTranslationRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateTranslationRequestDto: 'createTranslationRequestDto',
    });
  });

/** @internal */
export type TranslationControllerCreateTranslationEndpointRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  CreateTranslationRequestDto: components.CreateTranslationRequestDto$Outbound;
};

/** @internal */
export const TranslationControllerCreateTranslationEndpointRequest$outboundSchema: z.ZodType<
  TranslationControllerCreateTranslationEndpointRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerCreateTranslationEndpointRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    createTranslationRequestDto: components.CreateTranslationRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createTranslationRequestDto: 'CreateTranslationRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerCreateTranslationEndpointRequest$ {
  /** @deprecated use `TranslationControllerCreateTranslationEndpointRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerCreateTranslationEndpointRequest$inboundSchema;
  /** @deprecated use `TranslationControllerCreateTranslationEndpointRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerCreateTranslationEndpointRequest$outboundSchema;
  /** @deprecated use `TranslationControllerCreateTranslationEndpointRequest$Outbound` instead. */
  export type Outbound = TranslationControllerCreateTranslationEndpointRequest$Outbound;
}

export function translationControllerCreateTranslationEndpointRequestToJSON(
  translationControllerCreateTranslationEndpointRequest: TranslationControllerCreateTranslationEndpointRequest
): string {
  return JSON.stringify(
    TranslationControllerCreateTranslationEndpointRequest$outboundSchema.parse(
      translationControllerCreateTranslationEndpointRequest
    )
  );
}

export function translationControllerCreateTranslationEndpointRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerCreateTranslationEndpointRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerCreateTranslationEndpointRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerCreateTranslationEndpointRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerCreateTranslationEndpointRequestToJSON(translationControllerCreateTranslationEndpointRequest: TranslationControllerCreateTranslationEndpointRequest)
 - translationControllerCreateTranslationEndpointRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerCreateTranslationEndpointRequest$Outbound;
}

export function translationContro...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerCreateTranslationEndpointRequestToJSON
- export function translationControllerCreateTranslationEndpointRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrollerdeletetranslationendpoint.ts
Tamaño: 5378 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Resource type
 */
export const TranslationControllerDeleteTranslationEndpointPathParamResourceType = {
  Workflow: 'workflow',
  Layout: 'layout',
} as const;
/**
 * Resource type
 */
export type TranslationControllerDeleteTranslationEndpointPathParamResourceType = ClosedEnum<
  typeof TranslationControllerDeleteTranslationEndpointPathParamResourceType
>;

export type TranslationControllerDeleteTranslationEndpointRequest = {
  /**
   * Resource type
   */
  resourceType: TranslationControllerDeleteTranslationEndpointPathParamResourceType;
  /**
   * Resource ID
   */
  resourceId: string;
  /**
   * Locale code
   */
  locale: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const TranslationControllerDeleteTranslationEndpointPathParamResourceType$inboundSchema: z.ZodNativeEnum<
  typeof TranslationControllerDeleteTranslationEndpointPathParamResourceType
> = z.nativeEnum(TranslationControllerDeleteTranslationEndpointPathParamResourceType);

/** @internal */
export const TranslationControllerDeleteTranslationEndpointPathParamResourceType$outboundSchema: z.ZodNativeEnum<
  typeof TranslationControllerDeleteTranslationEndpointPathParamResourceType
> = TranslationControllerDeleteTranslationEndpointPathParamResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerDeleteTranslationEndpointPathParamResourceType$ {
  /** @deprecated use `TranslationControllerDeleteTranslationEndpointPathParamResourceType$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerDeleteTranslationEndpointPathParamResourceType$inboundSchema;
  /** @deprecated use `TranslationControllerDeleteTranslationEndpointPathParamResourceType$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerDeleteTranslationEndpointPathParamResourceType$outboundSchema;
}

/** @internal */
export const TranslationControllerDeleteTranslationEndpointRequest$inboundSchema: z.ZodType<
  TranslationControllerDeleteTranslationEndpointRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    resourceType: TranslationControllerDeleteTranslationEndpointPathParamResourceType$inboundSchema,
    resourceId: z.string(),
    locale: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TranslationControllerDeleteTranslationEndpointRequest$Outbound = {
  resourceType: string;
  resourceId: string;
  locale: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TranslationControllerDeleteTranslationEndpointRequest$outboundSchema: z.ZodType<
  TranslationControllerDeleteTranslationEndpointRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerDeleteTranslationEndpointRequest
> = z
  .object({
    resourceType: TranslationControllerDeleteTranslationEndpointPathParamResourceType$outboundSchema,
    resourceId: z.string(),
    locale: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerDeleteTranslationEndpointRequest$ {
  /** @deprecated use `TranslationControllerDeleteTranslationEndpointRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerDeleteTranslationEndpointRequest$inboundSchema;
  /** @deprecated use `TranslationControllerDeleteTranslationEndpointRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerDeleteTranslationEndpointRequest$outboundSchema;
  /** @deprecated use `TranslationControllerDeleteTranslationEndpointRequest$Outbound` instead. */
  export type Outbound = TranslationControllerDeleteTranslationEndpointRequest$Outbound;
}

export function translationControllerDeleteTranslationEndpointRequestToJSON(
  translationControllerDeleteTranslationEndpointRequest: TranslationControllerDeleteTranslationEndpointRequest
): string {
  return JSON.stringify(
    TranslationControllerDeleteTranslationEndpointRequest$outboundSchema.parse(
      translationControllerDeleteTranslationEndpointRequest
    )
  );
}

export function translationControllerDeleteTranslationEndpointRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerDeleteTranslationEndpointRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerDeleteTranslationEndpointRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerDeleteTranslationEndpointRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerDeleteTranslationEndpointRequestToJSON(translationControllerDeleteTranslationEndpointRequest: TranslationControllerDeleteTranslationEndpointRequest)
 - translationControllerDeleteTranslationEndpointRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerDeleteTranslationEndpointRequest$Outbound;
}

export function translationContro...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerDeleteTranslationEndpointRequestToJSON
- export function translationControllerDeleteTranslationEndpointRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrollerdeletetranslationgroupendpoint.ts
Tamaño: 4433 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Resource type
 */
export const ResourceType = {
  Workflow: 'workflow',
  Layout: 'layout',
} as const;
/**
 * Resource type
 */
export type ResourceType = ClosedEnum<typeof ResourceType>;

export type TranslationControllerDeleteTranslationGroupEndpointRequest = {
  /**
   * Resource type
   */
  resourceType: ResourceType;
  /**
   * Resource ID
   */
  resourceId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const ResourceType$inboundSchema: z.ZodNativeEnum<typeof ResourceType> = z.nativeEnum(ResourceType);

/** @internal */
export const ResourceType$outboundSchema: z.ZodNativeEnum<typeof ResourceType> = ResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResourceType$ {
  /** @deprecated use `ResourceType$inboundSchema` instead. */
  export const inboundSchema = ResourceType$inboundSchema;
  /** @deprecated use `ResourceType$outboundSchema` instead. */
  export const outboundSchema = ResourceType$outboundSchema;
}

/** @internal */
export const TranslationControllerDeleteTranslationGroupEndpointRequest$inboundSchema: z.ZodType<
  TranslationControllerDeleteTranslationGroupEndpointRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    resourceType: ResourceType$inboundSchema,
    resourceId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TranslationControllerDeleteTranslationGroupEndpointRequest$Outbound = {
  resourceType: string;
  resourceId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TranslationControllerDeleteTranslationGroupEndpointRequest$outboundSchema: z.ZodType<
  TranslationControllerDeleteTranslationGroupEndpointRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerDeleteTranslationGroupEndpointRequest
> = z
  .object({
    resourceType: ResourceType$outboundSchema,
    resourceId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerDeleteTranslationGroupEndpointRequest$ {
  /** @deprecated use `TranslationControllerDeleteTranslationGroupEndpointRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerDeleteTranslationGroupEndpointRequest$inboundSchema;
  /** @deprecated use `TranslationControllerDeleteTranslationGroupEndpointRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerDeleteTranslationGroupEndpointRequest$outboundSchema;
  /** @deprecated use `TranslationControllerDeleteTranslationGroupEndpointRequest$Outbound` instead. */
  export type Outbound = TranslationControllerDeleteTranslationGroupEndpointRequest$Outbound;
}

export function translationControllerDeleteTranslationGroupEndpointRequestToJSON(
  translationControllerDeleteTranslationGroupEndpointRequest: TranslationControllerDeleteTranslationGroupEndpointRequest
): string {
  return JSON.stringify(
    TranslationControllerDeleteTranslationGroupEndpointRequest$outboundSchema.parse(
      translationControllerDeleteTranslationGroupEndpointRequest
    )
  );
}

export function translationControllerDeleteTranslationGroupEndpointRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerDeleteTranslationGroupEndpointRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerDeleteTranslationGroupEndpointRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerDeleteTranslationGroupEndpointRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerDeleteTranslationGroupEndpointRequestToJSON(translationControllerDeleteTranslationGroupEndpointRequest: TranslationControllerDeleteTranslationGroupEndpointRequest)
 - translationControllerDeleteTranslationGroupEndpointRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerDeleteTranslationGroupEndpointRequest$Outbound;
}

export function translationC...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerDeleteTranslationGroupEndpointRequestToJSON
- export function translationControllerDeleteTranslationGroupEndpointRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrollergetmasterjsonendpoint.ts
Tamaño: 3201 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TranslationControllerGetMasterJsonEndpointRequest = {
  /**
   * Locale to export. If not provided, exports organization default locale
   */
  locale?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const TranslationControllerGetMasterJsonEndpointRequest$inboundSchema: z.ZodType<
  TranslationControllerGetMasterJsonEndpointRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    locale: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TranslationControllerGetMasterJsonEndpointRequest$Outbound = {
  locale?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TranslationControllerGetMasterJsonEndpointRequest$outboundSchema: z.ZodType<
  TranslationControllerGetMasterJsonEndpointRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerGetMasterJsonEndpointRequest
> = z
  .object({
    locale: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerGetMasterJsonEndpointRequest$ {
  /** @deprecated use `TranslationControllerGetMasterJsonEndpointRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerGetMasterJsonEndpointRequest$inboundSchema;
  /** @deprecated use `TranslationControllerGetMasterJsonEndpointRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerGetMasterJsonEndpointRequest$outboundSchema;
  /** @deprecated use `TranslationControllerGetMasterJsonEndpointRequest$Outbound` instead. */
  export type Outbound = TranslationControllerGetMasterJsonEndpointRequest$Outbound;
}

export function translationControllerGetMasterJsonEndpointRequestToJSON(
  translationControllerGetMasterJsonEndpointRequest: TranslationControllerGetMasterJsonEndpointRequest
): string {
  return JSON.stringify(
    TranslationControllerGetMasterJsonEndpointRequest$outboundSchema.parse(
      translationControllerGetMasterJsonEndpointRequest
    )
  );
}

export function translationControllerGetMasterJsonEndpointRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerGetMasterJsonEndpointRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerGetMasterJsonEndpointRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerGetMasterJsonEndpointRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerGetMasterJsonEndpointRequestToJSON(translationControllerGetMasterJsonEndpointRequest: TranslationControllerGetMasterJsonEndpointRequest)
 - translationControllerGetMasterJsonEndpointRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerGetMasterJsonEndpointRequest$Outbound;
}

export function translationController...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerGetMasterJsonEndpointRequestToJSON
- export function translationControllerGetMasterJsonEndpointRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrollergetsingletranslation.ts
Tamaño: 4473 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Resource type
 */
export const PathParamResourceType = {
  Workflow: 'workflow',
  Layout: 'layout',
} as const;
/**
 * Resource type
 */
export type PathParamResourceType = ClosedEnum<typeof PathParamResourceType>;

export type TranslationControllerGetSingleTranslationRequest = {
  /**
   * Resource type
   */
  resourceType: PathParamResourceType;
  /**
   * Resource ID
   */
  resourceId: string;
  /**
   * Locale code
   */
  locale: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const PathParamResourceType$inboundSchema: z.ZodNativeEnum<typeof PathParamResourceType> =
  z.nativeEnum(PathParamResourceType);

/** @internal */
export const PathParamResourceType$outboundSchema: z.ZodNativeEnum<typeof PathParamResourceType> =
  PathParamResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PathParamResourceType$ {
  /** @deprecated use `PathParamResourceType$inboundSchema` instead. */
  export const inboundSchema = PathParamResourceType$inboundSchema;
  /** @deprecated use `PathParamResourceType$outboundSchema` instead. */
  export const outboundSchema = PathParamResourceType$outboundSchema;
}

/** @internal */
export const TranslationControllerGetSingleTranslationRequest$inboundSchema: z.ZodType<
  TranslationControllerGetSingleTranslationRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    resourceType: PathParamResourceType$inboundSchema,
    resourceId: z.string(),
    locale: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TranslationControllerGetSingleTranslationRequest$Outbound = {
  resourceType: string;
  resourceId: string;
  locale: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TranslationControllerGetSingleTranslationRequest$outboundSchema: z.ZodType<
  TranslationControllerGetSingleTranslationRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerGetSingleTranslationRequest
> = z
  .object({
    resourceType: PathParamResourceType$outboundSchema,
    resourceId: z.string(),
    locale: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerGetSingleTranslationRequest$ {
  /** @deprecated use `TranslationControllerGetSingleTranslationRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerGetSingleTranslationRequest$inboundSchema;
  /** @deprecated use `TranslationControllerGetSingleTranslationRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerGetSingleTranslationRequest$outboundSchema;
  /** @deprecated use `TranslationControllerGetSingleTranslationRequest$Outbound` instead. */
  export type Outbound = TranslationControllerGetSingleTranslationRequest$Outbound;
}

export function translationControllerGetSingleTranslationRequestToJSON(
  translationControllerGetSingleTranslationRequest: TranslationControllerGetSingleTranslationRequest
): string {
  return JSON.stringify(
    TranslationControllerGetSingleTranslationRequest$outboundSchema.parse(
      translationControllerGetSingleTranslationRequest
    )
  );
}

export function translationControllerGetSingleTranslationRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerGetSingleTranslationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerGetSingleTranslationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerGetSingleTranslationRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerGetSingleTranslationRequestToJSON(translationControllerGetSingleTranslationRequest: TranslationControllerGetSingleTranslationRequest)
 - translationControllerGetSingleTranslationRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerGetSingleTranslationRequest$Outbound;
}

export function translationControllerG...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerGetSingleTranslationRequestToJSON
- export function translationControllerGetSingleTranslationRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrollergettranslationgroupendpoint.ts
Tamaño: 5345 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Resource type
 */
export const TranslationControllerGetTranslationGroupEndpointPathParamResourceType = {
  Workflow: 'workflow',
  Layout: 'layout',
} as const;
/**
 * Resource type
 */
export type TranslationControllerGetTranslationGroupEndpointPathParamResourceType = ClosedEnum<
  typeof TranslationControllerGetTranslationGroupEndpointPathParamResourceType
>;

export type TranslationControllerGetTranslationGroupEndpointRequest = {
  /**
   * Resource type
   */
  resourceType: TranslationControllerGetTranslationGroupEndpointPathParamResourceType;
  /**
   * Resource ID
   */
  resourceId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const TranslationControllerGetTranslationGroupEndpointPathParamResourceType$inboundSchema: z.ZodNativeEnum<
  typeof TranslationControllerGetTranslationGroupEndpointPathParamResourceType
> = z.nativeEnum(TranslationControllerGetTranslationGroupEndpointPathParamResourceType);

/** @internal */
export const TranslationControllerGetTranslationGroupEndpointPathParamResourceType$outboundSchema: z.ZodNativeEnum<
  typeof TranslationControllerGetTranslationGroupEndpointPathParamResourceType
> = TranslationControllerGetTranslationGroupEndpointPathParamResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerGetTranslationGroupEndpointPathParamResourceType$ {
  /** @deprecated use `TranslationControllerGetTranslationGroupEndpointPathParamResourceType$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerGetTranslationGroupEndpointPathParamResourceType$inboundSchema;
  /** @deprecated use `TranslationControllerGetTranslationGroupEndpointPathParamResourceType$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerGetTranslationGroupEndpointPathParamResourceType$outboundSchema;
}

/** @internal */
export const TranslationControllerGetTranslationGroupEndpointRequest$inboundSchema: z.ZodType<
  TranslationControllerGetTranslationGroupEndpointRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    resourceType: TranslationControllerGetTranslationGroupEndpointPathParamResourceType$inboundSchema,
    resourceId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TranslationControllerGetTranslationGroupEndpointRequest$Outbound = {
  resourceType: string;
  resourceId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TranslationControllerGetTranslationGroupEndpointRequest$outboundSchema: z.ZodType<
  TranslationControllerGetTranslationGroupEndpointRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerGetTranslationGroupEndpointRequest
> = z
  .object({
    resourceType: TranslationControllerGetTranslationGroupEndpointPathParamResourceType$outboundSchema,
    resourceId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerGetTranslationGroupEndpointRequest$ {
  /** @deprecated use `TranslationControllerGetTranslationGroupEndpointRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerGetTranslationGroupEndpointRequest$inboundSchema;
  /** @deprecated use `TranslationControllerGetTranslationGroupEndpointRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerGetTranslationGroupEndpointRequest$outboundSchema;
  /** @deprecated use `TranslationControllerGetTranslationGroupEndpointRequest$Outbound` instead. */
  export type Outbound = TranslationControllerGetTranslationGroupEndpointRequest$Outbound;
}

export function translationControllerGetTranslationGroupEndpointRequestToJSON(
  translationControllerGetTranslationGroupEndpointRequest: TranslationControllerGetTranslationGroupEndpointRequest
): string {
  return JSON.stringify(
    TranslationControllerGetTranslationGroupEndpointRequest$outboundSchema.parse(
      translationControllerGetTranslationGroupEndpointRequest
    )
  );
}

export function translationControllerGetTranslationGroupEndpointRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerGetTranslationGroupEndpointRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerGetTranslationGroupEndpointRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerGetTranslationGroupEndpointRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerGetTranslationGroupEndpointRequestToJSON(translationControllerGetTranslationGroupEndpointRequest: TranslationControllerGetTranslationGroupEndpointRequest)
 - translationControllerGetTranslationGroupEndpointRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerGetTranslationGroupEndpointRequest$Outbound;
}

export function translationCont...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerGetTranslationGroupEndpointRequestToJSON
- export function translationControllerGetTranslationGroupEndpointRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrollerimportmasterjsonendpoint.ts
Tamaño: 3550 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TranslationControllerImportMasterJsonEndpointRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  importMasterJsonRequestDto: components.ImportMasterJsonRequestDto;
};

/** @internal */
export const TranslationControllerImportMasterJsonEndpointRequest$inboundSchema: z.ZodType<
  TranslationControllerImportMasterJsonEndpointRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    ImportMasterJsonRequestDto: components.ImportMasterJsonRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      ImportMasterJsonRequestDto: 'importMasterJsonRequestDto',
    });
  });

/** @internal */
export type TranslationControllerImportMasterJsonEndpointRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  ImportMasterJsonRequestDto: components.ImportMasterJsonRequestDto$Outbound;
};

/** @internal */
export const TranslationControllerImportMasterJsonEndpointRequest$outboundSchema: z.ZodType<
  TranslationControllerImportMasterJsonEndpointRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerImportMasterJsonEndpointRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    importMasterJsonRequestDto: components.ImportMasterJsonRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      importMasterJsonRequestDto: 'ImportMasterJsonRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerImportMasterJsonEndpointRequest$ {
  /** @deprecated use `TranslationControllerImportMasterJsonEndpointRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerImportMasterJsonEndpointRequest$inboundSchema;
  /** @deprecated use `TranslationControllerImportMasterJsonEndpointRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerImportMasterJsonEndpointRequest$outboundSchema;
  /** @deprecated use `TranslationControllerImportMasterJsonEndpointRequest$Outbound` instead. */
  export type Outbound = TranslationControllerImportMasterJsonEndpointRequest$Outbound;
}

export function translationControllerImportMasterJsonEndpointRequestToJSON(
  translationControllerImportMasterJsonEndpointRequest: TranslationControllerImportMasterJsonEndpointRequest
): string {
  return JSON.stringify(
    TranslationControllerImportMasterJsonEndpointRequest$outboundSchema.parse(
      translationControllerImportMasterJsonEndpointRequest
    )
  );
}

export function translationControllerImportMasterJsonEndpointRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerImportMasterJsonEndpointRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerImportMasterJsonEndpointRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerImportMasterJsonEndpointRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerImportMasterJsonEndpointRequestToJSON(translationControllerImportMasterJsonEndpointRequest: TranslationControllerImportMasterJsonEndpointRequest)
 - translationControllerImportMasterJsonEndpointRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerImportMasterJsonEndpointRequest$Outbound;
}

export function translationControl...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerImportMasterJsonEndpointRequestToJSON
- export function translationControllerImportMasterJsonEndpointRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrolleruploadmasterjsonendpoint.ts
Tamaño: 3050 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TranslationControllerUploadMasterJsonEndpointRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const TranslationControllerUploadMasterJsonEndpointRequest$inboundSchema: z.ZodType<
  TranslationControllerUploadMasterJsonEndpointRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TranslationControllerUploadMasterJsonEndpointRequest$Outbound = {
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TranslationControllerUploadMasterJsonEndpointRequest$outboundSchema: z.ZodType<
  TranslationControllerUploadMasterJsonEndpointRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerUploadMasterJsonEndpointRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerUploadMasterJsonEndpointRequest$ {
  /** @deprecated use `TranslationControllerUploadMasterJsonEndpointRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerUploadMasterJsonEndpointRequest$inboundSchema;
  /** @deprecated use `TranslationControllerUploadMasterJsonEndpointRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerUploadMasterJsonEndpointRequest$outboundSchema;
  /** @deprecated use `TranslationControllerUploadMasterJsonEndpointRequest$Outbound` instead. */
  export type Outbound = TranslationControllerUploadMasterJsonEndpointRequest$Outbound;
}

export function translationControllerUploadMasterJsonEndpointRequestToJSON(
  translationControllerUploadMasterJsonEndpointRequest: TranslationControllerUploadMasterJsonEndpointRequest
): string {
  return JSON.stringify(
    TranslationControllerUploadMasterJsonEndpointRequest$outboundSchema.parse(
      translationControllerUploadMasterJsonEndpointRequest
    )
  );
}

export function translationControllerUploadMasterJsonEndpointRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerUploadMasterJsonEndpointRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerUploadMasterJsonEndpointRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerUploadMasterJsonEndpointRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerUploadMasterJsonEndpointRequestToJSON(translationControllerUploadMasterJsonEndpointRequest: TranslationControllerUploadMasterJsonEndpointRequest)
 - translationControllerUploadMasterJsonEndpointRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerUploadMasterJsonEndpointRequest$Outbound;
}

export function translationControl...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerUploadMasterJsonEndpointRequestToJSON
- export function translationControllerUploadMasterJsonEndpointRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrolleruploadtranslationfiles.ts
Tamaño: 3583 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TranslationControllerUploadTranslationFilesRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Translation files upload body details
   */
  uploadTranslationsRequestDto: components.UploadTranslationsRequestDto;
};

/** @internal */
export const TranslationControllerUploadTranslationFilesRequest$inboundSchema: z.ZodType<
  TranslationControllerUploadTranslationFilesRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    UploadTranslationsRequestDto: components.UploadTranslationsRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UploadTranslationsRequestDto: 'uploadTranslationsRequestDto',
    });
  });

/** @internal */
export type TranslationControllerUploadTranslationFilesRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  UploadTranslationsRequestDto: components.UploadTranslationsRequestDto$Outbound;
};

/** @internal */
export const TranslationControllerUploadTranslationFilesRequest$outboundSchema: z.ZodType<
  TranslationControllerUploadTranslationFilesRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerUploadTranslationFilesRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    uploadTranslationsRequestDto: components.UploadTranslationsRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      uploadTranslationsRequestDto: 'UploadTranslationsRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerUploadTranslationFilesRequest$ {
  /** @deprecated use `TranslationControllerUploadTranslationFilesRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerUploadTranslationFilesRequest$inboundSchema;
  /** @deprecated use `TranslationControllerUploadTranslationFilesRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerUploadTranslationFilesRequest$outboundSchema;
  /** @deprecated use `TranslationControllerUploadTranslationFilesRequest$Outbound` instead. */
  export type Outbound = TranslationControllerUploadTranslationFilesRequest$Outbound;
}

export function translationControllerUploadTranslationFilesRequestToJSON(
  translationControllerUploadTranslationFilesRequest: TranslationControllerUploadTranslationFilesRequest
): string {
  return JSON.stringify(
    TranslationControllerUploadTranslationFilesRequest$outboundSchema.parse(
      translationControllerUploadTranslationFilesRequest
    )
  );
}

export function translationControllerUploadTranslationFilesRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerUploadTranslationFilesRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerUploadTranslationFilesRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerUploadTranslationFilesRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerUploadTranslationFilesRequestToJSON(translationControllerUploadTranslationFilesRequest: TranslationControllerUploadTranslationFilesRequest)
 - translationControllerUploadTranslationFilesRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerUploadTranslationFilesRequest$Outbound;
}

export function translationControlle...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerUploadTranslationFilesRequestToJSON
- export function translationControllerUploadTranslationFilesRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollercreate.ts
Tamaño: 5383 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerCreateRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Workflow creation details
   */
  createWorkflowDto: components.CreateWorkflowDto;
};

export type WorkflowControllerCreateResponse = {
  headers: { [k: string]: Array<string> };
  result: components.WorkflowResponseDto;
};

/** @internal */
export const WorkflowControllerCreateRequest$inboundSchema: z.ZodType<
  WorkflowControllerCreateRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    CreateWorkflowDto: components.CreateWorkflowDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateWorkflowDto: 'createWorkflowDto',
    });
  });

/** @internal */
export type WorkflowControllerCreateRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  CreateWorkflowDto: components.CreateWorkflowDto$Outbound;
};

/** @internal */
export const WorkflowControllerCreateRequest$outboundSchema: z.ZodType<
  WorkflowControllerCreateRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerCreateRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    createWorkflowDto: components.CreateWorkflowDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createWorkflowDto: 'CreateWorkflowDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerCreateRequest$ {
  /** @deprecated use `WorkflowControllerCreateRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerCreateRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerCreateRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerCreateRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerCreateRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerCreateRequest$Outbound;
}

export function workflowControllerCreateRequestToJSON(
  workflowControllerCreateRequest: WorkflowControllerCreateRequest
): string {
  return JSON.stringify(WorkflowControllerCreateRequest$outboundSchema.parse(workflowControllerCreateRequest));
}

export function workflowControllerCreateRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerCreateRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerCreateRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerCreateRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerCreateResponse$inboundSchema: z.ZodType<
  WorkflowControllerCreateResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.WorkflowResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerCreateResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.WorkflowResponseDto$Outbound;
};

/** @internal */
export const WorkflowControllerCreateResponse$outboundSchema: z.ZodType<
  WorkflowControllerCreateResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerCreateResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.WorkflowResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerCreateResponse$ {
  /** @deprecated use `WorkflowControllerCreateResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerCreateResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerCreateResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerCreateResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerCreateResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerCreateResponse$Outbound;
}

export function workflowControllerCreateResponseToJSON(
  workflowControllerCreateResponse: WorkflowControllerCreateResponse
): string {
  return JSON.stringify(WorkflowControllerCreateResponse$outboundSchema.parse(workflowControllerCreateResponse));
}

export function workflowControllerCreateResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerCreateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerCreateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerCreateResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerCreateRequestToJSON(workflowControllerCreateRequest: WorkflowControllerCreateRequest)
 - workflowControllerCreateRequestFromJSON(jsonString: string)
 - workflowControllerCreateResponseToJSON(workflowControllerCreateResponse: WorkflowControllerCreateResponse)
 - workflowControllerCreateResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerCreateRequest$Outbound;
}

export function workflowControllerCreateRequestToJSON(
...)
 - Outbound(WorkflowControllerCreateResponse$Outbound;
}

export function workflowControllerCreateResponseToJSON...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerCreateRequestToJSON
- export function workflowControllerCreateRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerCreateResponseToJSON
- export function workflowControllerCreateResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollerduplicateworkflow.ts
Tamaño: 5998 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerDuplicateWorkflowRequest = {
  workflowId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  duplicateWorkflowDto: components.DuplicateWorkflowDto;
};

export type WorkflowControllerDuplicateWorkflowResponse = {
  headers: { [k: string]: Array<string> };
  result: components.WorkflowResponseDto;
};

/** @internal */
export const WorkflowControllerDuplicateWorkflowRequest$inboundSchema: z.ZodType<
  WorkflowControllerDuplicateWorkflowRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowId: z.string(),
    'idempotency-key': z.string().optional(),
    DuplicateWorkflowDto: components.DuplicateWorkflowDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      DuplicateWorkflowDto: 'duplicateWorkflowDto',
    });
  });

/** @internal */
export type WorkflowControllerDuplicateWorkflowRequest$Outbound = {
  workflowId: string;
  'idempotency-key'?: string | undefined;
  DuplicateWorkflowDto: components.DuplicateWorkflowDto$Outbound;
};

/** @internal */
export const WorkflowControllerDuplicateWorkflowRequest$outboundSchema: z.ZodType<
  WorkflowControllerDuplicateWorkflowRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerDuplicateWorkflowRequest
> = z
  .object({
    workflowId: z.string(),
    idempotencyKey: z.string().optional(),
    duplicateWorkflowDto: components.DuplicateWorkflowDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      duplicateWorkflowDto: 'DuplicateWorkflowDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerDuplicateWorkflowRequest$ {
  /** @deprecated use `WorkflowControllerDuplicateWorkflowRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerDuplicateWorkflowRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerDuplicateWorkflowRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerDuplicateWorkflowRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerDuplicateWorkflowRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerDuplicateWorkflowRequest$Outbound;
}

export function workflowControllerDuplicateWorkflowRequestToJSON(
  workflowControllerDuplicateWorkflowRequest: WorkflowControllerDuplicateWorkflowRequest
): string {
  return JSON.stringify(
    WorkflowControllerDuplicateWorkflowRequest$outboundSchema.parse(workflowControllerDuplicateWorkflowRequest)
  );
}

export function workflowControllerDuplicateWorkflowRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerDuplicateWorkflowRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerDuplicateWorkflowRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerDuplicateWorkflowRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerDuplicateWorkflowResponse$inboundSchema: z.ZodType<
  WorkflowControllerDuplicateWorkflowResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.WorkflowResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerDuplicateWorkflowResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.WorkflowResponseDto$Outbound;
};

/** @internal */
export const WorkflowControllerDuplicateWorkflowResponse$outboundSchema: z.ZodType<
  WorkflowControllerDuplicateWorkflowResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerDuplicateWorkflowResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.WorkflowResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerDuplicateWorkflowResponse$ {
  /** @deprecated use `WorkflowControllerDuplicateWorkflowResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerDuplicateWorkflowResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerDuplicateWorkflowResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerDuplicateWorkflowResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerDuplicateWorkflowResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerDuplicateWorkflowResponse$Outbound;
}

export function workflowControllerDuplicateWorkflowResponseToJSON(
  workflowControllerDuplicateWorkflowResponse: WorkflowControllerDuplicateWorkflowResponse
): string {
  return JSON.stringify(
    WorkflowControllerDuplicateWorkflowResponse$outboundSchema.parse(workflowControllerDuplicateWorkflowResponse)
  );
}

export function workflowControllerDuplicateWorkflowResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerDuplicateWorkflowResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerDuplicateWorkflowResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerDuplicateWorkflowResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerDuplicateWorkflowRequestToJSON(workflowControllerDuplicateWorkflowRequest: WorkflowControllerDuplicateWorkflowRequest)
 - workflowControllerDuplicateWorkflowRequestFromJSON(jsonString: string)
 - workflowControllerDuplicateWorkflowResponseToJSON(workflowControllerDuplicateWorkflowResponse: WorkflowControllerDuplicateWorkflowResponse)
 - workflowControllerDuplicateWorkflowResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerDuplicateWorkflowRequest$Outbound;
}

export function workflowControllerDuplicateW...)
 - Outbound(WorkflowControllerDuplicateWorkflowResponse$Outbound;
}

export function workflowControllerDuplicate...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerDuplicateWorkflowRequestToJSON
- export function workflowControllerDuplicateWorkflowRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerDuplicateWorkflowResponseToJSON
- export function workflowControllerDuplicateWorkflowResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollergeneratepreview.ts
Tamaño: 6122 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerGeneratePreviewRequest = {
  workflowId: string;
  stepId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Preview generation details
   */
  generatePreviewRequestDto: components.GeneratePreviewRequestDto;
};

export type WorkflowControllerGeneratePreviewResponse = {
  headers: { [k: string]: Array<string> };
  result: components.GeneratePreviewResponseDto;
};

/** @internal */
export const WorkflowControllerGeneratePreviewRequest$inboundSchema: z.ZodType<
  WorkflowControllerGeneratePreviewRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowId: z.string(),
    stepId: z.string(),
    'idempotency-key': z.string().optional(),
    GeneratePreviewRequestDto: components.GeneratePreviewRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      GeneratePreviewRequestDto: 'generatePreviewRequestDto',
    });
  });

/** @internal */
export type WorkflowControllerGeneratePreviewRequest$Outbound = {
  workflowId: string;
  stepId: string;
  'idempotency-key'?: string | undefined;
  GeneratePreviewRequestDto: components.GeneratePreviewRequestDto$Outbound;
};

/** @internal */
export const WorkflowControllerGeneratePreviewRequest$outboundSchema: z.ZodType<
  WorkflowControllerGeneratePreviewRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerGeneratePreviewRequest
> = z
  .object({
    workflowId: z.string(),
    stepId: z.string(),
    idempotencyKey: z.string().optional(),
    generatePreviewRequestDto: components.GeneratePreviewRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      generatePreviewRequestDto: 'GeneratePreviewRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerGeneratePreviewRequest$ {
  /** @deprecated use `WorkflowControllerGeneratePreviewRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerGeneratePreviewRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerGeneratePreviewRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerGeneratePreviewRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerGeneratePreviewRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerGeneratePreviewRequest$Outbound;
}

export function workflowControllerGeneratePreviewRequestToJSON(
  workflowControllerGeneratePreviewRequest: WorkflowControllerGeneratePreviewRequest
): string {
  return JSON.stringify(
    WorkflowControllerGeneratePreviewRequest$outboundSchema.parse(workflowControllerGeneratePreviewRequest)
  );
}

export function workflowControllerGeneratePreviewRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerGeneratePreviewRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerGeneratePreviewRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerGeneratePreviewRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerGeneratePreviewResponse$inboundSchema: z.ZodType<
  WorkflowControllerGeneratePreviewResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.GeneratePreviewResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerGeneratePreviewResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.GeneratePreviewResponseDto$Outbound;
};

/** @internal */
export const WorkflowControllerGeneratePreviewResponse$outboundSchema: z.ZodType<
  WorkflowControllerGeneratePreviewResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerGeneratePreviewResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.GeneratePreviewResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerGeneratePreviewResponse$ {
  /** @deprecated use `WorkflowControllerGeneratePreviewResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerGeneratePreviewResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerGeneratePreviewResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerGeneratePreviewResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerGeneratePreviewResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerGeneratePreviewResponse$Outbound;
}

export function workflowControllerGeneratePreviewResponseToJSON(
  workflowControllerGeneratePreviewResponse: WorkflowControllerGeneratePreviewResponse
): string {
  return JSON.stringify(
    WorkflowControllerGeneratePreviewResponse$outboundSchema.parse(workflowControllerGeneratePreviewResponse)
  );
}

export function workflowControllerGeneratePreviewResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerGeneratePreviewResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerGeneratePreviewResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerGeneratePreviewResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerGeneratePreviewRequestToJSON(workflowControllerGeneratePreviewRequest: WorkflowControllerGeneratePreviewRequest)
 - workflowControllerGeneratePreviewRequestFromJSON(jsonString: string)
 - workflowControllerGeneratePreviewResponseToJSON(workflowControllerGeneratePreviewResponse: WorkflowControllerGeneratePreviewResponse)
 - workflowControllerGeneratePreviewResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerGeneratePreviewRequest$Outbound;
}

export function workflowControllerGeneratePrev...)
 - Outbound(WorkflowControllerGeneratePreviewResponse$Outbound;
}

export function workflowControllerGeneratePre...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerGeneratePreviewRequestToJSON
- export function workflowControllerGeneratePreviewRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerGeneratePreviewResponseToJSON
- export function workflowControllerGeneratePreviewResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollergetworkflow.ts
Tamaño: 5508 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerGetWorkflowRequest = {
  workflowId: string;
  environmentId?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type WorkflowControllerGetWorkflowResponse = {
  headers: { [k: string]: Array<string> };
  result: components.WorkflowResponseDto;
};

/** @internal */
export const WorkflowControllerGetWorkflowRequest$inboundSchema: z.ZodType<
  WorkflowControllerGetWorkflowRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowId: z.string(),
    environmentId: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type WorkflowControllerGetWorkflowRequest$Outbound = {
  workflowId: string;
  environmentId?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const WorkflowControllerGetWorkflowRequest$outboundSchema: z.ZodType<
  WorkflowControllerGetWorkflowRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerGetWorkflowRequest
> = z
  .object({
    workflowId: z.string(),
    environmentId: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerGetWorkflowRequest$ {
  /** @deprecated use `WorkflowControllerGetWorkflowRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerGetWorkflowRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerGetWorkflowRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerGetWorkflowRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerGetWorkflowRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerGetWorkflowRequest$Outbound;
}

export function workflowControllerGetWorkflowRequestToJSON(
  workflowControllerGetWorkflowRequest: WorkflowControllerGetWorkflowRequest
): string {
  return JSON.stringify(
    WorkflowControllerGetWorkflowRequest$outboundSchema.parse(workflowControllerGetWorkflowRequest)
  );
}

export function workflowControllerGetWorkflowRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerGetWorkflowRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerGetWorkflowRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerGetWorkflowRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerGetWorkflowResponse$inboundSchema: z.ZodType<
  WorkflowControllerGetWorkflowResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.WorkflowResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerGetWorkflowResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.WorkflowResponseDto$Outbound;
};

/** @internal */
export const WorkflowControllerGetWorkflowResponse$outboundSchema: z.ZodType<
  WorkflowControllerGetWorkflowResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerGetWorkflowResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.WorkflowResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerGetWorkflowResponse$ {
  /** @deprecated use `WorkflowControllerGetWorkflowResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerGetWorkflowResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerGetWorkflowResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerGetWorkflowResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerGetWorkflowResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerGetWorkflowResponse$Outbound;
}

export function workflowControllerGetWorkflowResponseToJSON(
  workflowControllerGetWorkflowResponse: WorkflowControllerGetWorkflowResponse
): string {
  return JSON.stringify(
    WorkflowControllerGetWorkflowResponse$outboundSchema.parse(workflowControllerGetWorkflowResponse)
  );
}

export function workflowControllerGetWorkflowResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerGetWorkflowResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerGetWorkflowResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerGetWorkflowResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerGetWorkflowRequestToJSON(workflowControllerGetWorkflowRequest: WorkflowControllerGetWorkflowRequest)
 - workflowControllerGetWorkflowRequestFromJSON(jsonString: string)
 - workflowControllerGetWorkflowResponseToJSON(workflowControllerGetWorkflowResponse: WorkflowControllerGetWorkflowResponse)
 - workflowControllerGetWorkflowResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerGetWorkflowRequest$Outbound;
}

export function workflowControllerGetWorkflowReque...)
 - Outbound(WorkflowControllerGetWorkflowResponse$Outbound;
}

export function workflowControllerGetWorkflowResp...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerGetWorkflowRequestToJSON
- export function workflowControllerGetWorkflowRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerGetWorkflowResponseToJSON
- export function workflowControllerGetWorkflowResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollergetworkflowstepdata.ts
Tamaño: 5784 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerGetWorkflowStepDataRequest = {
  workflowId: string;
  stepId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type WorkflowControllerGetWorkflowStepDataResponse = {
  headers: { [k: string]: Array<string> };
  result: components.StepResponseDto;
};

/** @internal */
export const WorkflowControllerGetWorkflowStepDataRequest$inboundSchema: z.ZodType<
  WorkflowControllerGetWorkflowStepDataRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowId: z.string(),
    stepId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type WorkflowControllerGetWorkflowStepDataRequest$Outbound = {
  workflowId: string;
  stepId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const WorkflowControllerGetWorkflowStepDataRequest$outboundSchema: z.ZodType<
  WorkflowControllerGetWorkflowStepDataRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerGetWorkflowStepDataRequest
> = z
  .object({
    workflowId: z.string(),
    stepId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerGetWorkflowStepDataRequest$ {
  /** @deprecated use `WorkflowControllerGetWorkflowStepDataRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerGetWorkflowStepDataRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerGetWorkflowStepDataRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerGetWorkflowStepDataRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerGetWorkflowStepDataRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerGetWorkflowStepDataRequest$Outbound;
}

export function workflowControllerGetWorkflowStepDataRequestToJSON(
  workflowControllerGetWorkflowStepDataRequest: WorkflowControllerGetWorkflowStepDataRequest
): string {
  return JSON.stringify(
    WorkflowControllerGetWorkflowStepDataRequest$outboundSchema.parse(workflowControllerGetWorkflowStepDataRequest)
  );
}

export function workflowControllerGetWorkflowStepDataRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerGetWorkflowStepDataRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerGetWorkflowStepDataRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerGetWorkflowStepDataRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerGetWorkflowStepDataResponse$inboundSchema: z.ZodType<
  WorkflowControllerGetWorkflowStepDataResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.StepResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerGetWorkflowStepDataResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.StepResponseDto$Outbound;
};

/** @internal */
export const WorkflowControllerGetWorkflowStepDataResponse$outboundSchema: z.ZodType<
  WorkflowControllerGetWorkflowStepDataResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerGetWorkflowStepDataResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.StepResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerGetWorkflowStepDataResponse$ {
  /** @deprecated use `WorkflowControllerGetWorkflowStepDataResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerGetWorkflowStepDataResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerGetWorkflowStepDataResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerGetWorkflowStepDataResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerGetWorkflowStepDataResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerGetWorkflowStepDataResponse$Outbound;
}

export function workflowControllerGetWorkflowStepDataResponseToJSON(
  workflowControllerGetWorkflowStepDataResponse: WorkflowControllerGetWorkflowStepDataResponse
): string {
  return JSON.stringify(
    WorkflowControllerGetWorkflowStepDataResponse$outboundSchema.parse(workflowControllerGetWorkflowStepDataResponse)
  );
}

export function workflowControllerGetWorkflowStepDataResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerGetWorkflowStepDataResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerGetWorkflowStepDataResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerGetWorkflowStepDataResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerGetWorkflowStepDataRequestToJSON(workflowControllerGetWorkflowStepDataRequest: WorkflowControllerGetWorkflowStepDataRequest)
 - workflowControllerGetWorkflowStepDataRequestFromJSON(jsonString: string)
 - workflowControllerGetWorkflowStepDataResponseToJSON(workflowControllerGetWorkflowStepDataResponse: WorkflowControllerGetWorkflowStepDataResponse)
 - workflowControllerGetWorkflowStepDataResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerGetWorkflowStepDataRequest$Outbound;
}

export function workflowControllerGetWorkf...)
 - Outbound(WorkflowControllerGetWorkflowStepDataResponse$Outbound;
}

export function workflowControllerGetWork...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerGetWorkflowStepDataRequestToJSON
- export function workflowControllerGetWorkflowStepDataRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerGetWorkflowStepDataResponseToJSON
- export function workflowControllerGetWorkflowStepDataResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollerpatchworkflow.ts
Tamaño: 5806 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerPatchWorkflowRequest = {
  workflowId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Workflow patch details
   */
  patchWorkflowDto: components.PatchWorkflowDto;
};

export type WorkflowControllerPatchWorkflowResponse = {
  headers: { [k: string]: Array<string> };
  result: components.WorkflowResponseDto;
};

/** @internal */
export const WorkflowControllerPatchWorkflowRequest$inboundSchema: z.ZodType<
  WorkflowControllerPatchWorkflowRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowId: z.string(),
    'idempotency-key': z.string().optional(),
    PatchWorkflowDto: components.PatchWorkflowDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      PatchWorkflowDto: 'patchWorkflowDto',
    });
  });

/** @internal */
export type WorkflowControllerPatchWorkflowRequest$Outbound = {
  workflowId: string;
  'idempotency-key'?: string | undefined;
  PatchWorkflowDto: components.PatchWorkflowDto$Outbound;
};

/** @internal */
export const WorkflowControllerPatchWorkflowRequest$outboundSchema: z.ZodType<
  WorkflowControllerPatchWorkflowRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerPatchWorkflowRequest
> = z
  .object({
    workflowId: z.string(),
    idempotencyKey: z.string().optional(),
    patchWorkflowDto: components.PatchWorkflowDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      patchWorkflowDto: 'PatchWorkflowDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerPatchWorkflowRequest$ {
  /** @deprecated use `WorkflowControllerPatchWorkflowRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerPatchWorkflowRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerPatchWorkflowRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerPatchWorkflowRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerPatchWorkflowRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerPatchWorkflowRequest$Outbound;
}

export function workflowControllerPatchWorkflowRequestToJSON(
  workflowControllerPatchWorkflowRequest: WorkflowControllerPatchWorkflowRequest
): string {
  return JSON.stringify(
    WorkflowControllerPatchWorkflowRequest$outboundSchema.parse(workflowControllerPatchWorkflowRequest)
  );
}

export function workflowControllerPatchWorkflowRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerPatchWorkflowRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerPatchWorkflowRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerPatchWorkflowRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerPatchWorkflowResponse$inboundSchema: z.ZodType<
  WorkflowControllerPatchWorkflowResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.WorkflowResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerPatchWorkflowResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.WorkflowResponseDto$Outbound;
};

/** @internal */
export const WorkflowControllerPatchWorkflowResponse$outboundSchema: z.ZodType<
  WorkflowControllerPatchWorkflowResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerPatchWorkflowResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.WorkflowResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerPatchWorkflowResponse$ {
  /** @deprecated use `WorkflowControllerPatchWorkflowResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerPatchWorkflowResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerPatchWorkflowResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerPatchWorkflowResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerPatchWorkflowResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerPatchWorkflowResponse$Outbound;
}

export function workflowControllerPatchWorkflowResponseToJSON(
  workflowControllerPatchWorkflowResponse: WorkflowControllerPatchWorkflowResponse
): string {
  return JSON.stringify(
    WorkflowControllerPatchWorkflowResponse$outboundSchema.parse(workflowControllerPatchWorkflowResponse)
  );
}

export function workflowControllerPatchWorkflowResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerPatchWorkflowResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerPatchWorkflowResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerPatchWorkflowResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerPatchWorkflowRequestToJSON(workflowControllerPatchWorkflowRequest: WorkflowControllerPatchWorkflowRequest)
 - workflowControllerPatchWorkflowRequestFromJSON(jsonString: string)
 - workflowControllerPatchWorkflowResponseToJSON(workflowControllerPatchWorkflowResponse: WorkflowControllerPatchWorkflowResponse)
 - workflowControllerPatchWorkflowResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerPatchWorkflowRequest$Outbound;
}

export function workflowControllerPatchWorkflowR...)
 - Outbound(WorkflowControllerPatchWorkflowResponse$Outbound;
}

export function workflowControllerPatchWorkflow...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerPatchWorkflowRequestToJSON
- export function workflowControllerPatchWorkflowRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerPatchWorkflowResponseToJSON
- export function workflowControllerPatchWorkflowResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollerremoveworkflow.ts
Tamaño: 5174 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerRemoveWorkflowRequest = {
  workflowId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type WorkflowControllerRemoveWorkflowResponse = {
  headers: { [k: string]: Array<string> };
};

/** @internal */
export const WorkflowControllerRemoveWorkflowRequest$inboundSchema: z.ZodType<
  WorkflowControllerRemoveWorkflowRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type WorkflowControllerRemoveWorkflowRequest$Outbound = {
  workflowId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const WorkflowControllerRemoveWorkflowRequest$outboundSchema: z.ZodType<
  WorkflowControllerRemoveWorkflowRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerRemoveWorkflowRequest
> = z
  .object({
    workflowId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerRemoveWorkflowRequest$ {
  /** @deprecated use `WorkflowControllerRemoveWorkflowRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerRemoveWorkflowRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerRemoveWorkflowRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerRemoveWorkflowRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerRemoveWorkflowRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerRemoveWorkflowRequest$Outbound;
}

export function workflowControllerRemoveWorkflowRequestToJSON(
  workflowControllerRemoveWorkflowRequest: WorkflowControllerRemoveWorkflowRequest
): string {
  return JSON.stringify(
    WorkflowControllerRemoveWorkflowRequest$outboundSchema.parse(workflowControllerRemoveWorkflowRequest)
  );
}

export function workflowControllerRemoveWorkflowRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerRemoveWorkflowRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerRemoveWorkflowRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerRemoveWorkflowRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerRemoveWorkflowResponse$inboundSchema: z.ZodType<
  WorkflowControllerRemoveWorkflowResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
    });
  });

/** @internal */
export type WorkflowControllerRemoveWorkflowResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
};

/** @internal */
export const WorkflowControllerRemoveWorkflowResponse$outboundSchema: z.ZodType<
  WorkflowControllerRemoveWorkflowResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerRemoveWorkflowResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerRemoveWorkflowResponse$ {
  /** @deprecated use `WorkflowControllerRemoveWorkflowResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerRemoveWorkflowResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerRemoveWorkflowResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerRemoveWorkflowResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerRemoveWorkflowResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerRemoveWorkflowResponse$Outbound;
}

export function workflowControllerRemoveWorkflowResponseToJSON(
  workflowControllerRemoveWorkflowResponse: WorkflowControllerRemoveWorkflowResponse
): string {
  return JSON.stringify(
    WorkflowControllerRemoveWorkflowResponse$outboundSchema.parse(workflowControllerRemoveWorkflowResponse)
  );
}

export function workflowControllerRemoveWorkflowResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerRemoveWorkflowResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerRemoveWorkflowResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerRemoveWorkflowResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerRemoveWorkflowRequestToJSON(workflowControllerRemoveWorkflowRequest: WorkflowControllerRemoveWorkflowRequest)
 - workflowControllerRemoveWorkflowRequestFromJSON(jsonString: string)
 - workflowControllerRemoveWorkflowResponseToJSON(workflowControllerRemoveWorkflowResponse: WorkflowControllerRemoveWorkflowResponse)
 - workflowControllerRemoveWorkflowResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerRemoveWorkflowRequest$Outbound;
}

export function workflowControllerRemoveWorkflo...)
 - Outbound(WorkflowControllerRemoveWorkflowResponse$Outbound;
}

export function workflowControllerRemoveWorkfl...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerRemoveWorkflowRequestToJSON
- export function workflowControllerRemoveWorkflowRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerRemoveWorkflowResponseToJSON
- export function workflowControllerRemoveWorkflowResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollersearchworkflows.ts
Tamaño: 7076 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerSearchWorkflowsRequest = {
  /**
   * Number of items to return per page
   */
  limit?: number | undefined;
  /**
   * Number of items to skip before starting to return results
   */
  offset?: number | undefined;
  /**
   * Direction of sorting
   */
  orderDirection?: components.DirectionEnum | undefined;
  /**
   * Field to sort the results by
   */
  orderBy?: components.WorkflowResponseDtoSortField | undefined;
  /**
   * Search query to filter workflows
   */
  query?: string | undefined;
  /**
   * Filter workflows by tags
   */
  tags?: Array<string> | undefined;
  /**
   * Filter workflows by status
   */
  status?: Array<components.WorkflowStatusEnum> | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type WorkflowControllerSearchWorkflowsResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ListWorkflowResponse;
};

/** @internal */
export const WorkflowControllerSearchWorkflowsRequest$inboundSchema: z.ZodType<
  WorkflowControllerSearchWorkflowsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    limit: z.number().optional(),
    offset: z.number().optional(),
    orderDirection: components.DirectionEnum$inboundSchema.optional(),
    orderBy: components.WorkflowResponseDtoSortField$inboundSchema.optional(),
    query: z.string().optional(),
    tags: z.array(z.string()).optional(),
    status: z.array(components.WorkflowStatusEnum$inboundSchema).optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type WorkflowControllerSearchWorkflowsRequest$Outbound = {
  limit?: number | undefined;
  offset?: number | undefined;
  orderDirection?: string | undefined;
  orderBy?: string | undefined;
  query?: string | undefined;
  tags?: Array<string> | undefined;
  status?: Array<string> | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const WorkflowControllerSearchWorkflowsRequest$outboundSchema: z.ZodType<
  WorkflowControllerSearchWorkflowsRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerSearchWorkflowsRequest
> = z
  .object({
    limit: z.number().optional(),
    offset: z.number().optional(),
    orderDirection: components.DirectionEnum$outboundSchema.optional(),
    orderBy: components.WorkflowResponseDtoSortField$outboundSchema.optional(),
    query: z.string().optional(),
    tags: z.array(z.string()).optional(),
    status: z.array(components.WorkflowStatusEnum$outboundSchema).optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerSearchWorkflowsRequest$ {
  /** @deprecated use `WorkflowControllerSearchWorkflowsRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerSearchWorkflowsRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerSearchWorkflowsRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerSearchWorkflowsRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerSearchWorkflowsRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerSearchWorkflowsRequest$Outbound;
}

export function workflowControllerSearchWorkflowsRequestToJSON(
  workflowControllerSearchWorkflowsRequest: WorkflowControllerSearchWorkflowsRequest
): string {
  return JSON.stringify(
    WorkflowControllerSearchWorkflowsRequest$outboundSchema.parse(workflowControllerSearchWorkflowsRequest)
  );
}

export function workflowControllerSearchWorkflowsRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerSearchWorkflowsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerSearchWorkflowsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerSearchWorkflowsRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerSearchWorkflowsResponse$inboundSchema: z.ZodType<
  WorkflowControllerSearchWorkflowsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ListWorkflowResponse$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerSearchWorkflowsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ListWorkflowResponse$Outbound;
};

/** @internal */
export const WorkflowControllerSearchWorkflowsResponse$outboundSchema: z.ZodType<
  WorkflowControllerSearchWorkflowsResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerSearchWorkflowsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ListWorkflowResponse$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerSearchWorkflowsResponse$ {
  /** @deprecated use `WorkflowControllerSearchWorkflowsResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerSearchWorkflowsResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerSearchWorkflowsResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerSearchWorkflowsResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerSearchWorkflowsResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerSearchWorkflowsResponse$Outbound;
}

export function workflowControllerSearchWorkflowsResponseToJSON(
  workflowControllerSearchWorkflowsResponse: WorkflowControllerSearchWorkflowsResponse
): string {
  return JSON.stringify(
    WorkflowControllerSearchWorkflowsResponse$outboundSchema.parse(workflowControllerSearchWorkflowsResponse)
  );
}

export function workflowControllerSearchWorkflowsResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerSearchWorkflowsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerSearchWorkflowsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerSearchWorkflowsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerSearchWorkflowsRequestToJSON(workflowControllerSearchWorkflowsRequest: WorkflowControllerSearchWorkflowsRequest)
 - workflowControllerSearchWorkflowsRequestFromJSON(jsonString: string)
 - workflowControllerSearchWorkflowsResponseToJSON(workflowControllerSearchWorkflowsResponse: WorkflowControllerSearchWorkflowsResponse)
 - workflowControllerSearchWorkflowsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerSearchWorkflowsRequest$Outbound;
}

export function workflowControllerSearchWorkfl...)
 - Outbound(WorkflowControllerSearchWorkflowsResponse$Outbound;
}

export function workflowControllerSearchWorkf...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerSearchWorkflowsRequestToJSON
- export function workflowControllerSearchWorkflowsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerSearchWorkflowsResponseToJSON
- export function workflowControllerSearchWorkflowsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollersync.ts
Tamaño: 5363 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerSyncRequest = {
  workflowId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Sync workflow details
   */
  syncWorkflowDto: components.SyncWorkflowDto;
};

export type WorkflowControllerSyncResponse = {
  headers: { [k: string]: Array<string> };
  result: components.WorkflowResponseDto;
};

/** @internal */
export const WorkflowControllerSyncRequest$inboundSchema: z.ZodType<
  WorkflowControllerSyncRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowId: z.string(),
    'idempotency-key': z.string().optional(),
    SyncWorkflowDto: components.SyncWorkflowDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      SyncWorkflowDto: 'syncWorkflowDto',
    });
  });

/** @internal */
export type WorkflowControllerSyncRequest$Outbound = {
  workflowId: string;
  'idempotency-key'?: string | undefined;
  SyncWorkflowDto: components.SyncWorkflowDto$Outbound;
};

/** @internal */
export const WorkflowControllerSyncRequest$outboundSchema: z.ZodType<
  WorkflowControllerSyncRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerSyncRequest
> = z
  .object({
    workflowId: z.string(),
    idempotencyKey: z.string().optional(),
    syncWorkflowDto: components.SyncWorkflowDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      syncWorkflowDto: 'SyncWorkflowDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerSyncRequest$ {
  /** @deprecated use `WorkflowControllerSyncRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerSyncRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerSyncRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerSyncRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerSyncRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerSyncRequest$Outbound;
}

export function workflowControllerSyncRequestToJSON(
  workflowControllerSyncRequest: WorkflowControllerSyncRequest
): string {
  return JSON.stringify(WorkflowControllerSyncRequest$outboundSchema.parse(workflowControllerSyncRequest));
}

export function workflowControllerSyncRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerSyncRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerSyncRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerSyncRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerSyncResponse$inboundSchema: z.ZodType<
  WorkflowControllerSyncResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.WorkflowResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerSyncResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.WorkflowResponseDto$Outbound;
};

/** @internal */
export const WorkflowControllerSyncResponse$outboundSchema: z.ZodType<
  WorkflowControllerSyncResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerSyncResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.WorkflowResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerSyncResponse$ {
  /** @deprecated use `WorkflowControllerSyncResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerSyncResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerSyncResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerSyncResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerSyncResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerSyncResponse$Outbound;
}

export function workflowControllerSyncResponseToJSON(
  workflowControllerSyncResponse: WorkflowControllerSyncResponse
): string {
  return JSON.stringify(WorkflowControllerSyncResponse$outboundSchema.parse(workflowControllerSyncResponse));
}

export function workflowControllerSyncResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerSyncResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerSyncResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerSyncResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerSyncRequestToJSON(workflowControllerSyncRequest: WorkflowControllerSyncRequest)
 - workflowControllerSyncRequestFromJSON(jsonString: string)
 - workflowControllerSyncResponseToJSON(workflowControllerSyncResponse: WorkflowControllerSyncResponse)
 - workflowControllerSyncResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerSyncRequest$Outbound;
}

export function workflowControllerSyncRequestToJSON(
  wo...)
 - Outbound(WorkflowControllerSyncResponse$Outbound;
}

export function workflowControllerSyncResponseToJSON(
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerSyncRequestToJSON
- export function workflowControllerSyncRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerSyncResponseToJSON
- export function workflowControllerSyncResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollerupdate.ts
Tamaño: 5481 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerUpdateRequest = {
  workflowId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Workflow update details
   */
  updateWorkflowDto: components.UpdateWorkflowDto;
};

export type WorkflowControllerUpdateResponse = {
  headers: { [k: string]: Array<string> };
  result: components.WorkflowResponseDto;
};

/** @internal */
export const WorkflowControllerUpdateRequest$inboundSchema: z.ZodType<
  WorkflowControllerUpdateRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowId: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateWorkflowDto: components.UpdateWorkflowDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateWorkflowDto: 'updateWorkflowDto',
    });
  });

/** @internal */
export type WorkflowControllerUpdateRequest$Outbound = {
  workflowId: string;
  'idempotency-key'?: string | undefined;
  UpdateWorkflowDto: components.UpdateWorkflowDto$Outbound;
};

/** @internal */
export const WorkflowControllerUpdateRequest$outboundSchema: z.ZodType<
  WorkflowControllerUpdateRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerUpdateRequest
> = z
  .object({
    workflowId: z.string(),
    idempotencyKey: z.string().optional(),
    updateWorkflowDto: components.UpdateWorkflowDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateWorkflowDto: 'UpdateWorkflowDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerUpdateRequest$ {
  /** @deprecated use `WorkflowControllerUpdateRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerUpdateRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerUpdateRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerUpdateRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerUpdateRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerUpdateRequest$Outbound;
}

export function workflowControllerUpdateRequestToJSON(
  workflowControllerUpdateRequest: WorkflowControllerUpdateRequest
): string {
  return JSON.stringify(WorkflowControllerUpdateRequest$outboundSchema.parse(workflowControllerUpdateRequest));
}

export function workflowControllerUpdateRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerUpdateRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerUpdateRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerUpdateRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerUpdateResponse$inboundSchema: z.ZodType<
  WorkflowControllerUpdateResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.WorkflowResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerUpdateResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.WorkflowResponseDto$Outbound;
};

/** @internal */
export const WorkflowControllerUpdateResponse$outboundSchema: z.ZodType<
  WorkflowControllerUpdateResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerUpdateResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.WorkflowResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerUpdateResponse$ {
  /** @deprecated use `WorkflowControllerUpdateResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerUpdateResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerUpdateResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerUpdateResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerUpdateResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerUpdateResponse$Outbound;
}

export function workflowControllerUpdateResponseToJSON(
  workflowControllerUpdateResponse: WorkflowControllerUpdateResponse
): string {
  return JSON.stringify(WorkflowControllerUpdateResponse$outboundSchema.parse(workflowControllerUpdateResponse));
}

export function workflowControllerUpdateResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerUpdateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerUpdateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerUpdateResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerUpdateRequestToJSON(workflowControllerUpdateRequest: WorkflowControllerUpdateRequest)
 - workflowControllerUpdateRequestFromJSON(jsonString: string)
 - workflowControllerUpdateResponseToJSON(workflowControllerUpdateResponse: WorkflowControllerUpdateResponse)
 - workflowControllerUpdateResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerUpdateRequest$Outbound;
}

export function workflowControllerUpdateRequestToJSON(
...)
 - Outbound(WorkflowControllerUpdateResponse$Outbound;
}

export function workflowControllerUpdateResponseToJSON...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerUpdateRequestToJSON
- export function workflowControllerUpdateRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerUpdateResponseToJSON
- export function workflowControllerUpdateResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/_context.tsx
Tamaño: 605 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###


import React from "react";

import { NovuCore } from "../core.js";

const NovuContext = React.createContext<NovuCore | null>(null);

export function NovuProvider(props: { client: NovuCore, children: React.ReactNode }): React.ReactNode { 
  return (
    <NovuContext.Provider value={props.client}>
      {props.children}
    </NovuContext.Provider>
  );
}

export function useNovuContext(): NovuCore { 
  const value = React.useContext(NovuContext);
  if (value === null) {
    throw new Error("SDK not initialized. Create an instance of NovuCore and pass it to <NovuProvider />.");
  }
  return value;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React from "react";
import { NovuCore } from "../core.js";
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/_types.ts
Tamaño: 3801 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { RequestOptions } from "../lib/sdks.js";
import { PageIterator } from "../types/operations.js";

import type {
  DefaultError,
  InfiniteData,
  InfiniteQueryPageParamsOptions,
  OmitKeyof,
  QueryKey,
  QueryObserverOptions,
  SkipToken,
  UseMutationOptions,
  UseQueryOptions,
  UseSuspenseQueryOptions,
} from "@tanstack/react-query";

// Reaction to breaking change in 5.80.0 https://github.com/TanStack/query/pull/9224#issuecomment-2934835936
interface UseInfiniteQueryOptions<
  TQueryFnData = unknown,
  TError = DefaultError,
  TData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey,
  TPageParam = unknown,
> extends
  OmitKeyof<
    InfiniteQueryObserverOptions<
      TQueryFnData,
      TError,
      TData,
      TQueryKey,
      TPageParam
    >,
    "suspense"
  >
{
  /**
   * Set this to `false` to unsubscribe this observer from updates to the query cache.
   * Defaults to `true`.
   */
  subscribed?: boolean;
}

// Reaction to breaking change in 5.80.0 https://github.com/TanStack/query/pull/9224#issuecomment-2934835936
interface InfiniteQueryObserverOptions<
  TQueryFnData = unknown,
  TError = DefaultError,
  TData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey,
  TPageParam = unknown,
> extends
  QueryObserverOptions<
    TQueryFnData,
    TError,
    TData,
    InfiniteData<TQueryFnData, TPageParam>,
    TQueryKey,
    TPageParam
  >,
  InfiniteQueryPageParamsOptions<TQueryFnData, TPageParam>
{
}

// Reaction to breaking change in 5.80.0 https://github.com/TanStack/query/pull/9224#issuecomment-2934835936
interface UseSuspenseInfiniteQueryOptions<
  TQueryFnData = unknown,
  TError = DefaultError,
  TData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey,
  TPageParam = unknown,
> extends
  OmitKeyof<
    UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,
    "queryFn" | "enabled" | "throwOnError" | "placeholderData"
  >
{
  queryFn?: Exclude<
    UseInfiniteQueryOptions<
      TQueryFnData,
      TError,
      TData,
      TQueryKey,
      TPageParam
    >["queryFn"],
    SkipToken
  >;
}
export type TupleToPrefixes<T extends any[]> = T extends [...infer Prefix, any]
  ? TupleToPrefixes<Prefix> | T
  : never;

export type QueryHookOptions<Data> =
  & Omit<
    UseQueryOptions<Data, Error>,
    "queryKey" | "queryFn" | "select" | keyof RequestOptions
  >
  & RequestOptions;

export type SuspenseQueryHookOptions<Data> =
  & Omit<
    UseSuspenseQueryOptions<Data, Error>,
    "queryKey" | "queryFn" | "select" | keyof RequestOptions
  >
  & RequestOptions;

export type InfiniteQueryHookOptions<
  Data extends PageIterator<unknown, unknown>,
> =
  & Omit<
    UseInfiniteQueryOptions<
      Data,
      Error,
      InfiniteData<Data, Data["~next"]>,
      QueryKey,
      Data["~next"]
    >,
    | "queryKey"
    | "queryFn"
    | "select"
    | "getNextPageParam"
    | "getPreviousPageParam"
    | "initialPageParam"
    | keyof RequestOptions
  >
  & RequestOptions
  & { initialPageParam?: Data["~next"] };

export type SuspenseInfiniteQueryHookOptions<
  Data extends PageIterator<unknown, unknown>,
> =
  & Omit<
    UseSuspenseInfiniteQueryOptions<
      Data,
      Error,
      InfiniteData<Data, Data["~next"]>,
      QueryKey,
      Data["~next"]
    >,
    | "queryKey"
    | "queryFn"
    | "select"
    | "getNextPageParam"
    | "getPreviousPageParam"
    | "initialPageParam"
    | keyof RequestOptions
  >
  & RequestOptions
  & { initialPageParam?: Data["~next"] };

export type MutationHookOptions<
  Data = unknown,
  Err = Error,
  Variables = unknown,
> =
  & Omit<
    UseMutationOptions<Data, Err, Variables>,
    "mutationKey" | "mutationFn" | keyof RequestOptions
  >
  & RequestOptions;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/activityChartsRetrieve.ts
Tamaño: 5951 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { activityChartsRetrieve } from "../funcs/activityChartsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type ActivityChartsRetrieveQueryData = components.GetChartsResponseDto;

/**
 * Retrieve activity charts
 *
 * @remarks
 * Retrieve chart data for activity analytics and metrics visualization.
 */
export function useActivityChartsRetrieve(
  request: operations.ActivityControllerGetChartsRequest,
  options?: QueryHookOptions<ActivityChartsRetrieveQueryData>,
): UseQueryResult<ActivityChartsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildActivityChartsRetrieveQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve activity charts
 *
 * @remarks
 * Retrieve chart data for activity analytics and metrics visualization.
 */
export function useActivityChartsRetrieveSuspense(
  request: operations.ActivityControllerGetChartsRequest,
  options?: SuspenseQueryHookOptions<ActivityChartsRetrieveQueryData>,
): UseSuspenseQueryResult<ActivityChartsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildActivityChartsRetrieveQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchActivityChartsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.ActivityControllerGetChartsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildActivityChartsRetrieveQuery(
      client$,
      request,
    ),
  });
}

export function setActivityChartsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      createdAtGte?: string | undefined;
      createdAtLte?: string | undefined;
      reportType: Array<operations.ReportType>;
      workflowIds?: Array<string> | undefined;
      subscriberIds?: Array<string> | undefined;
      transactionIds?: Array<string> | undefined;
      statuses?: Array<operations.Statuses> | undefined;
      channels?: Array<string> | undefined;
      topicKey?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: ActivityChartsRetrieveQueryData,
): ActivityChartsRetrieveQueryData | undefined {
  const key = queryKeyActivityChartsRetrieve(...queryKeyBase);

  return client.setQueryData<ActivityChartsRetrieveQueryData>(key, data);
}

export function invalidateActivityChartsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      createdAtGte?: string | undefined;
      createdAtLte?: string | undefined;
      reportType: Array<operations.ReportType>;
      workflowIds?: Array<string> | undefined;
      subscriberIds?: Array<string> | undefined;
      transactionIds?: Array<string> | undefined;
      statuses?: Array<operations.Statuses> | undefined;
      channels?: Array<string> | undefined;
      topicKey?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Charts", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllActivityChartsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Charts", "retrieve"],
  });
}

export function buildActivityChartsRetrieveQuery(
  client$: NovuCore,
  request: operations.ActivityControllerGetChartsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<ActivityChartsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyActivityChartsRetrieve({
      createdAtGte: request.createdAtGte,
      createdAtLte: request.createdAtLte,
      reportType: request.reportType,
      workflowIds: request.workflowIds,
      subscriberIds: request.subscriberIds,
      transactionIds: request.transactionIds,
      statuses: request.statuses,
      channels: request.channels,
      topicKey: request.topicKey,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function activityChartsRetrieveQueryFn(
      ctx,
    ): Promise<ActivityChartsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(activityChartsRetrieve(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyActivityChartsRetrieve(
  parameters: {
    createdAtGte?: string | undefined;
    createdAtLte?: string | undefined;
    reportType: Array<operations.ReportType>;
    workflowIds?: Array<string> | undefined;
    subscriberIds?: Array<string> | undefined;
    transactionIds?: Array<string> | undefined;
    statuses?: Array<operations.Statuses> | undefined;
    channels?: Array<string> | undefined;
    topicKey?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Charts", "retrieve", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useActivityChartsRetrieve(request: operations.ActivityControllerGetChartsRequest,
  options?: QueryHookOptions<ActivityChartsRetrieveQueryData>,)
 - useActivityChartsRetrieveSuspense(request: operations.ActivityControllerGetChartsRequest,
  options?: SuspenseQueryHookOptions<ActivityChartsRetrieveQueryData>,)
 - prefetchActivityChartsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.ActivityControllerGetChartsRequest,)
 - setActivityChartsRetrieveData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      createdAtGte?: string | undefined;
      createdAtLte?: string | undefined;
      reportType: Array<operations.ReportType>;
      workflowIds?: Array<string> | undefined;
      subscriberIds?: Array<string> | undefined;
      transactionIds?: Array<string> | undefined;
      statuses?: Array<operations.Statuses> | undefined;
      channels?: Array<string> | undefined;
      topicKey?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: ActivityChartsRetrieveQueryData,)
 - invalidateActivityChartsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      createdAtGte?: string | undefined;
      createdAtLte?: string | undefined;
      reportType: Array<operations.ReportType>;
      workflowIds?: Array<string> | undefined;
      subscriberIds?: Array<string> | undefined;
      transactionIds?: Array<string> | undefined;
      statuses?: Array<operations.Statuses> | undefined;
      channels?: Array<string> | undefined;
      topicKey?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllActivityChartsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildActivityChartsRetrieveQuery(client$: NovuCore,
  request: operations.ActivityControllerGetChartsRequest,
  options?: RequestOptions,)
 - activityChartsRetrieveQueryFn(ctx,)
 - queryKeyActivityChartsRetrieve(parameters: {
    createdAtGte?: string | undefined;
    createdAtLte?: string | undefined;
    reportType: Array<operations.ReportType>;
    workflowIds?: Array<string> | undefined;
    subscriberIds?: Array<string> | undefined;
    transactionIds?: Array<string> | undefined;
    statuses?: Array<operations.Statuses> | undefined;
    channels?: Array<string> | undefined;
    topicKey?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyActivityChartsRetrieve(...queryKeyBase);

  return client.setQueryData<ActivityChartsRetriev...)
Declaraciones 'export' encontradas:
- export  type
- export function useActivityChartsRetrieve
- export function useActivityChartsRetrieveSuspense
- export function prefetchActivityChartsRetrieve
- export function setActivityChartsRetrieveData
- export function invalidateActivityChartsRetrieve
- export function invalidateAllActivityChartsRetrieve
- export function buildActivityChartsRetrieveQuery
- export function queryKeyActivityChartsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/activityRequestsList.ts
Tamaño: 5221 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { activityRequestsList } from "../funcs/activityRequestsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type ActivityRequestsListQueryData = components.GetRequestsResponseDto;

/**
 * List activity requests
 *
 * @remarks
 * Retrieve a list of activity requests with optional filtering and pagination.
 */
export function useActivityRequestsList(
  request: operations.ActivityControllerGetLogsRequest,
  options?: QueryHookOptions<ActivityRequestsListQueryData>,
): UseQueryResult<ActivityRequestsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildActivityRequestsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List activity requests
 *
 * @remarks
 * Retrieve a list of activity requests with optional filtering and pagination.
 */
export function useActivityRequestsListSuspense(
  request: operations.ActivityControllerGetLogsRequest,
  options?: SuspenseQueryHookOptions<ActivityRequestsListQueryData>,
): UseSuspenseQueryResult<ActivityRequestsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildActivityRequestsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchActivityRequestsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.ActivityControllerGetLogsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildActivityRequestsListQuery(
      client$,
      request,
    ),
  });
}

export function setActivityRequestsListData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      page?: number | undefined;
      limit?: number | undefined;
      statusCodes?: Array<number> | undefined;
      urlPattern?: string | undefined;
      transactionId?: string | undefined;
      createdGte?: number | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: ActivityRequestsListQueryData,
): ActivityRequestsListQueryData | undefined {
  const key = queryKeyActivityRequestsList(...queryKeyBase);

  return client.setQueryData<ActivityRequestsListQueryData>(key, data);
}

export function invalidateActivityRequestsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      page?: number | undefined;
      limit?: number | undefined;
      statusCodes?: Array<number> | undefined;
      urlPattern?: string | undefined;
      transactionId?: string | undefined;
      createdGte?: number | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Requests", "list", ...queryKeyBase],
  });
}

export function invalidateAllActivityRequestsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Requests", "list"],
  });
}

export function buildActivityRequestsListQuery(
  client$: NovuCore,
  request: operations.ActivityControllerGetLogsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<ActivityRequestsListQueryData>;
} {
  return {
    queryKey: queryKeyActivityRequestsList({
      page: request.page,
      limit: request.limit,
      statusCodes: request.statusCodes,
      urlPattern: request.urlPattern,
      transactionId: request.transactionId,
      createdGte: request.createdGte,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function activityRequestsListQueryFn(
      ctx,
    ): Promise<ActivityRequestsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(activityRequestsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyActivityRequestsList(
  parameters: {
    page?: number | undefined;
    limit?: number | undefined;
    statusCodes?: Array<number> | undefined;
    urlPattern?: string | undefined;
    transactionId?: string | undefined;
    createdGte?: number | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Requests", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useActivityRequestsList(request: operations.ActivityControllerGetLogsRequest,
  options?: QueryHookOptions<ActivityRequestsListQueryData>,)
 - useActivityRequestsListSuspense(request: operations.ActivityControllerGetLogsRequest,
  options?: SuspenseQueryHookOptions<ActivityRequestsListQueryData>,)
 - prefetchActivityRequestsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.ActivityControllerGetLogsRequest,)
 - setActivityRequestsListData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      page?: number | undefined;
      limit?: number | undefined;
      statusCodes?: Array<number> | undefined;
      urlPattern?: string | undefined;
      transactionId?: string | undefined;
      createdGte?: number | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: ActivityRequestsListQueryData,)
 - invalidateActivityRequestsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      page?: number | undefined;
      limit?: number | undefined;
      statusCodes?: Array<number> | undefined;
      urlPattern?: string | undefined;
      transactionId?: string | undefined;
      createdGte?: number | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllActivityRequestsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildActivityRequestsListQuery(client$: NovuCore,
  request: operations.ActivityControllerGetLogsRequest,
  options?: RequestOptions,)
 - activityRequestsListQueryFn(ctx,)
 - queryKeyActivityRequestsList(parameters: {
    page?: number | undefined;
    limit?: number | undefined;
    statusCodes?: Array<number> | undefined;
    urlPattern?: string | undefined;
    transactionId?: string | undefined;
    createdGte?: number | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyActivityRequestsList(...queryKeyBase);

  return client.setQueryData<ActivityRequestsListQue...)
Declaraciones 'export' encontradas:
- export  type
- export function useActivityRequestsList
- export function useActivityRequestsListSuspense
- export function prefetchActivityRequestsList
- export function setActivityRequestsListData
- export function invalidateActivityRequestsList
- export function invalidateAllActivityRequestsList
- export function buildActivityRequestsListQuery
- export function queryKeyActivityRequestsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/activityRequestsRetrieve.ts
Tamaño: 4524 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { activityRequestsRetrieve } from "../funcs/activityRequestsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type ActivityRequestsRetrieveQueryData =
  components.GetRequestResponseDto;

/**
 * Retrieve activity request
 *
 * @remarks
 * Retrieve detailed traces and information for a specific activity request by ID.
 */
export function useActivityRequestsRetrieve(
  requestId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<ActivityRequestsRetrieveQueryData>,
): UseQueryResult<ActivityRequestsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildActivityRequestsRetrieveQuery(
      client,
      requestId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve activity request
 *
 * @remarks
 * Retrieve detailed traces and information for a specific activity request by ID.
 */
export function useActivityRequestsRetrieveSuspense(
  requestId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<ActivityRequestsRetrieveQueryData>,
): UseSuspenseQueryResult<ActivityRequestsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildActivityRequestsRetrieveQuery(
      client,
      requestId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchActivityRequestsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  requestId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildActivityRequestsRetrieveQuery(
      client$,
      requestId,
      idempotencyKey,
    ),
  });
}

export function setActivityRequestsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    requestId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: ActivityRequestsRetrieveQueryData,
): ActivityRequestsRetrieveQueryData | undefined {
  const key = queryKeyActivityRequestsRetrieve(...queryKeyBase);

  return client.setQueryData<ActivityRequestsRetrieveQueryData>(key, data);
}

export function invalidateActivityRequestsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [requestId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Requests", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllActivityRequestsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Requests", "retrieve"],
  });
}

export function buildActivityRequestsRetrieveQuery(
  client$: NovuCore,
  requestId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<ActivityRequestsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyActivityRequestsRetrieve(requestId, { idempotencyKey }),
    queryFn: async function activityRequestsRetrieveQueryFn(
      ctx,
    ): Promise<ActivityRequestsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(activityRequestsRetrieve(
        client$,
        requestId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyActivityRequestsRetrieve(
  requestId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Requests", "retrieve", requestId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useActivityRequestsRetrieve(requestId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<ActivityRequestsRetrieveQueryData>,)
 - useActivityRequestsRetrieveSuspense(requestId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<ActivityRequestsRetrieveQueryData>,)
 - prefetchActivityRequestsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  requestId: string,
  idempotencyKey?: string | undefined,)
 - setActivityRequestsRetrieveData(client: QueryClient,
  queryKeyBase: [
    requestId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: ActivityRequestsRetrieveQueryData,)
 - invalidateActivityRequestsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [requestId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllActivityRequestsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildActivityRequestsRetrieveQuery(client$: NovuCore,
  requestId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - activityRequestsRetrieveQueryFn(ctx,)
 - queryKeyActivityRequestsRetrieve(requestId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyActivityRequestsRetrieve(...queryKeyBase);

  return client.setQueryData<ActivityRequestsRet...)
Declaraciones 'export' encontradas:
- export  type
- export function useActivityRequestsRetrieve
- export function useActivityRequestsRetrieveSuspense
- export function prefetchActivityRequestsRetrieve
- export function setActivityRequestsRetrieveData
- export function invalidateActivityRequestsRetrieve
- export function invalidateAllActivityRequestsRetrieve
- export function buildActivityRequestsRetrieveQuery
- export function queryKeyActivityRequestsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/activityTrack.ts
Tamaño: 2369 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { activityTrack } from "../funcs/activityTrack.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type ActivityTrackMutationVariables = {
  request: operations.InboundWebhooksControllerHandleWebhookRequest;
  options?: RequestOptions;
};

export type ActivityTrackMutationData = Array<components.WebhookResultDto>;

/**
 * Track activity and engagement events
 *
 * @remarks
 * Track activity and engagement events for a specific delivery provider
 */
export function useActivityTrackMutation(
  options?: MutationHookOptions<
    ActivityTrackMutationData,
    Error,
    ActivityTrackMutationVariables
  >,
): UseMutationResult<
  ActivityTrackMutationData,
  Error,
  ActivityTrackMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildActivityTrackMutation(client, options),
    ...options,
  });
}

export function mutationKeyActivityTrack(): MutationKey {
  return ["@novu/api", "Activity", "track"];
}

export function buildActivityTrackMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: ActivityTrackMutationVariables,
  ) => Promise<ActivityTrackMutationData>;
} {
  return {
    mutationKey: mutationKeyActivityTrack(),
    mutationFn: function activityTrackMutationFn({
      request,
      options,
    }): Promise<ActivityTrackMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(activityTrack(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useActivityTrackMutation(options?: MutationHookOptions<
    ActivityTrackMutationData,
    Error,
    ActivityTrackMutationVariables
  >,)
 - mutationKeyActivityTrack()
 - buildActivityTrackMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - activityTrackMutationFn({
      request,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildActivityTrackMutation(client, options),
    ......)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useActivityTrackMutation
- export function mutationKeyActivityTrack
- export function buildActivityTrackMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/activityWorkflowRunsList.ts
Tamaño: 6507 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { activityWorkflowRunsList } from "../funcs/activityWorkflowRunsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type ActivityWorkflowRunsListQueryData =
  components.GetWorkflowRunsResponseDto;

/**
 * List workflow runs
 *
 * @remarks
 * Retrieve a list of workflow runs with optional filtering and pagination.
 */
export function useActivityWorkflowRunsList(
  request: operations.ActivityControllerGetWorkflowRunsRequest,
  options?: QueryHookOptions<ActivityWorkflowRunsListQueryData>,
): UseQueryResult<ActivityWorkflowRunsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildActivityWorkflowRunsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List workflow runs
 *
 * @remarks
 * Retrieve a list of workflow runs with optional filtering and pagination.
 */
export function useActivityWorkflowRunsListSuspense(
  request: operations.ActivityControllerGetWorkflowRunsRequest,
  options?: SuspenseQueryHookOptions<ActivityWorkflowRunsListQueryData>,
): UseSuspenseQueryResult<ActivityWorkflowRunsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildActivityWorkflowRunsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchActivityWorkflowRunsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.ActivityControllerGetWorkflowRunsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildActivityWorkflowRunsListQuery(
      client$,
      request,
    ),
  });
}

export function setActivityWorkflowRunsListData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      limit: number | undefined;
      cursor?: string | undefined;
      workflowIds?: Array<string> | undefined;
      subscriberIds?: Array<string> | undefined;
      transactionIds?: Array<string> | undefined;
      statuses?: Array<operations.QueryParamStatuses> | undefined;
      channels?: Array<string> | undefined;
      topicKey?: string | undefined;
      createdGte?: string | undefined;
      createdLte?: string | undefined;
      severity?: Array<operations.Severity> | undefined;
      contextKeys?: Array<string> | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: ActivityWorkflowRunsListQueryData,
): ActivityWorkflowRunsListQueryData | undefined {
  const key = queryKeyActivityWorkflowRunsList(...queryKeyBase);

  return client.setQueryData<ActivityWorkflowRunsListQueryData>(key, data);
}

export function invalidateActivityWorkflowRunsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      limit: number | undefined;
      cursor?: string | undefined;
      workflowIds?: Array<string> | undefined;
      subscriberIds?: Array<string> | undefined;
      transactionIds?: Array<string> | undefined;
      statuses?: Array<operations.QueryParamStatuses> | undefined;
      channels?: Array<string> | undefined;
      topicKey?: string | undefined;
      createdGte?: string | undefined;
      createdLte?: string | undefined;
      severity?: Array<operations.Severity> | undefined;
      contextKeys?: Array<string> | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "WorkflowRuns", "list", ...queryKeyBase],
  });
}

export function invalidateAllActivityWorkflowRunsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "WorkflowRuns", "list"],
  });
}

export function buildActivityWorkflowRunsListQuery(
  client$: NovuCore,
  request: operations.ActivityControllerGetWorkflowRunsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<ActivityWorkflowRunsListQueryData>;
} {
  return {
    queryKey: queryKeyActivityWorkflowRunsList({
      limit: request.limit,
      cursor: request.cursor,
      workflowIds: request.workflowIds,
      subscriberIds: request.subscriberIds,
      transactionIds: request.transactionIds,
      statuses: request.statuses,
      channels: request.channels,
      topicKey: request.topicKey,
      createdGte: request.createdGte,
      createdLte: request.createdLte,
      severity: request.severity,
      contextKeys: request.contextKeys,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function activityWorkflowRunsListQueryFn(
      ctx,
    ): Promise<ActivityWorkflowRunsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(activityWorkflowRunsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyActivityWorkflowRunsList(
  parameters: {
    limit: number | undefined;
    cursor?: string | undefined;
    workflowIds?: Array<string> | undefined;
    subscriberIds?: Array<string> | undefined;
    transactionIds?: Array<string> | undefined;
    statuses?: Array<operations.QueryParamStatuses> | undefined;
    channels?: Array<string> | undefined;
    topicKey?: string | undefined;
    createdGte?: string | undefined;
    createdLte?: string | undefined;
    severity?: Array<operations.Severity> | undefined;
    contextKeys?: Array<string> | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "WorkflowRuns", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useActivityWorkflowRunsList(request: operations.ActivityControllerGetWorkflowRunsRequest,
  options?: QueryHookOptions<ActivityWorkflowRunsListQueryData>,)
 - useActivityWorkflowRunsListSuspense(request: operations.ActivityControllerGetWorkflowRunsRequest,
  options?: SuspenseQueryHookOptions<ActivityWorkflowRunsListQueryData>,)
 - prefetchActivityWorkflowRunsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.ActivityControllerGetWorkflowRunsRequest,)
 - setActivityWorkflowRunsListData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      limit: number | undefined;
      cursor?: string | undefined;
      workflowIds?: Array<string> | undefined;
      subscriberIds?: Array<string> | undefined;
      transactionIds?: Array<string> | undefined;
      statuses?: Array<operations.QueryParamStatuses> | undefined;
      channels?: Array<string> | undefined;
      topicKey?: string | undefined;
      createdGte?: string | undefined;
      createdLte?: string | undefined;
      severity?: Array<operations.Severity> | undefined;
      contextKeys?: Array<string> | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: ActivityWorkflowRunsListQueryData,)
 - invalidateActivityWorkflowRunsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      limit: number | undefined;
      cursor?: string | undefined;
      workflowIds?: Array<string> | undefined;
      subscriberIds?: Array<string> | undefined;
      transactionIds?: Array<string> | undefined;
      statuses?: Array<operations.QueryParamStatuses> | undefined;
      channels?: Array<string> | undefined;
      topicKey?: string | undefined;
      createdGte?: string | undefined;
      createdLte?: string | undefined;
      severity?: Array<operations.Severity> | undefined;
      contextKeys?: Array<string> | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllActivityWorkflowRunsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildActivityWorkflowRunsListQuery(client$: NovuCore,
  request: operations.ActivityControllerGetWorkflowRunsRequest,
  options?: RequestOptions,)
 - activityWorkflowRunsListQueryFn(ctx,)
 - queryKeyActivityWorkflowRunsList(parameters: {
    limit: number | undefined;
    cursor?: string | undefined;
    workflowIds?: Array<string> | undefined;
    subscriberIds?: Array<string> | undefined;
    transactionIds?: Array<string> | undefined;
    statuses?: Array<operations.QueryParamStatuses> | undefined;
    channels?: Array<string> | undefined;
    topicKey?: string | undefined;
    createdGte?: string | undefined;
    createdLte?: string | undefined;
    severity?: Array<operations.Severity> | undefined;
    contextKeys?: Array<string> | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyActivityWorkflowRunsList(...queryKeyBase);

  return client.setQueryData<ActivityWorkflowRun...)
Declaraciones 'export' encontradas:
- export  type
- export function useActivityWorkflowRunsList
- export function useActivityWorkflowRunsListSuspense
- export function prefetchActivityWorkflowRunsList
- export function setActivityWorkflowRunsListData
- export function invalidateActivityWorkflowRunsList
- export function invalidateAllActivityWorkflowRunsList
- export function buildActivityWorkflowRunsListQuery
- export function queryKeyActivityWorkflowRunsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/activityWorkflowRunsRetrieve.ts
Tamaño: 4673 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { activityWorkflowRunsRetrieve } from "../funcs/activityWorkflowRunsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type ActivityWorkflowRunsRetrieveQueryData =
  components.GetWorkflowRunResponseDto;

/**
 * Retrieve workflow run
 *
 * @remarks
 * Retrieve detailed information for a specific workflow run by ID.
 */
export function useActivityWorkflowRunsRetrieve(
  workflowRunId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<ActivityWorkflowRunsRetrieveQueryData>,
): UseQueryResult<ActivityWorkflowRunsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildActivityWorkflowRunsRetrieveQuery(
      client,
      workflowRunId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve workflow run
 *
 * @remarks
 * Retrieve detailed information for a specific workflow run by ID.
 */
export function useActivityWorkflowRunsRetrieveSuspense(
  workflowRunId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<ActivityWorkflowRunsRetrieveQueryData>,
): UseSuspenseQueryResult<ActivityWorkflowRunsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildActivityWorkflowRunsRetrieveQuery(
      client,
      workflowRunId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchActivityWorkflowRunsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  workflowRunId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildActivityWorkflowRunsRetrieveQuery(
      client$,
      workflowRunId,
      idempotencyKey,
    ),
  });
}

export function setActivityWorkflowRunsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    workflowRunId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: ActivityWorkflowRunsRetrieveQueryData,
): ActivityWorkflowRunsRetrieveQueryData | undefined {
  const key = queryKeyActivityWorkflowRunsRetrieve(...queryKeyBase);

  return client.setQueryData<ActivityWorkflowRunsRetrieveQueryData>(key, data);
}

export function invalidateActivityWorkflowRunsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [workflowRunId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "WorkflowRuns", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllActivityWorkflowRunsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "WorkflowRuns", "retrieve"],
  });
}

export function buildActivityWorkflowRunsRetrieveQuery(
  client$: NovuCore,
  workflowRunId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<ActivityWorkflowRunsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyActivityWorkflowRunsRetrieve(workflowRunId, {
      idempotencyKey,
    }),
    queryFn: async function activityWorkflowRunsRetrieveQueryFn(
      ctx,
    ): Promise<ActivityWorkflowRunsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(activityWorkflowRunsRetrieve(
        client$,
        workflowRunId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyActivityWorkflowRunsRetrieve(
  workflowRunId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "WorkflowRuns", "retrieve", workflowRunId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useActivityWorkflowRunsRetrieve(workflowRunId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<ActivityWorkflowRunsRetrieveQueryData>,)
 - useActivityWorkflowRunsRetrieveSuspense(workflowRunId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<ActivityWorkflowRunsRetrieveQueryData>,)
 - prefetchActivityWorkflowRunsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  workflowRunId: string,
  idempotencyKey?: string | undefined,)
 - setActivityWorkflowRunsRetrieveData(client: QueryClient,
  queryKeyBase: [
    workflowRunId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: ActivityWorkflowRunsRetrieveQueryData,)
 - invalidateActivityWorkflowRunsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [workflowRunId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllActivityWorkflowRunsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildActivityWorkflowRunsRetrieveQuery(client$: NovuCore,
  workflowRunId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - activityWorkflowRunsRetrieveQueryFn(ctx,)
 - queryKeyActivityWorkflowRunsRetrieve(workflowRunId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyActivityWorkflowRunsRetrieve(...queryKeyBase);

  return client.setQueryData<ActivityWorkflo...)
Declaraciones 'export' encontradas:
- export  type
- export function useActivityWorkflowRunsRetrieve
- export function useActivityWorkflowRunsRetrieveSuspense
- export function prefetchActivityWorkflowRunsRetrieve
- export function setActivityWorkflowRunsRetrieveData
- export function invalidateActivityWorkflowRunsRetrieve
- export function invalidateAllActivityWorkflowRunsRetrieve
- export function buildActivityWorkflowRunsRetrieveQuery
- export function queryKeyActivityWorkflowRunsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/cancel.ts
Tamaño: 2323 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { cancel } from "../funcs/cancel.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type CancelMutationVariables = {
  transactionId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type CancelMutationData = operations.EventsControllerCancelResponse;

/**
 * Cancel triggered event
 *
 * @remarks
 *
 *     Using a previously generated transactionId during the event trigger,
 *      will cancel any active or pending workflows. This is useful to cancel active digests, delays etc...
 */
export function useCancelMutation(
  options?: MutationHookOptions<
    CancelMutationData,
    Error,
    CancelMutationVariables
  >,
): UseMutationResult<CancelMutationData, Error, CancelMutationVariables> {
  const client = useNovuContext();
  return useMutation({
    ...buildCancelMutation(client, options),
    ...options,
  });
}

export function mutationKeyCancel(): MutationKey {
  return ["@novu/api", "cancel"];
}

export function buildCancelMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: CancelMutationVariables,
  ) => Promise<CancelMutationData>;
} {
  return {
    mutationKey: mutationKeyCancel(),
    mutationFn: function cancelMutationFn({
      transactionId,
      idempotencyKey,
      options,
    }): Promise<CancelMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(cancel(
        client$,
        transactionId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useCancelMutation(options?: MutationHookOptions<
    CancelMutationData,
    Error,
    CancelMutationVariables
  >,)
 - mutationKeyCancel()
 - buildCancelMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - cancelMutationFn({
      transactionId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildCancelMutation(client, options),
    ...options...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useCancelMutation
- export function mutationKeyCancel
- export function buildCancelMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/contextsCreate.ts
Tamaño: 2524 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { contextsCreate } from "../funcs/contextsCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type ContextsCreateMutationVariables = {
  createContextRequestDto: components.CreateContextRequestDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type ContextsCreateMutationData =
  operations.ContextsControllerCreateContextResponse;

/**
 * Create context
 *
 * @remarks
 * Create a new context with the specified type, id, and data. Returns 409 if context already exists.
 */
export function useContextsCreateMutation(
  options?: MutationHookOptions<
    ContextsCreateMutationData,
    Error,
    ContextsCreateMutationVariables
  >,
): UseMutationResult<
  ContextsCreateMutationData,
  Error,
  ContextsCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildContextsCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeyContextsCreate(): MutationKey {
  return ["@novu/api", "Contexts", "create"];
}

export function buildContextsCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: ContextsCreateMutationVariables,
  ) => Promise<ContextsCreateMutationData>;
} {
  return {
    mutationKey: mutationKeyContextsCreate(),
    mutationFn: function contextsCreateMutationFn({
      createContextRequestDto,
      idempotencyKey,
      options,
    }): Promise<ContextsCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(contextsCreate(
        client$,
        createContextRequestDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useContextsCreateMutation(options?: MutationHookOptions<
    ContextsCreateMutationData,
    Error,
    ContextsCreateMutationVariables
  >,)
 - mutationKeyContextsCreate()
 - buildContextsCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - contextsCreateMutationFn({
      createContextRequestDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildContextsCreateMutation(client, options),
    .....)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useContextsCreateMutation
- export function mutationKeyContextsCreate
- export function buildContextsCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/contextsDelete.ts
Tamaño: 2367 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { contextsDelete } from "../funcs/contextsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type ContextsDeleteMutationVariables = {
  type: string;
  id: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type ContextsDeleteMutationData =
  | operations.ContextsControllerDeleteContextResponse
  | undefined;

/**
 * Delete context
 *
 * @remarks
 * Delete a context by its type and id
 */
export function useContextsDeleteMutation(
  options?: MutationHookOptions<
    ContextsDeleteMutationData,
    Error,
    ContextsDeleteMutationVariables
  >,
): UseMutationResult<
  ContextsDeleteMutationData,
  Error,
  ContextsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildContextsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyContextsDelete(): MutationKey {
  return ["@novu/api", "Contexts", "delete"];
}

export function buildContextsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: ContextsDeleteMutationVariables,
  ) => Promise<ContextsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyContextsDelete(),
    mutationFn: function contextsDeleteMutationFn({
      type,
      id,
      idempotencyKey,
      options,
    }): Promise<ContextsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(contextsDelete(
        client$,
        type,
        id,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useContextsDeleteMutation(options?: MutationHookOptions<
    ContextsDeleteMutationData,
    Error,
    ContextsDeleteMutationVariables
  >,)
 - mutationKeyContextsDelete()
 - buildContextsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - contextsDeleteMutationFn({
      type,
      id,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildContextsDeleteMutation(client, options),
    .....)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useContextsDeleteMutation
- export function mutationKeyContextsDelete
- export function buildContextsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/contextsList.ts
Tamaño: 5360 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { contextsList } from "../funcs/contextsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type ContextsListQueryData =
  operations.ContextsControllerListContextsResponse;

/**
 * List contexts
 *
 * @remarks
 * Retrieve a paginated list of contexts, optionally filtered by type and key pattern
 */
export function useContextsList(
  request: operations.ContextsControllerListContextsRequest,
  options?: QueryHookOptions<ContextsListQueryData>,
): UseQueryResult<ContextsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildContextsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List contexts
 *
 * @remarks
 * Retrieve a paginated list of contexts, optionally filtered by type and key pattern
 */
export function useContextsListSuspense(
  request: operations.ContextsControllerListContextsRequest,
  options?: SuspenseQueryHookOptions<ContextsListQueryData>,
): UseSuspenseQueryResult<ContextsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildContextsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchContextsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.ContextsControllerListContextsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildContextsListQuery(
      client$,
      request,
    ),
  });
}

export function setContextsListData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?: operations.OrderDirection | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      type?: string | undefined;
      id?: string | undefined;
      search?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: ContextsListQueryData,
): ContextsListQueryData | undefined {
  const key = queryKeyContextsList(...queryKeyBase);

  return client.setQueryData<ContextsListQueryData>(key, data);
}

export function invalidateContextsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?: operations.OrderDirection | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      type?: string | undefined;
      id?: string | undefined;
      search?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Contexts", "list", ...queryKeyBase],
  });
}

export function invalidateAllContextsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Contexts", "list"],
  });
}

export function buildContextsListQuery(
  client$: NovuCore,
  request: operations.ContextsControllerListContextsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (context: QueryFunctionContext) => Promise<ContextsListQueryData>;
} {
  return {
    queryKey: queryKeyContextsList({
      after: request.after,
      before: request.before,
      limit: request.limit,
      orderDirection: request.orderDirection,
      orderBy: request.orderBy,
      includeCursor: request.includeCursor,
      type: request.type,
      id: request.id,
      search: request.search,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function contextsListQueryFn(
      ctx,
    ): Promise<ContextsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(contextsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyContextsList(
  parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?: operations.OrderDirection | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    type?: string | undefined;
    id?: string | undefined;
    search?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Contexts", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useContextsList(request: operations.ContextsControllerListContextsRequest,
  options?: QueryHookOptions<ContextsListQueryData>,)
 - useContextsListSuspense(request: operations.ContextsControllerListContextsRequest,
  options?: SuspenseQueryHookOptions<ContextsListQueryData>,)
 - prefetchContextsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.ContextsControllerListContextsRequest,)
 - setContextsListData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?: operations.OrderDirection | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      type?: string | undefined;
      id?: string | undefined;
      search?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: ContextsListQueryData,)
 - invalidateContextsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?: operations.OrderDirection | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      type?: string | undefined;
      id?: string | undefined;
      search?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllContextsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildContextsListQuery(client$: NovuCore,
  request: operations.ContextsControllerListContextsRequest,
  options?: RequestOptions,)
 - contextsListQueryFn(ctx,)
 - queryKeyContextsList(parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?: operations.OrderDirection | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    type?: string | undefined;
    id?: string | undefined;
    search?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyContextsList(...queryKeyBase);

  return client.setQueryData<ContextsListQueryData>(key, dat...)
Declaraciones 'export' encontradas:
- export  type
- export function useContextsList
- export function useContextsListSuspense
- export function prefetchContextsList
- export function setContextsListData
- export function invalidateContextsList
- export function invalidateAllContextsList
- export function buildContextsListQuery
- export function queryKeyContextsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/contextsRetrieve.ts
Tamaño: 4349 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { contextsRetrieve } from "../funcs/contextsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type ContextsRetrieveQueryData =
  operations.ContextsControllerGetContextResponse;

/**
 * Get context by id
 *
 * @remarks
 * Retrieve a specific context by its type and id
 */
export function useContextsRetrieve(
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<ContextsRetrieveQueryData>,
): UseQueryResult<ContextsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildContextsRetrieveQuery(
      client,
      type,
      id,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Get context by id
 *
 * @remarks
 * Retrieve a specific context by its type and id
 */
export function useContextsRetrieveSuspense(
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<ContextsRetrieveQueryData>,
): UseSuspenseQueryResult<ContextsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildContextsRetrieveQuery(
      client,
      type,
      id,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchContextsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildContextsRetrieveQuery(
      client$,
      type,
      id,
      idempotencyKey,
    ),
  });
}

export function setContextsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    type: string,
    id: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: ContextsRetrieveQueryData,
): ContextsRetrieveQueryData | undefined {
  const key = queryKeyContextsRetrieve(...queryKeyBase);

  return client.setQueryData<ContextsRetrieveQueryData>(key, data);
}

export function invalidateContextsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      type: string,
      id: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Contexts", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllContextsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Contexts", "retrieve"],
  });
}

export function buildContextsRetrieveQuery(
  client$: NovuCore,
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<ContextsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyContextsRetrieve(type, id, { idempotencyKey }),
    queryFn: async function contextsRetrieveQueryFn(
      ctx,
    ): Promise<ContextsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(contextsRetrieve(
        client$,
        type,
        id,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyContextsRetrieve(
  type: string,
  id: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Contexts", "retrieve", type, id, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useContextsRetrieve(type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<ContextsRetrieveQueryData>,)
 - useContextsRetrieveSuspense(type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<ContextsRetrieveQueryData>,)
 - prefetchContextsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  type: string,
  id: string,
  idempotencyKey?: string | undefined,)
 - setContextsRetrieveData(client: QueryClient,
  queryKeyBase: [
    type: string,
    id: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: ContextsRetrieveQueryData,)
 - invalidateContextsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      type: string,
      id: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllContextsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildContextsRetrieveQuery(client$: NovuCore,
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - contextsRetrieveQueryFn(ctx,)
 - queryKeyContextsRetrieve(type: string,
  id: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyContextsRetrieve(...queryKeyBase);

  return client.setQueryData<ContextsRetrieveQueryData>(...)
Declaraciones 'export' encontradas:
- export  type
- export function useContextsRetrieve
- export function useContextsRetrieveSuspense
- export function prefetchContextsRetrieve
- export function setContextsRetrieveData
- export function invalidateContextsRetrieve
- export function invalidateAllContextsRetrieve
- export function buildContextsRetrieveQuery
- export function queryKeyContextsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/contextsUpdate.ts
Tamaño: 2330 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { contextsUpdate } from "../funcs/contextsUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type ContextsUpdateMutationVariables = {
  request: operations.ContextsControllerUpdateContextRequest;
  options?: RequestOptions;
};

export type ContextsUpdateMutationData =
  operations.ContextsControllerUpdateContextResponse;

/**
 * Update context data
 *
 * @remarks
 * Update the data of an existing context. Returns 404 if context does not exist.
 */
export function useContextsUpdateMutation(
  options?: MutationHookOptions<
    ContextsUpdateMutationData,
    Error,
    ContextsUpdateMutationVariables
  >,
): UseMutationResult<
  ContextsUpdateMutationData,
  Error,
  ContextsUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildContextsUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeyContextsUpdate(): MutationKey {
  return ["@novu/api", "Contexts", "update"];
}

export function buildContextsUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: ContextsUpdateMutationVariables,
  ) => Promise<ContextsUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeyContextsUpdate(),
    mutationFn: function contextsUpdateMutationFn({
      request,
      options,
    }): Promise<ContextsUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(contextsUpdate(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useContextsUpdateMutation(options?: MutationHookOptions<
    ContextsUpdateMutationData,
    Error,
    ContextsUpdateMutationVariables
  >,)
 - mutationKeyContextsUpdate()
 - buildContextsUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - contextsUpdateMutationFn({
      request,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildContextsUpdateMutation(client, options),
    .....)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useContextsUpdateMutation
- export function mutationKeyContextsUpdate
- export function buildContextsUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/environmentsCreate.ts
Tamaño: 2765 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { environmentsCreate } from "../funcs/environmentsCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type EnvironmentsCreateMutationVariables = {
  createEnvironmentRequestDto: components.CreateEnvironmentRequestDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type EnvironmentsCreateMutationData =
  operations.EnvironmentsControllerV1CreateEnvironmentResponse;

/**
 * Create an environment
 *
 * @remarks
 * Creates a new environment within the current organization.
 *     Environments allow you to manage different stages of your application development lifecycle.
 *     Each environment has its own set of API keys and configurations.
 */
export function useEnvironmentsCreateMutation(
  options?: MutationHookOptions<
    EnvironmentsCreateMutationData,
    Error,
    EnvironmentsCreateMutationVariables
  >,
): UseMutationResult<
  EnvironmentsCreateMutationData,
  Error,
  EnvironmentsCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildEnvironmentsCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeyEnvironmentsCreate(): MutationKey {
  return ["@novu/api", "Environments", "create"];
}

export function buildEnvironmentsCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: EnvironmentsCreateMutationVariables,
  ) => Promise<EnvironmentsCreateMutationData>;
} {
  return {
    mutationKey: mutationKeyEnvironmentsCreate(),
    mutationFn: function environmentsCreateMutationFn({
      createEnvironmentRequestDto,
      idempotencyKey,
      options,
    }): Promise<EnvironmentsCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(environmentsCreate(
        client$,
        createEnvironmentRequestDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useEnvironmentsCreateMutation(options?: MutationHookOptions<
    EnvironmentsCreateMutationData,
    Error,
    EnvironmentsCreateMutationVariables
  >,)
 - mutationKeyEnvironmentsCreate()
 - buildEnvironmentsCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - environmentsCreateMutationFn({
      createEnvironmentRequestDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildEnvironmentsCreateMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useEnvironmentsCreateMutation
- export function mutationKeyEnvironmentsCreate
- export function buildEnvironmentsCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/environmentsDelete.ts
Tamaño: 2577 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { environmentsDelete } from "../funcs/environmentsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type EnvironmentsDeleteMutationVariables = {
  environmentId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type EnvironmentsDeleteMutationData =
  | operations.EnvironmentsControllerV1DeleteEnvironmentResponse
  | undefined;

/**
 * Delete an environment
 *
 * @remarks
 * Delete an environment by its unique identifier **environmentId**.
 *     This action is irreversible and will remove the environment and all its associated data.
 */
export function useEnvironmentsDeleteMutation(
  options?: MutationHookOptions<
    EnvironmentsDeleteMutationData,
    Error,
    EnvironmentsDeleteMutationVariables
  >,
): UseMutationResult<
  EnvironmentsDeleteMutationData,
  Error,
  EnvironmentsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildEnvironmentsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyEnvironmentsDelete(): MutationKey {
  return ["@novu/api", "Environments", "delete"];
}

export function buildEnvironmentsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: EnvironmentsDeleteMutationVariables,
  ) => Promise<EnvironmentsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyEnvironmentsDelete(),
    mutationFn: function environmentsDeleteMutationFn({
      environmentId,
      idempotencyKey,
      options,
    }): Promise<EnvironmentsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(environmentsDelete(
        client$,
        environmentId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useEnvironmentsDeleteMutation(options?: MutationHookOptions<
    EnvironmentsDeleteMutationData,
    Error,
    EnvironmentsDeleteMutationVariables
  >,)
 - mutationKeyEnvironmentsDelete()
 - buildEnvironmentsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - environmentsDeleteMutationFn({
      environmentId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildEnvironmentsDeleteMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useEnvironmentsDeleteMutation
- export function mutationKeyEnvironmentsDelete
- export function buildEnvironmentsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/environmentsGetTags.ts
Tamaño: 4557 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { environmentsGetTags } from "../funcs/environmentsGetTags.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type EnvironmentsGetTagsQueryData =
  operations.EnvironmentsControllerGetEnvironmentTagsResponse;

/**
 * Get environment tags
 *
 * @remarks
 * Retrieve all unique tags used in workflows within the specified environment. These tags can be used for filtering workflows.
 */
export function useEnvironmentsGetTags(
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<EnvironmentsGetTagsQueryData>,
): UseQueryResult<EnvironmentsGetTagsQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildEnvironmentsGetTagsQuery(
      client,
      environmentId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Get environment tags
 *
 * @remarks
 * Retrieve all unique tags used in workflows within the specified environment. These tags can be used for filtering workflows.
 */
export function useEnvironmentsGetTagsSuspense(
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<EnvironmentsGetTagsQueryData>,
): UseSuspenseQueryResult<EnvironmentsGetTagsQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildEnvironmentsGetTagsQuery(
      client,
      environmentId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchEnvironmentsGetTags(
  queryClient: QueryClient,
  client$: NovuCore,
  environmentId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildEnvironmentsGetTagsQuery(
      client$,
      environmentId,
      idempotencyKey,
    ),
  });
}

export function setEnvironmentsGetTagsData(
  client: QueryClient,
  queryKeyBase: [
    environmentId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: EnvironmentsGetTagsQueryData,
): EnvironmentsGetTagsQueryData | undefined {
  const key = queryKeyEnvironmentsGetTags(...queryKeyBase);

  return client.setQueryData<EnvironmentsGetTagsQueryData>(key, data);
}

export function invalidateEnvironmentsGetTags(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [environmentId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Environments", "getTags", ...queryKeyBase],
  });
}

export function invalidateAllEnvironmentsGetTags(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Environments", "getTags"],
  });
}

export function buildEnvironmentsGetTagsQuery(
  client$: NovuCore,
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<EnvironmentsGetTagsQueryData>;
} {
  return {
    queryKey: queryKeyEnvironmentsGetTags(environmentId, { idempotencyKey }),
    queryFn: async function environmentsGetTagsQueryFn(
      ctx,
    ): Promise<EnvironmentsGetTagsQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(environmentsGetTags(
        client$,
        environmentId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyEnvironmentsGetTags(
  environmentId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Environments", "getTags", environmentId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useEnvironmentsGetTags(environmentId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<EnvironmentsGetTagsQueryData>,)
 - useEnvironmentsGetTagsSuspense(environmentId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<EnvironmentsGetTagsQueryData>,)
 - prefetchEnvironmentsGetTags(queryClient: QueryClient,
  client$: NovuCore,
  environmentId: string,
  idempotencyKey?: string | undefined,)
 - setEnvironmentsGetTagsData(client: QueryClient,
  queryKeyBase: [
    environmentId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: EnvironmentsGetTagsQueryData,)
 - invalidateEnvironmentsGetTags(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [environmentId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllEnvironmentsGetTags(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildEnvironmentsGetTagsQuery(client$: NovuCore,
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - environmentsGetTagsQueryFn(ctx,)
 - queryKeyEnvironmentsGetTags(environmentId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyEnvironmentsGetTags(...queryKeyBase);

  return client.setQueryData<EnvironmentsGetTagsQuery...)
Declaraciones 'export' encontradas:
- export  type
- export function useEnvironmentsGetTags
- export function useEnvironmentsGetTagsSuspense
- export function prefetchEnvironmentsGetTags
- export function setEnvironmentsGetTagsData
- export function invalidateEnvironmentsGetTags
- export function invalidateAllEnvironmentsGetTags
- export function buildEnvironmentsGetTagsQuery
- export function queryKeyEnvironmentsGetTags

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/environmentsList.ts
Tamaño: 4255 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { environmentsList } from "../funcs/environmentsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type EnvironmentsListQueryData =
  operations.EnvironmentsControllerV1ListMyEnvironmentsResponse;

/**
 * List all environments
 *
 * @remarks
 * This API returns a list of environments for the current organization.
 *     Each environment contains its configuration, API keys (if user has access), and metadata.
 */
export function useEnvironmentsList(
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<EnvironmentsListQueryData>,
): UseQueryResult<EnvironmentsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildEnvironmentsListQuery(
      client,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * List all environments
 *
 * @remarks
 * This API returns a list of environments for the current organization.
 *     Each environment contains its configuration, API keys (if user has access), and metadata.
 */
export function useEnvironmentsListSuspense(
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<EnvironmentsListQueryData>,
): UseSuspenseQueryResult<EnvironmentsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildEnvironmentsListQuery(
      client,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchEnvironmentsList(
  queryClient: QueryClient,
  client$: NovuCore,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildEnvironmentsListQuery(
      client$,
      idempotencyKey,
    ),
  });
}

export function setEnvironmentsListData(
  client: QueryClient,
  queryKeyBase: [parameters: { idempotencyKey?: string | undefined }],
  data: EnvironmentsListQueryData,
): EnvironmentsListQueryData | undefined {
  const key = queryKeyEnvironmentsList(...queryKeyBase);

  return client.setQueryData<EnvironmentsListQueryData>(key, data);
}

export function invalidateEnvironmentsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Environments", "list", ...queryKeyBase],
  });
}

export function invalidateAllEnvironmentsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Environments", "list"],
  });
}

export function buildEnvironmentsListQuery(
  client$: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<EnvironmentsListQueryData>;
} {
  return {
    queryKey: queryKeyEnvironmentsList({ idempotencyKey }),
    queryFn: async function environmentsListQueryFn(
      ctx,
    ): Promise<EnvironmentsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(environmentsList(
        client$,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyEnvironmentsList(
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Environments", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useEnvironmentsList(idempotencyKey?: string | undefined,
  options?: QueryHookOptions<EnvironmentsListQueryData>,)
 - useEnvironmentsListSuspense(idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<EnvironmentsListQueryData>,)
 - prefetchEnvironmentsList(queryClient: QueryClient,
  client$: NovuCore,
  idempotencyKey?: string | undefined,)
 - setEnvironmentsListData(client: QueryClient,
  queryKeyBase: [parameters: { idempotencyKey?: string | undefined }],
  data: EnvironmentsListQueryData,)
 - invalidateEnvironmentsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllEnvironmentsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildEnvironmentsListQuery(client$: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - environmentsListQueryFn(ctx,)
 - queryKeyEnvironmentsList(parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyEnvironmentsList(...queryKeyBase);

  return client.setQueryData<EnvironmentsListQueryData>(...)
Declaraciones 'export' encontradas:
- export  type
- export function useEnvironmentsList
- export function useEnvironmentsListSuspense
- export function prefetchEnvironmentsList
- export function setEnvironmentsListData
- export function invalidateEnvironmentsList
- export function invalidateAllEnvironmentsList
- export function buildEnvironmentsListQuery
- export function queryKeyEnvironmentsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/environmentsUpdate.ts
Tamaño: 2768 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { environmentsUpdate } from "../funcs/environmentsUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type EnvironmentsUpdateMutationVariables = {
  updateEnvironmentRequestDto: components.UpdateEnvironmentRequestDto;
  environmentId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type EnvironmentsUpdateMutationData =
  operations.EnvironmentsControllerV1UpdateMyEnvironmentResponse;

/**
 * Update an environment
 *
 * @remarks
 * Update an environment by its unique identifier **environmentId**.
 *     You can modify the environment name, identifier, color, and other configuration settings.
 */
export function useEnvironmentsUpdateMutation(
  options?: MutationHookOptions<
    EnvironmentsUpdateMutationData,
    Error,
    EnvironmentsUpdateMutationVariables
  >,
): UseMutationResult<
  EnvironmentsUpdateMutationData,
  Error,
  EnvironmentsUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildEnvironmentsUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeyEnvironmentsUpdate(): MutationKey {
  return ["@novu/api", "Environments", "update"];
}

export function buildEnvironmentsUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: EnvironmentsUpdateMutationVariables,
  ) => Promise<EnvironmentsUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeyEnvironmentsUpdate(),
    mutationFn: function environmentsUpdateMutationFn({
      updateEnvironmentRequestDto,
      environmentId,
      idempotencyKey,
      options,
    }): Promise<EnvironmentsUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(environmentsUpdate(
        client$,
        updateEnvironmentRequestDto,
        environmentId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useEnvironmentsUpdateMutation(options?: MutationHookOptions<
    EnvironmentsUpdateMutationData,
    Error,
    EnvironmentsUpdateMutationVariables
  >,)
 - mutationKeyEnvironmentsUpdate()
 - buildEnvironmentsUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - environmentsUpdateMutationFn({
      updateEnvironmentRequestDto,
      environmentId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildEnvironmentsUpdateMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useEnvironmentsUpdateMutation
- export function mutationKeyEnvironmentsUpdate
- export function buildEnvironmentsUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/index.ts
Tamaño: 3886 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export { NovuProvider, useNovuContext } from "./_context.js";
export * from "./_types.js";

export * from "./activityChartsRetrieve.js";
export * from "./activityRequestsList.js";
export * from "./activityRequestsRetrieve.js";
export * from "./activityTrack.js";
export * from "./activityWorkflowRunsList.js";
export * from "./activityWorkflowRunsRetrieve.js";
export * from "./cancel.js";
export * from "./contextsCreate.js";
export * from "./contextsDelete.js";
export * from "./contextsList.js";
export * from "./contextsRetrieve.js";
export * from "./contextsUpdate.js";
export * from "./environmentsCreate.js";
export * from "./environmentsDelete.js";
export * from "./environmentsGetTags.js";
export * from "./environmentsList.js";
export * from "./environmentsUpdate.js";
export * from "./integrationsCreate.js";
export * from "./integrationsDelete.js";
export * from "./integrationsIntegrationsControllerAutoConfigureIntegration.js";
export * from "./integrationsList.js";
export * from "./integrationsListActive.js";
export * from "./integrationsSetAsPrimary.js";
export * from "./integrationsUpdate.js";
export * from "./layoutsCreate.js";
export * from "./layoutsDelete.js";
export * from "./layoutsDuplicate.js";
export * from "./layoutsGeneratePreview.js";
export * from "./layoutsList.js";
export * from "./layoutsRetrieve.js";
export * from "./layoutsUpdate.js";
export * from "./layoutsUsage.js";
export * from "./messagesDelete.js";
export * from "./messagesDeleteByTransactionId.js";
export * from "./messagesRetrieve.js";
export * from "./notificationsList.js";
export * from "./notificationsRetrieve.js";
export * from "./subscribersCreate.js";
export * from "./subscribersCreateBulk.js";
export * from "./subscribersCredentialsAppend.js";
export * from "./subscribersCredentialsDelete.js";
export * from "./subscribersCredentialsUpdate.js";
export * from "./subscribersDelete.js";
export * from "./subscribersMessagesMarkAll.js";
export * from "./subscribersMessagesMarkAllAs.js";
export * from "./subscribersMessagesUpdateAsSeen.js";
export * from "./subscribersNotificationsFeed.js";
export * from "./subscribersNotificationsUnseenCount.js";
export * from "./subscribersPatch.js";
export * from "./subscribersPreferencesBulkUpdate.js";
export * from "./subscribersPreferencesList.js";
export * from "./subscribersPreferencesUpdate.js";
export * from "./subscribersPropertiesUpdateOnlineFlag.js";
export * from "./subscribersRetrieve.js";
export * from "./subscribersSearch.js";
export * from "./subscribersTopicsList.js";
export * from "./topicsCreate.js";
export * from "./topicsDelete.js";
export * from "./topicsGet.js";
export * from "./topicsList.js";
export * from "./topicsSubscribersRetrieve.js";
export * from "./topicsSubscriptionsCreate.js";
export * from "./topicsSubscriptionsDelete.js";
export * from "./topicsSubscriptionsList.js";
export * from "./topicsUpdate.js";
export * from "./translationsCreate.js";
export * from "./translationsDelete.js";
export * from "./translationsGroupsDelete.js";
export * from "./translationsGroupsRetrieve.js";
export * from "./translationsMasterImport.js";
export * from "./translationsMasterRetrieve.js";
export * from "./translationsMasterUpload.js";
export * from "./translationsRetrieve.js";
export * from "./translationsUpload.js";
export * from "./trigger.js";
export * from "./triggerBroadcast.js";
export * from "./triggerBulk.js";
export * from "./workflowsCreate.js";
export * from "./workflowsDelete.js";
export * from "./workflowsDuplicate.js";
export * from "./workflowsGet.js";
export * from "./workflowsList.js";
export * from "./workflowsPatch.js";
export * from "./workflowsStepsGeneratePreview.js";
export * from "./workflowsStepsRetrieve.js";
export * from "./workflowsSync.js";
export * from "./workflowsUpdate.js";


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/integrationsCreate.ts
Tamaño: 2729 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { integrationsCreate } from "../funcs/integrationsCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type IntegrationsCreateMutationVariables = {
  createIntegrationRequestDto: components.CreateIntegrationRequestDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type IntegrationsCreateMutationData =
  operations.IntegrationsControllerCreateIntegrationResponse;

/**
 * Create an integration
 *
 * @remarks
 * Create an integration for the current environment the user is based on the API key provided.
 *     Each provider supports different credentials, check the provider documentation for more details.
 */
export function useIntegrationsCreateMutation(
  options?: MutationHookOptions<
    IntegrationsCreateMutationData,
    Error,
    IntegrationsCreateMutationVariables
  >,
): UseMutationResult<
  IntegrationsCreateMutationData,
  Error,
  IntegrationsCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildIntegrationsCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeyIntegrationsCreate(): MutationKey {
  return ["@novu/api", "Integrations", "create"];
}

export function buildIntegrationsCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: IntegrationsCreateMutationVariables,
  ) => Promise<IntegrationsCreateMutationData>;
} {
  return {
    mutationKey: mutationKeyIntegrationsCreate(),
    mutationFn: function integrationsCreateMutationFn({
      createIntegrationRequestDto,
      idempotencyKey,
      options,
    }): Promise<IntegrationsCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(integrationsCreate(
        client$,
        createIntegrationRequestDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useIntegrationsCreateMutation(options?: MutationHookOptions<
    IntegrationsCreateMutationData,
    Error,
    IntegrationsCreateMutationVariables
  >,)
 - mutationKeyIntegrationsCreate()
 - buildIntegrationsCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - integrationsCreateMutationFn({
      createIntegrationRequestDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildIntegrationsCreateMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useIntegrationsCreateMutation
- export function mutationKeyIntegrationsCreate
- export function buildIntegrationsCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/integrationsDelete.ts
Tamaño: 2503 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { integrationsDelete } from "../funcs/integrationsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type IntegrationsDeleteMutationVariables = {
  integrationId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type IntegrationsDeleteMutationData =
  operations.IntegrationsControllerRemoveIntegrationResponse;

/**
 * Delete an integration
 *
 * @remarks
 * Delete an integration by its unique key identifier **integrationId**.
 *     This action is irreversible.
 */
export function useIntegrationsDeleteMutation(
  options?: MutationHookOptions<
    IntegrationsDeleteMutationData,
    Error,
    IntegrationsDeleteMutationVariables
  >,
): UseMutationResult<
  IntegrationsDeleteMutationData,
  Error,
  IntegrationsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildIntegrationsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyIntegrationsDelete(): MutationKey {
  return ["@novu/api", "Integrations", "delete"];
}

export function buildIntegrationsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: IntegrationsDeleteMutationVariables,
  ) => Promise<IntegrationsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyIntegrationsDelete(),
    mutationFn: function integrationsDeleteMutationFn({
      integrationId,
      idempotencyKey,
      options,
    }): Promise<IntegrationsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(integrationsDelete(
        client$,
        integrationId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useIntegrationsDeleteMutation(options?: MutationHookOptions<
    IntegrationsDeleteMutationData,
    Error,
    IntegrationsDeleteMutationVariables
  >,)
 - mutationKeyIntegrationsDelete()
 - buildIntegrationsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - integrationsDeleteMutationFn({
      integrationId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildIntegrationsDeleteMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useIntegrationsDeleteMutation
- export function mutationKeyIntegrationsDelete
- export function buildIntegrationsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/integrationsIntegrationsControllerAutoConfigureIntegration.ts
Tamaño: 3592 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { integrationsIntegrationsControllerAutoConfigureIntegration } from "../funcs/integrationsIntegrationsControllerAutoConfigureIntegration.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationVariables =
  {
    integrationId: string;
    idempotencyKey?: string | undefined;
    options?: RequestOptions;
  };

export type IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationData =
  operations.IntegrationsControllerAutoConfigureIntegrationResponse;

/**
 * Auto-configure an integration for inbound webhooks
 *
 * @remarks
 * Auto-configure an integration by its unique key identifier **integrationId** for inbound webhook support.
 *     This will automatically generate required webhook signing keys and configure webhook endpoints.
 */
export function useIntegrationsIntegrationsControllerAutoConfigureIntegrationMutation(
  options?: MutationHookOptions<
    IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationData,
    Error,
    IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationVariables
  >,
): UseMutationResult<
  IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationData,
  Error,
  IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildIntegrationsIntegrationsControllerAutoConfigureIntegrationMutation(
      client,
      options,
    ),
    ...options,
  });
}

export function mutationKeyIntegrationsIntegrationsControllerAutoConfigureIntegration(): MutationKey {
  return [
    "@novu/api",
    "Integrations",
    "integrationsControllerAutoConfigureIntegration",
  ];
}

export function buildIntegrationsIntegrationsControllerAutoConfigureIntegrationMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables:
      IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationVariables,
  ) => Promise<
    IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationData
  >;
} {
  return {
    mutationKey:
      mutationKeyIntegrationsIntegrationsControllerAutoConfigureIntegration(),
    mutationFn:
      function integrationsIntegrationsControllerAutoConfigureIntegrationMutationFn(
        {
          integrationId,
          idempotencyKey,
          options,
        },
      ): Promise<
        IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationData
      > {
        const mergedOptions = {
          ...hookOptions,
          ...options,
          fetchOptions: {
            ...hookOptions?.fetchOptions,
            ...options?.fetchOptions,
            signal: combineSignals(
              hookOptions?.fetchOptions?.signal,
              options?.fetchOptions?.signal,
            ),
          },
        };
        return unwrapAsync(
          integrationsIntegrationsControllerAutoConfigureIntegration(
            client$,
            integrationId,
            idempotencyKey,
            mergedOptions,
          ),
        );
      },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useIntegrationsIntegrationsControllerAutoConfigureIntegrationMutation(options?: MutationHookOptions<
    IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationData,
    Error,
    IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationVariables
  >,)
 - mutationKeyIntegrationsIntegrationsControllerAutoConfigureIntegration()
 - buildIntegrationsIntegrationsControllerAutoConfigureIntegrationMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - integrationsIntegrationsControllerAutoConfigureIntegrationMutationFn({
          integrationId,
          idempotencyKey,
          options,
        },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildIntegrationsIntegrationsControllerAutoConfigure...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useIntegrationsIntegrationsControllerAutoConfigureIntegrationMutation
- export function mutationKeyIntegrationsIntegrationsControllerAutoConfigureIntegration
- export function buildIntegrationsIntegrationsControllerAutoConfigureIntegrationMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/integrationsList.ts
Tamaño: 4043 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { integrationsList } from "../funcs/integrationsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type IntegrationsListQueryData =
  operations.IntegrationsControllerListIntegrationsResponse;

/**
 * List all integrations
 *
 * @remarks
 * List all the channels integrations created in the organization
 */
export function useIntegrationsList(
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<IntegrationsListQueryData>,
): UseQueryResult<IntegrationsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildIntegrationsListQuery(
      client,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * List all integrations
 *
 * @remarks
 * List all the channels integrations created in the organization
 */
export function useIntegrationsListSuspense(
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<IntegrationsListQueryData>,
): UseSuspenseQueryResult<IntegrationsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildIntegrationsListQuery(
      client,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchIntegrationsList(
  queryClient: QueryClient,
  client$: NovuCore,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildIntegrationsListQuery(
      client$,
      idempotencyKey,
    ),
  });
}

export function setIntegrationsListData(
  client: QueryClient,
  queryKeyBase: [parameters: { idempotencyKey?: string | undefined }],
  data: IntegrationsListQueryData,
): IntegrationsListQueryData | undefined {
  const key = queryKeyIntegrationsList(...queryKeyBase);

  return client.setQueryData<IntegrationsListQueryData>(key, data);
}

export function invalidateIntegrationsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Integrations", "list", ...queryKeyBase],
  });
}

export function invalidateAllIntegrationsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Integrations", "list"],
  });
}

export function buildIntegrationsListQuery(
  client$: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<IntegrationsListQueryData>;
} {
  return {
    queryKey: queryKeyIntegrationsList({ idempotencyKey }),
    queryFn: async function integrationsListQueryFn(
      ctx,
    ): Promise<IntegrationsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(integrationsList(
        client$,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyIntegrationsList(
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Integrations", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useIntegrationsList(idempotencyKey?: string | undefined,
  options?: QueryHookOptions<IntegrationsListQueryData>,)
 - useIntegrationsListSuspense(idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<IntegrationsListQueryData>,)
 - prefetchIntegrationsList(queryClient: QueryClient,
  client$: NovuCore,
  idempotencyKey?: string | undefined,)
 - setIntegrationsListData(client: QueryClient,
  queryKeyBase: [parameters: { idempotencyKey?: string | undefined }],
  data: IntegrationsListQueryData,)
 - invalidateIntegrationsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllIntegrationsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildIntegrationsListQuery(client$: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - integrationsListQueryFn(ctx,)
 - queryKeyIntegrationsList(parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyIntegrationsList(...queryKeyBase);

  return client.setQueryData<IntegrationsListQueryData>(...)
Declaraciones 'export' encontradas:
- export  type
- export function useIntegrationsList
- export function useIntegrationsListSuspense
- export function prefetchIntegrationsList
- export function setIntegrationsListData
- export function invalidateIntegrationsList
- export function invalidateAllIntegrationsList
- export function buildIntegrationsListQuery
- export function queryKeyIntegrationsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/integrationsListActive.ts
Tamaño: 4230 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { integrationsListActive } from "../funcs/integrationsListActive.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type IntegrationsListActiveQueryData =
  operations.IntegrationsControllerGetActiveIntegrationsResponse;

/**
 * List active integrations
 *
 * @remarks
 * List all the active integrations created in the organization
 */
export function useIntegrationsListActive(
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<IntegrationsListActiveQueryData>,
): UseQueryResult<IntegrationsListActiveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildIntegrationsListActiveQuery(
      client,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * List active integrations
 *
 * @remarks
 * List all the active integrations created in the organization
 */
export function useIntegrationsListActiveSuspense(
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<IntegrationsListActiveQueryData>,
): UseSuspenseQueryResult<IntegrationsListActiveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildIntegrationsListActiveQuery(
      client,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchIntegrationsListActive(
  queryClient: QueryClient,
  client$: NovuCore,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildIntegrationsListActiveQuery(
      client$,
      idempotencyKey,
    ),
  });
}

export function setIntegrationsListActiveData(
  client: QueryClient,
  queryKeyBase: [parameters: { idempotencyKey?: string | undefined }],
  data: IntegrationsListActiveQueryData,
): IntegrationsListActiveQueryData | undefined {
  const key = queryKeyIntegrationsListActive(...queryKeyBase);

  return client.setQueryData<IntegrationsListActiveQueryData>(key, data);
}

export function invalidateIntegrationsListActive(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Integrations", "listActive", ...queryKeyBase],
  });
}

export function invalidateAllIntegrationsListActive(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Integrations", "listActive"],
  });
}

export function buildIntegrationsListActiveQuery(
  client$: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<IntegrationsListActiveQueryData>;
} {
  return {
    queryKey: queryKeyIntegrationsListActive({ idempotencyKey }),
    queryFn: async function integrationsListActiveQueryFn(
      ctx,
    ): Promise<IntegrationsListActiveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(integrationsListActive(
        client$,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyIntegrationsListActive(
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Integrations", "listActive", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useIntegrationsListActive(idempotencyKey?: string | undefined,
  options?: QueryHookOptions<IntegrationsListActiveQueryData>,)
 - useIntegrationsListActiveSuspense(idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<IntegrationsListActiveQueryData>,)
 - prefetchIntegrationsListActive(queryClient: QueryClient,
  client$: NovuCore,
  idempotencyKey?: string | undefined,)
 - setIntegrationsListActiveData(client: QueryClient,
  queryKeyBase: [parameters: { idempotencyKey?: string | undefined }],
  data: IntegrationsListActiveQueryData,)
 - invalidateIntegrationsListActive(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllIntegrationsListActive(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildIntegrationsListActiveQuery(client$: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - integrationsListActiveQueryFn(ctx,)
 - queryKeyIntegrationsListActive(parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyIntegrationsListActive(...queryKeyBase);

  return client.setQueryData<IntegrationsListActiv...)
Declaraciones 'export' encontradas:
- export  type
- export function useIntegrationsListActive
- export function useIntegrationsListActiveSuspense
- export function prefetchIntegrationsListActive
- export function setIntegrationsListActiveData
- export function invalidateIntegrationsListActive
- export function invalidateAllIntegrationsListActive
- export function buildIntegrationsListActiveQuery
- export function queryKeyIntegrationsListActive

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/integrationsSetAsPrimary.ts
Tamaño: 2810 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { integrationsSetAsPrimary } from "../funcs/integrationsSetAsPrimary.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type IntegrationsSetAsPrimaryMutationVariables = {
  integrationId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type IntegrationsSetAsPrimaryMutationData =
  operations.IntegrationsControllerSetIntegrationAsPrimaryResponse;

/**
 * Update integration as primary
 *
 * @remarks
 * Update an integration as **primary** by its unique key identifier **integrationId**.
 *     This API will set the integration as primary for that channel in the current environment.
 *     Primary integration is used to deliver notification for sms and email channels in the workflow.
 */
export function useIntegrationsSetAsPrimaryMutation(
  options?: MutationHookOptions<
    IntegrationsSetAsPrimaryMutationData,
    Error,
    IntegrationsSetAsPrimaryMutationVariables
  >,
): UseMutationResult<
  IntegrationsSetAsPrimaryMutationData,
  Error,
  IntegrationsSetAsPrimaryMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildIntegrationsSetAsPrimaryMutation(client, options),
    ...options,
  });
}

export function mutationKeyIntegrationsSetAsPrimary(): MutationKey {
  return ["@novu/api", "Integrations", "setAsPrimary"];
}

export function buildIntegrationsSetAsPrimaryMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: IntegrationsSetAsPrimaryMutationVariables,
  ) => Promise<IntegrationsSetAsPrimaryMutationData>;
} {
  return {
    mutationKey: mutationKeyIntegrationsSetAsPrimary(),
    mutationFn: function integrationsSetAsPrimaryMutationFn({
      integrationId,
      idempotencyKey,
      options,
    }): Promise<IntegrationsSetAsPrimaryMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(integrationsSetAsPrimary(
        client$,
        integrationId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useIntegrationsSetAsPrimaryMutation(options?: MutationHookOptions<
    IntegrationsSetAsPrimaryMutationData,
    Error,
    IntegrationsSetAsPrimaryMutationVariables
  >,)
 - mutationKeyIntegrationsSetAsPrimary()
 - buildIntegrationsSetAsPrimaryMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - integrationsSetAsPrimaryMutationFn({
      integrationId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildIntegrationsSetAsPrimaryMutation(client, option...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useIntegrationsSetAsPrimaryMutation
- export function mutationKeyIntegrationsSetAsPrimary
- export function buildIntegrationsSetAsPrimaryMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/integrationsUpdate.ts
Tamaño: 2779 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { integrationsUpdate } from "../funcs/integrationsUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type IntegrationsUpdateMutationVariables = {
  updateIntegrationRequestDto: components.UpdateIntegrationRequestDto;
  integrationId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type IntegrationsUpdateMutationData =
  operations.IntegrationsControllerUpdateIntegrationByIdResponse;

/**
 * Update an integration
 *
 * @remarks
 * Update an integration by its unique key identifier **integrationId**.
 *     Each provider supports different credentials, check the provider documentation for more details.
 */
export function useIntegrationsUpdateMutation(
  options?: MutationHookOptions<
    IntegrationsUpdateMutationData,
    Error,
    IntegrationsUpdateMutationVariables
  >,
): UseMutationResult<
  IntegrationsUpdateMutationData,
  Error,
  IntegrationsUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildIntegrationsUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeyIntegrationsUpdate(): MutationKey {
  return ["@novu/api", "Integrations", "update"];
}

export function buildIntegrationsUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: IntegrationsUpdateMutationVariables,
  ) => Promise<IntegrationsUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeyIntegrationsUpdate(),
    mutationFn: function integrationsUpdateMutationFn({
      updateIntegrationRequestDto,
      integrationId,
      idempotencyKey,
      options,
    }): Promise<IntegrationsUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(integrationsUpdate(
        client$,
        updateIntegrationRequestDto,
        integrationId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useIntegrationsUpdateMutation(options?: MutationHookOptions<
    IntegrationsUpdateMutationData,
    Error,
    IntegrationsUpdateMutationVariables
  >,)
 - mutationKeyIntegrationsUpdate()
 - buildIntegrationsUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - integrationsUpdateMutationFn({
      updateIntegrationRequestDto,
      integrationId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildIntegrationsUpdateMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useIntegrationsUpdateMutation
- export function mutationKeyIntegrationsUpdate
- export function buildIntegrationsUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/layoutsCreate.ts
Tamaño: 2418 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { layoutsCreate } from "../funcs/layoutsCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type LayoutsCreateMutationVariables = {
  createLayoutDto: components.CreateLayoutDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type LayoutsCreateMutationData =
  operations.LayoutsControllerCreateResponse;

/**
 * Create a layout
 *
 * @remarks
 * Creates a new layout in the Novu Cloud environment
 */
export function useLayoutsCreateMutation(
  options?: MutationHookOptions<
    LayoutsCreateMutationData,
    Error,
    LayoutsCreateMutationVariables
  >,
): UseMutationResult<
  LayoutsCreateMutationData,
  Error,
  LayoutsCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildLayoutsCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeyLayoutsCreate(): MutationKey {
  return ["@novu/api", "Layouts", "create"];
}

export function buildLayoutsCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: LayoutsCreateMutationVariables,
  ) => Promise<LayoutsCreateMutationData>;
} {
  return {
    mutationKey: mutationKeyLayoutsCreate(),
    mutationFn: function layoutsCreateMutationFn({
      createLayoutDto,
      idempotencyKey,
      options,
    }): Promise<LayoutsCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(layoutsCreate(
        client$,
        createLayoutDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useLayoutsCreateMutation(options?: MutationHookOptions<
    LayoutsCreateMutationData,
    Error,
    LayoutsCreateMutationVariables
  >,)
 - mutationKeyLayoutsCreate()
 - buildLayoutsCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - layoutsCreateMutationFn({
      createLayoutDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildLayoutsCreateMutation(client, options),
    ......)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useLayoutsCreateMutation
- export function mutationKeyLayoutsCreate
- export function buildLayoutsCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/layoutsDelete.ts
Tamaño: 2345 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { layoutsDelete } from "../funcs/layoutsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type LayoutsDeleteMutationVariables = {
  layoutId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type LayoutsDeleteMutationData =
  | operations.LayoutsControllerDeleteResponse
  | undefined;

/**
 * Delete a layout
 *
 * @remarks
 * Removes a specific layout by its unique identifier **layoutId**
 */
export function useLayoutsDeleteMutation(
  options?: MutationHookOptions<
    LayoutsDeleteMutationData,
    Error,
    LayoutsDeleteMutationVariables
  >,
): UseMutationResult<
  LayoutsDeleteMutationData,
  Error,
  LayoutsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildLayoutsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyLayoutsDelete(): MutationKey {
  return ["@novu/api", "Layouts", "delete"];
}

export function buildLayoutsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: LayoutsDeleteMutationVariables,
  ) => Promise<LayoutsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyLayoutsDelete(),
    mutationFn: function layoutsDeleteMutationFn({
      layoutId,
      idempotencyKey,
      options,
    }): Promise<LayoutsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(layoutsDelete(
        client$,
        layoutId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useLayoutsDeleteMutation(options?: MutationHookOptions<
    LayoutsDeleteMutationData,
    Error,
    LayoutsDeleteMutationVariables
  >,)
 - mutationKeyLayoutsDelete()
 - buildLayoutsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - layoutsDeleteMutationFn({
      layoutId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildLayoutsDeleteMutation(client, options),
    ......)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useLayoutsDeleteMutation
- export function mutationKeyLayoutsDelete
- export function buildLayoutsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/layoutsDuplicate.ts
Tamaño: 2626 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { layoutsDuplicate } from "../funcs/layoutsDuplicate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type LayoutsDuplicateMutationVariables = {
  duplicateLayoutDto: components.DuplicateLayoutDto;
  layoutId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type LayoutsDuplicateMutationData =
  operations.LayoutsControllerDuplicateResponse;

/**
 * Duplicate a layout
 *
 * @remarks
 * Duplicates a layout by its unique identifier **layoutId**. This will create a new layout with the content of the original layout.
 */
export function useLayoutsDuplicateMutation(
  options?: MutationHookOptions<
    LayoutsDuplicateMutationData,
    Error,
    LayoutsDuplicateMutationVariables
  >,
): UseMutationResult<
  LayoutsDuplicateMutationData,
  Error,
  LayoutsDuplicateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildLayoutsDuplicateMutation(client, options),
    ...options,
  });
}

export function mutationKeyLayoutsDuplicate(): MutationKey {
  return ["@novu/api", "Layouts", "duplicate"];
}

export function buildLayoutsDuplicateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: LayoutsDuplicateMutationVariables,
  ) => Promise<LayoutsDuplicateMutationData>;
} {
  return {
    mutationKey: mutationKeyLayoutsDuplicate(),
    mutationFn: function layoutsDuplicateMutationFn({
      duplicateLayoutDto,
      layoutId,
      idempotencyKey,
      options,
    }): Promise<LayoutsDuplicateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(layoutsDuplicate(
        client$,
        duplicateLayoutDto,
        layoutId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useLayoutsDuplicateMutation(options?: MutationHookOptions<
    LayoutsDuplicateMutationData,
    Error,
    LayoutsDuplicateMutationVariables
  >,)
 - mutationKeyLayoutsDuplicate()
 - buildLayoutsDuplicateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - layoutsDuplicateMutationFn({
      duplicateLayoutDto,
      layoutId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildLayoutsDuplicateMutation(client, options),
    ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useLayoutsDuplicateMutation
- export function mutationKeyLayoutsDuplicate
- export function buildLayoutsDuplicateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/layoutsGeneratePreview.ts
Tamaño: 2712 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { layoutsGeneratePreview } from "../funcs/layoutsGeneratePreview.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type LayoutsGeneratePreviewMutationVariables = {
  layoutPreviewRequestDto: components.LayoutPreviewRequestDto;
  layoutId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type LayoutsGeneratePreviewMutationData =
  operations.LayoutsControllerGeneratePreviewResponse;

/**
 * Generate layout preview
 *
 * @remarks
 * Generates a preview for a layout by its unique identifier **layoutId**
 */
export function useLayoutsGeneratePreviewMutation(
  options?: MutationHookOptions<
    LayoutsGeneratePreviewMutationData,
    Error,
    LayoutsGeneratePreviewMutationVariables
  >,
): UseMutationResult<
  LayoutsGeneratePreviewMutationData,
  Error,
  LayoutsGeneratePreviewMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildLayoutsGeneratePreviewMutation(client, options),
    ...options,
  });
}

export function mutationKeyLayoutsGeneratePreview(): MutationKey {
  return ["@novu/api", "Layouts", "generatePreview"];
}

export function buildLayoutsGeneratePreviewMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: LayoutsGeneratePreviewMutationVariables,
  ) => Promise<LayoutsGeneratePreviewMutationData>;
} {
  return {
    mutationKey: mutationKeyLayoutsGeneratePreview(),
    mutationFn: function layoutsGeneratePreviewMutationFn({
      layoutPreviewRequestDto,
      layoutId,
      idempotencyKey,
      options,
    }): Promise<LayoutsGeneratePreviewMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(layoutsGeneratePreview(
        client$,
        layoutPreviewRequestDto,
        layoutId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useLayoutsGeneratePreviewMutation(options?: MutationHookOptions<
    LayoutsGeneratePreviewMutationData,
    Error,
    LayoutsGeneratePreviewMutationVariables
  >,)
 - mutationKeyLayoutsGeneratePreview()
 - buildLayoutsGeneratePreviewMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - layoutsGeneratePreviewMutationFn({
      layoutPreviewRequestDto,
      layoutId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildLayoutsGeneratePreviewMutation(client, options)...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useLayoutsGeneratePreviewMutation
- export function mutationKeyLayoutsGeneratePreview
- export function buildLayoutsGeneratePreviewMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/layoutsList.ts
Tamaño: 4868 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { layoutsList } from "../funcs/layoutsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type LayoutsListQueryData = operations.LayoutsControllerListResponse;

/**
 * List all layouts
 *
 * @remarks
 * Retrieves a list of layouts with optional filtering and pagination
 */
export function useLayoutsList(
  request: operations.LayoutsControllerListRequest,
  options?: QueryHookOptions<LayoutsListQueryData>,
): UseQueryResult<LayoutsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildLayoutsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List all layouts
 *
 * @remarks
 * Retrieves a list of layouts with optional filtering and pagination
 */
export function useLayoutsListSuspense(
  request: operations.LayoutsControllerListRequest,
  options?: SuspenseQueryHookOptions<LayoutsListQueryData>,
): UseSuspenseQueryResult<LayoutsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildLayoutsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchLayoutsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.LayoutsControllerListRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildLayoutsListQuery(
      client$,
      request,
    ),
  });
}

export function setLayoutsListData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      limit?: number | undefined;
      offset?: number | undefined;
      orderDirection?: components.DirectionEnum | undefined;
      orderBy?: components.LayoutResponseDtoSortField | undefined;
      query?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: LayoutsListQueryData,
): LayoutsListQueryData | undefined {
  const key = queryKeyLayoutsList(...queryKeyBase);

  return client.setQueryData<LayoutsListQueryData>(key, data);
}

export function invalidateLayoutsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      limit?: number | undefined;
      offset?: number | undefined;
      orderDirection?: components.DirectionEnum | undefined;
      orderBy?: components.LayoutResponseDtoSortField | undefined;
      query?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Layouts", "list", ...queryKeyBase],
  });
}

export function invalidateAllLayoutsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Layouts", "list"],
  });
}

export function buildLayoutsListQuery(
  client$: NovuCore,
  request: operations.LayoutsControllerListRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (context: QueryFunctionContext) => Promise<LayoutsListQueryData>;
} {
  return {
    queryKey: queryKeyLayoutsList({
      limit: request.limit,
      offset: request.offset,
      orderDirection: request.orderDirection,
      orderBy: request.orderBy,
      query: request.query,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function layoutsListQueryFn(
      ctx,
    ): Promise<LayoutsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(layoutsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyLayoutsList(
  parameters: {
    limit?: number | undefined;
    offset?: number | undefined;
    orderDirection?: components.DirectionEnum | undefined;
    orderBy?: components.LayoutResponseDtoSortField | undefined;
    query?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Layouts", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useLayoutsList(request: operations.LayoutsControllerListRequest,
  options?: QueryHookOptions<LayoutsListQueryData>,)
 - useLayoutsListSuspense(request: operations.LayoutsControllerListRequest,
  options?: SuspenseQueryHookOptions<LayoutsListQueryData>,)
 - prefetchLayoutsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.LayoutsControllerListRequest,)
 - setLayoutsListData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      limit?: number | undefined;
      offset?: number | undefined;
      orderDirection?: components.DirectionEnum | undefined;
      orderBy?: components.LayoutResponseDtoSortField | undefined;
      query?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: LayoutsListQueryData,)
 - invalidateLayoutsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      limit?: number | undefined;
      offset?: number | undefined;
      orderDirection?: components.DirectionEnum | undefined;
      orderBy?: components.LayoutResponseDtoSortField | undefined;
      query?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllLayoutsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildLayoutsListQuery(client$: NovuCore,
  request: operations.LayoutsControllerListRequest,
  options?: RequestOptions,)
 - layoutsListQueryFn(ctx,)
 - queryKeyLayoutsList(parameters: {
    limit?: number | undefined;
    offset?: number | undefined;
    orderDirection?: components.DirectionEnum | undefined;
    orderBy?: components.LayoutResponseDtoSortField | undefined;
    query?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyLayoutsList(...queryKeyBase);

  return client.setQueryData<LayoutsListQueryData>(key, data)...)
Declaraciones 'export' encontradas:
- export  type
- export function useLayoutsList
- export function useLayoutsListSuspense
- export function prefetchLayoutsList
- export function setLayoutsListData
- export function invalidateLayoutsList
- export function invalidateAllLayoutsList
- export function buildLayoutsListQuery
- export function queryKeyLayoutsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/layoutsRetrieve.ts
Tamaño: 4235 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { layoutsRetrieve } from "../funcs/layoutsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type LayoutsRetrieveQueryData = operations.LayoutsControllerGetResponse;

/**
 * Retrieve a layout
 *
 * @remarks
 * Fetches details of a specific layout by its unique identifier **layoutId**
 */
export function useLayoutsRetrieve(
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<LayoutsRetrieveQueryData>,
): UseQueryResult<LayoutsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildLayoutsRetrieveQuery(
      client,
      layoutId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve a layout
 *
 * @remarks
 * Fetches details of a specific layout by its unique identifier **layoutId**
 */
export function useLayoutsRetrieveSuspense(
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<LayoutsRetrieveQueryData>,
): UseSuspenseQueryResult<LayoutsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildLayoutsRetrieveQuery(
      client,
      layoutId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchLayoutsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildLayoutsRetrieveQuery(
      client$,
      layoutId,
      idempotencyKey,
    ),
  });
}

export function setLayoutsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    layoutId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: LayoutsRetrieveQueryData,
): LayoutsRetrieveQueryData | undefined {
  const key = queryKeyLayoutsRetrieve(...queryKeyBase);

  return client.setQueryData<LayoutsRetrieveQueryData>(key, data);
}

export function invalidateLayoutsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [layoutId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Layouts", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllLayoutsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Layouts", "retrieve"],
  });
}

export function buildLayoutsRetrieveQuery(
  client$: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (context: QueryFunctionContext) => Promise<LayoutsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyLayoutsRetrieve(layoutId, { idempotencyKey }),
    queryFn: async function layoutsRetrieveQueryFn(
      ctx,
    ): Promise<LayoutsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(layoutsRetrieve(
        client$,
        layoutId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyLayoutsRetrieve(
  layoutId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Layouts", "retrieve", layoutId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useLayoutsRetrieve(layoutId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<LayoutsRetrieveQueryData>,)
 - useLayoutsRetrieveSuspense(layoutId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<LayoutsRetrieveQueryData>,)
 - prefetchLayoutsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,)
 - setLayoutsRetrieveData(client: QueryClient,
  queryKeyBase: [
    layoutId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: LayoutsRetrieveQueryData,)
 - invalidateLayoutsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [layoutId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllLayoutsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildLayoutsRetrieveQuery(client$: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - layoutsRetrieveQueryFn(ctx,)
 - queryKeyLayoutsRetrieve(layoutId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyLayoutsRetrieve(...queryKeyBase);

  return client.setQueryData<LayoutsRetrieveQueryData>(ke...)
Declaraciones 'export' encontradas:
- export  type
- export function useLayoutsRetrieve
- export function useLayoutsRetrieveSuspense
- export function prefetchLayoutsRetrieve
- export function setLayoutsRetrieveData
- export function invalidateLayoutsRetrieve
- export function invalidateAllLayoutsRetrieve
- export function buildLayoutsRetrieveQuery
- export function queryKeyLayoutsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/layoutsUpdate.ts
Tamaño: 2514 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { layoutsUpdate } from "../funcs/layoutsUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type LayoutsUpdateMutationVariables = {
  updateLayoutDto: components.UpdateLayoutDto;
  layoutId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type LayoutsUpdateMutationData =
  operations.LayoutsControllerUpdateResponse;

/**
 * Update a layout
 *
 * @remarks
 * Updates the details of an existing layout, here **layoutId** is the identifier of the layout
 */
export function useLayoutsUpdateMutation(
  options?: MutationHookOptions<
    LayoutsUpdateMutationData,
    Error,
    LayoutsUpdateMutationVariables
  >,
): UseMutationResult<
  LayoutsUpdateMutationData,
  Error,
  LayoutsUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildLayoutsUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeyLayoutsUpdate(): MutationKey {
  return ["@novu/api", "Layouts", "update"];
}

export function buildLayoutsUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: LayoutsUpdateMutationVariables,
  ) => Promise<LayoutsUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeyLayoutsUpdate(),
    mutationFn: function layoutsUpdateMutationFn({
      updateLayoutDto,
      layoutId,
      idempotencyKey,
      options,
    }): Promise<LayoutsUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(layoutsUpdate(
        client$,
        updateLayoutDto,
        layoutId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useLayoutsUpdateMutation(options?: MutationHookOptions<
    LayoutsUpdateMutationData,
    Error,
    LayoutsUpdateMutationVariables
  >,)
 - mutationKeyLayoutsUpdate()
 - buildLayoutsUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - layoutsUpdateMutationFn({
      updateLayoutDto,
      layoutId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildLayoutsUpdateMutation(client, options),
    ......)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useLayoutsUpdateMutation
- export function mutationKeyLayoutsUpdate
- export function buildLayoutsUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/layoutsUsage.ts
Tamaño: 4212 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { layoutsUsage } from "../funcs/layoutsUsage.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type LayoutsUsageQueryData =
  operations.LayoutsControllerGetUsageResponse;

/**
 * Get layout usage
 *
 * @remarks
 * Retrieves information about workflows that use the specified layout by its unique identifier **layoutId**
 */
export function useLayoutsUsage(
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<LayoutsUsageQueryData>,
): UseQueryResult<LayoutsUsageQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildLayoutsUsageQuery(
      client,
      layoutId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Get layout usage
 *
 * @remarks
 * Retrieves information about workflows that use the specified layout by its unique identifier **layoutId**
 */
export function useLayoutsUsageSuspense(
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<LayoutsUsageQueryData>,
): UseSuspenseQueryResult<LayoutsUsageQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildLayoutsUsageQuery(
      client,
      layoutId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchLayoutsUsage(
  queryClient: QueryClient,
  client$: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildLayoutsUsageQuery(
      client$,
      layoutId,
      idempotencyKey,
    ),
  });
}

export function setLayoutsUsageData(
  client: QueryClient,
  queryKeyBase: [
    layoutId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: LayoutsUsageQueryData,
): LayoutsUsageQueryData | undefined {
  const key = queryKeyLayoutsUsage(...queryKeyBase);

  return client.setQueryData<LayoutsUsageQueryData>(key, data);
}

export function invalidateLayoutsUsage(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [layoutId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Layouts", "usage", ...queryKeyBase],
  });
}

export function invalidateAllLayoutsUsage(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Layouts", "usage"],
  });
}

export function buildLayoutsUsageQuery(
  client$: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (context: QueryFunctionContext) => Promise<LayoutsUsageQueryData>;
} {
  return {
    queryKey: queryKeyLayoutsUsage(layoutId, { idempotencyKey }),
    queryFn: async function layoutsUsageQueryFn(
      ctx,
    ): Promise<LayoutsUsageQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(layoutsUsage(
        client$,
        layoutId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyLayoutsUsage(
  layoutId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Layouts", "usage", layoutId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useLayoutsUsage(layoutId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<LayoutsUsageQueryData>,)
 - useLayoutsUsageSuspense(layoutId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<LayoutsUsageQueryData>,)
 - prefetchLayoutsUsage(queryClient: QueryClient,
  client$: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,)
 - setLayoutsUsageData(client: QueryClient,
  queryKeyBase: [
    layoutId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: LayoutsUsageQueryData,)
 - invalidateLayoutsUsage(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [layoutId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllLayoutsUsage(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildLayoutsUsageQuery(client$: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - layoutsUsageQueryFn(ctx,)
 - queryKeyLayoutsUsage(layoutId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyLayoutsUsage(...queryKeyBase);

  return client.setQueryData<LayoutsUsageQueryData>(key, dat...)
Declaraciones 'export' encontradas:
- export  type
- export function useLayoutsUsage
- export function useLayoutsUsageSuspense
- export function prefetchLayoutsUsage
- export function setLayoutsUsageData
- export function invalidateLayoutsUsage
- export function invalidateAllLayoutsUsage
- export function buildLayoutsUsageQuery
- export function queryKeyLayoutsUsage

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/messagesDelete.ts
Tamaño: 2446 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { messagesDelete } from "../funcs/messagesDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type MessagesDeleteMutationVariables = {
  messageId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type MessagesDeleteMutationData =
  operations.MessagesControllerDeleteMessageResponse;

/**
 * Delete a message
 *
 * @remarks
 * Delete a message entity from the Novu platform by **messageId**.
 *     This action is irreversible. **messageId** is required and of mongodbId type.
 */
export function useMessagesDeleteMutation(
  options?: MutationHookOptions<
    MessagesDeleteMutationData,
    Error,
    MessagesDeleteMutationVariables
  >,
): UseMutationResult<
  MessagesDeleteMutationData,
  Error,
  MessagesDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildMessagesDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyMessagesDelete(): MutationKey {
  return ["@novu/api", "Messages", "delete"];
}

export function buildMessagesDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: MessagesDeleteMutationVariables,
  ) => Promise<MessagesDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyMessagesDelete(),
    mutationFn: function messagesDeleteMutationFn({
      messageId,
      idempotencyKey,
      options,
    }): Promise<MessagesDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(messagesDelete(
        client$,
        messageId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useMessagesDeleteMutation(options?: MutationHookOptions<
    MessagesDeleteMutationData,
    Error,
    MessagesDeleteMutationVariables
  >,)
 - mutationKeyMessagesDelete()
 - buildMessagesDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - messagesDeleteMutationFn({
      messageId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildMessagesDeleteMutation(client, options),
    .....)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useMessagesDeleteMutation
- export function mutationKeyMessagesDelete
- export function buildMessagesDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/messagesDeleteByTransactionId.ts
Tamaño: 2922 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { messagesDeleteByTransactionId } from "../funcs/messagesDeleteByTransactionId.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type MessagesDeleteByTransactionIdMutationVariables = {
  transactionId: string;
  channel?: operations.Channel | undefined;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type MessagesDeleteByTransactionIdMutationData =
  | operations.MessagesControllerDeleteMessagesByTransactionIdResponse
  | undefined;

/**
 * Delete messages by transactionId
 *
 * @remarks
 * Delete multiple messages from the Novu platform using **transactionId** of triggered event.
 *     This API supports filtering by **channel** and delete all messages associated with the **transactionId**.
 */
export function useMessagesDeleteByTransactionIdMutation(
  options?: MutationHookOptions<
    MessagesDeleteByTransactionIdMutationData,
    Error,
    MessagesDeleteByTransactionIdMutationVariables
  >,
): UseMutationResult<
  MessagesDeleteByTransactionIdMutationData,
  Error,
  MessagesDeleteByTransactionIdMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildMessagesDeleteByTransactionIdMutation(client, options),
    ...options,
  });
}

export function mutationKeyMessagesDeleteByTransactionId(): MutationKey {
  return ["@novu/api", "Messages", "deleteByTransactionId"];
}

export function buildMessagesDeleteByTransactionIdMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: MessagesDeleteByTransactionIdMutationVariables,
  ) => Promise<MessagesDeleteByTransactionIdMutationData>;
} {
  return {
    mutationKey: mutationKeyMessagesDeleteByTransactionId(),
    mutationFn: function messagesDeleteByTransactionIdMutationFn({
      transactionId,
      channel,
      idempotencyKey,
      options,
    }): Promise<MessagesDeleteByTransactionIdMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(messagesDeleteByTransactionId(
        client$,
        transactionId,
        channel,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useMessagesDeleteByTransactionIdMutation(options?: MutationHookOptions<
    MessagesDeleteByTransactionIdMutationData,
    Error,
    MessagesDeleteByTransactionIdMutationVariables
  >,)
 - mutationKeyMessagesDeleteByTransactionId()
 - buildMessagesDeleteByTransactionIdMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - messagesDeleteByTransactionIdMutationFn({
      transactionId,
      channel,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildMessagesDeleteByTransactionIdMutation(client, o...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useMessagesDeleteByTransactionIdMutation
- export function mutationKeyMessagesDeleteByTransactionId
- export function buildMessagesDeleteByTransactionIdMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/messagesRetrieve.ts
Tamaño: 5456 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { messagesRetrieve } from "../funcs/messagesRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type MessagesRetrieveQueryData =
  operations.MessagesControllerGetMessagesResponse;

/**
 * List all messages
 *
 * @remarks
 * List all messages for the current environment.
 *     This API supports filtering by **channel**, **subscriberId**, and **transactionId**.
 *     This API returns a paginated list of messages.
 */
export function useMessagesRetrieve(
  request: operations.MessagesControllerGetMessagesRequest,
  options?: QueryHookOptions<MessagesRetrieveQueryData>,
): UseQueryResult<MessagesRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildMessagesRetrieveQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List all messages
 *
 * @remarks
 * List all messages for the current environment.
 *     This API supports filtering by **channel**, **subscriberId**, and **transactionId**.
 *     This API returns a paginated list of messages.
 */
export function useMessagesRetrieveSuspense(
  request: operations.MessagesControllerGetMessagesRequest,
  options?: SuspenseQueryHookOptions<MessagesRetrieveQueryData>,
): UseSuspenseQueryResult<MessagesRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildMessagesRetrieveQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchMessagesRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.MessagesControllerGetMessagesRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildMessagesRetrieveQuery(
      client$,
      request,
    ),
  });
}

export function setMessagesRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      channel?: components.ChannelTypeEnum | undefined;
      subscriberId?: string | undefined;
      transactionId?: Array<string> | undefined;
      contextKeys?: Array<string> | undefined;
      page?: number | undefined;
      limit?: number | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: MessagesRetrieveQueryData,
): MessagesRetrieveQueryData | undefined {
  const key = queryKeyMessagesRetrieve(...queryKeyBase);

  return client.setQueryData<MessagesRetrieveQueryData>(key, data);
}

export function invalidateMessagesRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      channel?: components.ChannelTypeEnum | undefined;
      subscriberId?: string | undefined;
      transactionId?: Array<string> | undefined;
      contextKeys?: Array<string> | undefined;
      page?: number | undefined;
      limit?: number | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Messages", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllMessagesRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Messages", "retrieve"],
  });
}

export function buildMessagesRetrieveQuery(
  client$: NovuCore,
  request: operations.MessagesControllerGetMessagesRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<MessagesRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyMessagesRetrieve({
      channel: request.channel,
      subscriberId: request.subscriberId,
      transactionId: request.transactionId,
      contextKeys: request.contextKeys,
      page: request.page,
      limit: request.limit,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function messagesRetrieveQueryFn(
      ctx,
    ): Promise<MessagesRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(messagesRetrieve(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyMessagesRetrieve(
  parameters: {
    channel?: components.ChannelTypeEnum | undefined;
    subscriberId?: string | undefined;
    transactionId?: Array<string> | undefined;
    contextKeys?: Array<string> | undefined;
    page?: number | undefined;
    limit?: number | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Messages", "retrieve", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useMessagesRetrieve(request: operations.MessagesControllerGetMessagesRequest,
  options?: QueryHookOptions<MessagesRetrieveQueryData>,)
 - useMessagesRetrieveSuspense(request: operations.MessagesControllerGetMessagesRequest,
  options?: SuspenseQueryHookOptions<MessagesRetrieveQueryData>,)
 - prefetchMessagesRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.MessagesControllerGetMessagesRequest,)
 - setMessagesRetrieveData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      channel?: components.ChannelTypeEnum | undefined;
      subscriberId?: string | undefined;
      transactionId?: Array<string> | undefined;
      contextKeys?: Array<string> | undefined;
      page?: number | undefined;
      limit?: number | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: MessagesRetrieveQueryData,)
 - invalidateMessagesRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      channel?: components.ChannelTypeEnum | undefined;
      subscriberId?: string | undefined;
      transactionId?: Array<string> | undefined;
      contextKeys?: Array<string> | undefined;
      page?: number | undefined;
      limit?: number | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllMessagesRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildMessagesRetrieveQuery(client$: NovuCore,
  request: operations.MessagesControllerGetMessagesRequest,
  options?: RequestOptions,)
 - messagesRetrieveQueryFn(ctx,)
 - queryKeyMessagesRetrieve(parameters: {
    channel?: components.ChannelTypeEnum | undefined;
    subscriberId?: string | undefined;
    transactionId?: Array<string> | undefined;
    contextKeys?: Array<string> | undefined;
    page?: number | undefined;
    limit?: number | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyMessagesRetrieve(...queryKeyBase);

  return client.setQueryData<MessagesRetrieveQueryData>(...)
Declaraciones 'export' encontradas:
- export  type
- export function useMessagesRetrieve
- export function useMessagesRetrieveSuspense
- export function prefetchMessagesRetrieve
- export function setMessagesRetrieveData
- export function invalidateMessagesRetrieve
- export function invalidateAllMessagesRetrieve
- export function buildMessagesRetrieveQuery
- export function queryKeyMessagesRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/notificationsList.ts
Tamaño: 6936 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { notificationsList } from "../funcs/notificationsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type NotificationsListQueryData =
  operations.NotificationsControllerListNotificationsResponse;

/**
 * List all events
 *
 * @remarks
 * List all notification events (triggered events) for the current environment.
 *     This API supports filtering by **channels**, **templates**, **emails**, **subscriberIds**, **transactionId**, **topicKey**.
 *     Checkout all available filters in the query section.
 *     This API returns event triggers, to list each channel notifications, check messages APIs.
 */
export function useNotificationsList(
  request: operations.NotificationsControllerListNotificationsRequest,
  options?: QueryHookOptions<NotificationsListQueryData>,
): UseQueryResult<NotificationsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildNotificationsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List all events
 *
 * @remarks
 * List all notification events (triggered events) for the current environment.
 *     This API supports filtering by **channels**, **templates**, **emails**, **subscriberIds**, **transactionId**, **topicKey**.
 *     Checkout all available filters in the query section.
 *     This API returns event triggers, to list each channel notifications, check messages APIs.
 */
export function useNotificationsListSuspense(
  request: operations.NotificationsControllerListNotificationsRequest,
  options?: SuspenseQueryHookOptions<NotificationsListQueryData>,
): UseSuspenseQueryResult<NotificationsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildNotificationsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchNotificationsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.NotificationsControllerListNotificationsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildNotificationsListQuery(
      client$,
      request,
    ),
  });
}

export function setNotificationsListData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      channels?: Array<components.ChannelTypeEnum> | undefined;
      templates?: Array<string> | undefined;
      emails?: Array<string> | undefined;
      search?: string | undefined;
      subscriberIds?: Array<string> | undefined;
      severity?: Array<string> | undefined;
      page?: number | undefined;
      limit?: number | undefined;
      transactionId?: string | undefined;
      topicKey?: string | undefined;
      contextKeys?: Array<string> | undefined;
      after?: string | undefined;
      before?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: NotificationsListQueryData,
): NotificationsListQueryData | undefined {
  const key = queryKeyNotificationsList(...queryKeyBase);

  return client.setQueryData<NotificationsListQueryData>(key, data);
}

export function invalidateNotificationsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      channels?: Array<components.ChannelTypeEnum> | undefined;
      templates?: Array<string> | undefined;
      emails?: Array<string> | undefined;
      search?: string | undefined;
      subscriberIds?: Array<string> | undefined;
      severity?: Array<string> | undefined;
      page?: number | undefined;
      limit?: number | undefined;
      transactionId?: string | undefined;
      topicKey?: string | undefined;
      contextKeys?: Array<string> | undefined;
      after?: string | undefined;
      before?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Notifications", "list", ...queryKeyBase],
  });
}

export function invalidateAllNotificationsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Notifications", "list"],
  });
}

export function buildNotificationsListQuery(
  client$: NovuCore,
  request: operations.NotificationsControllerListNotificationsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<NotificationsListQueryData>;
} {
  return {
    queryKey: queryKeyNotificationsList({
      channels: request.channels,
      templates: request.templates,
      emails: request.emails,
      search: request.search,
      subscriberIds: request.subscriberIds,
      severity: request.severity,
      page: request.page,
      limit: request.limit,
      transactionId: request.transactionId,
      topicKey: request.topicKey,
      contextKeys: request.contextKeys,
      after: request.after,
      before: request.before,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function notificationsListQueryFn(
      ctx,
    ): Promise<NotificationsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(notificationsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyNotificationsList(
  parameters: {
    channels?: Array<components.ChannelTypeEnum> | undefined;
    templates?: Array<string> | undefined;
    emails?: Array<string> | undefined;
    search?: string | undefined;
    subscriberIds?: Array<string> | undefined;
    severity?: Array<string> | undefined;
    page?: number | undefined;
    limit?: number | undefined;
    transactionId?: string | undefined;
    topicKey?: string | undefined;
    contextKeys?: Array<string> | undefined;
    after?: string | undefined;
    before?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Notifications", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useNotificationsList(request: operations.NotificationsControllerListNotificationsRequest,
  options?: QueryHookOptions<NotificationsListQueryData>,)
 - useNotificationsListSuspense(request: operations.NotificationsControllerListNotificationsRequest,
  options?: SuspenseQueryHookOptions<NotificationsListQueryData>,)
 - prefetchNotificationsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.NotificationsControllerListNotificationsRequest,)
 - setNotificationsListData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      channels?: Array<components.ChannelTypeEnum> | undefined;
      templates?: Array<string> | undefined;
      emails?: Array<string> | undefined;
      search?: string | undefined;
      subscriberIds?: Array<string> | undefined;
      severity?: Array<string> | undefined;
      page?: number | undefined;
      limit?: number | undefined;
      transactionId?: string | undefined;
      topicKey?: string | undefined;
      contextKeys?: Array<string> | undefined;
      after?: string | undefined;
      before?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: NotificationsListQueryData,)
 - invalidateNotificationsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      channels?: Array<components.ChannelTypeEnum> | undefined;
      templates?: Array<string> | undefined;
      emails?: Array<string> | undefined;
      search?: string | undefined;
      subscriberIds?: Array<string> | undefined;
      severity?: Array<string> | undefined;
      page?: number | undefined;
      limit?: number | undefined;
      transactionId?: string | undefined;
      topicKey?: string | undefined;
      contextKeys?: Array<string> | undefined;
      after?: string | undefined;
      before?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllNotificationsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildNotificationsListQuery(client$: NovuCore,
  request: operations.NotificationsControllerListNotificationsRequest,
  options?: RequestOptions,)
 - notificationsListQueryFn(ctx,)
 - queryKeyNotificationsList(parameters: {
    channels?: Array<components.ChannelTypeEnum> | undefined;
    templates?: Array<string> | undefined;
    emails?: Array<string> | undefined;
    search?: string | undefined;
    subscriberIds?: Array<string> | undefined;
    severity?: Array<string> | undefined;
    page?: number | undefined;
    limit?: number | undefined;
    transactionId?: string | undefined;
    topicKey?: string | undefined;
    contextKeys?: Array<string> | undefined;
    after?: string | undefined;
    before?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyNotificationsList(...queryKeyBase);

  return client.setQueryData<NotificationsListQueryData...)
Declaraciones 'export' encontradas:
- export  type
- export function useNotificationsList
- export function useNotificationsListSuspense
- export function prefetchNotificationsList
- export function setNotificationsListData
- export function invalidateNotificationsList
- export function invalidateAllNotificationsList
- export function buildNotificationsListQuery
- export function queryKeyNotificationsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/notificationsRetrieve.ts
Tamaño: 4893 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { notificationsRetrieve } from "../funcs/notificationsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type NotificationsRetrieveQueryData =
  operations.NotificationsControllerGetNotificationResponse;

/**
 * Retrieve an event
 *
 * @remarks
 * Retrieve an event by its unique key identifier **notificationId**.
 *     Here **notificationId** is of mongodbId type.
 *     This API returns the event details - execution logs, status, actual notification (message) generated by each workflow step.
 */
export function useNotificationsRetrieve(
  notificationId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<NotificationsRetrieveQueryData>,
): UseQueryResult<NotificationsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildNotificationsRetrieveQuery(
      client,
      notificationId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve an event
 *
 * @remarks
 * Retrieve an event by its unique key identifier **notificationId**.
 *     Here **notificationId** is of mongodbId type.
 *     This API returns the event details - execution logs, status, actual notification (message) generated by each workflow step.
 */
export function useNotificationsRetrieveSuspense(
  notificationId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<NotificationsRetrieveQueryData>,
): UseSuspenseQueryResult<NotificationsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildNotificationsRetrieveQuery(
      client,
      notificationId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchNotificationsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  notificationId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildNotificationsRetrieveQuery(
      client$,
      notificationId,
      idempotencyKey,
    ),
  });
}

export function setNotificationsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    notificationId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: NotificationsRetrieveQueryData,
): NotificationsRetrieveQueryData | undefined {
  const key = queryKeyNotificationsRetrieve(...queryKeyBase);

  return client.setQueryData<NotificationsRetrieveQueryData>(key, data);
}

export function invalidateNotificationsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      notificationId: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Notifications", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllNotificationsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Notifications", "retrieve"],
  });
}

export function buildNotificationsRetrieveQuery(
  client$: NovuCore,
  notificationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<NotificationsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyNotificationsRetrieve(notificationId, { idempotencyKey }),
    queryFn: async function notificationsRetrieveQueryFn(
      ctx,
    ): Promise<NotificationsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(notificationsRetrieve(
        client$,
        notificationId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyNotificationsRetrieve(
  notificationId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Notifications", "retrieve", notificationId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useNotificationsRetrieve(notificationId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<NotificationsRetrieveQueryData>,)
 - useNotificationsRetrieveSuspense(notificationId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<NotificationsRetrieveQueryData>,)
 - prefetchNotificationsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  notificationId: string,
  idempotencyKey?: string | undefined,)
 - setNotificationsRetrieveData(client: QueryClient,
  queryKeyBase: [
    notificationId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: NotificationsRetrieveQueryData,)
 - invalidateNotificationsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      notificationId: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllNotificationsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildNotificationsRetrieveQuery(client$: NovuCore,
  notificationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - notificationsRetrieveQueryFn(ctx,)
 - queryKeyNotificationsRetrieve(notificationId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyNotificationsRetrieve(...queryKeyBase);

  return client.setQueryData<NotificationsRetrieveQ...)
Declaraciones 'export' encontradas:
- export  type
- export function useNotificationsRetrieve
- export function useNotificationsRetrieveSuspense
- export function prefetchNotificationsRetrieve
- export function setNotificationsRetrieveData
- export function invalidateNotificationsRetrieve
- export function invalidateAllNotificationsRetrieve
- export function buildNotificationsRetrieveQuery
- export function queryKeyNotificationsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersCreate.ts
Tamaño: 2769 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersCreate } from "../funcs/subscribersCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersCreateMutationVariables = {
  createSubscriberRequestDto: components.CreateSubscriberRequestDto;
  failIfExists?: boolean | undefined;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersCreateMutationData =
  operations.SubscribersControllerCreateSubscriberResponse;

/**
 * Create a subscriber
 *
 * @remarks
 * Create a subscriber with the subscriber attributes.
 *       **subscriberId** is a required field, rest other fields are optional, if the subscriber already exists, it will be updated
 */
export function useSubscribersCreateMutation(
  options?: MutationHookOptions<
    SubscribersCreateMutationData,
    Error,
    SubscribersCreateMutationVariables
  >,
): UseMutationResult<
  SubscribersCreateMutationData,
  Error,
  SubscribersCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersCreate(): MutationKey {
  return ["@novu/api", "Subscribers", "create"];
}

export function buildSubscribersCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersCreateMutationVariables,
  ) => Promise<SubscribersCreateMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersCreate(),
    mutationFn: function subscribersCreateMutationFn({
      createSubscriberRequestDto,
      failIfExists,
      idempotencyKey,
      options,
    }): Promise<SubscribersCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersCreate(
        client$,
        createSubscriberRequestDto,
        failIfExists,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersCreateMutation(options?: MutationHookOptions<
    SubscribersCreateMutationData,
    Error,
    SubscribersCreateMutationVariables
  >,)
 - mutationKeySubscribersCreate()
 - buildSubscribersCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersCreateMutationFn({
      createSubscriberRequestDto,
      failIfExists,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersCreateMutation(client, options),
   ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersCreateMutation
- export function mutationKeySubscribersCreate
- export function buildSubscribersCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersCreateBulk.ts
Tamaño: 2710 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersCreateBulk } from "../funcs/subscribersCreateBulk.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersCreateBulkMutationVariables = {
  bulkSubscriberCreateDto: components.BulkSubscriberCreateDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersCreateBulkMutationData =
  operations.SubscribersV1ControllerBulkCreateSubscribersResponse;

/**
 * Bulk create subscribers
 *
 * @remarks
 *
 *       Using this endpoint multiple subscribers can be created at once. The bulk API is limited to 500 subscribers per request.
 */
export function useSubscribersCreateBulkMutation(
  options?: MutationHookOptions<
    SubscribersCreateBulkMutationData,
    Error,
    SubscribersCreateBulkMutationVariables
  >,
): UseMutationResult<
  SubscribersCreateBulkMutationData,
  Error,
  SubscribersCreateBulkMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersCreateBulkMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersCreateBulk(): MutationKey {
  return ["@novu/api", "Subscribers", "createBulk"];
}

export function buildSubscribersCreateBulkMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersCreateBulkMutationVariables,
  ) => Promise<SubscribersCreateBulkMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersCreateBulk(),
    mutationFn: function subscribersCreateBulkMutationFn({
      bulkSubscriberCreateDto,
      idempotencyKey,
      options,
    }): Promise<SubscribersCreateBulkMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersCreateBulk(
        client$,
        bulkSubscriberCreateDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersCreateBulkMutation(options?: MutationHookOptions<
    SubscribersCreateBulkMutationData,
    Error,
    SubscribersCreateBulkMutationVariables
  >,)
 - mutationKeySubscribersCreateBulk()
 - buildSubscribersCreateBulkMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersCreateBulkMutationFn({
      bulkSubscriberCreateDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersCreateBulkMutation(client, options),...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersCreateBulkMutation
- export function mutationKeySubscribersCreateBulk
- export function buildSubscribersCreateBulkMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersCredentialsAppend.ts
Tamaño: 2995 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersCredentialsAppend } from "../funcs/subscribersCredentialsAppend.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersCredentialsAppendMutationVariables = {
  updateSubscriberChannelRequestDto:
    components.UpdateSubscriberChannelRequestDto;
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersCredentialsAppendMutationData =
  operations.SubscribersV1ControllerModifySubscriberChannelResponse;

/**
 * Update provider credentials
 *
 * @remarks
 * Update credentials for a provider such as **slack** and **FCM**.
 *       **providerId** is required field. This API creates the **deviceTokens** or replaces the existing ones.
 */
export function useSubscribersCredentialsAppendMutation(
  options?: MutationHookOptions<
    SubscribersCredentialsAppendMutationData,
    Error,
    SubscribersCredentialsAppendMutationVariables
  >,
): UseMutationResult<
  SubscribersCredentialsAppendMutationData,
  Error,
  SubscribersCredentialsAppendMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersCredentialsAppendMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersCredentialsAppend(): MutationKey {
  return ["@novu/api", "Credentials", "append"];
}

export function buildSubscribersCredentialsAppendMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersCredentialsAppendMutationVariables,
  ) => Promise<SubscribersCredentialsAppendMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersCredentialsAppend(),
    mutationFn: function subscribersCredentialsAppendMutationFn({
      updateSubscriberChannelRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersCredentialsAppendMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersCredentialsAppend(
        client$,
        updateSubscriberChannelRequestDto,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersCredentialsAppendMutation(options?: MutationHookOptions<
    SubscribersCredentialsAppendMutationData,
    Error,
    SubscribersCredentialsAppendMutationVariables
  >,)
 - mutationKeySubscribersCredentialsAppend()
 - buildSubscribersCredentialsAppendMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersCredentialsAppendMutationFn({
      updateSubscriberChannelRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersCredentialsAppendMutation(client, op...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersCredentialsAppendMutation
- export function mutationKeySubscribersCredentialsAppend
- export function buildSubscribersCredentialsAppendMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersCredentialsDelete.ts
Tamaño: 2877 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersCredentialsDelete } from "../funcs/subscribersCredentialsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersCredentialsDeleteMutationVariables = {
  subscriberId: string;
  providerId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersCredentialsDeleteMutationData =
  | operations.SubscribersV1ControllerDeleteSubscriberCredentialsResponse
  | undefined;

/**
 * Delete provider credentials
 *
 * @remarks
 * Delete subscriber credentials for a provider such as **slack** and **FCM** by **providerId**.
 *     This action is irreversible and will remove the credentials for the provider for particular **subscriberId**.
 */
export function useSubscribersCredentialsDeleteMutation(
  options?: MutationHookOptions<
    SubscribersCredentialsDeleteMutationData,
    Error,
    SubscribersCredentialsDeleteMutationVariables
  >,
): UseMutationResult<
  SubscribersCredentialsDeleteMutationData,
  Error,
  SubscribersCredentialsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersCredentialsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersCredentialsDelete(): MutationKey {
  return ["@novu/api", "Credentials", "delete"];
}

export function buildSubscribersCredentialsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersCredentialsDeleteMutationVariables,
  ) => Promise<SubscribersCredentialsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersCredentialsDelete(),
    mutationFn: function subscribersCredentialsDeleteMutationFn({
      subscriberId,
      providerId,
      idempotencyKey,
      options,
    }): Promise<SubscribersCredentialsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersCredentialsDelete(
        client$,
        subscriberId,
        providerId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersCredentialsDeleteMutation(options?: MutationHookOptions<
    SubscribersCredentialsDeleteMutationData,
    Error,
    SubscribersCredentialsDeleteMutationVariables
  >,)
 - mutationKeySubscribersCredentialsDelete()
 - buildSubscribersCredentialsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersCredentialsDeleteMutationFn({
      subscriberId,
      providerId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersCredentialsDeleteMutation(client, op...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersCredentialsDeleteMutation
- export function mutationKeySubscribersCredentialsDelete
- export function buildSubscribersCredentialsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersCredentialsUpdate.ts
Tamaño: 2993 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersCredentialsUpdate } from "../funcs/subscribersCredentialsUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersCredentialsUpdateMutationVariables = {
  updateSubscriberChannelRequestDto:
    components.UpdateSubscriberChannelRequestDto;
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersCredentialsUpdateMutationData =
  operations.SubscribersV1ControllerUpdateSubscriberChannelResponse;

/**
 * Upsert provider credentials
 *
 * @remarks
 * Upsert credentials for a provider such as slack and push tokens.
 *       **providerId** is required field. This API creates **deviceTokens** or appends to the existing ones.
 */
export function useSubscribersCredentialsUpdateMutation(
  options?: MutationHookOptions<
    SubscribersCredentialsUpdateMutationData,
    Error,
    SubscribersCredentialsUpdateMutationVariables
  >,
): UseMutationResult<
  SubscribersCredentialsUpdateMutationData,
  Error,
  SubscribersCredentialsUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersCredentialsUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersCredentialsUpdate(): MutationKey {
  return ["@novu/api", "Credentials", "update"];
}

export function buildSubscribersCredentialsUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersCredentialsUpdateMutationVariables,
  ) => Promise<SubscribersCredentialsUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersCredentialsUpdate(),
    mutationFn: function subscribersCredentialsUpdateMutationFn({
      updateSubscriberChannelRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersCredentialsUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersCredentialsUpdate(
        client$,
        updateSubscriberChannelRequestDto,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersCredentialsUpdateMutation(options?: MutationHookOptions<
    SubscribersCredentialsUpdateMutationData,
    Error,
    SubscribersCredentialsUpdateMutationVariables
  >,)
 - mutationKeySubscribersCredentialsUpdate()
 - buildSubscribersCredentialsUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersCredentialsUpdateMutationFn({
      updateSubscriberChannelRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersCredentialsUpdateMutation(client, op...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersCredentialsUpdateMutation
- export function mutationKeySubscribersCredentialsUpdate
- export function buildSubscribersCredentialsUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersDelete.ts
Tamaño: 2539 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersDelete } from "../funcs/subscribersDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersDeleteMutationVariables = {
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersDeleteMutationData =
  operations.SubscribersControllerRemoveSubscriberResponse;

/**
 * Delete a subscriber
 *
 * @remarks
 * Deletes a subscriber entity from the Novu platform along with associated messages, preferences, and topic subscriptions.
 *       **subscriberId** is a required field.
 */
export function useSubscribersDeleteMutation(
  options?: MutationHookOptions<
    SubscribersDeleteMutationData,
    Error,
    SubscribersDeleteMutationVariables
  >,
): UseMutationResult<
  SubscribersDeleteMutationData,
  Error,
  SubscribersDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersDelete(): MutationKey {
  return ["@novu/api", "Subscribers", "delete"];
}

export function buildSubscribersDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersDeleteMutationVariables,
  ) => Promise<SubscribersDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersDelete(),
    mutationFn: function subscribersDeleteMutationFn({
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersDelete(
        client$,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersDeleteMutation(options?: MutationHookOptions<
    SubscribersDeleteMutationData,
    Error,
    SubscribersDeleteMutationVariables
  >,)
 - mutationKeySubscribersDelete()
 - buildSubscribersDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersDeleteMutationFn({
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersDeleteMutation(client, options),
   ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersDeleteMutation
- export function mutationKeySubscribersDelete
- export function buildSubscribersDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersMessagesMarkAll.ts
Tamaño: 2862 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersMessagesMarkAll } from "../funcs/subscribersMessagesMarkAll.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersMessagesMarkAllMutationVariables = {
  markAllMessageAsRequestDto: components.MarkAllMessageAsRequestDto;
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersMessagesMarkAllMutationData =
  operations.SubscribersV1ControllerMarkAllUnreadAsReadResponse;

/**
 * Update all notifications state
 *
 * @remarks
 * Update all subscriber in-app (inbox) notifications state such as read, unread, seen or unseen by **subscriberId**.
 */
export function useSubscribersMessagesMarkAllMutation(
  options?: MutationHookOptions<
    SubscribersMessagesMarkAllMutationData,
    Error,
    SubscribersMessagesMarkAllMutationVariables
  >,
): UseMutationResult<
  SubscribersMessagesMarkAllMutationData,
  Error,
  SubscribersMessagesMarkAllMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersMessagesMarkAllMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersMessagesMarkAll(): MutationKey {
  return ["@novu/api", "Messages", "markAll"];
}

export function buildSubscribersMessagesMarkAllMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersMessagesMarkAllMutationVariables,
  ) => Promise<SubscribersMessagesMarkAllMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersMessagesMarkAll(),
    mutationFn: function subscribersMessagesMarkAllMutationFn({
      markAllMessageAsRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersMessagesMarkAllMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersMessagesMarkAll(
        client$,
        markAllMessageAsRequestDto,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersMessagesMarkAllMutation(options?: MutationHookOptions<
    SubscribersMessagesMarkAllMutationData,
    Error,
    SubscribersMessagesMarkAllMutationVariables
  >,)
 - mutationKeySubscribersMessagesMarkAll()
 - buildSubscribersMessagesMarkAllMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersMessagesMarkAllMutationFn({
      markAllMessageAsRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersMessagesMarkAllMutation(client, opti...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersMessagesMarkAllMutation
- export function mutationKeySubscribersMessagesMarkAll
- export function buildSubscribersMessagesMarkAllMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersMessagesMarkAllAs.ts
Tamaño: 2947 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersMessagesMarkAllAs } from "../funcs/subscribersMessagesMarkAllAs.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersMessagesMarkAllAsMutationVariables = {
  messageMarkAsRequestDto: components.MessageMarkAsRequestDto;
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersMessagesMarkAllAsMutationData =
  operations.SubscribersV1ControllerMarkMessagesAsResponse;

/**
 * Update notifications state
 *
 * @remarks
 * Update subscriber's multiple in-app (inbox) notifications state such as seen, read, unseen or unread by **subscriberId**.
 *       **messageId** is of type mongodbId of notifications
 */
export function useSubscribersMessagesMarkAllAsMutation(
  options?: MutationHookOptions<
    SubscribersMessagesMarkAllAsMutationData,
    Error,
    SubscribersMessagesMarkAllAsMutationVariables
  >,
): UseMutationResult<
  SubscribersMessagesMarkAllAsMutationData,
  Error,
  SubscribersMessagesMarkAllAsMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersMessagesMarkAllAsMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersMessagesMarkAllAs(): MutationKey {
  return ["@novu/api", "Messages", "markAllAs"];
}

export function buildSubscribersMessagesMarkAllAsMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersMessagesMarkAllAsMutationVariables,
  ) => Promise<SubscribersMessagesMarkAllAsMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersMessagesMarkAllAs(),
    mutationFn: function subscribersMessagesMarkAllAsMutationFn({
      messageMarkAsRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersMessagesMarkAllAsMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersMessagesMarkAllAs(
        client$,
        messageMarkAsRequestDto,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersMessagesMarkAllAsMutation(options?: MutationHookOptions<
    SubscribersMessagesMarkAllAsMutationData,
    Error,
    SubscribersMessagesMarkAllAsMutationVariables
  >,)
 - mutationKeySubscribersMessagesMarkAllAs()
 - buildSubscribersMessagesMarkAllAsMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersMessagesMarkAllAsMutationFn({
      messageMarkAsRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersMessagesMarkAllAsMutation(client, op...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersMessagesMarkAllAsMutation
- export function mutationKeySubscribersMessagesMarkAllAs
- export function buildSubscribersMessagesMarkAllAsMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersMessagesUpdateAsSeen.ts
Tamaño: 2772 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersMessagesUpdateAsSeen } from "../funcs/subscribersMessagesUpdateAsSeen.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersMessagesUpdateAsSeenMutationVariables = {
  request: operations.SubscribersV1ControllerMarkActionAsSeenRequest;
  options?: RequestOptions;
};

export type SubscribersMessagesUpdateAsSeenMutationData =
  operations.SubscribersV1ControllerMarkActionAsSeenResponse;

/**
 * Update notification action status
 *
 * @remarks
 * Update in-app (inbox) notification's action status by its unique key identifier **messageId** and type field **type**.
 *       **type** field can be **primary** or **secondary**
 */
export function useSubscribersMessagesUpdateAsSeenMutation(
  options?: MutationHookOptions<
    SubscribersMessagesUpdateAsSeenMutationData,
    Error,
    SubscribersMessagesUpdateAsSeenMutationVariables
  >,
): UseMutationResult<
  SubscribersMessagesUpdateAsSeenMutationData,
  Error,
  SubscribersMessagesUpdateAsSeenMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersMessagesUpdateAsSeenMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersMessagesUpdateAsSeen(): MutationKey {
  return ["@novu/api", "Messages", "updateAsSeen"];
}

export function buildSubscribersMessagesUpdateAsSeenMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersMessagesUpdateAsSeenMutationVariables,
  ) => Promise<SubscribersMessagesUpdateAsSeenMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersMessagesUpdateAsSeen(),
    mutationFn: function subscribersMessagesUpdateAsSeenMutationFn({
      request,
      options,
    }): Promise<SubscribersMessagesUpdateAsSeenMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersMessagesUpdateAsSeen(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersMessagesUpdateAsSeenMutation(options?: MutationHookOptions<
    SubscribersMessagesUpdateAsSeenMutationData,
    Error,
    SubscribersMessagesUpdateAsSeenMutationVariables
  >,)
 - mutationKeySubscribersMessagesUpdateAsSeen()
 - buildSubscribersMessagesUpdateAsSeenMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersMessagesUpdateAsSeenMutationFn({
      request,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersMessagesUpdateAsSeenMutation(client,...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersMessagesUpdateAsSeenMutation
- export function mutationKeySubscribersMessagesUpdateAsSeen
- export function buildSubscribersMessagesUpdateAsSeenMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersNotificationsFeed.ts
Tamaño: 5432 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersNotificationsFeed } from "../funcs/subscribersNotificationsFeed.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type SubscribersNotificationsFeedQueryData =
  operations.SubscribersV1ControllerGetNotificationsFeedResponse;

/**
 * Retrieve subscriber notifications
 *
 * @remarks
 * Retrieve subscriber in-app (inbox) notifications by its unique key identifier **subscriberId**.
 */
export function useSubscribersNotificationsFeed(
  request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
  options?: QueryHookOptions<SubscribersNotificationsFeedQueryData>,
): UseQueryResult<SubscribersNotificationsFeedQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildSubscribersNotificationsFeedQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve subscriber notifications
 *
 * @remarks
 * Retrieve subscriber in-app (inbox) notifications by its unique key identifier **subscriberId**.
 */
export function useSubscribersNotificationsFeedSuspense(
  request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
  options?: SuspenseQueryHookOptions<SubscribersNotificationsFeedQueryData>,
): UseSuspenseQueryResult<SubscribersNotificationsFeedQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildSubscribersNotificationsFeedQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchSubscribersNotificationsFeed(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildSubscribersNotificationsFeedQuery(
      client$,
      request,
    ),
  });
}

export function setSubscribersNotificationsFeedData(
  client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: {
      page?: number | undefined;
      limit?: number | undefined;
      read?: boolean | undefined;
      seen?: boolean | undefined;
      payload?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersNotificationsFeedQueryData,
): SubscribersNotificationsFeedQueryData | undefined {
  const key = queryKeySubscribersNotificationsFeed(...queryKeyBase);

  return client.setQueryData<SubscribersNotificationsFeedQueryData>(key, data);
}

export function invalidateSubscribersNotificationsFeed(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      subscriberId: string,
      parameters: {
        page?: number | undefined;
        limit?: number | undefined;
        read?: boolean | undefined;
        seen?: boolean | undefined;
        payload?: string | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Notifications", "feed", ...queryKeyBase],
  });
}

export function invalidateAllSubscribersNotificationsFeed(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Notifications", "feed"],
  });
}

export function buildSubscribersNotificationsFeedQuery(
  client$: NovuCore,
  request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<SubscribersNotificationsFeedQueryData>;
} {
  return {
    queryKey: queryKeySubscribersNotificationsFeed(request.subscriberId, {
      page: request.page,
      limit: request.limit,
      read: request.read,
      seen: request.seen,
      payload: request.payload,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function subscribersNotificationsFeedQueryFn(
      ctx,
    ): Promise<SubscribersNotificationsFeedQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(subscribersNotificationsFeed(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeySubscribersNotificationsFeed(
  subscriberId: string,
  parameters: {
    page?: number | undefined;
    limit?: number | undefined;
    read?: boolean | undefined;
    seen?: boolean | undefined;
    payload?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Notifications", "feed", subscriberId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersNotificationsFeed(request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
  options?: QueryHookOptions<SubscribersNotificationsFeedQueryData>,)
 - useSubscribersNotificationsFeedSuspense(request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
  options?: SuspenseQueryHookOptions<SubscribersNotificationsFeedQueryData>,)
 - prefetchSubscribersNotificationsFeed(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,)
 - setSubscribersNotificationsFeedData(client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: {
      page?: number | undefined;
      limit?: number | undefined;
      read?: boolean | undefined;
      seen?: boolean | undefined;
      payload?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersNotificationsFeedQueryData,)
 - invalidateSubscribersNotificationsFeed(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      subscriberId: string,
      parameters: {
        page?: number | undefined;
        limit?: number | undefined;
        read?: boolean | undefined;
        seen?: boolean | undefined;
        payload?: string | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllSubscribersNotificationsFeed(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildSubscribersNotificationsFeedQuery(client$: NovuCore,
  request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
  options?: RequestOptions,)
 - subscribersNotificationsFeedQueryFn(ctx,)
 - queryKeySubscribersNotificationsFeed(subscriberId: string,
  parameters: {
    page?: number | undefined;
    limit?: number | undefined;
    read?: boolean | undefined;
    seen?: boolean | undefined;
    payload?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeySubscribersNotificationsFeed(...queryKeyBase);

  return client.setQueryData<SubscribersNoti...)
Declaraciones 'export' encontradas:
- export  type
- export function useSubscribersNotificationsFeed
- export function useSubscribersNotificationsFeedSuspense
- export function prefetchSubscribersNotificationsFeed
- export function setSubscribersNotificationsFeedData
- export function invalidateSubscribersNotificationsFeed
- export function invalidateAllSubscribersNotificationsFeed
- export function buildSubscribersNotificationsFeedQuery
- export function queryKeySubscribersNotificationsFeed

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersNotificationsUnseenCount.ts
Tamaño: 5334 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersNotificationsUnseenCount } from "../funcs/subscribersNotificationsUnseenCount.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type SubscribersNotificationsUnseenCountQueryData =
  operations.SubscribersV1ControllerGetUnseenCountResponse;

/**
 * Retrieve unseen notifications count
 *
 * @remarks
 * Retrieve unseen in-app (inbox) notifications count for a subscriber by its unique key identifier **subscriberId**.
 */
export function useSubscribersNotificationsUnseenCount(
  request: operations.SubscribersV1ControllerGetUnseenCountRequest,
  options?: QueryHookOptions<SubscribersNotificationsUnseenCountQueryData>,
): UseQueryResult<SubscribersNotificationsUnseenCountQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildSubscribersNotificationsUnseenCountQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve unseen notifications count
 *
 * @remarks
 * Retrieve unseen in-app (inbox) notifications count for a subscriber by its unique key identifier **subscriberId**.
 */
export function useSubscribersNotificationsUnseenCountSuspense(
  request: operations.SubscribersV1ControllerGetUnseenCountRequest,
  options?: SuspenseQueryHookOptions<
    SubscribersNotificationsUnseenCountQueryData
  >,
): UseSuspenseQueryResult<SubscribersNotificationsUnseenCountQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildSubscribersNotificationsUnseenCountQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchSubscribersNotificationsUnseenCount(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.SubscribersV1ControllerGetUnseenCountRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildSubscribersNotificationsUnseenCountQuery(
      client$,
      request,
    ),
  });
}

export function setSubscribersNotificationsUnseenCountData(
  client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: {
      seen?: boolean | undefined;
      limit?: number | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersNotificationsUnseenCountQueryData,
): SubscribersNotificationsUnseenCountQueryData | undefined {
  const key = queryKeySubscribersNotificationsUnseenCount(...queryKeyBase);

  return client.setQueryData<SubscribersNotificationsUnseenCountQueryData>(
    key,
    data,
  );
}

export function invalidateSubscribersNotificationsUnseenCount(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      subscriberId: string,
      parameters: {
        seen?: boolean | undefined;
        limit?: number | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Notifications", "unseenCount", ...queryKeyBase],
  });
}

export function invalidateAllSubscribersNotificationsUnseenCount(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Notifications", "unseenCount"],
  });
}

export function buildSubscribersNotificationsUnseenCountQuery(
  client$: NovuCore,
  request: operations.SubscribersV1ControllerGetUnseenCountRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<SubscribersNotificationsUnseenCountQueryData>;
} {
  return {
    queryKey: queryKeySubscribersNotificationsUnseenCount(
      request.subscriberId,
      {
        seen: request.seen,
        limit: request.limit,
        idempotencyKey: request.idempotencyKey,
      },
    ),
    queryFn: async function subscribersNotificationsUnseenCountQueryFn(
      ctx,
    ): Promise<SubscribersNotificationsUnseenCountQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(subscribersNotificationsUnseenCount(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeySubscribersNotificationsUnseenCount(
  subscriberId: string,
  parameters: {
    seen?: boolean | undefined;
    limit?: number | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return [
    "@novu/api",
    "Notifications",
    "unseenCount",
    subscriberId,
    parameters,
  ];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersNotificationsUnseenCount(request: operations.SubscribersV1ControllerGetUnseenCountRequest,
  options?: QueryHookOptions<SubscribersNotificationsUnseenCountQueryData>,)
 - useSubscribersNotificationsUnseenCountSuspense(request: operations.SubscribersV1ControllerGetUnseenCountRequest,
  options?: SuspenseQueryHookOptions<
    SubscribersNotificationsUnseenCountQueryData
  >,)
 - prefetchSubscribersNotificationsUnseenCount(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.SubscribersV1ControllerGetUnseenCountRequest,)
 - setSubscribersNotificationsUnseenCountData(client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: {
      seen?: boolean | undefined;
      limit?: number | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersNotificationsUnseenCountQueryData,)
 - invalidateSubscribersNotificationsUnseenCount(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      subscriberId: string,
      parameters: {
        seen?: boolean | undefined;
        limit?: number | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllSubscribersNotificationsUnseenCount(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildSubscribersNotificationsUnseenCountQuery(client$: NovuCore,
  request: operations.SubscribersV1ControllerGetUnseenCountRequest,
  options?: RequestOptions,)
 - subscribersNotificationsUnseenCountQueryFn(ctx,)
 - queryKeySubscribersNotificationsUnseenCount(subscriberId: string,
  parameters: {
    seen?: boolean | undefined;
    limit?: number | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeySubscribersNotificationsUnseenCount(...queryKeyBase);

  return client.setQueryData<Subscrib...)
Declaraciones 'export' encontradas:
- export  type
- export function useSubscribersNotificationsUnseenCount
- export function useSubscribersNotificationsUnseenCountSuspense
- export function prefetchSubscribersNotificationsUnseenCount
- export function setSubscribersNotificationsUnseenCountData
- export function invalidateSubscribersNotificationsUnseenCount
- export function invalidateAllSubscribersNotificationsUnseenCount
- export function buildSubscribersNotificationsUnseenCountQuery
- export function queryKeySubscribersNotificationsUnseenCount

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersPatch.ts
Tamaño: 2690 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersPatch } from "../funcs/subscribersPatch.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersPatchMutationVariables = {
  patchSubscriberRequestDto: components.PatchSubscriberRequestDto;
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersPatchMutationData =
  operations.SubscribersControllerPatchSubscriberResponse;

/**
 * Update a subscriber
 *
 * @remarks
 * Update a subscriber by its unique key identifier **subscriberId**.
 *     **subscriberId** is a required field, rest other fields are optional
 */
export function useSubscribersPatchMutation(
  options?: MutationHookOptions<
    SubscribersPatchMutationData,
    Error,
    SubscribersPatchMutationVariables
  >,
): UseMutationResult<
  SubscribersPatchMutationData,
  Error,
  SubscribersPatchMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersPatchMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersPatch(): MutationKey {
  return ["@novu/api", "Subscribers", "patch"];
}

export function buildSubscribersPatchMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersPatchMutationVariables,
  ) => Promise<SubscribersPatchMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersPatch(),
    mutationFn: function subscribersPatchMutationFn({
      patchSubscriberRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersPatchMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersPatch(
        client$,
        patchSubscriberRequestDto,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersPatchMutation(options?: MutationHookOptions<
    SubscribersPatchMutationData,
    Error,
    SubscribersPatchMutationVariables
  >,)
 - mutationKeySubscribersPatch()
 - buildSubscribersPatchMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersPatchMutationFn({
      patchSubscriberRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersPatchMutation(client, options),
    ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersPatchMutation
- export function mutationKeySubscribersPatch
- export function buildSubscribersPatchMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersPreferencesBulkUpdate.ts
Tamaño: 3076 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersPreferencesBulkUpdate } from "../funcs/subscribersPreferencesBulkUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersPreferencesBulkUpdateMutationVariables = {
  bulkUpdateSubscriberPreferencesDto:
    components.BulkUpdateSubscriberPreferencesDto;
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersPreferencesBulkUpdateMutationData =
  operations.SubscribersControllerBulkUpdateSubscriberPreferencesResponse;

/**
 * Bulk update subscriber preferences
 *
 * @remarks
 * Bulk update subscriber preferences by its unique key identifier **subscriberId**.
 *     This API allows updating multiple workflow preferences in a single request.
 */
export function useSubscribersPreferencesBulkUpdateMutation(
  options?: MutationHookOptions<
    SubscribersPreferencesBulkUpdateMutationData,
    Error,
    SubscribersPreferencesBulkUpdateMutationVariables
  >,
): UseMutationResult<
  SubscribersPreferencesBulkUpdateMutationData,
  Error,
  SubscribersPreferencesBulkUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersPreferencesBulkUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersPreferencesBulkUpdate(): MutationKey {
  return ["@novu/api", "Preferences", "bulkUpdate"];
}

export function buildSubscribersPreferencesBulkUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersPreferencesBulkUpdateMutationVariables,
  ) => Promise<SubscribersPreferencesBulkUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersPreferencesBulkUpdate(),
    mutationFn: function subscribersPreferencesBulkUpdateMutationFn({
      bulkUpdateSubscriberPreferencesDto,
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersPreferencesBulkUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersPreferencesBulkUpdate(
        client$,
        bulkUpdateSubscriberPreferencesDto,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersPreferencesBulkUpdateMutation(options?: MutationHookOptions<
    SubscribersPreferencesBulkUpdateMutationData,
    Error,
    SubscribersPreferencesBulkUpdateMutationVariables
  >,)
 - mutationKeySubscribersPreferencesBulkUpdate()
 - buildSubscribersPreferencesBulkUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersPreferencesBulkUpdateMutationFn({
      bulkUpdateSubscriberPreferencesDto,
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersPreferencesBulkUpdateMutation(client...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersPreferencesBulkUpdateMutation
- export function mutationKeySubscribersPreferencesBulkUpdate
- export function buildSubscribersPreferencesBulkUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersPreferencesList.ts
Tamaño: 5400 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersPreferencesList } from "../funcs/subscribersPreferencesList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type SubscribersPreferencesListQueryData =
  operations.SubscribersControllerGetSubscriberPreferencesResponse;

/**
 * Retrieve subscriber preferences
 *
 * @remarks
 * Retrieve subscriber channel preferences by its unique key identifier **subscriberId**.
 *     This API returns all five channels preferences for all workflows and global preferences.
 */
export function useSubscribersPreferencesList(
  subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<SubscribersPreferencesListQueryData>,
): UseQueryResult<SubscribersPreferencesListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildSubscribersPreferencesListQuery(
      client,
      subscriberId,
      criticality,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve subscriber preferences
 *
 * @remarks
 * Retrieve subscriber channel preferences by its unique key identifier **subscriberId**.
 *     This API returns all five channels preferences for all workflows and global preferences.
 */
export function useSubscribersPreferencesListSuspense(
  subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<SubscribersPreferencesListQueryData>,
): UseSuspenseQueryResult<SubscribersPreferencesListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildSubscribersPreferencesListQuery(
      client,
      subscriberId,
      criticality,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchSubscribersPreferencesList(
  queryClient: QueryClient,
  client$: NovuCore,
  subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildSubscribersPreferencesListQuery(
      client$,
      subscriberId,
      criticality,
      idempotencyKey,
    ),
  });
}

export function setSubscribersPreferencesListData(
  client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: {
      criticality?: operations.Criticality | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersPreferencesListQueryData,
): SubscribersPreferencesListQueryData | undefined {
  const key = queryKeySubscribersPreferencesList(...queryKeyBase);

  return client.setQueryData<SubscribersPreferencesListQueryData>(key, data);
}

export function invalidateSubscribersPreferencesList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      subscriberId: string,
      parameters: {
        criticality?: operations.Criticality | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Preferences", "list", ...queryKeyBase],
  });
}

export function invalidateAllSubscribersPreferencesList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Preferences", "list"],
  });
}

export function buildSubscribersPreferencesListQuery(
  client$: NovuCore,
  subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<SubscribersPreferencesListQueryData>;
} {
  return {
    queryKey: queryKeySubscribersPreferencesList(subscriberId, {
      criticality,
      idempotencyKey,
    }),
    queryFn: async function subscribersPreferencesListQueryFn(
      ctx,
    ): Promise<SubscribersPreferencesListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(subscribersPreferencesList(
        client$,
        subscriberId,
        criticality,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeySubscribersPreferencesList(
  subscriberId: string,
  parameters: {
    criticality?: operations.Criticality | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Preferences", "list", subscriberId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersPreferencesList(subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<SubscribersPreferencesListQueryData>,)
 - useSubscribersPreferencesListSuspense(subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<SubscribersPreferencesListQueryData>,)
 - prefetchSubscribersPreferencesList(queryClient: QueryClient,
  client$: NovuCore,
  subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,)
 - setSubscribersPreferencesListData(client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: {
      criticality?: operations.Criticality | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersPreferencesListQueryData,)
 - invalidateSubscribersPreferencesList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      subscriberId: string,
      parameters: {
        criticality?: operations.Criticality | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllSubscribersPreferencesList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildSubscribersPreferencesListQuery(client$: NovuCore,
  subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - subscribersPreferencesListQueryFn(ctx,)
 - queryKeySubscribersPreferencesList(subscriberId: string,
  parameters: {
    criticality?: operations.Criticality | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeySubscribersPreferencesList(...queryKeyBase);

  return client.setQueryData<SubscribersPrefer...)
Declaraciones 'export' encontradas:
- export  type
- export function useSubscribersPreferencesList
- export function useSubscribersPreferencesListSuspense
- export function prefetchSubscribersPreferencesList
- export function setSubscribersPreferencesListData
- export function invalidateSubscribersPreferencesList
- export function invalidateAllSubscribersPreferencesList
- export function buildSubscribersPreferencesListQuery
- export function queryKeySubscribersPreferencesList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersPreferencesUpdate.ts
Tamaño: 3031 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersPreferencesUpdate } from "../funcs/subscribersPreferencesUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersPreferencesUpdateMutationVariables = {
  patchSubscriberPreferencesDto: components.PatchSubscriberPreferencesDto;
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersPreferencesUpdateMutationData =
  operations.SubscribersControllerUpdateSubscriberPreferencesResponse;

/**
 * Update subscriber preferences
 *
 * @remarks
 * Update subscriber preferences by its unique key identifier **subscriberId**.
 *     **workflowId** is optional field, if provided, this API will update that workflow preference,
 *     otherwise it will update global preferences
 */
export function useSubscribersPreferencesUpdateMutation(
  options?: MutationHookOptions<
    SubscribersPreferencesUpdateMutationData,
    Error,
    SubscribersPreferencesUpdateMutationVariables
  >,
): UseMutationResult<
  SubscribersPreferencesUpdateMutationData,
  Error,
  SubscribersPreferencesUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersPreferencesUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersPreferencesUpdate(): MutationKey {
  return ["@novu/api", "Preferences", "update"];
}

export function buildSubscribersPreferencesUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersPreferencesUpdateMutationVariables,
  ) => Promise<SubscribersPreferencesUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersPreferencesUpdate(),
    mutationFn: function subscribersPreferencesUpdateMutationFn({
      patchSubscriberPreferencesDto,
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersPreferencesUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersPreferencesUpdate(
        client$,
        patchSubscriberPreferencesDto,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersPreferencesUpdateMutation(options?: MutationHookOptions<
    SubscribersPreferencesUpdateMutationData,
    Error,
    SubscribersPreferencesUpdateMutationVariables
  >,)
 - mutationKeySubscribersPreferencesUpdate()
 - buildSubscribersPreferencesUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersPreferencesUpdateMutationFn({
      patchSubscriberPreferencesDto,
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersPreferencesUpdateMutation(client, op...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersPreferencesUpdateMutation
- export function mutationKeySubscribersPreferencesUpdate
- export function buildSubscribersPreferencesUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersPropertiesUpdateOnlineFlag.ts
Tamaño: 3090 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersPropertiesUpdateOnlineFlag } from "../funcs/subscribersPropertiesUpdateOnlineFlag.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersPropertiesUpdateOnlineFlagMutationVariables = {
  updateSubscriberOnlineFlagRequestDto:
    components.UpdateSubscriberOnlineFlagRequestDto;
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersPropertiesUpdateOnlineFlagMutationData =
  operations.SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse;

/**
 * Update subscriber online status
 *
 * @remarks
 * Update the subscriber online status by its unique key identifier **subscriberId**
 */
export function useSubscribersPropertiesUpdateOnlineFlagMutation(
  options?: MutationHookOptions<
    SubscribersPropertiesUpdateOnlineFlagMutationData,
    Error,
    SubscribersPropertiesUpdateOnlineFlagMutationVariables
  >,
): UseMutationResult<
  SubscribersPropertiesUpdateOnlineFlagMutationData,
  Error,
  SubscribersPropertiesUpdateOnlineFlagMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersPropertiesUpdateOnlineFlagMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersPropertiesUpdateOnlineFlag(): MutationKey {
  return ["@novu/api", "properties", "updateOnlineFlag"];
}

export function buildSubscribersPropertiesUpdateOnlineFlagMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersPropertiesUpdateOnlineFlagMutationVariables,
  ) => Promise<SubscribersPropertiesUpdateOnlineFlagMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersPropertiesUpdateOnlineFlag(),
    mutationFn: function subscribersPropertiesUpdateOnlineFlagMutationFn({
      updateSubscriberOnlineFlagRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersPropertiesUpdateOnlineFlagMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersPropertiesUpdateOnlineFlag(
        client$,
        updateSubscriberOnlineFlagRequestDto,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersPropertiesUpdateOnlineFlagMutation(options?: MutationHookOptions<
    SubscribersPropertiesUpdateOnlineFlagMutationData,
    Error,
    SubscribersPropertiesUpdateOnlineFlagMutationVariables
  >,)
 - mutationKeySubscribersPropertiesUpdateOnlineFlag()
 - buildSubscribersPropertiesUpdateOnlineFlagMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersPropertiesUpdateOnlineFlagMutationFn({
      updateSubscriberOnlineFlagRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersPropertiesUpdateOnlineFlagMutation(c...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersPropertiesUpdateOnlineFlagMutation
- export function mutationKeySubscribersPropertiesUpdateOnlineFlag
- export function buildSubscribersPropertiesUpdateOnlineFlagMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersRetrieve.ts
Tamaño: 4514 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersRetrieve } from "../funcs/subscribersRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type SubscribersRetrieveQueryData =
  operations.SubscribersControllerGetSubscriberResponse;

/**
 * Retrieve a subscriber
 *
 * @remarks
 * Retrieve a subscriber by its unique key identifier **subscriberId**.
 *     **subscriberId** field is required.
 */
export function useSubscribersRetrieve(
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<SubscribersRetrieveQueryData>,
): UseQueryResult<SubscribersRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildSubscribersRetrieveQuery(
      client,
      subscriberId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve a subscriber
 *
 * @remarks
 * Retrieve a subscriber by its unique key identifier **subscriberId**.
 *     **subscriberId** field is required.
 */
export function useSubscribersRetrieveSuspense(
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<SubscribersRetrieveQueryData>,
): UseSuspenseQueryResult<SubscribersRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildSubscribersRetrieveQuery(
      client,
      subscriberId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchSubscribersRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  subscriberId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildSubscribersRetrieveQuery(
      client$,
      subscriberId,
      idempotencyKey,
    ),
  });
}

export function setSubscribersRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: SubscribersRetrieveQueryData,
): SubscribersRetrieveQueryData | undefined {
  const key = queryKeySubscribersRetrieve(...queryKeyBase);

  return client.setQueryData<SubscribersRetrieveQueryData>(key, data);
}

export function invalidateSubscribersRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [subscriberId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Subscribers", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllSubscribersRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Subscribers", "retrieve"],
  });
}

export function buildSubscribersRetrieveQuery(
  client$: NovuCore,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<SubscribersRetrieveQueryData>;
} {
  return {
    queryKey: queryKeySubscribersRetrieve(subscriberId, { idempotencyKey }),
    queryFn: async function subscribersRetrieveQueryFn(
      ctx,
    ): Promise<SubscribersRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(subscribersRetrieve(
        client$,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeySubscribersRetrieve(
  subscriberId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Subscribers", "retrieve", subscriberId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersRetrieve(subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<SubscribersRetrieveQueryData>,)
 - useSubscribersRetrieveSuspense(subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<SubscribersRetrieveQueryData>,)
 - prefetchSubscribersRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  subscriberId: string,
  idempotencyKey?: string | undefined,)
 - setSubscribersRetrieveData(client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: SubscribersRetrieveQueryData,)
 - invalidateSubscribersRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [subscriberId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllSubscribersRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildSubscribersRetrieveQuery(client$: NovuCore,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - subscribersRetrieveQueryFn(ctx,)
 - queryKeySubscribersRetrieve(subscriberId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeySubscribersRetrieve(...queryKeyBase);

  return client.setQueryData<SubscribersRetrieveQuery...)
Declaraciones 'export' encontradas:
- export  type
- export function useSubscribersRetrieve
- export function useSubscribersRetrieveSuspense
- export function prefetchSubscribersRetrieve
- export function setSubscribersRetrieveData
- export function invalidateSubscribersRetrieve
- export function invalidateAllSubscribersRetrieve
- export function buildSubscribersRetrieveQuery
- export function queryKeySubscribersRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersSearch.ts
Tamaño: 5994 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersSearch } from "../funcs/subscribersSearch.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type SubscribersSearchQueryData =
  operations.SubscribersControllerSearchSubscribersResponse;

/**
 * Search subscribers
 *
 * @remarks
 * Search subscribers by their **email**, **phone**, **subscriberId** and **name**.
 *     The search is case sensitive and supports pagination.Checkout all available filters in the query section.
 */
export function useSubscribersSearch(
  request: operations.SubscribersControllerSearchSubscribersRequest,
  options?: QueryHookOptions<SubscribersSearchQueryData>,
): UseQueryResult<SubscribersSearchQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildSubscribersSearchQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * Search subscribers
 *
 * @remarks
 * Search subscribers by their **email**, **phone**, **subscriberId** and **name**.
 *     The search is case sensitive and supports pagination.Checkout all available filters in the query section.
 */
export function useSubscribersSearchSuspense(
  request: operations.SubscribersControllerSearchSubscribersRequest,
  options?: SuspenseQueryHookOptions<SubscribersSearchQueryData>,
): UseSuspenseQueryResult<SubscribersSearchQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildSubscribersSearchQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchSubscribersSearch(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.SubscribersControllerSearchSubscribersRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildSubscribersSearchQuery(
      client$,
      request,
    ),
  });
}

export function setSubscribersSearchData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?: operations.QueryParamOrderDirection | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      email?: string | undefined;
      name?: string | undefined;
      phone?: string | undefined;
      subscriberId?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersSearchQueryData,
): SubscribersSearchQueryData | undefined {
  const key = queryKeySubscribersSearch(...queryKeyBase);

  return client.setQueryData<SubscribersSearchQueryData>(key, data);
}

export function invalidateSubscribersSearch(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?: operations.QueryParamOrderDirection | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      email?: string | undefined;
      name?: string | undefined;
      phone?: string | undefined;
      subscriberId?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Subscribers", "search", ...queryKeyBase],
  });
}

export function invalidateAllSubscribersSearch(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Subscribers", "search"],
  });
}

export function buildSubscribersSearchQuery(
  client$: NovuCore,
  request: operations.SubscribersControllerSearchSubscribersRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<SubscribersSearchQueryData>;
} {
  return {
    queryKey: queryKeySubscribersSearch({
      after: request.after,
      before: request.before,
      limit: request.limit,
      orderDirection: request.orderDirection,
      orderBy: request.orderBy,
      includeCursor: request.includeCursor,
      email: request.email,
      name: request.name,
      phone: request.phone,
      subscriberId: request.subscriberId,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function subscribersSearchQueryFn(
      ctx,
    ): Promise<SubscribersSearchQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(subscribersSearch(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeySubscribersSearch(
  parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?: operations.QueryParamOrderDirection | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    email?: string | undefined;
    name?: string | undefined;
    phone?: string | undefined;
    subscriberId?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Subscribers", "search", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersSearch(request: operations.SubscribersControllerSearchSubscribersRequest,
  options?: QueryHookOptions<SubscribersSearchQueryData>,)
 - useSubscribersSearchSuspense(request: operations.SubscribersControllerSearchSubscribersRequest,
  options?: SuspenseQueryHookOptions<SubscribersSearchQueryData>,)
 - prefetchSubscribersSearch(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.SubscribersControllerSearchSubscribersRequest,)
 - setSubscribersSearchData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?: operations.QueryParamOrderDirection | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      email?: string | undefined;
      name?: string | undefined;
      phone?: string | undefined;
      subscriberId?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersSearchQueryData,)
 - invalidateSubscribersSearch(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?: operations.QueryParamOrderDirection | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      email?: string | undefined;
      name?: string | undefined;
      phone?: string | undefined;
      subscriberId?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllSubscribersSearch(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildSubscribersSearchQuery(client$: NovuCore,
  request: operations.SubscribersControllerSearchSubscribersRequest,
  options?: RequestOptions,)
 - subscribersSearchQueryFn(ctx,)
 - queryKeySubscribersSearch(parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?: operations.QueryParamOrderDirection | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    email?: string | undefined;
    name?: string | undefined;
    phone?: string | undefined;
    subscriberId?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeySubscribersSearch(...queryKeyBase);

  return client.setQueryData<SubscribersSearchQueryData...)
Declaraciones 'export' encontradas:
- export  type
- export function useSubscribersSearch
- export function useSubscribersSearchSuspense
- export function prefetchSubscribersSearch
- export function setSubscribersSearchData
- export function invalidateSubscribersSearch
- export function invalidateAllSubscribersSearch
- export function buildSubscribersSearchQuery
- export function queryKeySubscribersSearch

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersTopicsList.ts
Tamaño: 5934 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersTopicsList } from "../funcs/subscribersTopicsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type SubscribersTopicsListQueryData =
  operations.SubscribersControllerListSubscriberTopicsResponse;

/**
 * Retrieve subscriber subscriptions
 *
 * @remarks
 * Retrieve subscriber's topic subscriptions by its unique key identifier **subscriberId**.
 *     Checkout all available filters in the query section.
 */
export function useSubscribersTopicsList(
  request: operations.SubscribersControllerListSubscriberTopicsRequest,
  options?: QueryHookOptions<SubscribersTopicsListQueryData>,
): UseQueryResult<SubscribersTopicsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildSubscribersTopicsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve subscriber subscriptions
 *
 * @remarks
 * Retrieve subscriber's topic subscriptions by its unique key identifier **subscriberId**.
 *     Checkout all available filters in the query section.
 */
export function useSubscribersTopicsListSuspense(
  request: operations.SubscribersControllerListSubscriberTopicsRequest,
  options?: SuspenseQueryHookOptions<SubscribersTopicsListQueryData>,
): UseSuspenseQueryResult<SubscribersTopicsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildSubscribersTopicsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchSubscribersTopicsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.SubscribersControllerListSubscriberTopicsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildSubscribersTopicsListQuery(
      client$,
      request,
    ),
  });
}

export function setSubscribersTopicsListData(
  client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?:
        | operations.SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
        | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      key?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersTopicsListQueryData,
): SubscribersTopicsListQueryData | undefined {
  const key = queryKeySubscribersTopicsList(...queryKeyBase);

  return client.setQueryData<SubscribersTopicsListQueryData>(key, data);
}

export function invalidateSubscribersTopicsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      subscriberId: string,
      parameters: {
        after?: string | undefined;
        before?: string | undefined;
        limit?: number | undefined;
        orderDirection?:
          | operations.SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
          | undefined;
        orderBy?: string | undefined;
        includeCursor?: boolean | undefined;
        key?: string | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Topics", "list", ...queryKeyBase],
  });
}

export function invalidateAllSubscribersTopicsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Topics", "list"],
  });
}

export function buildSubscribersTopicsListQuery(
  client$: NovuCore,
  request: operations.SubscribersControllerListSubscriberTopicsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<SubscribersTopicsListQueryData>;
} {
  return {
    queryKey: queryKeySubscribersTopicsList(request.subscriberId, {
      after: request.after,
      before: request.before,
      limit: request.limit,
      orderDirection: request.orderDirection,
      orderBy: request.orderBy,
      includeCursor: request.includeCursor,
      key: request.key,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function subscribersTopicsListQueryFn(
      ctx,
    ): Promise<SubscribersTopicsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(subscribersTopicsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeySubscribersTopicsList(
  subscriberId: string,
  parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?:
      | operations.SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
      | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    key?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Topics", "list", subscriberId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersTopicsList(request: operations.SubscribersControllerListSubscriberTopicsRequest,
  options?: QueryHookOptions<SubscribersTopicsListQueryData>,)
 - useSubscribersTopicsListSuspense(request: operations.SubscribersControllerListSubscriberTopicsRequest,
  options?: SuspenseQueryHookOptions<SubscribersTopicsListQueryData>,)
 - prefetchSubscribersTopicsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.SubscribersControllerListSubscriberTopicsRequest,)
 - setSubscribersTopicsListData(client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?:
        | operations.SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
        | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      key?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersTopicsListQueryData,)
 - invalidateSubscribersTopicsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      subscriberId: string,
      parameters: {
        after?: string | undefined;
        before?: string | undefined;
        limit?: number | undefined;
        orderDirection?:
          | operations.SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
          | undefined;
        orderBy?: string | undefined;
        includeCursor?: boolean | undefined;
        key?: string | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllSubscribersTopicsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildSubscribersTopicsListQuery(client$: NovuCore,
  request: operations.SubscribersControllerListSubscriberTopicsRequest,
  options?: RequestOptions,)
 - subscribersTopicsListQueryFn(ctx,)
 - queryKeySubscribersTopicsList(subscriberId: string,
  parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?:
      | operations.SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
      | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    key?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeySubscribersTopicsList(...queryKeyBase);

  return client.setQueryData<SubscribersTopicsListQ...)
Declaraciones 'export' encontradas:
- export  type
- export function useSubscribersTopicsList
- export function useSubscribersTopicsListSuspense
- export function prefetchSubscribersTopicsList
- export function setSubscribersTopicsListData
- export function invalidateSubscribersTopicsList
- export function invalidateAllSubscribersTopicsList
- export function buildSubscribersTopicsListQuery
- export function queryKeySubscribersTopicsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsCreate.ts
Tamaño: 2615 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsCreate } from "../funcs/topicsCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TopicsCreateMutationVariables = {
  createUpdateTopicRequestDto: components.CreateUpdateTopicRequestDto;
  failIfExists?: boolean | undefined;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TopicsCreateMutationData =
  operations.TopicsControllerUpsertTopicResponse;

/**
 * Create a topic
 *
 * @remarks
 * Creates a new topic if it does not exist, or updates an existing topic if it already exists. Use ?failIfExists=true to prevent updates.
 */
export function useTopicsCreateMutation(
  options?: MutationHookOptions<
    TopicsCreateMutationData,
    Error,
    TopicsCreateMutationVariables
  >,
): UseMutationResult<
  TopicsCreateMutationData,
  Error,
  TopicsCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTopicsCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeyTopicsCreate(): MutationKey {
  return ["@novu/api", "Topics", "create"];
}

export function buildTopicsCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TopicsCreateMutationVariables,
  ) => Promise<TopicsCreateMutationData>;
} {
  return {
    mutationKey: mutationKeyTopicsCreate(),
    mutationFn: function topicsCreateMutationFn({
      createUpdateTopicRequestDto,
      failIfExists,
      idempotencyKey,
      options,
    }): Promise<TopicsCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(topicsCreate(
        client$,
        createUpdateTopicRequestDto,
        failIfExists,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsCreateMutation(options?: MutationHookOptions<
    TopicsCreateMutationData,
    Error,
    TopicsCreateMutationVariables
  >,)
 - mutationKeyTopicsCreate()
 - buildTopicsCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - topicsCreateMutationFn({
      createUpdateTopicRequestDto,
      failIfExists,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTopicsCreateMutation(client, options),
    ...o...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTopicsCreateMutation
- export function mutationKeyTopicsCreate
- export function buildTopicsCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsDelete.ts
Tamaño: 2390 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsDelete } from "../funcs/topicsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TopicsDeleteMutationVariables = {
  topicKey: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TopicsDeleteMutationData =
  operations.TopicsControllerDeleteTopicResponse;

/**
 * Delete a topic
 *
 * @remarks
 * Delete a topic by its unique key identifier **topicKey**.
 *     This action is irreversible and will remove all subscriptions to the topic.
 */
export function useTopicsDeleteMutation(
  options?: MutationHookOptions<
    TopicsDeleteMutationData,
    Error,
    TopicsDeleteMutationVariables
  >,
): UseMutationResult<
  TopicsDeleteMutationData,
  Error,
  TopicsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTopicsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyTopicsDelete(): MutationKey {
  return ["@novu/api", "Topics", "delete"];
}

export function buildTopicsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TopicsDeleteMutationVariables,
  ) => Promise<TopicsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyTopicsDelete(),
    mutationFn: function topicsDeleteMutationFn({
      topicKey,
      idempotencyKey,
      options,
    }): Promise<TopicsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(topicsDelete(
        client$,
        topicKey,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsDeleteMutation(options?: MutationHookOptions<
    TopicsDeleteMutationData,
    Error,
    TopicsDeleteMutationVariables
  >,)
 - mutationKeyTopicsDelete()
 - buildTopicsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - topicsDeleteMutationFn({
      topicKey,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTopicsDeleteMutation(client, options),
    ...o...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTopicsDeleteMutation
- export function mutationKeyTopicsDelete
- export function buildTopicsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsGet.ts
Tamaño: 4012 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsGet } from "../funcs/topicsGet.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type TopicsGetQueryData = operations.TopicsControllerGetTopicResponse;

/**
 * Retrieve a topic
 *
 * @remarks
 * Retrieve a topic by its unique key identifier **topicKey**
 */
export function useTopicsGet(
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<TopicsGetQueryData>,
): UseQueryResult<TopicsGetQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildTopicsGetQuery(
      client,
      topicKey,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve a topic
 *
 * @remarks
 * Retrieve a topic by its unique key identifier **topicKey**
 */
export function useTopicsGetSuspense(
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<TopicsGetQueryData>,
): UseSuspenseQueryResult<TopicsGetQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildTopicsGetQuery(
      client,
      topicKey,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchTopicsGet(
  queryClient: QueryClient,
  client$: NovuCore,
  topicKey: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildTopicsGetQuery(
      client$,
      topicKey,
      idempotencyKey,
    ),
  });
}

export function setTopicsGetData(
  client: QueryClient,
  queryKeyBase: [
    topicKey: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: TopicsGetQueryData,
): TopicsGetQueryData | undefined {
  const key = queryKeyTopicsGet(...queryKeyBase);

  return client.setQueryData<TopicsGetQueryData>(key, data);
}

export function invalidateTopicsGet(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [topicKey: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Topics", "get", ...queryKeyBase],
  });
}

export function invalidateAllTopicsGet(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Topics", "get"],
  });
}

export function buildTopicsGetQuery(
  client$: NovuCore,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (context: QueryFunctionContext) => Promise<TopicsGetQueryData>;
} {
  return {
    queryKey: queryKeyTopicsGet(topicKey, { idempotencyKey }),
    queryFn: async function topicsGetQueryFn(ctx): Promise<TopicsGetQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(topicsGet(
        client$,
        topicKey,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyTopicsGet(
  topicKey: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Topics", "get", topicKey, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsGet(topicKey: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<TopicsGetQueryData>,)
 - useTopicsGetSuspense(topicKey: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<TopicsGetQueryData>,)
 - prefetchTopicsGet(queryClient: QueryClient,
  client$: NovuCore,
  topicKey: string,
  idempotencyKey?: string | undefined,)
 - setTopicsGetData(client: QueryClient,
  queryKeyBase: [
    topicKey: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: TopicsGetQueryData,)
 - invalidateTopicsGet(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [topicKey: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllTopicsGet(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildTopicsGetQuery(client$: NovuCore,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - topicsGetQueryFn(ctx)
 - queryKeyTopicsGet(topicKey: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyTopicsGet(...queryKeyBase);

  return client.setQueryData<TopicsGetQueryData>(key, data);
}
...)
Declaraciones 'export' encontradas:
- export  type
- export function useTopicsGet
- export function useTopicsGetSuspense
- export function prefetchTopicsGet
- export function setTopicsGetData
- export function invalidateTopicsGet
- export function invalidateAllTopicsGet
- export function buildTopicsGetQuery
- export function queryKeyTopicsGet

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsList.ts
Tamaño: 5562 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsList } from "../funcs/topicsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type TopicsListQueryData = operations.TopicsControllerListTopicsResponse;

/**
 * List all topics
 *
 * @remarks
 * This api returns a paginated list of topics.
 *     Topics can be filtered by **key**, **name**, or **includeCursor** to paginate through the list.
 *     Checkout all available filters in the query section.
 */
export function useTopicsList(
  request: operations.TopicsControllerListTopicsRequest,
  options?: QueryHookOptions<TopicsListQueryData>,
): UseQueryResult<TopicsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildTopicsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List all topics
 *
 * @remarks
 * This api returns a paginated list of topics.
 *     Topics can be filtered by **key**, **name**, or **includeCursor** to paginate through the list.
 *     Checkout all available filters in the query section.
 */
export function useTopicsListSuspense(
  request: operations.TopicsControllerListTopicsRequest,
  options?: SuspenseQueryHookOptions<TopicsListQueryData>,
): UseSuspenseQueryResult<TopicsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildTopicsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchTopicsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.TopicsControllerListTopicsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildTopicsListQuery(
      client$,
      request,
    ),
  });
}

export function setTopicsListData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?:
        | operations.TopicsControllerListTopicsQueryParamOrderDirection
        | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      key?: string | undefined;
      name?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: TopicsListQueryData,
): TopicsListQueryData | undefined {
  const key = queryKeyTopicsList(...queryKeyBase);

  return client.setQueryData<TopicsListQueryData>(key, data);
}

export function invalidateTopicsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?:
        | operations.TopicsControllerListTopicsQueryParamOrderDirection
        | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      key?: string | undefined;
      name?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Topics", "list", ...queryKeyBase],
  });
}

export function invalidateAllTopicsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Topics", "list"],
  });
}

export function buildTopicsListQuery(
  client$: NovuCore,
  request: operations.TopicsControllerListTopicsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (context: QueryFunctionContext) => Promise<TopicsListQueryData>;
} {
  return {
    queryKey: queryKeyTopicsList({
      after: request.after,
      before: request.before,
      limit: request.limit,
      orderDirection: request.orderDirection,
      orderBy: request.orderBy,
      includeCursor: request.includeCursor,
      key: request.key,
      name: request.name,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function topicsListQueryFn(
      ctx,
    ): Promise<TopicsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(topicsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyTopicsList(
  parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?:
      | operations.TopicsControllerListTopicsQueryParamOrderDirection
      | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    key?: string | undefined;
    name?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Topics", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsList(request: operations.TopicsControllerListTopicsRequest,
  options?: QueryHookOptions<TopicsListQueryData>,)
 - useTopicsListSuspense(request: operations.TopicsControllerListTopicsRequest,
  options?: SuspenseQueryHookOptions<TopicsListQueryData>,)
 - prefetchTopicsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.TopicsControllerListTopicsRequest,)
 - setTopicsListData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?:
        | operations.TopicsControllerListTopicsQueryParamOrderDirection
        | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      key?: string | undefined;
      name?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: TopicsListQueryData,)
 - invalidateTopicsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?:
        | operations.TopicsControllerListTopicsQueryParamOrderDirection
        | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      key?: string | undefined;
      name?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllTopicsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildTopicsListQuery(client$: NovuCore,
  request: operations.TopicsControllerListTopicsRequest,
  options?: RequestOptions,)
 - topicsListQueryFn(ctx,)
 - queryKeyTopicsList(parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?:
      | operations.TopicsControllerListTopicsQueryParamOrderDirection
      | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    key?: string | undefined;
    name?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyTopicsList(...queryKeyBase);

  return client.setQueryData<TopicsListQueryData>(key, data);
...)
Declaraciones 'export' encontradas:
- export  type
- export function useTopicsList
- export function useTopicsListSuspense
- export function prefetchTopicsList
- export function setTopicsListData
- export function invalidateTopicsList
- export function invalidateAllTopicsList
- export function buildTopicsListQuery
- export function queryKeyTopicsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsSubscribersRetrieve.ts
Tamaño: 4963 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsSubscribersRetrieve } from "../funcs/topicsSubscribersRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type TopicsSubscribersRetrieveQueryData =
  operations.TopicsV1ControllerGetTopicSubscriberResponse;

/**
 * Check topic subscriber
 *
 * @remarks
 * Check if a subscriber belongs to a certain topic
 */
export function useTopicsSubscribersRetrieve(
  topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<TopicsSubscribersRetrieveQueryData>,
): UseQueryResult<TopicsSubscribersRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildTopicsSubscribersRetrieveQuery(
      client,
      topicKey,
      externalSubscriberId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Check topic subscriber
 *
 * @remarks
 * Check if a subscriber belongs to a certain topic
 */
export function useTopicsSubscribersRetrieveSuspense(
  topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<TopicsSubscribersRetrieveQueryData>,
): UseSuspenseQueryResult<TopicsSubscribersRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildTopicsSubscribersRetrieveQuery(
      client,
      topicKey,
      externalSubscriberId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchTopicsSubscribersRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildTopicsSubscribersRetrieveQuery(
      client$,
      topicKey,
      externalSubscriberId,
      idempotencyKey,
    ),
  });
}

export function setTopicsSubscribersRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    topicKey: string,
    externalSubscriberId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: TopicsSubscribersRetrieveQueryData,
): TopicsSubscribersRetrieveQueryData | undefined {
  const key = queryKeyTopicsSubscribersRetrieve(...queryKeyBase);

  return client.setQueryData<TopicsSubscribersRetrieveQueryData>(key, data);
}

export function invalidateTopicsSubscribersRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      topicKey: string,
      externalSubscriberId: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Subscribers", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllTopicsSubscribersRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Subscribers", "retrieve"],
  });
}

export function buildTopicsSubscribersRetrieveQuery(
  client$: NovuCore,
  topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<TopicsSubscribersRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyTopicsSubscribersRetrieve(
      topicKey,
      externalSubscriberId,
      { idempotencyKey },
    ),
    queryFn: async function topicsSubscribersRetrieveQueryFn(
      ctx,
    ): Promise<TopicsSubscribersRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(topicsSubscribersRetrieve(
        client$,
        topicKey,
        externalSubscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyTopicsSubscribersRetrieve(
  topicKey: string,
  externalSubscriberId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return [
    "@novu/api",
    "Subscribers",
    "retrieve",
    topicKey,
    externalSubscriberId,
    parameters,
  ];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsSubscribersRetrieve(topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<TopicsSubscribersRetrieveQueryData>,)
 - useTopicsSubscribersRetrieveSuspense(topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<TopicsSubscribersRetrieveQueryData>,)
 - prefetchTopicsSubscribersRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,)
 - setTopicsSubscribersRetrieveData(client: QueryClient,
  queryKeyBase: [
    topicKey: string,
    externalSubscriberId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: TopicsSubscribersRetrieveQueryData,)
 - invalidateTopicsSubscribersRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      topicKey: string,
      externalSubscriberId: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllTopicsSubscribersRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildTopicsSubscribersRetrieveQuery(client$: NovuCore,
  topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - topicsSubscribersRetrieveQueryFn(ctx,)
 - queryKeyTopicsSubscribersRetrieve(topicKey: string,
  externalSubscriberId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyTopicsSubscribersRetrieve(...queryKeyBase);

  return client.setQueryData<TopicsSubscribersR...)
Declaraciones 'export' encontradas:
- export  type
- export function useTopicsSubscribersRetrieve
- export function useTopicsSubscribersRetrieveSuspense
- export function prefetchTopicsSubscribersRetrieve
- export function setTopicsSubscribersRetrieveData
- export function invalidateTopicsSubscribersRetrieve
- export function invalidateAllTopicsSubscribersRetrieve
- export function buildTopicsSubscribersRetrieveQuery
- export function queryKeyTopicsSubscribersRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsSubscriptionsCreate.ts
Tamaño: 2919 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsSubscriptionsCreate } from "../funcs/topicsSubscriptionsCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TopicsSubscriptionsCreateMutationVariables = {
  createTopicSubscriptionsRequestDto:
    components.CreateTopicSubscriptionsRequestDto;
  topicKey: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TopicsSubscriptionsCreateMutationData =
  operations.TopicsControllerCreateTopicSubscriptionsResponse;

/**
 * Create topic subscriptions
 *
 * @remarks
 * This api will create subscription for subscriberIds for a topic.
 *       Its like subscribing to a common interest group. if topic does not exist, it will be created.
 */
export function useTopicsSubscriptionsCreateMutation(
  options?: MutationHookOptions<
    TopicsSubscriptionsCreateMutationData,
    Error,
    TopicsSubscriptionsCreateMutationVariables
  >,
): UseMutationResult<
  TopicsSubscriptionsCreateMutationData,
  Error,
  TopicsSubscriptionsCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTopicsSubscriptionsCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeyTopicsSubscriptionsCreate(): MutationKey {
  return ["@novu/api", "Subscriptions", "create"];
}

export function buildTopicsSubscriptionsCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TopicsSubscriptionsCreateMutationVariables,
  ) => Promise<TopicsSubscriptionsCreateMutationData>;
} {
  return {
    mutationKey: mutationKeyTopicsSubscriptionsCreate(),
    mutationFn: function topicsSubscriptionsCreateMutationFn({
      createTopicSubscriptionsRequestDto,
      topicKey,
      idempotencyKey,
      options,
    }): Promise<TopicsSubscriptionsCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(topicsSubscriptionsCreate(
        client$,
        createTopicSubscriptionsRequestDto,
        topicKey,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsSubscriptionsCreateMutation(options?: MutationHookOptions<
    TopicsSubscriptionsCreateMutationData,
    Error,
    TopicsSubscriptionsCreateMutationVariables
  >,)
 - mutationKeyTopicsSubscriptionsCreate()
 - buildTopicsSubscriptionsCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - topicsSubscriptionsCreateMutationFn({
      createTopicSubscriptionsRequestDto,
      topicKey,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTopicsSubscriptionsCreateMutation(client, optio...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTopicsSubscriptionsCreateMutation
- export function mutationKeyTopicsSubscriptionsCreate
- export function buildTopicsSubscriptionsCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsSubscriptionsDelete.ts
Tamaño: 2803 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsSubscriptionsDelete } from "../funcs/topicsSubscriptionsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TopicsSubscriptionsDeleteMutationVariables = {
  deleteTopicSubscriptionsRequestDto:
    components.DeleteTopicSubscriptionsRequestDto;
  topicKey: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TopicsSubscriptionsDeleteMutationData =
  operations.TopicsControllerDeleteTopicSubscriptionsResponse;

/**
 * Delete topic subscriptions
 *
 * @remarks
 * Delete subscriptions for subscriberIds for a topic.
 */
export function useTopicsSubscriptionsDeleteMutation(
  options?: MutationHookOptions<
    TopicsSubscriptionsDeleteMutationData,
    Error,
    TopicsSubscriptionsDeleteMutationVariables
  >,
): UseMutationResult<
  TopicsSubscriptionsDeleteMutationData,
  Error,
  TopicsSubscriptionsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTopicsSubscriptionsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyTopicsSubscriptionsDelete(): MutationKey {
  return ["@novu/api", "Subscriptions", "delete"];
}

export function buildTopicsSubscriptionsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TopicsSubscriptionsDeleteMutationVariables,
  ) => Promise<TopicsSubscriptionsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyTopicsSubscriptionsDelete(),
    mutationFn: function topicsSubscriptionsDeleteMutationFn({
      deleteTopicSubscriptionsRequestDto,
      topicKey,
      idempotencyKey,
      options,
    }): Promise<TopicsSubscriptionsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(topicsSubscriptionsDelete(
        client$,
        deleteTopicSubscriptionsRequestDto,
        topicKey,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsSubscriptionsDeleteMutation(options?: MutationHookOptions<
    TopicsSubscriptionsDeleteMutationData,
    Error,
    TopicsSubscriptionsDeleteMutationVariables
  >,)
 - mutationKeyTopicsSubscriptionsDelete()
 - buildTopicsSubscriptionsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - topicsSubscriptionsDeleteMutationFn({
      deleteTopicSubscriptionsRequestDto,
      topicKey,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTopicsSubscriptionsDeleteMutation(client, optio...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTopicsSubscriptionsDeleteMutation
- export function mutationKeyTopicsSubscriptionsDelete
- export function buildTopicsSubscriptionsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsSubscriptionsList.ts
Tamaño: 5916 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsSubscriptionsList } from "../funcs/topicsSubscriptionsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type TopicsSubscriptionsListQueryData =
  operations.TopicsControllerListTopicSubscriptionsResponse;

/**
 * List topic subscriptions
 *
 * @remarks
 * List all subscriptions of subscribers for a topic.
 *     Checkout all available filters in the query section.
 */
export function useTopicsSubscriptionsList(
  request: operations.TopicsControllerListTopicSubscriptionsRequest,
  options?: QueryHookOptions<TopicsSubscriptionsListQueryData>,
): UseQueryResult<TopicsSubscriptionsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildTopicsSubscriptionsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List topic subscriptions
 *
 * @remarks
 * List all subscriptions of subscribers for a topic.
 *     Checkout all available filters in the query section.
 */
export function useTopicsSubscriptionsListSuspense(
  request: operations.TopicsControllerListTopicSubscriptionsRequest,
  options?: SuspenseQueryHookOptions<TopicsSubscriptionsListQueryData>,
): UseSuspenseQueryResult<TopicsSubscriptionsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildTopicsSubscriptionsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchTopicsSubscriptionsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.TopicsControllerListTopicSubscriptionsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildTopicsSubscriptionsListQuery(
      client$,
      request,
    ),
  });
}

export function setTopicsSubscriptionsListData(
  client: QueryClient,
  queryKeyBase: [
    topicKey: string,
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?:
        | operations.TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
        | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      subscriberId?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: TopicsSubscriptionsListQueryData,
): TopicsSubscriptionsListQueryData | undefined {
  const key = queryKeyTopicsSubscriptionsList(...queryKeyBase);

  return client.setQueryData<TopicsSubscriptionsListQueryData>(key, data);
}

export function invalidateTopicsSubscriptionsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      topicKey: string,
      parameters: {
        after?: string | undefined;
        before?: string | undefined;
        limit?: number | undefined;
        orderDirection?:
          | operations.TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
          | undefined;
        orderBy?: string | undefined;
        includeCursor?: boolean | undefined;
        subscriberId?: string | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Subscriptions", "list", ...queryKeyBase],
  });
}

export function invalidateAllTopicsSubscriptionsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Subscriptions", "list"],
  });
}

export function buildTopicsSubscriptionsListQuery(
  client$: NovuCore,
  request: operations.TopicsControllerListTopicSubscriptionsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<TopicsSubscriptionsListQueryData>;
} {
  return {
    queryKey: queryKeyTopicsSubscriptionsList(request.topicKey, {
      after: request.after,
      before: request.before,
      limit: request.limit,
      orderDirection: request.orderDirection,
      orderBy: request.orderBy,
      includeCursor: request.includeCursor,
      subscriberId: request.subscriberId,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function topicsSubscriptionsListQueryFn(
      ctx,
    ): Promise<TopicsSubscriptionsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(topicsSubscriptionsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyTopicsSubscriptionsList(
  topicKey: string,
  parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?:
      | operations.TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
      | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    subscriberId?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Subscriptions", "list", topicKey, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsSubscriptionsList(request: operations.TopicsControllerListTopicSubscriptionsRequest,
  options?: QueryHookOptions<TopicsSubscriptionsListQueryData>,)
 - useTopicsSubscriptionsListSuspense(request: operations.TopicsControllerListTopicSubscriptionsRequest,
  options?: SuspenseQueryHookOptions<TopicsSubscriptionsListQueryData>,)
 - prefetchTopicsSubscriptionsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.TopicsControllerListTopicSubscriptionsRequest,)
 - setTopicsSubscriptionsListData(client: QueryClient,
  queryKeyBase: [
    topicKey: string,
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?:
        | operations.TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
        | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      subscriberId?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: TopicsSubscriptionsListQueryData,)
 - invalidateTopicsSubscriptionsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      topicKey: string,
      parameters: {
        after?: string | undefined;
        before?: string | undefined;
        limit?: number | undefined;
        orderDirection?:
          | operations.TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
          | undefined;
        orderBy?: string | undefined;
        includeCursor?: boolean | undefined;
        subscriberId?: string | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllTopicsSubscriptionsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildTopicsSubscriptionsListQuery(client$: NovuCore,
  request: operations.TopicsControllerListTopicSubscriptionsRequest,
  options?: RequestOptions,)
 - topicsSubscriptionsListQueryFn(ctx,)
 - queryKeyTopicsSubscriptionsList(topicKey: string,
  parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?:
      | operations.TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
      | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    subscriberId?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyTopicsSubscriptionsList(...queryKeyBase);

  return client.setQueryData<TopicsSubscriptionsL...)
Declaraciones 'export' encontradas:
- export  type
- export function useTopicsSubscriptionsList
- export function useTopicsSubscriptionsListSuspense
- export function prefetchTopicsSubscriptionsList
- export function setTopicsSubscriptionsListData
- export function invalidateTopicsSubscriptionsList
- export function invalidateAllTopicsSubscriptionsList
- export function buildTopicsSubscriptionsListQuery
- export function queryKeyTopicsSubscriptionsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsUpdate.ts
Tamaño: 2491 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsUpdate } from "../funcs/topicsUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TopicsUpdateMutationVariables = {
  updateTopicRequestDto: components.UpdateTopicRequestDto;
  topicKey: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TopicsUpdateMutationData =
  operations.TopicsControllerUpdateTopicResponse;

/**
 * Update a topic
 *
 * @remarks
 * Update a topic name by its unique key identifier **topicKey**
 */
export function useTopicsUpdateMutation(
  options?: MutationHookOptions<
    TopicsUpdateMutationData,
    Error,
    TopicsUpdateMutationVariables
  >,
): UseMutationResult<
  TopicsUpdateMutationData,
  Error,
  TopicsUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTopicsUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeyTopicsUpdate(): MutationKey {
  return ["@novu/api", "Topics", "update"];
}

export function buildTopicsUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TopicsUpdateMutationVariables,
  ) => Promise<TopicsUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeyTopicsUpdate(),
    mutationFn: function topicsUpdateMutationFn({
      updateTopicRequestDto,
      topicKey,
      idempotencyKey,
      options,
    }): Promise<TopicsUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(topicsUpdate(
        client$,
        updateTopicRequestDto,
        topicKey,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsUpdateMutation(options?: MutationHookOptions<
    TopicsUpdateMutationData,
    Error,
    TopicsUpdateMutationVariables
  >,)
 - mutationKeyTopicsUpdate()
 - buildTopicsUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - topicsUpdateMutationFn({
      updateTopicRequestDto,
      topicKey,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTopicsUpdateMutation(client, options),
    ...o...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTopicsUpdateMutation
- export function mutationKeyTopicsUpdate
- export function buildTopicsUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsCreate.ts
Tamaño: 2554 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsCreate } from "../funcs/translationsCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TranslationsCreateMutationVariables = {
  createTranslationRequestDto: components.CreateTranslationRequestDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TranslationsCreateMutationData = components.TranslationResponseDto;

/**
 * Create a translation
 *
 * @remarks
 * Create a translation for a specific workflow and locale, if the translation already exists, it will be updated
 */
export function useTranslationsCreateMutation(
  options?: MutationHookOptions<
    TranslationsCreateMutationData,
    Error,
    TranslationsCreateMutationVariables
  >,
): UseMutationResult<
  TranslationsCreateMutationData,
  Error,
  TranslationsCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTranslationsCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeyTranslationsCreate(): MutationKey {
  return ["@novu/api", "Translations", "create"];
}

export function buildTranslationsCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TranslationsCreateMutationVariables,
  ) => Promise<TranslationsCreateMutationData>;
} {
  return {
    mutationKey: mutationKeyTranslationsCreate(),
    mutationFn: function translationsCreateMutationFn({
      createTranslationRequestDto,
      idempotencyKey,
      options,
    }): Promise<TranslationsCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(translationsCreate(
        client$,
        createTranslationRequestDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsCreateMutation(options?: MutationHookOptions<
    TranslationsCreateMutationData,
    Error,
    TranslationsCreateMutationVariables
  >,)
 - mutationKeyTranslationsCreate()
 - buildTranslationsCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - translationsCreateMutationFn({
      createTranslationRequestDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTranslationsCreateMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTranslationsCreateMutation
- export function mutationKeyTranslationsCreate
- export function buildTranslationsCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsDelete.ts
Tamaño: 2366 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsDelete } from "../funcs/translationsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TranslationsDeleteMutationVariables = {
  request: operations.TranslationControllerDeleteTranslationEndpointRequest;
  options?: RequestOptions;
};

export type TranslationsDeleteMutationData = void;

/**
 * Delete a translation
 *
 * @remarks
 * Delete a specific translation by resource type, resource ID and locale
 */
export function useTranslationsDeleteMutation(
  options?: MutationHookOptions<
    TranslationsDeleteMutationData,
    Error,
    TranslationsDeleteMutationVariables
  >,
): UseMutationResult<
  TranslationsDeleteMutationData,
  Error,
  TranslationsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTranslationsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyTranslationsDelete(): MutationKey {
  return ["@novu/api", "Translations", "delete"];
}

export function buildTranslationsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TranslationsDeleteMutationVariables,
  ) => Promise<TranslationsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyTranslationsDelete(),
    mutationFn: function translationsDeleteMutationFn({
      request,
      options,
    }): Promise<TranslationsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(translationsDelete(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsDeleteMutation(options?: MutationHookOptions<
    TranslationsDeleteMutationData,
    Error,
    TranslationsDeleteMutationVariables
  >,)
 - mutationKeyTranslationsDelete()
 - buildTranslationsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - translationsDeleteMutationFn({
      request,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTranslationsDeleteMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTranslationsDeleteMutation
- export function mutationKeyTranslationsDelete
- export function buildTranslationsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsGroupsDelete.ts
Tamaño: 2582 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsGroupsDelete } from "../funcs/translationsGroupsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TranslationsGroupsDeleteMutationVariables = {
  resourceType: operations.ResourceType;
  resourceId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TranslationsGroupsDeleteMutationData = void;

/**
 * Delete a translation group
 *
 * @remarks
 * Delete an entire translation group and all its translations
 */
export function useTranslationsGroupsDeleteMutation(
  options?: MutationHookOptions<
    TranslationsGroupsDeleteMutationData,
    Error,
    TranslationsGroupsDeleteMutationVariables
  >,
): UseMutationResult<
  TranslationsGroupsDeleteMutationData,
  Error,
  TranslationsGroupsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTranslationsGroupsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyTranslationsGroupsDelete(): MutationKey {
  return ["@novu/api", "Groups", "delete"];
}

export function buildTranslationsGroupsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TranslationsGroupsDeleteMutationVariables,
  ) => Promise<TranslationsGroupsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyTranslationsGroupsDelete(),
    mutationFn: function translationsGroupsDeleteMutationFn({
      resourceType,
      resourceId,
      idempotencyKey,
      options,
    }): Promise<TranslationsGroupsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(translationsGroupsDelete(
        client$,
        resourceType,
        resourceId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsGroupsDeleteMutation(options?: MutationHookOptions<
    TranslationsGroupsDeleteMutationData,
    Error,
    TranslationsGroupsDeleteMutationVariables
  >,)
 - mutationKeyTranslationsGroupsDelete()
 - buildTranslationsGroupsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - translationsGroupsDeleteMutationFn({
      resourceType,
      resourceId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTranslationsGroupsDeleteMutation(client, option...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTranslationsGroupsDeleteMutation
- export function mutationKeyTranslationsGroupsDelete
- export function buildTranslationsGroupsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsGroupsRetrieve.ts
Tamaño: 5609 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsGroupsRetrieve } from "../funcs/translationsGroupsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type TranslationsGroupsRetrieveQueryData =
  components.TranslationGroupDto;

/**
 * Retrieve a translation group
 *
 * @remarks
 * Retrieves a single translation group by resource type (workflow, layout) and resource ID (workflowId, layoutId)
 */
export function useTranslationsGroupsRetrieve(
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<TranslationsGroupsRetrieveQueryData>,
): UseQueryResult<TranslationsGroupsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildTranslationsGroupsRetrieveQuery(
      client,
      resourceType,
      resourceId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve a translation group
 *
 * @remarks
 * Retrieves a single translation group by resource type (workflow, layout) and resource ID (workflowId, layoutId)
 */
export function useTranslationsGroupsRetrieveSuspense(
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<TranslationsGroupsRetrieveQueryData>,
): UseSuspenseQueryResult<TranslationsGroupsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildTranslationsGroupsRetrieveQuery(
      client,
      resourceType,
      resourceId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchTranslationsGroupsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildTranslationsGroupsRetrieveQuery(
      client$,
      resourceType,
      resourceId,
      idempotencyKey,
    ),
  });
}

export function setTranslationsGroupsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    resourceType:
      operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
    resourceId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: TranslationsGroupsRetrieveQueryData,
): TranslationsGroupsRetrieveQueryData | undefined {
  const key = queryKeyTranslationsGroupsRetrieve(...queryKeyBase);

  return client.setQueryData<TranslationsGroupsRetrieveQueryData>(key, data);
}

export function invalidateTranslationsGroupsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      resourceType:
        operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
      resourceId: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Groups", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllTranslationsGroupsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Groups", "retrieve"],
  });
}

export function buildTranslationsGroupsRetrieveQuery(
  client$: NovuCore,
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<TranslationsGroupsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyTranslationsGroupsRetrieve(resourceType, resourceId, {
      idempotencyKey,
    }),
    queryFn: async function translationsGroupsRetrieveQueryFn(
      ctx,
    ): Promise<TranslationsGroupsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(translationsGroupsRetrieve(
        client$,
        resourceType,
        resourceId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyTranslationsGroupsRetrieve(
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return [
    "@novu/api",
    "Groups",
    "retrieve",
    resourceType,
    resourceId,
    parameters,
  ];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsGroupsRetrieve(resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<TranslationsGroupsRetrieveQueryData>,)
 - useTranslationsGroupsRetrieveSuspense(resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<TranslationsGroupsRetrieveQueryData>,)
 - prefetchTranslationsGroupsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,)
 - setTranslationsGroupsRetrieveData(client: QueryClient,
  queryKeyBase: [
    resourceType:
      operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
    resourceId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: TranslationsGroupsRetrieveQueryData,)
 - invalidateTranslationsGroupsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      resourceType:
        operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
      resourceId: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllTranslationsGroupsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildTranslationsGroupsRetrieveQuery(client$: NovuCore,
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - translationsGroupsRetrieveQueryFn(ctx,)
 - queryKeyTranslationsGroupsRetrieve(resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyTranslationsGroupsRetrieve(...queryKeyBase);

  return client.setQueryData<TranslationsGroup...)
Declaraciones 'export' encontradas:
- export  type
- export function useTranslationsGroupsRetrieve
- export function useTranslationsGroupsRetrieveSuspense
- export function prefetchTranslationsGroupsRetrieve
- export function setTranslationsGroupsRetrieveData
- export function invalidateTranslationsGroupsRetrieve
- export function invalidateAllTranslationsGroupsRetrieve
- export function buildTranslationsGroupsRetrieveQuery
- export function queryKeyTranslationsGroupsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsMasterImport.ts
Tamaño: 2648 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsMasterImport } from "../funcs/translationsMasterImport.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TranslationsMasterImportMutationVariables = {
  importMasterJsonRequestDto: components.ImportMasterJsonRequestDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TranslationsMasterImportMutationData =
  components.ImportMasterJsonResponseDto;

/**
 * Import master translations JSON
 *
 * @remarks
 * Import translations for multiple workflows from master JSON format for a specific locale
 */
export function useTranslationsMasterImportMutation(
  options?: MutationHookOptions<
    TranslationsMasterImportMutationData,
    Error,
    TranslationsMasterImportMutationVariables
  >,
): UseMutationResult<
  TranslationsMasterImportMutationData,
  Error,
  TranslationsMasterImportMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTranslationsMasterImportMutation(client, options),
    ...options,
  });
}

export function mutationKeyTranslationsMasterImport(): MutationKey {
  return ["@novu/api", "master", "import"];
}

export function buildTranslationsMasterImportMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TranslationsMasterImportMutationVariables,
  ) => Promise<TranslationsMasterImportMutationData>;
} {
  return {
    mutationKey: mutationKeyTranslationsMasterImport(),
    mutationFn: function translationsMasterImportMutationFn({
      importMasterJsonRequestDto,
      idempotencyKey,
      options,
    }): Promise<TranslationsMasterImportMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(translationsMasterImport(
        client$,
        importMasterJsonRequestDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsMasterImportMutation(options?: MutationHookOptions<
    TranslationsMasterImportMutationData,
    Error,
    TranslationsMasterImportMutationVariables
  >,)
 - mutationKeyTranslationsMasterImport()
 - buildTranslationsMasterImportMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - translationsMasterImportMutationFn({
      importMasterJsonRequestDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTranslationsMasterImportMutation(client, option...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTranslationsMasterImportMutation
- export function mutationKeyTranslationsMasterImport
- export function buildTranslationsMasterImportMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsMasterRetrieve.ts
Tamaño: 4710 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsMasterRetrieve } from "../funcs/translationsMasterRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type TranslationsMasterRetrieveQueryData =
  components.GetMasterJsonResponseDto;

/**
 * Retrieve master translations JSON
 *
 * @remarks
 * Retrieve all translations for a locale in master JSON format organized by resourceId (workflowId)
 */
export function useTranslationsMasterRetrieve(
  locale?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<TranslationsMasterRetrieveQueryData>,
): UseQueryResult<TranslationsMasterRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildTranslationsMasterRetrieveQuery(
      client,
      locale,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve master translations JSON
 *
 * @remarks
 * Retrieve all translations for a locale in master JSON format organized by resourceId (workflowId)
 */
export function useTranslationsMasterRetrieveSuspense(
  locale?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<TranslationsMasterRetrieveQueryData>,
): UseSuspenseQueryResult<TranslationsMasterRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildTranslationsMasterRetrieveQuery(
      client,
      locale,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchTranslationsMasterRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  locale?: string | undefined,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildTranslationsMasterRetrieveQuery(
      client$,
      locale,
      idempotencyKey,
    ),
  });
}

export function setTranslationsMasterRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      locale?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: TranslationsMasterRetrieveQueryData,
): TranslationsMasterRetrieveQueryData | undefined {
  const key = queryKeyTranslationsMasterRetrieve(...queryKeyBase);

  return client.setQueryData<TranslationsMasterRetrieveQueryData>(key, data);
}

export function invalidateTranslationsMasterRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      locale?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "master", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllTranslationsMasterRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "master", "retrieve"],
  });
}

export function buildTranslationsMasterRetrieveQuery(
  client$: NovuCore,
  locale?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<TranslationsMasterRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyTranslationsMasterRetrieve({ locale, idempotencyKey }),
    queryFn: async function translationsMasterRetrieveQueryFn(
      ctx,
    ): Promise<TranslationsMasterRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(translationsMasterRetrieve(
        client$,
        locale,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyTranslationsMasterRetrieve(
  parameters: {
    locale?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "master", "retrieve", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsMasterRetrieve(locale?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<TranslationsMasterRetrieveQueryData>,)
 - useTranslationsMasterRetrieveSuspense(locale?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<TranslationsMasterRetrieveQueryData>,)
 - prefetchTranslationsMasterRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  locale?: string | undefined,
  idempotencyKey?: string | undefined,)
 - setTranslationsMasterRetrieveData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      locale?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: TranslationsMasterRetrieveQueryData,)
 - invalidateTranslationsMasterRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      locale?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllTranslationsMasterRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildTranslationsMasterRetrieveQuery(client$: NovuCore,
  locale?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - translationsMasterRetrieveQueryFn(ctx,)
 - queryKeyTranslationsMasterRetrieve(parameters: {
    locale?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyTranslationsMasterRetrieve(...queryKeyBase);

  return client.setQueryData<TranslationsMaste...)
Declaraciones 'export' encontradas:
- export  type
- export function useTranslationsMasterRetrieve
- export function useTranslationsMasterRetrieveSuspense
- export function prefetchTranslationsMasterRetrieve
- export function setTranslationsMasterRetrieveData
- export function invalidateTranslationsMasterRetrieve
- export function invalidateAllTranslationsMasterRetrieve
- export function buildTranslationsMasterRetrieveQuery
- export function queryKeyTranslationsMasterRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsMasterUpload.ts
Tamaño: 2565 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsMasterUpload } from "../funcs/translationsMasterUpload.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TranslationsMasterUploadMutationVariables = {
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TranslationsMasterUploadMutationData =
  components.ImportMasterJsonResponseDto;

/**
 * Upload master translations JSON file
 *
 * @remarks
 * Upload a master JSON file containing translations for multiple workflows. Locale is automatically detected from filename (e.g., en_US.json)
 */
export function useTranslationsMasterUploadMutation(
  options?: MutationHookOptions<
    TranslationsMasterUploadMutationData,
    Error,
    TranslationsMasterUploadMutationVariables
  >,
): UseMutationResult<
  TranslationsMasterUploadMutationData,
  Error,
  TranslationsMasterUploadMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTranslationsMasterUploadMutation(client, options),
    ...options,
  });
}

export function mutationKeyTranslationsMasterUpload(): MutationKey {
  return ["@novu/api", "master", "upload"];
}

export function buildTranslationsMasterUploadMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TranslationsMasterUploadMutationVariables,
  ) => Promise<TranslationsMasterUploadMutationData>;
} {
  return {
    mutationKey: mutationKeyTranslationsMasterUpload(),
    mutationFn: function translationsMasterUploadMutationFn({
      idempotencyKey,
      options,
    }): Promise<TranslationsMasterUploadMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(translationsMasterUpload(
        client$,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsMasterUploadMutation(options?: MutationHookOptions<
    TranslationsMasterUploadMutationData,
    Error,
    TranslationsMasterUploadMutationVariables
  >,)
 - mutationKeyTranslationsMasterUpload()
 - buildTranslationsMasterUploadMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - translationsMasterUploadMutationFn({
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTranslationsMasterUploadMutation(client, option...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTranslationsMasterUploadMutation
- export function mutationKeyTranslationsMasterUpload
- export function buildTranslationsMasterUploadMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsRetrieve.ts
Tamaño: 4814 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsRetrieve } from "../funcs/translationsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type TranslationsRetrieveQueryData = components.TranslationResponseDto;

/**
 * Retrieve a translation
 *
 * @remarks
 * Retrieve a specific translation by resource type, resource ID and locale
 */
export function useTranslationsRetrieve(
  request: operations.TranslationControllerGetSingleTranslationRequest,
  options?: QueryHookOptions<TranslationsRetrieveQueryData>,
): UseQueryResult<TranslationsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildTranslationsRetrieveQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve a translation
 *
 * @remarks
 * Retrieve a specific translation by resource type, resource ID and locale
 */
export function useTranslationsRetrieveSuspense(
  request: operations.TranslationControllerGetSingleTranslationRequest,
  options?: SuspenseQueryHookOptions<TranslationsRetrieveQueryData>,
): UseSuspenseQueryResult<TranslationsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildTranslationsRetrieveQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchTranslationsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.TranslationControllerGetSingleTranslationRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildTranslationsRetrieveQuery(
      client$,
      request,
    ),
  });
}

export function setTranslationsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    resourceType: operations.PathParamResourceType,
    resourceId: string,
    locale: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: TranslationsRetrieveQueryData,
): TranslationsRetrieveQueryData | undefined {
  const key = queryKeyTranslationsRetrieve(...queryKeyBase);

  return client.setQueryData<TranslationsRetrieveQueryData>(key, data);
}

export function invalidateTranslationsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      resourceType: operations.PathParamResourceType,
      resourceId: string,
      locale: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Translations", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllTranslationsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Translations", "retrieve"],
  });
}

export function buildTranslationsRetrieveQuery(
  client$: NovuCore,
  request: operations.TranslationControllerGetSingleTranslationRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<TranslationsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyTranslationsRetrieve(
      request.resourceType,
      request.resourceId,
      request.locale,
      { idempotencyKey: request.idempotencyKey },
    ),
    queryFn: async function translationsRetrieveQueryFn(
      ctx,
    ): Promise<TranslationsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(translationsRetrieve(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyTranslationsRetrieve(
  resourceType: operations.PathParamResourceType,
  resourceId: string,
  locale: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return [
    "@novu/api",
    "Translations",
    "retrieve",
    resourceType,
    resourceId,
    locale,
    parameters,
  ];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsRetrieve(request: operations.TranslationControllerGetSingleTranslationRequest,
  options?: QueryHookOptions<TranslationsRetrieveQueryData>,)
 - useTranslationsRetrieveSuspense(request: operations.TranslationControllerGetSingleTranslationRequest,
  options?: SuspenseQueryHookOptions<TranslationsRetrieveQueryData>,)
 - prefetchTranslationsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.TranslationControllerGetSingleTranslationRequest,)
 - setTranslationsRetrieveData(client: QueryClient,
  queryKeyBase: [
    resourceType: operations.PathParamResourceType,
    resourceId: string,
    locale: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: TranslationsRetrieveQueryData,)
 - invalidateTranslationsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      resourceType: operations.PathParamResourceType,
      resourceId: string,
      locale: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllTranslationsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildTranslationsRetrieveQuery(client$: NovuCore,
  request: operations.TranslationControllerGetSingleTranslationRequest,
  options?: RequestOptions,)
 - translationsRetrieveQueryFn(ctx,)
 - queryKeyTranslationsRetrieve(resourceType: operations.PathParamResourceType,
  resourceId: string,
  locale: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyTranslationsRetrieve(...queryKeyBase);

  return client.setQueryData<TranslationsRetrieveQue...)
Declaraciones 'export' encontradas:
- export  type
- export function useTranslationsRetrieve
- export function useTranslationsRetrieveSuspense
- export function prefetchTranslationsRetrieve
- export function setTranslationsRetrieveData
- export function invalidateTranslationsRetrieve
- export function invalidateAllTranslationsRetrieve
- export function buildTranslationsRetrieveQuery
- export function queryKeyTranslationsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsUpload.ts
Tamaño: 2577 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsUpload } from "../funcs/translationsUpload.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TranslationsUploadMutationVariables = {
  uploadTranslationsRequestDto: components.UploadTranslationsRequestDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TranslationsUploadMutationData =
  components.UploadTranslationsResponseDto;

/**
 * Upload translation files
 *
 * @remarks
 * Upload one or more JSON translation files for a specific workflow. Files name must match the locale, e.g. en_US.json
 */
export function useTranslationsUploadMutation(
  options?: MutationHookOptions<
    TranslationsUploadMutationData,
    Error,
    TranslationsUploadMutationVariables
  >,
): UseMutationResult<
  TranslationsUploadMutationData,
  Error,
  TranslationsUploadMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTranslationsUploadMutation(client, options),
    ...options,
  });
}

export function mutationKeyTranslationsUpload(): MutationKey {
  return ["@novu/api", "Translations", "upload"];
}

export function buildTranslationsUploadMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TranslationsUploadMutationVariables,
  ) => Promise<TranslationsUploadMutationData>;
} {
  return {
    mutationKey: mutationKeyTranslationsUpload(),
    mutationFn: function translationsUploadMutationFn({
      uploadTranslationsRequestDto,
      idempotencyKey,
      options,
    }): Promise<TranslationsUploadMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(translationsUpload(
        client$,
        uploadTranslationsRequestDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsUploadMutation(options?: MutationHookOptions<
    TranslationsUploadMutationData,
    Error,
    TranslationsUploadMutationVariables
  >,)
 - mutationKeyTranslationsUpload()
 - buildTranslationsUploadMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - translationsUploadMutationFn({
      uploadTranslationsRequestDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTranslationsUploadMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTranslationsUploadMutation
- export function mutationKeyTranslationsUpload
- export function buildTranslationsUploadMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/trigger.ts
Tamaño: 2736 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { trigger } from "../funcs/trigger.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TriggerMutationVariables = {
  triggerEventRequestDto: components.TriggerEventRequestDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TriggerMutationData = operations.EventsControllerTriggerResponse;

/**
 * Trigger event
 *
 * @remarks
 *
 *     Trigger event is the main (and only) way to send notifications to subscribers. The trigger identifier is used to match the particular workflow associated with it. Additional information can be passed according the body interface below.
 *     To prevent duplicate triggers, you can optionally pass a **transactionId** in the request body. If the same **transactionId** is used again, the trigger will be ignored. The retention period depends on your billing tier.
 */
export function useTriggerMutation(
  options?: MutationHookOptions<
    TriggerMutationData,
    Error,
    TriggerMutationVariables
  >,
): UseMutationResult<TriggerMutationData, Error, TriggerMutationVariables> {
  const client = useNovuContext();
  return useMutation({
    ...buildTriggerMutation(client, options),
    ...options,
  });
}

export function mutationKeyTrigger(): MutationKey {
  return ["@novu/api", "trigger"];
}

export function buildTriggerMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TriggerMutationVariables,
  ) => Promise<TriggerMutationData>;
} {
  return {
    mutationKey: mutationKeyTrigger(),
    mutationFn: function triggerMutationFn({
      triggerEventRequestDto,
      idempotencyKey,
      options,
    }): Promise<TriggerMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(trigger(
        client$,
        triggerEventRequestDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTriggerMutation(options?: MutationHookOptions<
    TriggerMutationData,
    Error,
    TriggerMutationVariables
  >,)
 - mutationKeyTrigger()
 - buildTriggerMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - triggerMutationFn({
      triggerEventRequestDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTriggerMutation(client, options),
    ...option...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTriggerMutation
- export function mutationKeyTrigger
- export function buildTriggerMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/triggerBroadcast.ts
Tamaño: 2692 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { triggerBroadcast } from "../funcs/triggerBroadcast.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TriggerBroadcastMutationVariables = {
  triggerEventToAllRequestDto: components.TriggerEventToAllRequestDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TriggerBroadcastMutationData =
  operations.EventsControllerBroadcastEventToAllResponse;

/**
 * Broadcast event to all
 *
 * @remarks
 * Trigger a broadcast event to all existing subscribers, could be used to send announcements, etc.
 *       In the future could be used to trigger events to a subset of subscribers based on defined filters.
 */
export function useTriggerBroadcastMutation(
  options?: MutationHookOptions<
    TriggerBroadcastMutationData,
    Error,
    TriggerBroadcastMutationVariables
  >,
): UseMutationResult<
  TriggerBroadcastMutationData,
  Error,
  TriggerBroadcastMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTriggerBroadcastMutation(client, options),
    ...options,
  });
}

export function mutationKeyTriggerBroadcast(): MutationKey {
  return ["@novu/api", "triggerBroadcast"];
}

export function buildTriggerBroadcastMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TriggerBroadcastMutationVariables,
  ) => Promise<TriggerBroadcastMutationData>;
} {
  return {
    mutationKey: mutationKeyTriggerBroadcast(),
    mutationFn: function triggerBroadcastMutationFn({
      triggerEventToAllRequestDto,
      idempotencyKey,
      options,
    }): Promise<TriggerBroadcastMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(triggerBroadcast(
        client$,
        triggerEventToAllRequestDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTriggerBroadcastMutation(options?: MutationHookOptions<
    TriggerBroadcastMutationData,
    Error,
    TriggerBroadcastMutationVariables
  >,)
 - mutationKeyTriggerBroadcast()
 - buildTriggerBroadcastMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - triggerBroadcastMutationFn({
      triggerEventToAllRequestDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTriggerBroadcastMutation(client, options),
    ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTriggerBroadcastMutation
- export function mutationKeyTriggerBroadcast
- export function buildTriggerBroadcastMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/triggerBulk.ts
Tamaño: 2514 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { triggerBulk } from "../funcs/triggerBulk.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TriggerBulkMutationVariables = {
  bulkTriggerEventDto: components.BulkTriggerEventDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TriggerBulkMutationData =
  operations.EventsControllerTriggerBulkResponse;

/**
 * Bulk trigger event
 *
 * @remarks
 *
 *       Using this endpoint you can trigger multiple events at once, to avoid multiple calls to the API.
 *       The bulk API is limited to 100 events per request.
 */
export function useTriggerBulkMutation(
  options?: MutationHookOptions<
    TriggerBulkMutationData,
    Error,
    TriggerBulkMutationVariables
  >,
): UseMutationResult<
  TriggerBulkMutationData,
  Error,
  TriggerBulkMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTriggerBulkMutation(client, options),
    ...options,
  });
}

export function mutationKeyTriggerBulk(): MutationKey {
  return ["@novu/api", "triggerBulk"];
}

export function buildTriggerBulkMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TriggerBulkMutationVariables,
  ) => Promise<TriggerBulkMutationData>;
} {
  return {
    mutationKey: mutationKeyTriggerBulk(),
    mutationFn: function triggerBulkMutationFn({
      bulkTriggerEventDto,
      idempotencyKey,
      options,
    }): Promise<TriggerBulkMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(triggerBulk(
        client$,
        bulkTriggerEventDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTriggerBulkMutation(options?: MutationHookOptions<
    TriggerBulkMutationData,
    Error,
    TriggerBulkMutationVariables
  >,)
 - mutationKeyTriggerBulk()
 - buildTriggerBulkMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - triggerBulkMutationFn({
      bulkTriggerEventDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTriggerBulkMutation(client, options),
    ...op...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTriggerBulkMutation
- export function mutationKeyTriggerBulk
- export function buildTriggerBulkMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsCreate.ts
Tamaño: 2469 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsCreate } from "../funcs/workflowsCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type WorkflowsCreateMutationVariables = {
  createWorkflowDto: components.CreateWorkflowDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type WorkflowsCreateMutationData =
  operations.WorkflowControllerCreateResponse;

/**
 * Create a workflow
 *
 * @remarks
 * Creates a new workflow in the Novu Cloud environment
 */
export function useWorkflowsCreateMutation(
  options?: MutationHookOptions<
    WorkflowsCreateMutationData,
    Error,
    WorkflowsCreateMutationVariables
  >,
): UseMutationResult<
  WorkflowsCreateMutationData,
  Error,
  WorkflowsCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildWorkflowsCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeyWorkflowsCreate(): MutationKey {
  return ["@novu/api", "Workflows", "create"];
}

export function buildWorkflowsCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: WorkflowsCreateMutationVariables,
  ) => Promise<WorkflowsCreateMutationData>;
} {
  return {
    mutationKey: mutationKeyWorkflowsCreate(),
    mutationFn: function workflowsCreateMutationFn({
      createWorkflowDto,
      idempotencyKey,
      options,
    }): Promise<WorkflowsCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(workflowsCreate(
        client$,
        createWorkflowDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsCreateMutation(options?: MutationHookOptions<
    WorkflowsCreateMutationData,
    Error,
    WorkflowsCreateMutationVariables
  >,)
 - mutationKeyWorkflowsCreate()
 - buildWorkflowsCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - workflowsCreateMutationFn({
      createWorkflowDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildWorkflowsCreateMutation(client, options),
    ....)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useWorkflowsCreateMutation
- export function mutationKeyWorkflowsCreate
- export function buildWorkflowsCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsDelete.ts
Tamaño: 2404 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsDelete } from "../funcs/workflowsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type WorkflowsDeleteMutationVariables = {
  workflowId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type WorkflowsDeleteMutationData =
  | operations.WorkflowControllerRemoveWorkflowResponse
  | undefined;

/**
 * Delete a workflow
 *
 * @remarks
 * Removes a specific workflow by its unique identifier **workflowId**
 */
export function useWorkflowsDeleteMutation(
  options?: MutationHookOptions<
    WorkflowsDeleteMutationData,
    Error,
    WorkflowsDeleteMutationVariables
  >,
): UseMutationResult<
  WorkflowsDeleteMutationData,
  Error,
  WorkflowsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildWorkflowsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyWorkflowsDelete(): MutationKey {
  return ["@novu/api", "Workflows", "delete"];
}

export function buildWorkflowsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: WorkflowsDeleteMutationVariables,
  ) => Promise<WorkflowsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyWorkflowsDelete(),
    mutationFn: function workflowsDeleteMutationFn({
      workflowId,
      idempotencyKey,
      options,
    }): Promise<WorkflowsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(workflowsDelete(
        client$,
        workflowId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsDeleteMutation(options?: MutationHookOptions<
    WorkflowsDeleteMutationData,
    Error,
    WorkflowsDeleteMutationVariables
  >,)
 - mutationKeyWorkflowsDelete()
 - buildWorkflowsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - workflowsDeleteMutationFn({
      workflowId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildWorkflowsDeleteMutation(client, options),
    ....)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useWorkflowsDeleteMutation
- export function mutationKeyWorkflowsDelete
- export function buildWorkflowsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsDuplicate.ts
Tamaño: 2688 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsDuplicate } from "../funcs/workflowsDuplicate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type WorkflowsDuplicateMutationVariables = {
  duplicateWorkflowDto: components.DuplicateWorkflowDto;
  workflowId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type WorkflowsDuplicateMutationData =
  operations.WorkflowControllerDuplicateWorkflowResponse;

/**
 * Duplicate a workflow
 *
 * @remarks
 * Duplicates a workflow by its unique identifier **workflowId**. This will create a new workflow with the same steps and settings.
 */
export function useWorkflowsDuplicateMutation(
  options?: MutationHookOptions<
    WorkflowsDuplicateMutationData,
    Error,
    WorkflowsDuplicateMutationVariables
  >,
): UseMutationResult<
  WorkflowsDuplicateMutationData,
  Error,
  WorkflowsDuplicateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildWorkflowsDuplicateMutation(client, options),
    ...options,
  });
}

export function mutationKeyWorkflowsDuplicate(): MutationKey {
  return ["@novu/api", "Workflows", "duplicate"];
}

export function buildWorkflowsDuplicateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: WorkflowsDuplicateMutationVariables,
  ) => Promise<WorkflowsDuplicateMutationData>;
} {
  return {
    mutationKey: mutationKeyWorkflowsDuplicate(),
    mutationFn: function workflowsDuplicateMutationFn({
      duplicateWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    }): Promise<WorkflowsDuplicateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(workflowsDuplicate(
        client$,
        duplicateWorkflowDto,
        workflowId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsDuplicateMutation(options?: MutationHookOptions<
    WorkflowsDuplicateMutationData,
    Error,
    WorkflowsDuplicateMutationVariables
  >,)
 - mutationKeyWorkflowsDuplicate()
 - buildWorkflowsDuplicateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - workflowsDuplicateMutationFn({
      duplicateWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildWorkflowsDuplicateMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useWorkflowsDuplicateMutation
- export function mutationKeyWorkflowsDuplicate
- export function buildWorkflowsDuplicateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsGet.ts
Tamaño: 4642 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsGet } from "../funcs/workflowsGet.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type WorkflowsGetQueryData =
  operations.WorkflowControllerGetWorkflowResponse;

/**
 * Retrieve a workflow
 *
 * @remarks
 * Fetches details of a specific workflow by its unique identifier **workflowId**
 */
export function useWorkflowsGet(
  workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<WorkflowsGetQueryData>,
): UseQueryResult<WorkflowsGetQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildWorkflowsGetQuery(
      client,
      workflowId,
      environmentId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve a workflow
 *
 * @remarks
 * Fetches details of a specific workflow by its unique identifier **workflowId**
 */
export function useWorkflowsGetSuspense(
  workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<WorkflowsGetQueryData>,
): UseSuspenseQueryResult<WorkflowsGetQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildWorkflowsGetQuery(
      client,
      workflowId,
      environmentId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchWorkflowsGet(
  queryClient: QueryClient,
  client$: NovuCore,
  workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildWorkflowsGetQuery(
      client$,
      workflowId,
      environmentId,
      idempotencyKey,
    ),
  });
}

export function setWorkflowsGetData(
  client: QueryClient,
  queryKeyBase: [
    workflowId: string,
    parameters: {
      environmentId?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: WorkflowsGetQueryData,
): WorkflowsGetQueryData | undefined {
  const key = queryKeyWorkflowsGet(...queryKeyBase);

  return client.setQueryData<WorkflowsGetQueryData>(key, data);
}

export function invalidateWorkflowsGet(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      workflowId: string,
      parameters: {
        environmentId?: string | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Workflows", "get", ...queryKeyBase],
  });
}

export function invalidateAllWorkflowsGet(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Workflows", "get"],
  });
}

export function buildWorkflowsGetQuery(
  client$: NovuCore,
  workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (context: QueryFunctionContext) => Promise<WorkflowsGetQueryData>;
} {
  return {
    queryKey: queryKeyWorkflowsGet(workflowId, {
      environmentId,
      idempotencyKey,
    }),
    queryFn: async function workflowsGetQueryFn(
      ctx,
    ): Promise<WorkflowsGetQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(workflowsGet(
        client$,
        workflowId,
        environmentId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyWorkflowsGet(
  workflowId: string,
  parameters: {
    environmentId?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Workflows", "get", workflowId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsGet(workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<WorkflowsGetQueryData>,)
 - useWorkflowsGetSuspense(workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<WorkflowsGetQueryData>,)
 - prefetchWorkflowsGet(queryClient: QueryClient,
  client$: NovuCore,
  workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,)
 - setWorkflowsGetData(client: QueryClient,
  queryKeyBase: [
    workflowId: string,
    parameters: {
      environmentId?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: WorkflowsGetQueryData,)
 - invalidateWorkflowsGet(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      workflowId: string,
      parameters: {
        environmentId?: string | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllWorkflowsGet(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildWorkflowsGetQuery(client$: NovuCore,
  workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - workflowsGetQueryFn(ctx,)
 - queryKeyWorkflowsGet(workflowId: string,
  parameters: {
    environmentId?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyWorkflowsGet(...queryKeyBase);

  return client.setQueryData<WorkflowsGetQueryData>(key, dat...)
Declaraciones 'export' encontradas:
- export  type
- export function useWorkflowsGet
- export function useWorkflowsGetSuspense
- export function prefetchWorkflowsGet
- export function setWorkflowsGetData
- export function invalidateWorkflowsGet
- export function invalidateAllWorkflowsGet
- export function buildWorkflowsGetQuery
- export function queryKeyWorkflowsGet

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsList.ts
Tamaño: 5371 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsList } from "../funcs/workflowsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type WorkflowsListQueryData =
  operations.WorkflowControllerSearchWorkflowsResponse;

/**
 * List all workflows
 *
 * @remarks
 * Retrieves a list of workflows with optional filtering and pagination
 */
export function useWorkflowsList(
  request: operations.WorkflowControllerSearchWorkflowsRequest,
  options?: QueryHookOptions<WorkflowsListQueryData>,
): UseQueryResult<WorkflowsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildWorkflowsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List all workflows
 *
 * @remarks
 * Retrieves a list of workflows with optional filtering and pagination
 */
export function useWorkflowsListSuspense(
  request: operations.WorkflowControllerSearchWorkflowsRequest,
  options?: SuspenseQueryHookOptions<WorkflowsListQueryData>,
): UseSuspenseQueryResult<WorkflowsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildWorkflowsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchWorkflowsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.WorkflowControllerSearchWorkflowsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildWorkflowsListQuery(
      client$,
      request,
    ),
  });
}

export function setWorkflowsListData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      limit?: number | undefined;
      offset?: number | undefined;
      orderDirection?: components.DirectionEnum | undefined;
      orderBy?: components.WorkflowResponseDtoSortField | undefined;
      query?: string | undefined;
      tags?: Array<string> | undefined;
      status?: Array<components.WorkflowStatusEnum> | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: WorkflowsListQueryData,
): WorkflowsListQueryData | undefined {
  const key = queryKeyWorkflowsList(...queryKeyBase);

  return client.setQueryData<WorkflowsListQueryData>(key, data);
}

export function invalidateWorkflowsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      limit?: number | undefined;
      offset?: number | undefined;
      orderDirection?: components.DirectionEnum | undefined;
      orderBy?: components.WorkflowResponseDtoSortField | undefined;
      query?: string | undefined;
      tags?: Array<string> | undefined;
      status?: Array<components.WorkflowStatusEnum> | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Workflows", "list", ...queryKeyBase],
  });
}

export function invalidateAllWorkflowsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Workflows", "list"],
  });
}

export function buildWorkflowsListQuery(
  client$: NovuCore,
  request: operations.WorkflowControllerSearchWorkflowsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (context: QueryFunctionContext) => Promise<WorkflowsListQueryData>;
} {
  return {
    queryKey: queryKeyWorkflowsList({
      limit: request.limit,
      offset: request.offset,
      orderDirection: request.orderDirection,
      orderBy: request.orderBy,
      query: request.query,
      tags: request.tags,
      status: request.status,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function workflowsListQueryFn(
      ctx,
    ): Promise<WorkflowsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(workflowsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyWorkflowsList(
  parameters: {
    limit?: number | undefined;
    offset?: number | undefined;
    orderDirection?: components.DirectionEnum | undefined;
    orderBy?: components.WorkflowResponseDtoSortField | undefined;
    query?: string | undefined;
    tags?: Array<string> | undefined;
    status?: Array<components.WorkflowStatusEnum> | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Workflows", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsList(request: operations.WorkflowControllerSearchWorkflowsRequest,
  options?: QueryHookOptions<WorkflowsListQueryData>,)
 - useWorkflowsListSuspense(request: operations.WorkflowControllerSearchWorkflowsRequest,
  options?: SuspenseQueryHookOptions<WorkflowsListQueryData>,)
 - prefetchWorkflowsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.WorkflowControllerSearchWorkflowsRequest,)
 - setWorkflowsListData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      limit?: number | undefined;
      offset?: number | undefined;
      orderDirection?: components.DirectionEnum | undefined;
      orderBy?: components.WorkflowResponseDtoSortField | undefined;
      query?: string | undefined;
      tags?: Array<string> | undefined;
      status?: Array<components.WorkflowStatusEnum> | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: WorkflowsListQueryData,)
 - invalidateWorkflowsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      limit?: number | undefined;
      offset?: number | undefined;
      orderDirection?: components.DirectionEnum | undefined;
      orderBy?: components.WorkflowResponseDtoSortField | undefined;
      query?: string | undefined;
      tags?: Array<string> | undefined;
      status?: Array<components.WorkflowStatusEnum> | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllWorkflowsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildWorkflowsListQuery(client$: NovuCore,
  request: operations.WorkflowControllerSearchWorkflowsRequest,
  options?: RequestOptions,)
 - workflowsListQueryFn(ctx,)
 - queryKeyWorkflowsList(parameters: {
    limit?: number | undefined;
    offset?: number | undefined;
    orderDirection?: components.DirectionEnum | undefined;
    orderBy?: components.WorkflowResponseDtoSortField | undefined;
    query?: string | undefined;
    tags?: Array<string> | undefined;
    status?: Array<components.WorkflowStatusEnum> | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyWorkflowsList(...queryKeyBase);

  return client.setQueryData<WorkflowsListQueryData>(key, d...)
Declaraciones 'export' encontradas:
- export  type
- export function useWorkflowsList
- export function useWorkflowsListSuspense
- export function prefetchWorkflowsList
- export function setWorkflowsListData
- export function invalidateWorkflowsList
- export function invalidateAllWorkflowsList
- export function buildWorkflowsListQuery
- export function queryKeyWorkflowsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsPatch.ts
Tamaño: 2529 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsPatch } from "../funcs/workflowsPatch.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type WorkflowsPatchMutationVariables = {
  patchWorkflowDto: components.PatchWorkflowDto;
  workflowId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type WorkflowsPatchMutationData =
  operations.WorkflowControllerPatchWorkflowResponse;

/**
 * Update a workflow
 *
 * @remarks
 * Partially updates a workflow by its unique identifier **workflowId**
 */
export function useWorkflowsPatchMutation(
  options?: MutationHookOptions<
    WorkflowsPatchMutationData,
    Error,
    WorkflowsPatchMutationVariables
  >,
): UseMutationResult<
  WorkflowsPatchMutationData,
  Error,
  WorkflowsPatchMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildWorkflowsPatchMutation(client, options),
    ...options,
  });
}

export function mutationKeyWorkflowsPatch(): MutationKey {
  return ["@novu/api", "Workflows", "patch"];
}

export function buildWorkflowsPatchMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: WorkflowsPatchMutationVariables,
  ) => Promise<WorkflowsPatchMutationData>;
} {
  return {
    mutationKey: mutationKeyWorkflowsPatch(),
    mutationFn: function workflowsPatchMutationFn({
      patchWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    }): Promise<WorkflowsPatchMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(workflowsPatch(
        client$,
        patchWorkflowDto,
        workflowId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsPatchMutation(options?: MutationHookOptions<
    WorkflowsPatchMutationData,
    Error,
    WorkflowsPatchMutationVariables
  >,)
 - mutationKeyWorkflowsPatch()
 - buildWorkflowsPatchMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - workflowsPatchMutationFn({
      patchWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildWorkflowsPatchMutation(client, options),
    .....)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useWorkflowsPatchMutation
- export function mutationKeyWorkflowsPatch
- export function buildWorkflowsPatchMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsStepsGeneratePreview.ts
Tamaño: 2618 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsStepsGeneratePreview } from "../funcs/workflowsStepsGeneratePreview.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type WorkflowsStepsGeneratePreviewMutationVariables = {
  request: operations.WorkflowControllerGeneratePreviewRequest;
  options?: RequestOptions;
};

export type WorkflowsStepsGeneratePreviewMutationData =
  operations.WorkflowControllerGeneratePreviewResponse;

/**
 * Generate step preview
 *
 * @remarks
 * Generates a preview for a specific workflow step by its unique identifier **stepId**
 */
export function useWorkflowsStepsGeneratePreviewMutation(
  options?: MutationHookOptions<
    WorkflowsStepsGeneratePreviewMutationData,
    Error,
    WorkflowsStepsGeneratePreviewMutationVariables
  >,
): UseMutationResult<
  WorkflowsStepsGeneratePreviewMutationData,
  Error,
  WorkflowsStepsGeneratePreviewMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildWorkflowsStepsGeneratePreviewMutation(client, options),
    ...options,
  });
}

export function mutationKeyWorkflowsStepsGeneratePreview(): MutationKey {
  return ["@novu/api", "Steps", "generatePreview"];
}

export function buildWorkflowsStepsGeneratePreviewMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: WorkflowsStepsGeneratePreviewMutationVariables,
  ) => Promise<WorkflowsStepsGeneratePreviewMutationData>;
} {
  return {
    mutationKey: mutationKeyWorkflowsStepsGeneratePreview(),
    mutationFn: function workflowsStepsGeneratePreviewMutationFn({
      request,
      options,
    }): Promise<WorkflowsStepsGeneratePreviewMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(workflowsStepsGeneratePreview(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsStepsGeneratePreviewMutation(options?: MutationHookOptions<
    WorkflowsStepsGeneratePreviewMutationData,
    Error,
    WorkflowsStepsGeneratePreviewMutationVariables
  >,)
 - mutationKeyWorkflowsStepsGeneratePreview()
 - buildWorkflowsStepsGeneratePreviewMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - workflowsStepsGeneratePreviewMutationFn({
      request,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildWorkflowsStepsGeneratePreviewMutation(client, o...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useWorkflowsStepsGeneratePreviewMutation
- export function mutationKeyWorkflowsStepsGeneratePreview
- export function buildWorkflowsStepsGeneratePreviewMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsStepsRetrieve.ts
Tamaño: 4666 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsStepsRetrieve } from "../funcs/workflowsStepsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type WorkflowsStepsRetrieveQueryData =
  operations.WorkflowControllerGetWorkflowStepDataResponse;

/**
 * Retrieve workflow step
 *
 * @remarks
 * Retrieves data for a specific step in a workflow
 */
export function useWorkflowsStepsRetrieve(
  workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<WorkflowsStepsRetrieveQueryData>,
): UseQueryResult<WorkflowsStepsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildWorkflowsStepsRetrieveQuery(
      client,
      workflowId,
      stepId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve workflow step
 *
 * @remarks
 * Retrieves data for a specific step in a workflow
 */
export function useWorkflowsStepsRetrieveSuspense(
  workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<WorkflowsStepsRetrieveQueryData>,
): UseSuspenseQueryResult<WorkflowsStepsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildWorkflowsStepsRetrieveQuery(
      client,
      workflowId,
      stepId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchWorkflowsStepsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildWorkflowsStepsRetrieveQuery(
      client$,
      workflowId,
      stepId,
      idempotencyKey,
    ),
  });
}

export function setWorkflowsStepsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    workflowId: string,
    stepId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: WorkflowsStepsRetrieveQueryData,
): WorkflowsStepsRetrieveQueryData | undefined {
  const key = queryKeyWorkflowsStepsRetrieve(...queryKeyBase);

  return client.setQueryData<WorkflowsStepsRetrieveQueryData>(key, data);
}

export function invalidateWorkflowsStepsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      workflowId: string,
      stepId: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Steps", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllWorkflowsStepsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Steps", "retrieve"],
  });
}

export function buildWorkflowsStepsRetrieveQuery(
  client$: NovuCore,
  workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<WorkflowsStepsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyWorkflowsStepsRetrieve(workflowId, stepId, {
      idempotencyKey,
    }),
    queryFn: async function workflowsStepsRetrieveQueryFn(
      ctx,
    ): Promise<WorkflowsStepsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(workflowsStepsRetrieve(
        client$,
        workflowId,
        stepId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyWorkflowsStepsRetrieve(
  workflowId: string,
  stepId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Steps", "retrieve", workflowId, stepId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsStepsRetrieve(workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<WorkflowsStepsRetrieveQueryData>,)
 - useWorkflowsStepsRetrieveSuspense(workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<WorkflowsStepsRetrieveQueryData>,)
 - prefetchWorkflowsStepsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,)
 - setWorkflowsStepsRetrieveData(client: QueryClient,
  queryKeyBase: [
    workflowId: string,
    stepId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: WorkflowsStepsRetrieveQueryData,)
 - invalidateWorkflowsStepsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      workflowId: string,
      stepId: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllWorkflowsStepsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildWorkflowsStepsRetrieveQuery(client$: NovuCore,
  workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - workflowsStepsRetrieveQueryFn(ctx,)
 - queryKeyWorkflowsStepsRetrieve(workflowId: string,
  stepId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyWorkflowsStepsRetrieve(...queryKeyBase);

  return client.setQueryData<WorkflowsStepsRetriev...)
Declaraciones 'export' encontradas:
- export  type
- export function useWorkflowsStepsRetrieve
- export function useWorkflowsStepsRetrieveSuspense
- export function prefetchWorkflowsStepsRetrieve
- export function setWorkflowsStepsRetrieveData
- export function invalidateWorkflowsStepsRetrieve
- export function invalidateAllWorkflowsStepsRetrieve
- export function buildWorkflowsStepsRetrieveQuery
- export function queryKeyWorkflowsStepsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsSync.ts
Tamaño: 2476 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsSync } from "../funcs/workflowsSync.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type WorkflowsSyncMutationVariables = {
  syncWorkflowDto: components.SyncWorkflowDto;
  workflowId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type WorkflowsSyncMutationData =
  operations.WorkflowControllerSyncResponse;

/**
 * Sync a workflow
 *
 * @remarks
 * Synchronizes a workflow to the target environment
 */
export function useWorkflowsSyncMutation(
  options?: MutationHookOptions<
    WorkflowsSyncMutationData,
    Error,
    WorkflowsSyncMutationVariables
  >,
): UseMutationResult<
  WorkflowsSyncMutationData,
  Error,
  WorkflowsSyncMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildWorkflowsSyncMutation(client, options),
    ...options,
  });
}

export function mutationKeyWorkflowsSync(): MutationKey {
  return ["@novu/api", "Workflows", "sync"];
}

export function buildWorkflowsSyncMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: WorkflowsSyncMutationVariables,
  ) => Promise<WorkflowsSyncMutationData>;
} {
  return {
    mutationKey: mutationKeyWorkflowsSync(),
    mutationFn: function workflowsSyncMutationFn({
      syncWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    }): Promise<WorkflowsSyncMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(workflowsSync(
        client$,
        syncWorkflowDto,
        workflowId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsSyncMutation(options?: MutationHookOptions<
    WorkflowsSyncMutationData,
    Error,
    WorkflowsSyncMutationVariables
  >,)
 - mutationKeyWorkflowsSync()
 - buildWorkflowsSyncMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - workflowsSyncMutationFn({
      syncWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildWorkflowsSyncMutation(client, options),
    ......)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useWorkflowsSyncMutation
- export function mutationKeyWorkflowsSync
- export function buildWorkflowsSyncMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsUpdate.ts
Tamaño: 2575 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsUpdate } from "../funcs/workflowsUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type WorkflowsUpdateMutationVariables = {
  updateWorkflowDto: components.UpdateWorkflowDto;
  workflowId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type WorkflowsUpdateMutationData =
  operations.WorkflowControllerUpdateResponse;

/**
 * Update a workflow
 *
 * @remarks
 * Updates the details of an existing workflow, here **workflowId** is the identifier of the workflow
 */
export function useWorkflowsUpdateMutation(
  options?: MutationHookOptions<
    WorkflowsUpdateMutationData,
    Error,
    WorkflowsUpdateMutationVariables
  >,
): UseMutationResult<
  WorkflowsUpdateMutationData,
  Error,
  WorkflowsUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildWorkflowsUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeyWorkflowsUpdate(): MutationKey {
  return ["@novu/api", "Workflows", "update"];
}

export function buildWorkflowsUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: WorkflowsUpdateMutationVariables,
  ) => Promise<WorkflowsUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeyWorkflowsUpdate(),
    mutationFn: function workflowsUpdateMutationFn({
      updateWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    }): Promise<WorkflowsUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(workflowsUpdate(
        client$,
        updateWorkflowDto,
        workflowId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsUpdateMutation(options?: MutationHookOptions<
    WorkflowsUpdateMutationData,
    Error,
    WorkflowsUpdateMutationVariables
  >,)
 - mutationKeyWorkflowsUpdate()
 - buildWorkflowsUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - workflowsUpdateMutationFn({
      updateWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildWorkflowsUpdateMutation(client, options),
    ....)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useWorkflowsUpdateMutation
- export function mutationKeyWorkflowsUpdate
- export function buildWorkflowsUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/activity.ts
Tamaño: 1339 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { activityTrack } from "../funcs/activityTrack.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { Charts } from "./charts.js";
import { Requests } from "./requests.js";
import { WorkflowRuns } from "./workflowruns.js";

export class Activity extends ClientSDK {
  private _charts?: Charts;
  get charts(): Charts {
    return (this._charts ??= new Charts(this._options));
  }

  private _requests?: Requests;
  get requests(): Requests {
    return (this._requests ??= new Requests(this._options));
  }

  private _workflowRuns?: WorkflowRuns;
  get workflowRuns(): WorkflowRuns {
    return (this._workflowRuns ??= new WorkflowRuns(this._options));
  }

  /**
   * Track activity and engagement events
   *
   * @remarks
   * Track activity and engagement events for a specific delivery provider
   */
  async track(
    request: operations.InboundWebhooksControllerHandleWebhookRequest,
    options?: RequestOptions,
  ): Promise<Array<components.WebhookResultDto>> {
    return unwrapAsync(activityTrack(
      this,
      request,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Activity

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/charts.ts
Tamaño: 818 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { activityChartsRetrieve } from "../funcs/activityChartsRetrieve.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Charts extends ClientSDK {
  /**
   * Retrieve activity charts
   *
   * @remarks
   * Retrieve chart data for activity analytics and metrics visualization.
   */
  async retrieve(
    request: operations.ActivityControllerGetChartsRequest,
    options?: RequestOptions,
  ): Promise<components.GetChartsResponseDto> {
    return unwrapAsync(activityChartsRetrieve(
      this,
      request,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Charts

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/contexts.ts
Tamaño: 2807 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { contextsCreate } from "../funcs/contextsCreate.js";
import { contextsDelete } from "../funcs/contextsDelete.js";
import { contextsList } from "../funcs/contextsList.js";
import { contextsRetrieve } from "../funcs/contextsRetrieve.js";
import { contextsUpdate } from "../funcs/contextsUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Contexts extends ClientSDK {
  /**
   * Create context
   *
   * @remarks
   * Create a new context with the specified type, id, and data. Returns 409 if context already exists.
   */
  async create(
    createContextRequestDto: components.CreateContextRequestDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.ContextsControllerCreateContextResponse> {
    return unwrapAsync(contextsCreate(
      this,
      createContextRequestDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * List contexts
   *
   * @remarks
   * Retrieve a paginated list of contexts, optionally filtered by type and key pattern
   */
  async list(
    request: operations.ContextsControllerListContextsRequest,
    options?: RequestOptions,
  ): Promise<operations.ContextsControllerListContextsResponse> {
    return unwrapAsync(contextsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Update context data
   *
   * @remarks
   * Update the data of an existing context. Returns 404 if context does not exist.
   */
  async update(
    request: operations.ContextsControllerUpdateContextRequest,
    options?: RequestOptions,
  ): Promise<operations.ContextsControllerUpdateContextResponse> {
    return unwrapAsync(contextsUpdate(
      this,
      request,
      options,
    ));
  }

  /**
   * Get context by id
   *
   * @remarks
   * Retrieve a specific context by its type and id
   */
  async retrieve(
    type: string,
    id: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.ContextsControllerGetContextResponse> {
    return unwrapAsync(contextsRetrieve(
      this,
      type,
      id,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete context
   *
   * @remarks
   * Delete a context by its type and id
   */
  async delete(
    type: string,
    id: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.ContextsControllerDeleteContextResponse | undefined> {
    return unwrapAsync(contextsDelete(
      this,
      type,
      id,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Contexts

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/credentials.ts
Tamaño: 2737 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { subscribersCredentialsAppend } from "../funcs/subscribersCredentialsAppend.js";
import { subscribersCredentialsDelete } from "../funcs/subscribersCredentialsDelete.js";
import { subscribersCredentialsUpdate } from "../funcs/subscribersCredentialsUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Credentials extends ClientSDK {
  /**
   * Upsert provider credentials
   *
   * @remarks
   * Upsert credentials for a provider such as slack and push tokens.
   *       **providerId** is required field. This API creates **deviceTokens** or appends to the existing ones.
   */
  async update(
    updateSubscriberChannelRequestDto:
      components.UpdateSubscriberChannelRequestDto,
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    operations.SubscribersV1ControllerUpdateSubscriberChannelResponse
  > {
    return unwrapAsync(subscribersCredentialsUpdate(
      this,
      updateSubscriberChannelRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Update provider credentials
   *
   * @remarks
   * Update credentials for a provider such as **slack** and **FCM**.
   *       **providerId** is required field. This API creates the **deviceTokens** or replaces the existing ones.
   */
  async append(
    updateSubscriberChannelRequestDto:
      components.UpdateSubscriberChannelRequestDto,
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    operations.SubscribersV1ControllerModifySubscriberChannelResponse
  > {
    return unwrapAsync(subscribersCredentialsAppend(
      this,
      updateSubscriberChannelRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete provider credentials
   *
   * @remarks
   * Delete subscriber credentials for a provider such as **slack** and **FCM** by **providerId**.
   *     This action is irreversible and will remove the credentials for the provider for particular **subscriberId**.
   */
  async delete(
    subscriberId: string,
    providerId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    | operations.SubscribersV1ControllerDeleteSubscriberCredentialsResponse
    | undefined
  > {
    return unwrapAsync(subscribersCredentialsDelete(
      this,
      subscriberId,
      providerId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Credentials

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/environments.ts
Tamaño: 3593 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { environmentsCreate } from "../funcs/environmentsCreate.js";
import { environmentsDelete } from "../funcs/environmentsDelete.js";
import { environmentsGetTags } from "../funcs/environmentsGetTags.js";
import { environmentsList } from "../funcs/environmentsList.js";
import { environmentsUpdate } from "../funcs/environmentsUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Environments extends ClientSDK {
  /**
   * Get environment tags
   *
   * @remarks
   * Retrieve all unique tags used in workflows within the specified environment. These tags can be used for filtering workflows.
   */
  async getTags(
    environmentId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.EnvironmentsControllerGetEnvironmentTagsResponse> {
    return unwrapAsync(environmentsGetTags(
      this,
      environmentId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Create an environment
   *
   * @remarks
   * Creates a new environment within the current organization.
   *     Environments allow you to manage different stages of your application development lifecycle.
   *     Each environment has its own set of API keys and configurations.
   */
  async create(
    createEnvironmentRequestDto: components.CreateEnvironmentRequestDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.EnvironmentsControllerV1CreateEnvironmentResponse> {
    return unwrapAsync(environmentsCreate(
      this,
      createEnvironmentRequestDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * List all environments
   *
   * @remarks
   * This API returns a list of environments for the current organization.
   *     Each environment contains its configuration, API keys (if user has access), and metadata.
   */
  async list(
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.EnvironmentsControllerV1ListMyEnvironmentsResponse> {
    return unwrapAsync(environmentsList(
      this,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Update an environment
   *
   * @remarks
   * Update an environment by its unique identifier **environmentId**.
   *     You can modify the environment name, identifier, color, and other configuration settings.
   */
  async update(
    updateEnvironmentRequestDto: components.UpdateEnvironmentRequestDto,
    environmentId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.EnvironmentsControllerV1UpdateMyEnvironmentResponse> {
    return unwrapAsync(environmentsUpdate(
      this,
      updateEnvironmentRequestDto,
      environmentId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete an environment
   *
   * @remarks
   * Delete an environment by its unique identifier **environmentId**.
   *     This action is irreversible and will remove the environment and all its associated data.
   */
  async delete(
    environmentId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    operations.EnvironmentsControllerV1DeleteEnvironmentResponse | undefined
  > {
    return unwrapAsync(environmentsDelete(
      this,
      environmentId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Environments

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/groups.ts
Tamaño: 1564 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { translationsGroupsDelete } from "../funcs/translationsGroupsDelete.js";
import { translationsGroupsRetrieve } from "../funcs/translationsGroupsRetrieve.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Groups extends ClientSDK {
  /**
   * Delete a translation group
   *
   * @remarks
   * Delete an entire translation group and all its translations
   */
  async delete(
    resourceType: operations.ResourceType,
    resourceId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(translationsGroupsDelete(
      this,
      resourceType,
      resourceId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Retrieve a translation group
   *
   * @remarks
   * Retrieves a single translation group by resource type (workflow, layout) and resource ID (workflowId, layoutId)
   */
  async retrieve(
    resourceType:
      operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
    resourceId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.TranslationGroupDto> {
    return unwrapAsync(translationsGroupsRetrieve(
      this,
      resourceType,
      resourceId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Groups

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/index.ts
Tamaño: 103 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export * from "./sdk.js";


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/integrations.ts
Tamaño: 4944 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { integrationsCreate } from "../funcs/integrationsCreate.js";
import { integrationsDelete } from "../funcs/integrationsDelete.js";
import { integrationsIntegrationsControllerAutoConfigureIntegration } from "../funcs/integrationsIntegrationsControllerAutoConfigureIntegration.js";
import { integrationsList } from "../funcs/integrationsList.js";
import { integrationsListActive } from "../funcs/integrationsListActive.js";
import { integrationsSetAsPrimary } from "../funcs/integrationsSetAsPrimary.js";
import { integrationsUpdate } from "../funcs/integrationsUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Integrations extends ClientSDK {
  /**
   * List all integrations
   *
   * @remarks
   * List all the channels integrations created in the organization
   */
  async list(
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.IntegrationsControllerListIntegrationsResponse> {
    return unwrapAsync(integrationsList(
      this,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Create an integration
   *
   * @remarks
   * Create an integration for the current environment the user is based on the API key provided.
   *     Each provider supports different credentials, check the provider documentation for more details.
   */
  async create(
    createIntegrationRequestDto: components.CreateIntegrationRequestDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.IntegrationsControllerCreateIntegrationResponse> {
    return unwrapAsync(integrationsCreate(
      this,
      createIntegrationRequestDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Update an integration
   *
   * @remarks
   * Update an integration by its unique key identifier **integrationId**.
   *     Each provider supports different credentials, check the provider documentation for more details.
   */
  async update(
    updateIntegrationRequestDto: components.UpdateIntegrationRequestDto,
    integrationId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.IntegrationsControllerUpdateIntegrationByIdResponse> {
    return unwrapAsync(integrationsUpdate(
      this,
      updateIntegrationRequestDto,
      integrationId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete an integration
   *
   * @remarks
   * Delete an integration by its unique key identifier **integrationId**.
   *     This action is irreversible.
   */
  async delete(
    integrationId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.IntegrationsControllerRemoveIntegrationResponse> {
    return unwrapAsync(integrationsDelete(
      this,
      integrationId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Auto-configure an integration for inbound webhooks
   *
   * @remarks
   * Auto-configure an integration by its unique key identifier **integrationId** for inbound webhook support.
   *     This will automatically generate required webhook signing keys and configure webhook endpoints.
   */
  async integrationsControllerAutoConfigureIntegration(
    integrationId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    operations.IntegrationsControllerAutoConfigureIntegrationResponse
  > {
    return unwrapAsync(
      integrationsIntegrationsControllerAutoConfigureIntegration(
        this,
        integrationId,
        idempotencyKey,
        options,
      ),
    );
  }

  /**
   * Update integration as primary
   *
   * @remarks
   * Update an integration as **primary** by its unique key identifier **integrationId**.
   *     This API will set the integration as primary for that channel in the current environment.
   *     Primary integration is used to deliver notification for sms and email channels in the workflow.
   */
  async setAsPrimary(
    integrationId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.IntegrationsControllerSetIntegrationAsPrimaryResponse> {
    return unwrapAsync(integrationsSetAsPrimary(
      this,
      integrationId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * List active integrations
   *
   * @remarks
   * List all the active integrations created in the organization
   */
  async listActive(
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.IntegrationsControllerGetActiveIntegrationsResponse> {
    return unwrapAsync(integrationsListActive(
      this,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Integrations

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/layouts.ts
Tamaño: 4536 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { layoutsCreate } from "../funcs/layoutsCreate.js";
import { layoutsDelete } from "../funcs/layoutsDelete.js";
import { layoutsDuplicate } from "../funcs/layoutsDuplicate.js";
import { layoutsGeneratePreview } from "../funcs/layoutsGeneratePreview.js";
import { layoutsList } from "../funcs/layoutsList.js";
import { layoutsRetrieve } from "../funcs/layoutsRetrieve.js";
import { layoutsUpdate } from "../funcs/layoutsUpdate.js";
import { layoutsUsage } from "../funcs/layoutsUsage.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Layouts extends ClientSDK {
  /**
   * Create a layout
   *
   * @remarks
   * Creates a new layout in the Novu Cloud environment
   */
  async create(
    createLayoutDto: components.CreateLayoutDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.LayoutsControllerCreateResponse> {
    return unwrapAsync(layoutsCreate(
      this,
      createLayoutDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * List all layouts
   *
   * @remarks
   * Retrieves a list of layouts with optional filtering and pagination
   */
  async list(
    request: operations.LayoutsControllerListRequest,
    options?: RequestOptions,
  ): Promise<operations.LayoutsControllerListResponse> {
    return unwrapAsync(layoutsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Update a layout
   *
   * @remarks
   * Updates the details of an existing layout, here **layoutId** is the identifier of the layout
   */
  async update(
    updateLayoutDto: components.UpdateLayoutDto,
    layoutId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.LayoutsControllerUpdateResponse> {
    return unwrapAsync(layoutsUpdate(
      this,
      updateLayoutDto,
      layoutId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Retrieve a layout
   *
   * @remarks
   * Fetches details of a specific layout by its unique identifier **layoutId**
   */
  async retrieve(
    layoutId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.LayoutsControllerGetResponse> {
    return unwrapAsync(layoutsRetrieve(
      this,
      layoutId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete a layout
   *
   * @remarks
   * Removes a specific layout by its unique identifier **layoutId**
   */
  async delete(
    layoutId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.LayoutsControllerDeleteResponse | undefined> {
    return unwrapAsync(layoutsDelete(
      this,
      layoutId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Duplicate a layout
   *
   * @remarks
   * Duplicates a layout by its unique identifier **layoutId**. This will create a new layout with the content of the original layout.
   */
  async duplicate(
    duplicateLayoutDto: components.DuplicateLayoutDto,
    layoutId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.LayoutsControllerDuplicateResponse> {
    return unwrapAsync(layoutsDuplicate(
      this,
      duplicateLayoutDto,
      layoutId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Generate layout preview
   *
   * @remarks
   * Generates a preview for a layout by its unique identifier **layoutId**
   */
  async generatePreview(
    layoutPreviewRequestDto: components.LayoutPreviewRequestDto,
    layoutId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.LayoutsControllerGeneratePreviewResponse> {
    return unwrapAsync(layoutsGeneratePreview(
      this,
      layoutPreviewRequestDto,
      layoutId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Get layout usage
   *
   * @remarks
   * Retrieves information about workflows that use the specified layout by its unique identifier **layoutId**
   */
  async usage(
    layoutId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.LayoutsControllerGetUsageResponse> {
    return unwrapAsync(layoutsUsage(
      this,
      layoutId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Layouts

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/master.ts
Tamaño: 1998 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { translationsMasterImport } from "../funcs/translationsMasterImport.js";
import { translationsMasterRetrieve } from "../funcs/translationsMasterRetrieve.js";
import { translationsMasterUpload } from "../funcs/translationsMasterUpload.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Master extends ClientSDK {
  /**
   * Retrieve master translations JSON
   *
   * @remarks
   * Retrieve all translations for a locale in master JSON format organized by resourceId (workflowId)
   */
  async retrieve(
    locale?: string | undefined,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.GetMasterJsonResponseDto> {
    return unwrapAsync(translationsMasterRetrieve(
      this,
      locale,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Import master translations JSON
   *
   * @remarks
   * Import translations for multiple workflows from master JSON format for a specific locale
   */
  async import(
    importMasterJsonRequestDto: components.ImportMasterJsonRequestDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.ImportMasterJsonResponseDto> {
    return unwrapAsync(translationsMasterImport(
      this,
      importMasterJsonRequestDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Upload master translations JSON file
   *
   * @remarks
   * Upload a master JSON file containing translations for multiple workflows. Locale is automatically detected from filename (e.g., en_US.json)
   */
  async upload(
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.ImportMasterJsonResponseDto> {
    return unwrapAsync(translationsMasterUpload(
      this,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Master

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/messages.ts
Tamaño: 2254 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { messagesDelete } from "../funcs/messagesDelete.js";
import { messagesDeleteByTransactionId } from "../funcs/messagesDeleteByTransactionId.js";
import { messagesRetrieve } from "../funcs/messagesRetrieve.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Messages extends ClientSDK {
  /**
   * List all messages
   *
   * @remarks
   * List all messages for the current environment.
   *     This API supports filtering by **channel**, **subscriberId**, and **transactionId**.
   *     This API returns a paginated list of messages.
   */
  async retrieve(
    request: operations.MessagesControllerGetMessagesRequest,
    options?: RequestOptions,
  ): Promise<operations.MessagesControllerGetMessagesResponse> {
    return unwrapAsync(messagesRetrieve(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete a message
   *
   * @remarks
   * Delete a message entity from the Novu platform by **messageId**.
   *     This action is irreversible. **messageId** is required and of mongodbId type.
   */
  async delete(
    messageId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.MessagesControllerDeleteMessageResponse> {
    return unwrapAsync(messagesDelete(
      this,
      messageId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete messages by transactionId
   *
   * @remarks
   * Delete multiple messages from the Novu platform using **transactionId** of triggered event.
   *     This API supports filtering by **channel** and delete all messages associated with the **transactionId**.
   */
  async deleteByTransactionId(
    transactionId: string,
    channel?: operations.Channel | undefined,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    | operations.MessagesControllerDeleteMessagesByTransactionIdResponse
    | undefined
  > {
    return unwrapAsync(messagesDeleteByTransactionId(
      this,
      transactionId,
      channel,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Messages

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/notifications.ts
Tamaño: 1788 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { notificationsList } from "../funcs/notificationsList.js";
import { notificationsRetrieve } from "../funcs/notificationsRetrieve.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Notifications extends ClientSDK {
  /**
   * List all events
   *
   * @remarks
   * List all notification events (triggered events) for the current environment.
   *     This API supports filtering by **channels**, **templates**, **emails**, **subscriberIds**, **transactionId**, **topicKey**.
   *     Checkout all available filters in the query section.
   *     This API returns event triggers, to list each channel notifications, check messages APIs.
   */
  async list(
    request: operations.NotificationsControllerListNotificationsRequest,
    options?: RequestOptions,
  ): Promise<operations.NotificationsControllerListNotificationsResponse> {
    return unwrapAsync(notificationsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Retrieve an event
   *
   * @remarks
   * Retrieve an event by its unique key identifier **notificationId**.
   *     Here **notificationId** is of mongodbId type.
   *     This API returns the event details - execution logs, status, actual notification (message) generated by each workflow step.
   */
  async retrieve(
    notificationId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.NotificationsControllerGetNotificationResponse> {
    return unwrapAsync(notificationsRetrieve(
      this,
      notificationId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Notifications

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/novumessages.ts
Tamaño: 2478 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { subscribersMessagesMarkAll } from "../funcs/subscribersMessagesMarkAll.js";
import { subscribersMessagesMarkAllAs } from "../funcs/subscribersMessagesMarkAllAs.js";
import { subscribersMessagesUpdateAsSeen } from "../funcs/subscribersMessagesUpdateAsSeen.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class NovuMessages extends ClientSDK {
  /**
   * Update notification action status
   *
   * @remarks
   * Update in-app (inbox) notification's action status by its unique key identifier **messageId** and type field **type**.
   *       **type** field can be **primary** or **secondary**
   */
  async updateAsSeen(
    request: operations.SubscribersV1ControllerMarkActionAsSeenRequest,
    options?: RequestOptions,
  ): Promise<operations.SubscribersV1ControllerMarkActionAsSeenResponse> {
    return unwrapAsync(subscribersMessagesUpdateAsSeen(
      this,
      request,
      options,
    ));
  }

  /**
   * Update all notifications state
   *
   * @remarks
   * Update all subscriber in-app (inbox) notifications state such as read, unread, seen or unseen by **subscriberId**.
   */
  async markAll(
    markAllMessageAsRequestDto: components.MarkAllMessageAsRequestDto,
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.SubscribersV1ControllerMarkAllUnreadAsReadResponse> {
    return unwrapAsync(subscribersMessagesMarkAll(
      this,
      markAllMessageAsRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Update notifications state
   *
   * @remarks
   * Update subscriber's multiple in-app (inbox) notifications state such as seen, read, unseen or unread by **subscriberId**.
   *       **messageId** is of type mongodbId of notifications
   */
  async markAllAs(
    messageMarkAsRequestDto: components.MessageMarkAsRequestDto,
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.SubscribersV1ControllerMarkMessagesAsResponse> {
    return unwrapAsync(subscribersMessagesMarkAllAs(
      this,
      messageMarkAsRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NovuMessages

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/novunotifications.ts
Tamaño: 1468 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { subscribersNotificationsFeed } from "../funcs/subscribersNotificationsFeed.js";
import { subscribersNotificationsUnseenCount } from "../funcs/subscribersNotificationsUnseenCount.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class NovuNotifications extends ClientSDK {
  /**
   * Retrieve subscriber notifications
   *
   * @remarks
   * Retrieve subscriber in-app (inbox) notifications by its unique key identifier **subscriberId**.
   */
  async feed(
    request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
    options?: RequestOptions,
  ): Promise<operations.SubscribersV1ControllerGetNotificationsFeedResponse> {
    return unwrapAsync(subscribersNotificationsFeed(
      this,
      request,
      options,
    ));
  }

  /**
   * Retrieve unseen notifications count
   *
   * @remarks
   * Retrieve unseen in-app (inbox) notifications count for a subscriber by its unique key identifier **subscriberId**.
   */
  async unseenCount(
    request: operations.SubscribersV1ControllerGetUnseenCountRequest,
    options?: RequestOptions,
  ): Promise<operations.SubscribersV1ControllerGetUnseenCountResponse> {
    return unwrapAsync(subscribersNotificationsUnseenCount(
      this,
      request,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NovuNotifications

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/novusubscribers.ts
Tamaño: 864 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { topicsSubscribersRetrieve } from "../funcs/topicsSubscribersRetrieve.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class NovuSubscribers extends ClientSDK {
  /**
   * Check topic subscriber
   *
   * @remarks
   * Check if a subscriber belongs to a certain topic
   */
  async retrieve(
    topicKey: string,
    externalSubscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.TopicsV1ControllerGetTopicSubscriberResponse> {
    return unwrapAsync(topicsSubscribersRetrieve(
      this,
      topicKey,
      externalSubscriberId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NovuSubscribers

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/novutopics.ts
Tamaño: 887 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { subscribersTopicsList } from "../funcs/subscribersTopicsList.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class NovuTopics extends ClientSDK {
  /**
   * Retrieve subscriber subscriptions
   *
   * @remarks
   * Retrieve subscriber's topic subscriptions by its unique key identifier **subscriberId**.
   *     Checkout all available filters in the query section.
   */
  async list(
    request: operations.SubscribersControllerListSubscriberTopicsRequest,
    options?: RequestOptions,
  ): Promise<operations.SubscribersControllerListSubscriberTopicsResponse> {
    return unwrapAsync(subscribersTopicsList(
      this,
      request,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NovuTopics

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/preferences.ts
Tamaño: 2767 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { subscribersPreferencesBulkUpdate } from "../funcs/subscribersPreferencesBulkUpdate.js";
import { subscribersPreferencesList } from "../funcs/subscribersPreferencesList.js";
import { subscribersPreferencesUpdate } from "../funcs/subscribersPreferencesUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Preferences extends ClientSDK {
  /**
   * Retrieve subscriber preferences
   *
   * @remarks
   * Retrieve subscriber channel preferences by its unique key identifier **subscriberId**.
   *     This API returns all five channels preferences for all workflows and global preferences.
   */
  async list(
    subscriberId: string,
    criticality?: operations.Criticality | undefined,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.SubscribersControllerGetSubscriberPreferencesResponse> {
    return unwrapAsync(subscribersPreferencesList(
      this,
      subscriberId,
      criticality,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Update subscriber preferences
   *
   * @remarks
   * Update subscriber preferences by its unique key identifier **subscriberId**.
   *     **workflowId** is optional field, if provided, this API will update that workflow preference,
   *     otherwise it will update global preferences
   */
  async update(
    patchSubscriberPreferencesDto: components.PatchSubscriberPreferencesDto,
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    operations.SubscribersControllerUpdateSubscriberPreferencesResponse
  > {
    return unwrapAsync(subscribersPreferencesUpdate(
      this,
      patchSubscriberPreferencesDto,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Bulk update subscriber preferences
   *
   * @remarks
   * Bulk update subscriber preferences by its unique key identifier **subscriberId**.
   *     This API allows updating multiple workflow preferences in a single request.
   */
  async bulkUpdate(
    bulkUpdateSubscriberPreferencesDto:
      components.BulkUpdateSubscriberPreferencesDto,
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    operations.SubscribersControllerBulkUpdateSubscriberPreferencesResponse
  > {
    return unwrapAsync(subscribersPreferencesBulkUpdate(
      this,
      bulkUpdateSubscriberPreferencesDto,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Preferences

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/properties.ts
Tamaño: 1114 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { subscribersPropertiesUpdateOnlineFlag } from "../funcs/subscribersPropertiesUpdateOnlineFlag.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Properties extends ClientSDK {
  /**
   * Update subscriber online status
   *
   * @remarks
   * Update the subscriber online status by its unique key identifier **subscriberId**
   */
  async updateOnlineFlag(
    updateSubscriberOnlineFlagRequestDto:
      components.UpdateSubscriberOnlineFlagRequestDto,
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    operations.SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse
  > {
    return unwrapAsync(subscribersPropertiesUpdateOnlineFlag(
      this,
      updateSubscriberOnlineFlagRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Properties

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/requests.ts
Tamaño: 1332 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { activityRequestsList } from "../funcs/activityRequestsList.js";
import { activityRequestsRetrieve } from "../funcs/activityRequestsRetrieve.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Requests extends ClientSDK {
  /**
   * List activity requests
   *
   * @remarks
   * Retrieve a list of activity requests with optional filtering and pagination.
   */
  async list(
    request: operations.ActivityControllerGetLogsRequest,
    options?: RequestOptions,
  ): Promise<components.GetRequestsResponseDto> {
    return unwrapAsync(activityRequestsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Retrieve activity request
   *
   * @remarks
   * Retrieve detailed traces and information for a specific activity request by ID.
   */
  async retrieve(
    requestId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.GetRequestResponseDto> {
    return unwrapAsync(activityRequestsRetrieve(
      this,
      requestId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Requests

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/sdk.ts
Tamaño: 5179 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { cancel } from "../funcs/cancel.js";
import { trigger } from "../funcs/trigger.js";
import { triggerBroadcast } from "../funcs/triggerBroadcast.js";
import { triggerBulk } from "../funcs/triggerBulk.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { Activity } from "./activity.js";
import { Contexts } from "./contexts.js";
import { Environments } from "./environments.js";
import { Integrations } from "./integrations.js";
import { Layouts } from "./layouts.js";
import { Messages } from "./messages.js";
import { Notifications } from "./notifications.js";
import { Subscribers } from "./subscribers.js";
import { Topics } from "./topics.js";
import { Translations } from "./translations.js";
import { Workflows } from "./workflows.js";

export class Novu extends ClientSDK {
  private _contexts?: Contexts;
  get contexts(): Contexts {
    return (this._contexts ??= new Contexts(this._options));
  }

  private _environments?: Environments;
  get environments(): Environments {
    return (this._environments ??= new Environments(this._options));
  }

  private _activity?: Activity;
  get activity(): Activity {
    return (this._activity ??= new Activity(this._options));
  }

  private _layouts?: Layouts;
  get layouts(): Layouts {
    return (this._layouts ??= new Layouts(this._options));
  }

  private _subscribers?: Subscribers;
  get subscribers(): Subscribers {
    return (this._subscribers ??= new Subscribers(this._options));
  }

  private _topics?: Topics;
  get topics(): Topics {
    return (this._topics ??= new Topics(this._options));
  }

  private _translations?: Translations;
  get translations(): Translations {
    return (this._translations ??= new Translations(this._options));
  }

  private _workflows?: Workflows;
  get workflows(): Workflows {
    return (this._workflows ??= new Workflows(this._options));
  }

  private _integrations?: Integrations;
  get integrations(): Integrations {
    return (this._integrations ??= new Integrations(this._options));
  }

  private _messages?: Messages;
  get messages(): Messages {
    return (this._messages ??= new Messages(this._options));
  }

  private _notifications?: Notifications;
  get notifications(): Notifications {
    return (this._notifications ??= new Notifications(this._options));
  }

  /**
   * Trigger event
   *
   * @remarks
   *
   *     Trigger event is the main (and only) way to send notifications to subscribers. The trigger identifier is used to match the particular workflow associated with it. Additional information can be passed according the body interface below.
   *     To prevent duplicate triggers, you can optionally pass a **transactionId** in the request body. If the same **transactionId** is used again, the trigger will be ignored. The retention period depends on your billing tier.
   */
  async trigger(
    triggerEventRequestDto: components.TriggerEventRequestDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.EventsControllerTriggerResponse> {
    return unwrapAsync(trigger(
      this,
      triggerEventRequestDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Cancel triggered event
   *
   * @remarks
   *
   *     Using a previously generated transactionId during the event trigger,
   *      will cancel any active or pending workflows. This is useful to cancel active digests, delays etc...
   */
  async cancel(
    transactionId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.EventsControllerCancelResponse> {
    return unwrapAsync(cancel(
      this,
      transactionId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Broadcast event to all
   *
   * @remarks
   * Trigger a broadcast event to all existing subscribers, could be used to send announcements, etc.
   *       In the future could be used to trigger events to a subset of subscribers based on defined filters.
   */
  async triggerBroadcast(
    triggerEventToAllRequestDto: components.TriggerEventToAllRequestDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.EventsControllerBroadcastEventToAllResponse> {
    return unwrapAsync(triggerBroadcast(
      this,
      triggerEventToAllRequestDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Bulk trigger event
   *
   * @remarks
   *
   *       Using this endpoint you can trigger multiple events at once, to avoid multiple calls to the API.
   *       The bulk API is limited to 100 events per request.
   */
  async triggerBulk(
    bulkTriggerEventDto: components.BulkTriggerEventDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.EventsControllerTriggerBulkResponse> {
    return unwrapAsync(triggerBulk(
      this,
      bulkTriggerEventDto,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Novu

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/steps.ts
Tamaño: 1360 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { workflowsStepsGeneratePreview } from "../funcs/workflowsStepsGeneratePreview.js";
import { workflowsStepsRetrieve } from "../funcs/workflowsStepsRetrieve.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Steps extends ClientSDK {
  /**
   * Generate step preview
   *
   * @remarks
   * Generates a preview for a specific workflow step by its unique identifier **stepId**
   */
  async generatePreview(
    request: operations.WorkflowControllerGeneratePreviewRequest,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerGeneratePreviewResponse> {
    return unwrapAsync(workflowsStepsGeneratePreview(
      this,
      request,
      options,
    ));
  }

  /**
   * Retrieve workflow step
   *
   * @remarks
   * Retrieves data for a specific step in a workflow
   */
  async retrieve(
    workflowId: string,
    stepId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerGetWorkflowStepDataResponse> {
    return unwrapAsync(workflowsStepsRetrieve(
      this,
      workflowId,
      stepId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Steps

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/subscribers.ts
Tamaño: 5362 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { subscribersCreate } from "../funcs/subscribersCreate.js";
import { subscribersCreateBulk } from "../funcs/subscribersCreateBulk.js";
import { subscribersDelete } from "../funcs/subscribersDelete.js";
import { subscribersPatch } from "../funcs/subscribersPatch.js";
import { subscribersRetrieve } from "../funcs/subscribersRetrieve.js";
import { subscribersSearch } from "../funcs/subscribersSearch.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { Credentials } from "./credentials.js";
import { NovuMessages } from "./novumessages.js";
import { NovuNotifications } from "./novunotifications.js";
import { NovuTopics } from "./novutopics.js";
import { Preferences } from "./preferences.js";
import { Properties } from "./properties.js";

export class Subscribers extends ClientSDK {
  private _preferences?: Preferences;
  get preferences(): Preferences {
    return (this._preferences ??= new Preferences(this._options));
  }

  private _topics?: NovuTopics;
  get topics(): NovuTopics {
    return (this._topics ??= new NovuTopics(this._options));
  }

  private _credentials?: Credentials;
  get credentials(): Credentials {
    return (this._credentials ??= new Credentials(this._options));
  }

  private _messages?: NovuMessages;
  get messages(): NovuMessages {
    return (this._messages ??= new NovuMessages(this._options));
  }

  private _notifications?: NovuNotifications;
  get notifications(): NovuNotifications {
    return (this._notifications ??= new NovuNotifications(this._options));
  }

  private _properties?: Properties;
  get properties(): Properties {
    return (this._properties ??= new Properties(this._options));
  }

  /**
   * Search subscribers
   *
   * @remarks
   * Search subscribers by their **email**, **phone**, **subscriberId** and **name**.
   *     The search is case sensitive and supports pagination.Checkout all available filters in the query section.
   */
  async search(
    request: operations.SubscribersControllerSearchSubscribersRequest,
    options?: RequestOptions,
  ): Promise<operations.SubscribersControllerSearchSubscribersResponse> {
    return unwrapAsync(subscribersSearch(
      this,
      request,
      options,
    ));
  }

  /**
   * Create a subscriber
   *
   * @remarks
   * Create a subscriber with the subscriber attributes.
   *       **subscriberId** is a required field, rest other fields are optional, if the subscriber already exists, it will be updated
   */
  async create(
    createSubscriberRequestDto: components.CreateSubscriberRequestDto,
    failIfExists?: boolean | undefined,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.SubscribersControllerCreateSubscriberResponse> {
    return unwrapAsync(subscribersCreate(
      this,
      createSubscriberRequestDto,
      failIfExists,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Retrieve a subscriber
   *
   * @remarks
   * Retrieve a subscriber by its unique key identifier **subscriberId**.
   *     **subscriberId** field is required.
   */
  async retrieve(
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.SubscribersControllerGetSubscriberResponse> {
    return unwrapAsync(subscribersRetrieve(
      this,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Update a subscriber
   *
   * @remarks
   * Update a subscriber by its unique key identifier **subscriberId**.
   *     **subscriberId** is a required field, rest other fields are optional
   */
  async patch(
    patchSubscriberRequestDto: components.PatchSubscriberRequestDto,
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.SubscribersControllerPatchSubscriberResponse> {
    return unwrapAsync(subscribersPatch(
      this,
      patchSubscriberRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete a subscriber
   *
   * @remarks
   * Deletes a subscriber entity from the Novu platform along with associated messages, preferences, and topic subscriptions.
   *       **subscriberId** is a required field.
   */
  async delete(
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.SubscribersControllerRemoveSubscriberResponse> {
    return unwrapAsync(subscribersDelete(
      this,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Bulk create subscribers
   *
   * @remarks
   *
   *       Using this endpoint multiple subscribers can be created at once. The bulk API is limited to 500 subscribers per request.
   */
  async createBulk(
    bulkSubscriberCreateDto: components.BulkSubscriberCreateDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.SubscribersV1ControllerBulkCreateSubscribersResponse> {
    return unwrapAsync(subscribersCreateBulk(
      this,
      bulkSubscriberCreateDto,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Subscribers

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/subscriptions.ts
Tamaño: 2324 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { topicsSubscriptionsCreate } from "../funcs/topicsSubscriptionsCreate.js";
import { topicsSubscriptionsDelete } from "../funcs/topicsSubscriptionsDelete.js";
import { topicsSubscriptionsList } from "../funcs/topicsSubscriptionsList.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Subscriptions extends ClientSDK {
  /**
   * List topic subscriptions
   *
   * @remarks
   * List all subscriptions of subscribers for a topic.
   *     Checkout all available filters in the query section.
   */
  async list(
    request: operations.TopicsControllerListTopicSubscriptionsRequest,
    options?: RequestOptions,
  ): Promise<operations.TopicsControllerListTopicSubscriptionsResponse> {
    return unwrapAsync(topicsSubscriptionsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Create topic subscriptions
   *
   * @remarks
   * This api will create subscription for subscriberIds for a topic.
   *       Its like subscribing to a common interest group. if topic does not exist, it will be created.
   */
  async create(
    createTopicSubscriptionsRequestDto:
      components.CreateTopicSubscriptionsRequestDto,
    topicKey: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.TopicsControllerCreateTopicSubscriptionsResponse> {
    return unwrapAsync(topicsSubscriptionsCreate(
      this,
      createTopicSubscriptionsRequestDto,
      topicKey,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete topic subscriptions
   *
   * @remarks
   * Delete subscriptions for subscriberIds for a topic.
   */
  async delete(
    deleteTopicSubscriptionsRequestDto:
      components.DeleteTopicSubscriptionsRequestDto,
    topicKey: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.TopicsControllerDeleteTopicSubscriptionsResponse> {
    return unwrapAsync(topicsSubscriptionsDelete(
      this,
      deleteTopicSubscriptionsRequestDto,
      topicKey,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Subscriptions

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/topics.ts
Tamaño: 3553 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { topicsCreate } from "../funcs/topicsCreate.js";
import { topicsDelete } from "../funcs/topicsDelete.js";
import { topicsGet } from "../funcs/topicsGet.js";
import { topicsList } from "../funcs/topicsList.js";
import { topicsUpdate } from "../funcs/topicsUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { NovuSubscribers } from "./novusubscribers.js";
import { Subscriptions } from "./subscriptions.js";

export class Topics extends ClientSDK {
  private _subscriptions?: Subscriptions;
  get subscriptions(): Subscriptions {
    return (this._subscriptions ??= new Subscriptions(this._options));
  }

  private _subscribers?: NovuSubscribers;
  get subscribers(): NovuSubscribers {
    return (this._subscribers ??= new NovuSubscribers(this._options));
  }

  /**
   * List all topics
   *
   * @remarks
   * This api returns a paginated list of topics.
   *     Topics can be filtered by **key**, **name**, or **includeCursor** to paginate through the list.
   *     Checkout all available filters in the query section.
   */
  async list(
    request: operations.TopicsControllerListTopicsRequest,
    options?: RequestOptions,
  ): Promise<operations.TopicsControllerListTopicsResponse> {
    return unwrapAsync(topicsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Create a topic
   *
   * @remarks
   * Creates a new topic if it does not exist, or updates an existing topic if it already exists. Use ?failIfExists=true to prevent updates.
   */
  async create(
    createUpdateTopicRequestDto: components.CreateUpdateTopicRequestDto,
    failIfExists?: boolean | undefined,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.TopicsControllerUpsertTopicResponse> {
    return unwrapAsync(topicsCreate(
      this,
      createUpdateTopicRequestDto,
      failIfExists,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Retrieve a topic
   *
   * @remarks
   * Retrieve a topic by its unique key identifier **topicKey**
   */
  async get(
    topicKey: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.TopicsControllerGetTopicResponse> {
    return unwrapAsync(topicsGet(
      this,
      topicKey,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Update a topic
   *
   * @remarks
   * Update a topic name by its unique key identifier **topicKey**
   */
  async update(
    updateTopicRequestDto: components.UpdateTopicRequestDto,
    topicKey: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.TopicsControllerUpdateTopicResponse> {
    return unwrapAsync(topicsUpdate(
      this,
      updateTopicRequestDto,
      topicKey,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete a topic
   *
   * @remarks
   * Delete a topic by its unique key identifier **topicKey**.
   *     This action is irreversible and will remove all subscriptions to the topic.
   */
  async delete(
    topicKey: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.TopicsControllerDeleteTopicResponse> {
    return unwrapAsync(topicsDelete(
      this,
      topicKey,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Topics

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/translations.ts
Tamaño: 2791 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { translationsCreate } from "../funcs/translationsCreate.js";
import { translationsDelete } from "../funcs/translationsDelete.js";
import { translationsRetrieve } from "../funcs/translationsRetrieve.js";
import { translationsUpload } from "../funcs/translationsUpload.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { Groups } from "./groups.js";
import { Master } from "./master.js";

export class Translations extends ClientSDK {
  private _groups?: Groups;
  get groups(): Groups {
    return (this._groups ??= new Groups(this._options));
  }

  private _master?: Master;
  get master(): Master {
    return (this._master ??= new Master(this._options));
  }

  /**
   * Create a translation
   *
   * @remarks
   * Create a translation for a specific workflow and locale, if the translation already exists, it will be updated
   */
  async create(
    createTranslationRequestDto: components.CreateTranslationRequestDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.TranslationResponseDto> {
    return unwrapAsync(translationsCreate(
      this,
      createTranslationRequestDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Retrieve a translation
   *
   * @remarks
   * Retrieve a specific translation by resource type, resource ID and locale
   */
  async retrieve(
    request: operations.TranslationControllerGetSingleTranslationRequest,
    options?: RequestOptions,
  ): Promise<components.TranslationResponseDto> {
    return unwrapAsync(translationsRetrieve(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete a translation
   *
   * @remarks
   * Delete a specific translation by resource type, resource ID and locale
   */
  async delete(
    request: operations.TranslationControllerDeleteTranslationEndpointRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(translationsDelete(
      this,
      request,
      options,
    ));
  }

  /**
   * Upload translation files
   *
   * @remarks
   * Upload one or more JSON translation files for a specific workflow. Files name must match the locale, e.g. en_US.json
   */
  async upload(
    uploadTranslationsRequestDto: components.UploadTranslationsRequestDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.UploadTranslationsResponseDto> {
    return unwrapAsync(translationsUpload(
      this,
      uploadTranslationsRequestDto,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Translations

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/workflowruns.ts
Tamaño: 1357 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { activityWorkflowRunsList } from "../funcs/activityWorkflowRunsList.js";
import { activityWorkflowRunsRetrieve } from "../funcs/activityWorkflowRunsRetrieve.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class WorkflowRuns extends ClientSDK {
  /**
   * List workflow runs
   *
   * @remarks
   * Retrieve a list of workflow runs with optional filtering and pagination.
   */
  async list(
    request: operations.ActivityControllerGetWorkflowRunsRequest,
    options?: RequestOptions,
  ): Promise<components.GetWorkflowRunsResponseDto> {
    return unwrapAsync(activityWorkflowRunsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Retrieve workflow run
   *
   * @remarks
   * Retrieve detailed information for a specific workflow run by ID.
   */
  async retrieve(
    workflowRunId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.GetWorkflowRunResponseDto> {
    return unwrapAsync(activityWorkflowRunsRetrieve(
      this,
      workflowRunId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowRuns

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/workflows.ts
Tamaño: 4834 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { workflowsCreate } from "../funcs/workflowsCreate.js";
import { workflowsDelete } from "../funcs/workflowsDelete.js";
import { workflowsDuplicate } from "../funcs/workflowsDuplicate.js";
import { workflowsGet } from "../funcs/workflowsGet.js";
import { workflowsList } from "../funcs/workflowsList.js";
import { workflowsPatch } from "../funcs/workflowsPatch.js";
import { workflowsSync } from "../funcs/workflowsSync.js";
import { workflowsUpdate } from "../funcs/workflowsUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { Steps } from "./steps.js";

export class Workflows extends ClientSDK {
  private _steps?: Steps;
  get steps(): Steps {
    return (this._steps ??= new Steps(this._options));
  }

  /**
   * Create a workflow
   *
   * @remarks
   * Creates a new workflow in the Novu Cloud environment
   */
  async create(
    createWorkflowDto: components.CreateWorkflowDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerCreateResponse> {
    return unwrapAsync(workflowsCreate(
      this,
      createWorkflowDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * List all workflows
   *
   * @remarks
   * Retrieves a list of workflows with optional filtering and pagination
   */
  async list(
    request: operations.WorkflowControllerSearchWorkflowsRequest,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerSearchWorkflowsResponse> {
    return unwrapAsync(workflowsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Update a workflow
   *
   * @remarks
   * Updates the details of an existing workflow, here **workflowId** is the identifier of the workflow
   */
  async update(
    updateWorkflowDto: components.UpdateWorkflowDto,
    workflowId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerUpdateResponse> {
    return unwrapAsync(workflowsUpdate(
      this,
      updateWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Retrieve a workflow
   *
   * @remarks
   * Fetches details of a specific workflow by its unique identifier **workflowId**
   */
  async get(
    workflowId: string,
    environmentId?: string | undefined,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerGetWorkflowResponse> {
    return unwrapAsync(workflowsGet(
      this,
      workflowId,
      environmentId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete a workflow
   *
   * @remarks
   * Removes a specific workflow by its unique identifier **workflowId**
   */
  async delete(
    workflowId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerRemoveWorkflowResponse | undefined> {
    return unwrapAsync(workflowsDelete(
      this,
      workflowId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Update a workflow
   *
   * @remarks
   * Partially updates a workflow by its unique identifier **workflowId**
   */
  async patch(
    patchWorkflowDto: components.PatchWorkflowDto,
    workflowId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerPatchWorkflowResponse> {
    return unwrapAsync(workflowsPatch(
      this,
      patchWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Duplicate a workflow
   *
   * @remarks
   * Duplicates a workflow by its unique identifier **workflowId**. This will create a new workflow with the same steps and settings.
   */
  async duplicate(
    duplicateWorkflowDto: components.DuplicateWorkflowDto,
    workflowId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerDuplicateWorkflowResponse> {
    return unwrapAsync(workflowsDuplicate(
      this,
      duplicateWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Sync a workflow
   *
   * @remarks
   * Synchronizes a workflow to the target environment
   */
  async sync(
    syncWorkflowDto: components.SyncWorkflowDto,
    workflowId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerSyncResponse> {
    return unwrapAsync(workflowsSync(
      this,
      syncWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Workflows

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/async.ts
Tamaño: 1634 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export type APICall =
  | {
      status: "complete";
      request: Request;
      response: Response;
    }
  | {
      status: "request-error";
      request: Request;
      response?: undefined;
    }
  | {
      status: "invalid";
      request?: undefined;
      response?: undefined;
    };

export class APIPromise<T> implements Promise<T> {
  readonly #promise: Promise<[T, APICall]>;
  readonly #unwrapped: Promise<T>;

  readonly [Symbol.toStringTag] = "APIPromise";

  constructor(p: [T, APICall] | Promise<[T, APICall]>) {
    this.#promise = p instanceof Promise ? p : Promise.resolve(p);
    this.#unwrapped =
      p instanceof Promise
        ? this.#promise.then(([value]) => value)
        : Promise.resolve(p[0]);
  }

  then<TResult1 = T, TResult2 = never>(
    onfulfilled?:
      | ((value: T) => TResult1 | PromiseLike<TResult1>)
      | null
      | undefined,
    onrejected?:
      | ((reason: any) => TResult2 | PromiseLike<TResult2>)
      | null
      | undefined,
  ): Promise<TResult1 | TResult2> {
    return this.#promise.then(
      onfulfilled ? ([value]) => onfulfilled(value) : void 0,
      onrejected,
    );
  }

  catch<TResult = never>(
    onrejected?:
      | ((reason: any) => TResult | PromiseLike<TResult>)
      | null
      | undefined,
  ): Promise<T | TResult> {
    return this.#unwrapped.catch(onrejected);
  }

  finally(onfinally?: (() => void) | null | undefined): Promise<T> {
    return this.#unwrapped.finally(onfinally);
  }

  $inspect(): Promise<[T, APICall]> {
    return this.#promise;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - unwrapped(p instanceof Promise
        ? this.#promise.then(([value]))
 - TResult2(never>(
    onfulfilled?:
      | ((value: T))
 - TResult(never>(
    onrejected?:
      | ((reason: any))
Declaraciones 'export' encontradas:
- export  type
- export class APIPromise

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/blobs.ts
Tamaño: 716 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';

export const blobLikeSchema: z.ZodType<Blob, z.ZodTypeDef, Blob> = z.custom<Blob>(isBlobLike, {
  message: 'expected a Blob, File or Blob-like object',
  fatal: true,
});

export function isBlobLike(val: unknown): val is Blob {
  if (val instanceof Blob) {
    return true;
  }

  if (typeof val !== 'object' || val == null || !(Symbol.toStringTag in val)) {
    return false;
  }

  const name = val[Symbol.toStringTag];
  if (typeof name !== 'string') {
    return false;
  }
  if (name !== 'Blob' && name !== 'File') {
    return false;
  }

  return 'stream' in val && typeof val.stream === 'function';
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - isBlobLike(val: unknown)
Declaraciones 'export' encontradas:
- export  const
- export function isBlobLike

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/constdatetime.ts
Tamaño: 362 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';

export function constDateTime(val: string): z.ZodType<string, z.ZodTypeDef, unknown> {
  return z.custom<string>((v) => {
    return typeof v === 'string' && new Date(v).getTime() === new Date(val).getTime();
  }, `Value must be equivalent to ${val}`);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - constDateTime(val: string)
Declaraciones 'export' encontradas:
- export function constDateTime

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/enums.ts
Tamaño: 493 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

declare const __brand: unique symbol;
export type Unrecognized<T> = T & { [__brand]: "unrecognized" };

export function catchUnrecognizedEnum<T>(value: T): Unrecognized<T> {
  return value as Unrecognized<T>;
}

type Prettify<T> = { [K in keyof T]: T[K] } & {};
export type ClosedEnum<T> = T[keyof T];
export type OpenEnum<T> =
  | Prettify<T[keyof T]>
  | Unrecognized<T[keyof T] extends number ? number : string>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export function catchUnrecognizedEnum
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/fp.ts
Tamaño: 1442 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

/**
 * A monad that captures the result of a function call or an error if it was not
 * successful. Railway programming, enabled by this type, can be a nicer
 * alternative to traditional exception throwing because it allows functions to
 * declare all _known_ errors with static types and then check for them
 * exhaustively in application code. Thrown exception have a type of `unknown`
 * and break out of regular control flow of programs making them harder to
 * inspect and more verbose work with due to try-catch blocks.
 */
export type Result<T, E = unknown> =
  | { ok: true; value: T; error?: never }
  | { ok: false; value?: never; error: E };

export function OK<V>(value: V): Result<V, never> {
  return { ok: true, value };
}

export function ERR<E>(error: E): Result<never, E> {
  return { ok: false, error };
}

/**
 * unwrap is a convenience function for extracting a value from a result or
 * throwing if there was an error.
 */
export function unwrap<T>(r: Result<T, unknown>): T {
  if (!r.ok) {
    throw r.error;
  }
  return r.value;
}

/**
 * unwrapAsync is a convenience function for resolving a value from a Promise
 * of a result or rejecting if an error occurred.
 */
export async function unwrapAsync<T>(
  pr: Promise<Result<T, unknown>>,
): Promise<T> {
  const r = await pr;
  if (!r.ok) {
    throw r.error;
  }

  return r.value;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export function OK
- export function ERR
- export function unwrap
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/index.ts
Tamaño: 453 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export { blobLikeSchema, isBlobLike } from "./blobs.js";
export { catchUnrecognizedEnum } from "./enums.js";
export type { ClosedEnum, OpenEnum, Unrecognized } from "./enums.js";
export type { Result } from "./fp.js";
export type { PageIterator, Paginator } from "./operations.js";
export { createPageIterator } from "./operations.js";
export { RFCDate } from "./rfcdate.js";


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export  type
- export  type
- export  type
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/operations.ts
Tamaño: 2500 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { Result } from "./fp.js";

export type Paginator<V> = () => Promise<V & { next: Paginator<V> }> | null;

export type PageIterator<V, PageState = unknown> = V & {
  next: Paginator<V>;
  [Symbol.asyncIterator]: () => AsyncIterableIterator<V>;
  "~next"?: PageState | undefined;
};

export function createPageIterator<V>(
  page: V & { next: Paginator<V> },
  halt: (v: V) => boolean,
): {
  [Symbol.asyncIterator]: () => AsyncIterableIterator<V>;
} {
  return {
    [Symbol.asyncIterator]: async function* paginator() {
      yield page;
      if (halt(page)) {
        return;
      }

      let p: typeof page | null = page;
      for (p = await p.next(); p != null; p = await p.next()) {
        yield p;
        if (halt(p)) {
          return;
        }
      }
    },
  };
}

/**
 * This utility create a special iterator that yields a single value and
 * terminates. It is useful in paginated SDK functions that have early return
 * paths when things go wrong.
 */
export function haltIterator<V extends object>(
  v: V,
): PageIterator<V, undefined> {
  return {
    ...v,
    next: () => null,
    [Symbol.asyncIterator]: async function* paginator() {
      yield v;
    },
  };
}

/**
 * Converts an async iterator of `Result<V, E>` into an async iterator of `V`.
 * When error results occur, the underlying error value is thrown.
 */
export async function unwrapResultIterator<V, PageState>(
  iteratorPromise: Promise<PageIterator<Result<V, unknown>, PageState>>,
): Promise<PageIterator<V, PageState>> {
  const resultIter = await iteratorPromise;

  if (!resultIter.ok) {
    throw resultIter.error;
  }

  return {
    ...resultIter.value,
    next: unwrapPaginator(resultIter.next),
    "~next": resultIter["~next"],
    [Symbol.asyncIterator]: async function* paginator() {
      for await (const page of resultIter) {
        if (!page.ok) {
          throw page.error;
        }
        yield page.value;
      }
    },
  };
}

function unwrapPaginator<V>(
  paginator: Paginator<Result<V, unknown>>,
): Paginator<V> {
  return () => {
    const nextResult = paginator();
    if (nextResult == null) {
      return null;
    }
    return nextResult.then((res) => {
      if (!res.ok) {
        throw res.error;
      }
      const out = {
        ...res.value,
        next: unwrapPaginator(res.next),
      };
      return out;
    });
  };
}

export const URL_OVERRIDE = Symbol("URL_OVERRIDE");


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - p(await p.next()) {
        yield p;
        if (halt(p)) {
          return;
        }
      }
    },...)
 - resultIter(await iteratorPromise;

  if (!resultIter.ok) {
    throw resultIter.error;
  }

  return {
    ...r...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function createPageIterator
- export function haltIterator
- export  async
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/rfcdate.ts
Tamaño: 1339 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

const dateRE = /^\d{4}-\d{2}-\d{2}$/;

export class RFCDate {
  private serialized: string;

  /**
   * Creates a new RFCDate instance using today's date.
   */
  static today(): RFCDate {
    return new RFCDate(new Date());
  }

  /**
   * Creates a new RFCDate instance using the provided input.
   * If a string is used then in must be in the format YYYY-MM-DD.
   *
   * @param date A Date object or a date string in YYYY-MM-DD format
   * @example
   * new RFCDate("2022-01-01")
   * @example
   * new RFCDate(new Date())
   */
  constructor(date: Date | string) {
    if (typeof date === "string" && !dateRE.test(date)) {
      throw new RangeError(
        "RFCDate: date strings must be in the format YYYY-MM-DD: " + date,
      );
    }

    const value = new Date(date);
    if (isNaN(+value)) {
      throw new RangeError("RFCDate: invalid date provided: " + date);
    }

    this.serialized = value.toISOString().slice(0, "YYYY-MM-DD".length);
    if (!dateRE.test(this.serialized)) {
      throw new TypeError(
        `RFCDate: failed to build valid date with given value: ${date} serialized to ${this.serialized}`,
      );
    }
  }

  toJSON(): string {
    return this.toString();
  }

  toString(): string {
    return this.serialized;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RFCDate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/streams.ts
Tamaño: 572 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export function isReadableStream<T = Uint8Array>(
  val: unknown,
): val is ReadableStream<T> {
  if (typeof val !== "object" || val === null) {
    return false;
  }

  // Check for the presence of methods specific to ReadableStream
  const stream = val as ReadableStream<Uint8Array>;

  // ReadableStream has methods like getReader, cancel, and tee
  return (
    typeof stream.getReader === "function" &&
    typeof stream.cancel === "function" &&
    typeof stream.tee === "function"
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export function isReadableStream

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/temp/example.ts
Tamaño: 115 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

const value: number = [object Object];

### ANALISIS AUTOMATICO (ESPAÑOL) ###

No se detectaron funciones/exportaciones con heurística JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/notifications/.gitignore
Tamaño: 87 bytes
Lenguaje detectado: GITIGNORE

### CONTENIDO ORIGINAL ###

.idea/*
.nyc_output
build
node_modules
test
src/**.js
coverage
*.log
package-lock.json


### ANALISIS AUTOMATICO (ESPAÑOL) ###

.idea/*
.nyc_output
build
node_modules
test
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/notifications/README.md
Tamaño: 109 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

# @novu/notifications

Reusable notification templates and workflows for the Novu platform.

## Installation


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# @novu/notifications
Reusable notification templates and workflows for the Novu platform.
## Installation
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/notifications/package.json
Tamaño: 1336 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/notifications",
  "version": "1.0.10",
  "description": "Novu notification templates and workflows",
  "main": "build/main/index.js",
  "typings": "build/main/index.d.ts",
  "module": "build/module/index.js",
  "private": true,
  "license": "MIT",
  "keywords": [],
  "scripts": {
    "build": "run-p build:*",
    "build:main": "tsc -p tsconfig.json",
    "build:module": "tsc -p tsconfig.module.json",
    "fix": "run-s fix:*",
    "check": "biome check .",
    "check:fix": "biome check --write .",
    "test": "echo 'Not tests available'",
    "test:watch": "echo 'Not tests available'",
    "watch:build": "tsc -p tsconfig.json -w",
    "reset-hard": "git clean -dfx && git reset --hard && pnpm install",
    "start:studio": "novu dev --port 3000 --route /v1/bridge/novu"
  },
  "dependencies": {
    "@react-email/components": "^0.0.15",
    "@novu/framework": "workspace:*",
    "@novu/shared": "workspace:*",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "typescript": "5.6.2",
    "npm-run-all": "^4.1.5",
    "novu": "workspace:*"
  },
  "files": [
    "build/main",
    "build/module",
    "!**/*.spec.*",
    "!**/*.json",
    "CHANGELOG.md",
    "LICENSE",
    "README.md"
  ]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/notifications",
"version": "1.0.10",
"description": "Novu notification templates and workflows",
"main": "build/main/index.js",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/notifications/project.json
Tamaño: 265 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/notifications",
  "sourceRoot": "libs/notifications/src",
  "projectType": "library",
  "targets": {
    "lint": {
      "executor": "nx:run-commands",
      "options": {
        "command": "npx biome lint libs/notifications"
      }
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/notifications",
"sourceRoot": "libs/notifications/src",
"projectType": "library",
"targets": {
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/notifications/tsconfig.json
Tamaño: 496 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "sourceMap": true,
    "strictNullChecks": false,
    "allowSyntheticDefaultImports": true,
    "outDir": "build/main",
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "rootDir": "src",
    "strict": true,
    "types": ["node", "jest"],
    "jsx": "react",
    "typeRoots": ["./node_modules/@types", "../../node_modules/@types"]
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules/**"]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"extends": "../../tsconfig.json",
"compilerOptions": {
"sourceMap": true,
"strictNullChecks": false,
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/notifications/tsconfig.module.json
Tamaño: 394 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "extends": "./tsconfig",
  "compilerOptions": {
    "sourceMap": true,
    "target": "esnext",
    "outDir": "build/module",
    "module": "esnext",
    "esModuleInterop": true,
    "types": ["jest", "node"],
    "jsx": "preserve",
    "typeRoots": ["./node_modules/@types", "../../node_modules/@types"]
  },
  "include": ["src/**/*.ts", "src/**/*.tsx"],
  "exclude": ["node_modules/**"]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"extends": "./tsconfig",
"compilerOptions": {
"sourceMap": true,
"target": "esnext",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/notifications/src/index.ts
Tamaño: 64 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './workflows/usage-limits/usage-limits.workflow';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/notifications/src/templates/layout.tsx
Tamaño: 908 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Body, Container, Head, Html, Img, Preview, Tailwind } from '@react-email/components';
import React from 'react';

interface IBaseEmailLayoutProps {
  previewText: string;
  children: React.ReactNode;
}

export function EmailLayout({ previewText, children }: IBaseEmailLayoutProps) {
  return (
    <Html>
      <Head />
      <Preview>{previewText}</Preview>
      <Tailwind>
        <Body className="mx-auto my-auto bg-white px-2 font-sans">
          <Container className="mx-auto my-[40px] max-w-[465px] rounded border border-solid border-[#eaeaea] p-[20px]">
            <Img
              src={`https://dashboard.novu.co/static/images/novu-colored-text.png`}
              width="100"
              height="37"
              alt="Novu"
              className="mx-auto my-[32px]"
            />
            {children}
          </Container>
        </Body>
      </Tailwind>
    </Html>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Body, Container, Head, Html, Img, Preview, Tailwind } from '@react-email/components';
import React from 'react';
interface IBaseEmailLayoutProps {
previewText: string;
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/notifications/src/workflows/usage-limits/email.tsx
Tamaño: 2001 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Button, Heading, renderAsync, Section, Text } from '@react-email/components';
import React from 'react';
import { EmailLayout } from '../../templates/layout';

interface IEmailProps {
  percentage?: number;
  organizationName?: string;
  previewText?: string;
}

export function UsageLimitsEmail({ percentage, organizationName, previewText }: IEmailProps) {
  const roundedPercentage = Math.round(percentage || 0);

  return (
    <EmailLayout previewText={previewText}>
      <Heading className="mx-0 my-[30px] p-0 text-center text-[24px] font-normal text-black">
        Used {roundedPercentage}% of Your Monthly Events
      </Heading>
      <Text className="text-[14px] leading-[24px] text-black">
        Your organization {organizationName} has used {roundedPercentage}% of the free tier monthly limit of 30,000
        events.
      </Text>

      <Text className="text-[14px] leading-[24px] text-black">
        To ensure uninterrupted service and access to additional features, we recommend upgrading your plan before
        reaching the limit.
      </Text>

      <Section className="mb-[32px] mt-[32px] text-center">
        <Button
          className="rounded bg-[#000000] px-5 py-3 text-center text-[12px] font-semibold text-white no-underline"
          href={'https://dashboard.novu.co/settings/billing'}
        >
          Upgrade Your Plan
        </Button>
      </Section>

      <Text className="text-[12px] leading-[20px] text-gray-500">
        Note: Once you consume 100% of your monthly limit, notifications will be blocked until you upgrade or the next
        billing cycle begins. begins.
      </Text>
    </EmailLayout>
  );
}

export interface IRenderEmailPayload {
  percentage?: number;
  organizationName?: string;
}

export interface IEmailControls {
  previewText?: string;
}

export async function renderUsageLimitsEmail(payload: IRenderEmailPayload, controls: IEmailControls) {
  return renderAsync(<UsageLimitsEmail {...payload} {...controls} />);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Button, Heading, renderAsync, Section, Text } from '@react-email/components';
import React from 'react';
import { EmailLayout } from '../../templates/layout';
interface IEmailProps {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/notifications/src/workflows/usage-limits/usage-limits.workflow.ts
Tamaño: 1379 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { workflow } from '@novu/framework';
import { z } from 'zod';
import { renderUsageLimitsEmail } from './email';

export const usageLimitsWorkflow = workflow(
  'usage-limits',
  async ({ step, payload }) => {
    await step.digest('digest', async () => {
      return {
        amount: 5,
        unit: 'minutes',
      };
    });

    await step.email(
      'email',
      async (controls) => {
        return {
          subject: controls.subject,
          body: await renderUsageLimitsEmail(payload, controls),
        };
      },
      {
        controlSchema: z.object({
          subject: z.string().default('You are approaching your usage limits'),
          previewText: z.string().default('You have used {{payload.percentage}}% of your monthly events'),
        }),
      }
    );

    await step.inApp(
      'in-app',
      async (controls) => {
        return {
          subject: controls.subject,
          body: controls.body,
        };
      },
      {
        controlSchema: z.object({
          subject: z.string().default('You are approaching your usage limits'),
          body: z.string().default('You have used {{payload.percentage}}% of your monthly events'),
        }),
      }
    );
  },
  {
    name: 'Usage Limits Alert',
    payloadSchema: z.object({
      percentage: z.number().min(0),
      organizationName: z.string(),
    }),
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - usageLimitsWorkflow(workflow(
  'usage-limits',
  async ({ step, payload }))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/.gitignore
Tamaño: 366 bytes
Lenguaje detectado: GITIGNORE

### CONTENIDO ORIGINAL ###

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage


# production
build

.npmrc
.idea/*
.nyc_output

test

src/**.js
coverage
*.log
package-lock.json

storybook-static

## Panda
styled-system
styled-system-studio

# react-scanner
src/component-audit/component-scans


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.
# dependencies
/node_modules
/.pnp
# testing
# production
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/package.json
Tamaño: 4660 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/novui",
  "version": "2.0.1",
  "repository": "https://github.com/novuhq/novu",
  "description": "Novu's Design System & Component Library",
  "types": "./dist/index.d.ts",
  "main": "./dist/index.js",
  "files": [
    "dist",
    "styled-system"
  ],
  "exports": {
    ".": {
      "source": "./src/index.ts",
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    },
    "./icons": {
      "source": "./src/icons/index.ts",
      "types": "./dist/icons/index.d.ts",
      "require": "./dist/icons/index.js",
      "import": "./dist/icons/index.js"
    },
    "./css": {
      "types": "./styled-system/css/index.d.ts",
      "require": "./styled-system/css/index.js",
      "import": "./styled-system/css/index.js"
    },
    "./tokens": {
      "types": "./styled-system/tokens/index.d.ts",
      "require": "./styled-system/tokens/index.js",
      "import": "./styled-system/tokens/index.js"
    },
    "./types": {
      "types": "./styled-system/types/index.d.ts",
      "require": "./styled-system/types/index.js",
      "import": "./styled-system/types/index.js"
    },
    "./patterns": {
      "types": "./styled-system/patterns/index.d.ts",
      "require": "./styled-system/patterns/index.js",
      "import": "./styled-system/patterns/index.js"
    },
    "./recipes": {
      "types": "./styled-system/recipes/index.d.ts",
      "require": "./styled-system/recipes/index.js",
      "import": "./styled-system/recipes/index.js"
    },
    "./jsx": {
      "types": "./styled-system/jsx/index.d.ts",
      "require": "./styled-system/jsx/index.js",
      "import": "./styled-system/jsx/index.js"
    },
    "./styles.css": "./src/index.css"
  },
  "scripts": {
    "dev": "pnpm build && pnpm storybook",
    "start": "npm run build:watch",
    "setup": "pnpm prepare:panda && pnpm build",
    "prepare:lib": "pnpm prepare:panda && pnpm prepare:audit",
    "prepare:panda": "pnpm panda codegen",
    "prepare:audit": "pnpm audit-components",
    "clean": "rimraf dist styled-system",
    "prebuild": "pnpm prepare:panda",
    "check": "biome check .",
    "check:fix": "biome check --write .",
    "build": "cross-env node_modules/.bin/tsc",
    "build:watch": "pnpm panda --watch & cross-env node_modules/.bin/tsc -w --preserveWatchOutput",
    "build:storybook": "pnpm panda && storybook build",
    "storybook": "pnpm panda --watch & storybook dev -p 6006",
    "studio": "pnpm panda studio",
    "audit-components": "pnpm react-scanner -c './react-scanner.config.js'"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@pandacss/dev": "^0.42.0",
    "@pandacss/studio": "^0.42.0",
    "@storybook/addon-actions": "8.1.0",
    "@storybook/addon-controls": "^8.1.0",
    "@storybook/addon-docs": "^8.1.0",
    "@storybook/react": "^8.1.0",
    "@storybook/react-vite": "^8.1.0",
    "@storybook/theming": "^8.1.0",
    "@storybook/types": "^8.1.0",
    "@testing-library/jest-dom": "^6.4.1",
    "@testing-library/react": "^12.1.5",
    "@testing-library/react-hooks": "^8.0.1",
    "@testing-library/user-event": "^14.5.2",
    "@types/node": "^20.15.0",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.0.3",
    "postcss": "^8.4.38",
    "postcss-preset-mantine": "^1.15.0",
    "postcss-simple-vars": "^7.0.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-scanner": "^1.2.0",
    "rimraf": "^3.0.2",
    "storybook": "^8.1.0",
    "storybook-dark-mode": "^4.0.1",
    "typescript": "5.6.2",
    "vite": "^4.5.2",
    "vite-tsconfig-paths": "^4.3.2",
    "vitest": "^1.2.1"
  },
  "peerDependencies": {
    "react": ">=17.0.0",
    "react-dom": ">=17.0.0"
  },
  "nx": {
    "targets": {
      "build-storybook": {
        "dependsOn": [
          "^build"
        ],
        "outputs": [
          "{projectRoot}/storybook-static"
        ],
        "inputs": [
          "{projectRoot}/.storybook",
          "{projectRoot}/src"
        ]
      }
    }
  },
  "dependencies": {
    "@mantine/code-highlight": "^7.12.1",
    "@mantine/core": "^7.12.1",
    "@mantine/hooks": "^7.12.1",
    "@mantine/tiptap": "^7.12.1",
    "@rjsf/core": "^5.20.0",
    "@rjsf/utils": "^5.20.0",
    "@rjsf/validator-ajv8": "^5.17.1",
    "@tanstack/react-table": "^8.17.3",
    "@tiptap/extension-document": "^2.6.6",
    "@tiptap/extension-history": "^2.6.6",
    "@tiptap/extension-mention": "^2.6.6",
    "@tiptap/extension-paragraph": "^2.6.6",
    "@tiptap/extension-text": "^2.6.6",
    "@tiptap/pm": "^2.6.6",
    "@tiptap/react": "^2.6.6",
    "@tiptap/suggestion": "^2.6.6",
    "react-icons": "5.0.1"
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/novui",
"version": "2.0.1",
"repository": "https://github.com/novuhq/novu",
"description": "Novu's Design System & Component Library",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/panda.config.ts
Tamaño: 1071 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineConfig } from '@pandacss/dev';
import { novuPandaPreset } from './src/panda-preset';

export default defineConfig({
  // Whether to use css reset
  preflight: true,

  /** Only allow defined values */
  strictTokens: true,

  // Where to look for your css declarations
  include: ['./src/**/*.{js,jsx,ts,tsx}', './.storybook/**/*.{js,jsx,ts,tsx}'],

  // Files to exclude
  exclude: ['./react-scanner.config.js'],

  presets: [novuPandaPreset],

  /**
   * Prefixes generated classes with the specified string (e.g. `nv-text_blue`)
   * https://panda-css.com/docs/references/config#prefix
   */
  prefix: 'nv',

  /*
   * Any additional configuration that is specific to design-system, but SHOULD NOT be propagated to
   * other apps or consumers. Use this sparingly!
   */
  theme: {
    extend: {},
  },

  importMap: 'styled-system',

  // extension of generated files
  outExtension: 'js',

  // The output directory for your css system
  outdir: 'styled-system',

  // Enables JSX util generation!
  jsxFramework: 'react',

  validation: 'error',
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default  defineConfig

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/postcss.config.cjs
Tamaño: 607 bytes
Lenguaje detectado: CJS

### CONTENIDO ORIGINAL ###

module.exports = {
  /**
   * Must use array + require syntax for vite + postcss & panda
   * https://vitejs.dev/config/shared-options.html#css-postcss
   * https://panda-css.com/docs/installation/storybook#install-panda
   */
  plugins: [
    require('@pandacss/dev/postcss')(),
    require('postcss-preset-mantine')(),
    require('postcss-simple-vars')({
      variables: {
        'mantine-breakpoint-xs': '36em',
        'mantine-breakpoint-sm': '48em',
        'mantine-breakpoint-md': '62em',
        'mantine-breakpoint-lg': '75em',
        'mantine-breakpoint-xl': '88em',
      },
    }),
  ],
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

module.exports = {
/**
* Must use array + require syntax for vite + postcss & panda
* https://vitejs.dev/config/shared-options.html#css-postcss
* https://panda-css.com/docs/installation/storybook#install-panda
Contiene 'require' o 'module.exports' (posible Node.js).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/project.json
Tamaño: 528 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/novui",
  "sourceRoot": "libs/novui/src",
  "projectType": "library",
  "targets": {
    "build": {
      "cache": false,
      "dependsOn": ["^build"],
      "inputs": [
        "default",
        "{projectRoot}/**/*",
        "!{projectRoot}/**/?(*.)+(spec|test).[jt]s?(x)?(.snap)",
        "!{projectRoot}/tsconfig.spec.json",
        "!{projectRoot}/jest.config.[jt]s"
      ],
      "outputs": ["{projectRoot}/dist", "{projectRoot}/build", "{projectRoot}/lib", "{projectRoot}/styled-system"]
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/novui",
"sourceRoot": "libs/novui/src",
"projectType": "library",
"targets": {
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/react-scanner.config.js
Tamaño: 5043 bytes
Lenguaje detectado: JavaScript

### CONTENIDO ORIGINAL ###

/**
 * Configuration file for react-scanner: https://github.com/moroshko/react-scanner
 *
 * Used to assess usage of Mantine and Design System components in web.
 *
 * To use:
 * 1. Run `pnpm audit-components`
 * 2. Check `OUTPUT_PATH` for your scan results!
 */

/** the path of the scan output */
const OUTPUT_PATH = './src/component-audit/component-scans';
const OUTPUT_FILE_NAME = 'scan';
const OUTPUT_FILE_EXTENSION = 'json';

/**
 * @param {string} suffix Optional filename suffix
 * @returns file path for the output file
 */
const getOutputFilePath = (suffix) => {
  return `${OUTPUT_PATH}/${OUTPUT_FILE_NAME}${suffix ?? ''}.${OUTPUT_FILE_EXTENSION}`;
};

const NOVU_ICON_REGEX = /^Icon(?!Button)[A-Z0-9]{1}[a-zA-Z0-9]+$/;
const RELATIVE_PATH_REGEX = /^(\.(\.){0,}\/)/;
const ANTD_ICON_MODULE_NAME = '@ant-design/icons';

const COMPONENT_NAME_EXCLUSION_REGEX = /^web\/.*(Page|Container|Provider|Sidebar|Modal)$/;

module.exports = {
  /** directory to scan */
  crawlFrom: '../../apps/web/src/',
  includeSubComponents: true,
  /**
   * Regex for determining which imports to include.
   * Currently includes: novu, antd, mantine, and local imports
   *
   * To see only local imports, replace with: /(\.(\.){0,}\/.*)/gim
   */
  importedFrom:
    /(@novu\/(novui|design-system|shared-web|notification-center)|@mantine\/core|@ant-design)(\/[a-z0-9\-)]+){0,}|(\.(\.){0,}\/.*)/gim,
  exclude: ['/src/api', '/src/styled-system'],
  processors: [countComponentsAndPropsProcessor({ minNumInstances: 1 }), groupByNamespaceProcessor],
  /** file patterns to scan */
  globs: ['**/!(*.test|*.spec|*.stories).@(js|ts)x'],
  /** function for naming components -- we use the returned name as the "group by" key. */
  getComponentName,
};

function getComponentName({ imported, local, moduleName, importType }) {
  const importedName = imported ?? local;

  // any relative imports should return early and be scoped to "web"
  if (RELATIVE_PATH_REGEX.test(moduleName)) {
    return `web/${importedName}`;
  }

  // get the module namespace / org (AKA novu or mantine), but remove @
  const moduleOrg = moduleName.split('/').join('_').replace('@', '');

  // group Icons if from Novu Design System or AntD
  const name =
    (moduleName === '@novu/design-system' && NOVU_ICON_REGEX.test(importedName)) || moduleName === ANTD_ICON_MODULE_NAME
      ? 'Icon'
      : importedName;

  return `${moduleOrg}/${name}`;
}

/**
 * @param {object} _ with the following properties:
 * @param {number} minNumInstances Minimum instance count (inclusive) of a component to include it in the output
 * @default 1
 *
 * Extension of a built-in processor from react-scanner to make it easier to customize.
 * https://github.com/moroshko/react-scanner/blob/master/src/processors/count-components-and-props.js
 */
function countComponentsAndPropsProcessor({ minNumInstances = 1 } = {}) {
  return ({ forEachComponent, sortObjectKeysByValue, output }) => {
    let result = {};

    forEachComponent(({ componentName, component }) => {
      const { instances } = component;

      if (!instances || instances.length < minNumInstances) {
        return;
      }

      if (COMPONENT_NAME_EXCLUSION_REGEX.test(componentName)) {
        console.log('Excluding component ' + componentName);

        return;
      }

      // include the package source as a prop
      const [srcPkg] = componentName.split('/');

      result[componentName] = {
        instances: instances.length,
        props: {},
        srcPkg,
      };

      instances.forEach((instance) => {
        for (const prop in instance.props) {
          if (result[componentName].props[prop] === undefined) {
            result[componentName].props[prop] = 0;
          }

          result[componentName].props[prop] += 1;
        }

        // aggregate icon names and output as a prop to stay consistent across all output components.
        if (componentName.includes('/Icon')) {
          const iconName = instance.importInfo.imported;
          const existingIconNames = result[componentName].props.iconNames;

          result[componentName].props.iconNames = existingIconNames ? existingIconNames.concat(iconName) : [iconName];
        }
      });

      result[componentName].props = sortObjectKeysByValue(result[componentName].props);
    });

    result = sortObjectKeysByValue(result, (component) => component.instances);

    output(result, getOutputFilePath());

    return result;
  };
}

/**
 * @precondition Must be called after `countComponentsAndPropsProcessor` in the processors array.
 * Processor for grouping by namespace (i.e. Novu, Mantine, etc)
 */
function groupByNamespaceProcessor({ prevResult, output }) {
  const result = Object.entries(prevResult).reduce((groupedResult, [compKey, compVal]) => {
    const [namespace, compName] = compKey.split('/');

    return {
      ...groupedResult,
      [namespace]: {
        ...groupedResult[namespace],
        [compName]: compVal,
      },
    };
  }, {});

  output(result, getOutputFilePath('.grouped'));

  return result;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getComponentName({ imported, local, moduleName, importType })
 - countComponentsAndPropsProcessor({ minNumInstances = 1 } = {})
 - groupByNamespaceProcessor({ prevResult, output })
Asignaciones con arrow functions encontradas (posibles funciones):
 - getOutputFilePath(suffix))
 - result({};

    forEachComponent(({ componentName, component }))
 - result(sortObjectKeysByValue(result, (component))
 - result(Object.entries(prevResult).reduce((groupedResult, [compKey, compVal]))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/setup-tests.ts
Tamaño: 224 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { cleanup } from '@testing-library/react';
import { afterEach } from 'vitest';
import '@testing-library/jest-dom/vitest';

// runs a clean after each test case (e.g. clearing jsdom)
afterEach(() => {
  cleanup();
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

No se detectaron funciones/exportaciones con heurística JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/tsconfig.json
Tamaño: 596 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "include": ["src", "styled-system"],
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "forceConsistentCasingInFileNames": true,
    "target": "es6",
    "module": "ESNext",
    "strict": true,
    "typeRoots": ["node_modules/@types"],
    "jsx": "react-jsx",
    "lib": ["ESNext", "dom", "dom.iterable"],
    "skipLibCheck": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": false,
    "allowSyntheticDefaultImports": true,
    "baseUrl": "."
  },
  "exclude": ["node_modules", "src/**/*.stories.*"]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"include": ["src", "styled-system"],
"extends": "../../tsconfig.json",
"compilerOptions": {
"outDir": "dist",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/vite.config.ts
Tamaño: 554 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import react from '@vitejs/plugin-react';
import { resolve } from 'path';
import { defineConfig } from 'vite';
import tsconfigPaths from 'vite-tsconfig-paths';

export default defineConfig({
  plugins: [
    // leverages tsconfig to work with panda styled-system
    tsconfigPaths(),
    react(),
  ],
  build: {
    lib: {
      entry: resolve(__dirname, 'src/index.ts'),
      formats: ['es'],
    },
    rollupOptions: {
      external: ['react', 'react/jsx-runtime'],
    },
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.jsx', '.js'],
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default  defineConfig

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/vitest.config.ts
Tamaño: 211 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/// <reference types="vitest" />

import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: './setup-tests.ts',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default  defineConfig

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/.storybook/NovuTheme.tsx
Tamaño: 538 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { ThemeVarsPartial } from '@storybook/theming';
import { create } from '@storybook/theming/create';

const themeBase: ThemeVarsPartial = {
  base: 'light',
  brandTitle: 'Novu Design System',
  brandTarget: '_self',
};
/**
 * Novu Design System theme for Storybook
 *
 * @see https://storybook.js.org/docs/configure/theming
 */
export const lightTheme = create({
  ...themeBase,
  brandImage: './novu-logo-light.svg',
});

export const darkTheme = create({
  ...themeBase,
  base: 'dark',
  brandImage: './novu-logo-dark.svg',
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { ThemeVarsPartial } from '@storybook/theming';
import { create } from '@storybook/theming/create';
const themeBase: ThemeVarsPartial = {
base: 'light',
/**
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/.storybook/main.ts
Tamaño: 455 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { StorybookConfig } from '@storybook/react-vite';

export default {
  stories: ['../src/**/*.stories.mdx', '../src/**/*.stories.@(js|jsx|ts|tsx)'],

  addons: ['storybook-dark-mode', '@storybook/addon-controls'],

  framework: {
    name: '@storybook/react-vite',
    options: {},
  },

  docs: {
    // TODO: re-enable docs when we decide how to incorporate them
    autodocs: false,
  },

  staticDirs: ['./public'],
} satisfies StorybookConfig;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/.storybook/manager-head.html
Tamaño: 62 bytes
Lenguaje detectado: HTML

### CONTENIDO ORIGINAL ###

<link rel="icon" type="image/svg+xml" href="./favicon.svg" />


### ANALISIS AUTOMATICO (ESPAÑOL) ###

<link rel="icon" type="image/svg+xml" href="./favicon.svg" />
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/.storybook/preview-head.html
Tamaño: 210 bytes
Lenguaje detectado: HTML

### CONTENIDO ORIGINAL ###

<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<script>
  window._env_ = {
    SKIP_PREFLIGHT_CHECK: 'true',
  };
</script>


### ANALISIS AUTOMATICO (ESPAÑOL) ###

<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<script>
window._env_ = {
SKIP_PREFLIGHT_CHECK: 'true',
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/.storybook/preview.tsx
Tamaño: 1867 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { MantineThemeProvider } from '@mantine/core';
import { Decorator, Parameters, Preview } from '@storybook/react';
import React from 'react';
import { NovuiProvider } from '../src/components';
import { css } from '../styled-system/css';
import { darkTheme, lightTheme } from './NovuTheme';

// Bring in the Panda-generated stylesheets + CSS Layers
import '../src/index.css';

export const parameters: Parameters = {
  layout: 'fullscreen',
  docs: {
    // TODO: fix the container context
    // container: DocsContainer,
  },
  actions: { argTypesRegex: '^on[A-Z].*' },
  controls: {
    matchers: {
      color: /(background|color)$/i,
      date: /Date$/,
    },
  },
  darkMode: {
    // Override the default dark theme
    dark: darkTheme,
    // Override the default light theme
    light: lightTheme,
    darkClass: 'dark',
    stylePreview: true,
  },
};

const DEFAULT_COLOR_PALETTE = 'mode.cloud';

function ColorSchemeThemeWrapper({ children }) {
  // wraps the component preview in a full-page container with proper bg color
  return (
    <section
      className={css({
        padding: '250',
        bg: 'surface.page',
        colorPalette: DEFAULT_COLOR_PALETTE,
        minHeight: '[100vh]',
        height: 'full',
      })}
    >
      {children}
    </section>
  );
}

export const decorators: Decorator[] = [
  (renderStory) => (
    <ColorSchemeThemeWrapper>
      <NovuiProvider>
        <MantineThemeProvider>{renderStory()}</MantineThemeProvider>
      </NovuiProvider>
    </ColorSchemeThemeWrapper>
  ),
];

/** Global controls  */
export const preview: Preview = {
  // The default value of the theme arg for all stories
  argTypes: {
    colorPalette: {
      options: ['mode.cloud', 'mode.local'],
      control: { type: 'select' },
    },
  },
  args: {
    colorPalette: DEFAULT_COLOR_PALETTE,
  },
};

export default preview;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { MantineThemeProvider } from '@mantine/core';
import { Decorator, Parameters, Preview } from '@storybook/react';
import React from 'react';
import { NovuiProvider } from '../src/components';
import { css } from '../styled-system/css';
// Bring in the Panda-generated stylesheets + CSS Layers
// TODO: fix the container context
// container: DocsContainer,
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/.storybook/public/favicon.svg
Tamaño: 796 bytes
Lenguaje detectado: SVG

### CONTENIDO ORIGINAL ###

<svg width="2000" height="2000" viewBox="0 0 2000 2000" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M1540 801.609C1540 855.379 1474.72 882.004 1437.11 843.57L667.229 56.7032C771.33 19.9793 883.332 0 1000 0C1198.91 0 1384.25 58.0733 1540 158.19V801.609ZM1820 427.485V801.609C1820 1106.31 1450.07 1257.18 1236.98 1039.39L409.055 193.205C161.022 375.186 0 668.789 0 1000C0 1212.94 66.5559 1410.33 180 1572.51V1200.39C180 895.692 549.933 744.819 763.025 962.612L1589.81 1807.63C1838.48 1625.71 2000 1331.72 2000 1000C2000 787.061 1933.44 589.667 1820 427.485ZM562.887 1158.43L1331.32 1943.81C1227.63 1980.21 1116.12 2000 1000 2000C801.093 2000 615.749 1941.93 460 1841.81V1200.39C460 1146.62 525.282 1120 562.887 1158.43Z" fill="black"/>
</svg>


### ANALISIS AUTOMATICO (ESPAÑOL) ###

<svg width="2000" height="2000" viewBox="0 0 2000 2000" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1540 801.609C1540 855.379 1474.72 882.004 1437.11 843.57L667.229 56.7032C771.33 19.9793 883.332 0 1000 0C1198.91 0 1384.25 58.0733 1540 158.19V801.609ZM1820 427.485V801.609C1820 1106.31 1450.07 1257.18 1236.98 1039.39L409.055 193.205C161.022 375.186 0 668.789 0 1000C0 1212.94 66.5559 1410.33 180 1572.51V1200.39C180 895.692 549.933 744.819 763.025 962.612L1589.81 1807.63C1838.48 1625.71 2000 1331.72 2000 1000C2000 787.061 1933.44 589.667 1820 427.485ZM562.887 1158.43L1331.32 1943.81C1227.63 1980.21 1116.12 2000 1000 2000C801.093 2000 615.749 1941.93 460 1841.81V1200.39C460 1146.62 525.282 1120 562.887 1158.43Z" fill="black"/>
</svg>
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/.storybook/public/novu-logo-dark.svg
Tamaño: 5637 bytes
Lenguaje detectado: SVG

### CONTENIDO ORIGINAL ###

<svg width="1049" height="300" viewBox="0 0 1049 300" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M231 120.241C231 128.307 221.208 132.301 215.567 126.536L100.084 8.50548C115.699 2.9969 132.5 0 150 0C179.836 0 207.638 8.711 231 23.7285V120.241ZM273 64.1228V120.241C273 165.946 217.51 188.577 185.546 155.908L61.3582 28.9807C24.1534 56.2779 0 100.318 0 150C0 181.941 9.98339 211.55 27 235.877V180.059C27 134.354 82.4899 111.723 114.454 144.392L238.471 271.145C275.773 243.857 300 199.758 300 150C300 118.059 290.017 88.45 273 64.1228ZM84.433 173.764L199.697 291.571C184.144 297.031 167.419 300 150 300C120.164 300 92.3624 291.289 69 276.272V180.059C69 171.993 78.7923 167.999 84.433 173.764Z" fill="url(#paint0_linear_1199_1981)"/>
<path d="M487.303 223.326V140.944C487.303 126.727 483.892 115.918 477.07 108.517C470.248 101.116 459.527 97.4157 444.908 97.4157C434.967 97.4157 427.073 98.3895 421.225 100.337C415.378 102.09 411.674 103.356 410.115 104.135V223.326H380V84.8539C380.78 84.4644 382.924 83.588 386.432 82.2247C389.941 80.8614 394.619 79.4007 400.467 77.8427C406.314 76.2846 413.136 74.9213 420.933 73.7528C428.73 72.5843 437.306 72 446.662 72C457.383 72 467.129 73.4607 475.9 76.382C484.672 79.1086 492.079 83.1011 498.121 88.3596C504.359 93.618 509.134 99.9476 512.448 107.348C515.761 114.749 517.418 123.124 517.418 132.472V223.326H487.303Z" fill="white"/>
<path d="M713.257 150C713.257 161.101 711.308 171.423 707.41 180.966C703.706 190.509 698.444 198.787 691.621 205.798C684.799 212.614 676.613 218.067 667.061 222.157C657.51 226.052 646.985 228 635.485 228C623.984 228 613.361 226.052 603.615 222.157C594.064 218.067 585.878 212.614 579.055 205.798C572.233 198.787 566.873 190.509 562.975 180.966C559.271 171.423 557.419 161.101 557.419 150C557.419 138.899 559.271 128.577 562.975 119.034C566.873 109.491 572.233 101.311 579.055 94.4944C585.878 87.4831 594.064 82.03 603.615 78.1348C613.361 74.0449 623.984 72 635.485 72C646.985 72 657.51 74.0449 667.061 78.1348C676.613 82.03 684.799 87.4831 691.621 94.4944C698.444 101.311 703.706 109.491 707.41 119.034C711.308 128.577 713.257 138.899 713.257 150ZM681.973 150C681.973 142.21 680.901 135.101 678.757 128.674C676.613 122.052 673.494 116.404 669.401 111.73C665.502 106.861 660.629 103.161 654.782 100.629C649.129 97.9026 642.697 96.5393 635.485 96.5393C628.078 96.5393 621.45 97.9026 615.603 100.629C609.95 103.161 605.077 106.861 600.984 111.73C597.085 116.404 594.064 122.052 591.92 128.674C589.776 135.101 588.704 142.21 588.704 150C588.704 157.79 589.776 164.996 591.92 171.618C594.064 178.045 597.085 183.693 600.984 188.562C605.077 193.236 609.95 196.936 615.603 199.663C621.45 202.195 628.078 203.461 635.485 203.461C642.697 203.461 649.129 202.195 654.782 199.663C660.629 196.936 665.502 193.236 669.401 188.562C673.494 183.693 676.613 178.045 678.757 171.618C680.901 164.996 681.973 157.79 681.973 150Z" fill="white"/>
<path d="M888.255 83.1011C887.086 87.3858 885.039 93.1311 882.116 100.337C879.387 107.348 876.17 115.236 872.467 124C868.764 132.764 864.67 142.015 860.187 151.753C855.899 161.296 851.513 170.644 847.03 179.798C842.742 188.757 838.551 197.228 834.458 205.213C830.559 213.004 827.148 219.528 824.224 224.787H792.94C789.431 218.554 785.728 211.738 781.829 204.337C778.126 196.742 774.325 189.146 770.427 181.551C766.723 173.76 763.117 166.067 759.609 158.472C756.1 150.876 752.786 143.865 749.668 137.438C746.744 130.816 744.113 124.974 741.774 119.91C739.629 114.846 737.973 110.951 736.803 108.225C735.634 105.498 734.464 102.577 733.294 99.4607C732.125 96.3446 731.54 93.4232 731.54 90.6966C731.54 87.191 732.71 83.9775 735.049 81.0562C737.388 78.1348 741.384 76.6742 747.036 76.6742C750.935 76.6742 753.956 77.0637 756.1 77.8427C758.244 78.6217 759.414 79.1086 759.609 79.3034C762.922 88.4569 766.723 98.4869 771.011 109.393C775.495 120.3 779.978 131.109 784.461 141.82C789.139 152.337 793.622 162.464 797.91 172.202C802.199 181.745 805.999 189.828 809.313 196.449C811.652 191.97 814.673 185.64 818.377 177.461C822.275 169.086 826.271 159.933 830.364 150C834.653 140.067 838.941 129.843 843.229 119.326C847.517 108.809 851.318 99.1685 854.632 90.4045C856.191 86.1198 858.14 82.809 860.479 80.4719C862.818 77.9401 866.717 76.6742 872.175 76.6742C876.853 76.6742 880.556 77.5506 883.285 79.3034C886.209 81.0562 887.866 82.3221 888.255 83.1011Z" fill="white"/>
<path d="M1018.88 90.4045C1018.88 85.7303 1020.25 82.3221 1022.98 80.1798C1025.71 77.8427 1029.61 76.6742 1034.67 76.6742C1037.99 76.6742 1040.91 77.0637 1043.44 77.8427C1046.17 78.6217 1048.03 79.206 1049 79.5955V223.326C1047.64 223.715 1045.2 224.105 1041.69 224.494C1038.38 224.884 1034.28 225.273 1029.41 225.663C1024.54 226.247 1019.18 226.637 1013.33 226.831C1007.48 227.221 1001.54 227.416 995.495 227.416C977.757 227.416 963.333 225.273 952.223 220.989C941.307 216.704 932.633 210.472 926.201 202.292C918.209 191.97 914.213 178.24 914.213 161.101V90.4045C914.213 85.7303 915.578 82.3221 918.307 80.1798C921.035 77.8427 924.934 76.6742 930.002 76.6742C933.315 76.6742 936.239 77.0637 938.773 77.8427C941.502 78.6217 943.354 79.206 944.328 79.5955V157.888C944.328 172.689 948.032 183.79 955.439 191.191C963.041 198.592 975.808 202.292 993.74 202.292C1000.56 202.292 1006.02 202.097 1010.11 201.708C1014.4 201.124 1017.33 200.637 1018.88 200.247V90.4045Z" fill="white"/>
<defs>
<linearGradient id="paint0_linear_1199_1981" x1="300" y1="0" x2="3.57628e-05" y2="300" gradientUnits="userSpaceOnUse">
<stop offset="0.231667" stop-color="#FF884D"/>
<stop offset="0.801667" stop-color="#E300BD"/>
</linearGradient>
</defs>
</svg>


### ANALISIS AUTOMATICO (ESPAÑOL) ###

<svg width="1049" height="300" viewBox="0 0 1049 300" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M231 120.241C231 128.307 221.208 132.301 215.567 126.536L100.084 8.50548C115.699 2.9969 132.5 0 150 0C179.836 0 207.638 8.711 231 23.7285V120.241ZM273 64.1228V120.241C273 165.946 217.51 188.577 185.546 155.908L61.3582 28.9807C24.1534 56.2779 0 100.318 0 150C0 181.941 9.98339 211.55 27 235.877V180.059C27 134.354 82.4899 111.723 114.454 144.392L238.471 271.145C275.773 243.857 300 199.758 300 150C300 118.059 290.017 88.45 273 64.1228ZM84.433 173.764L199.697 291.571C184.144 297.031 167.419 300 150 300C120.164 300 92.3624 291.289 69 276.272V180.059C69 171.993 78.7923 167.999 84.433 173.764Z" fill="url(#paint0_linear_1199_1981)"/>
<path d="M487.303 223.326V140.944C487.303 126.727 483.892 115.918 477.07 108.517C470.248 101.116 459.527 97.4157 444.908 97.4157C434.967 97.4157 427.073 98.3895 421.225 100.337C415.378 102.09 411.674 103.356 410.115 104.135V223.326H380V84.8539C380.78 84.4644 382.924 83.588 386.432 82.2247C389.941 80.8614 394.619 79.4007 400.467 77.8427C406.314 76.2846 413.136 74.9213 420.933 73.7528C428.73 72.5843 437.306 72 446.662 72C457.383 72 467.129 73.4607 475.9 76.382C484.672 79.1086 492.079 83.1011 498.121 88.3596C504.359 93.618 509.134 99.9476 512.448 107.348C515.761 114.749 517.418 123.124 517.418 132.472V223.326H487.303Z" fill="white"/>
<path d="M713.257 150C713.257 161.101 711.308 171.423 707.41 180.966C703.706 190.509 698.444 198.787 691.621 205.798C684.799 212.614 676.613 218.067 667.061 222.157C657.51 226.052 646.985 228 635.485 228C623.984 228 613.361 226.052 603.615 222.157C594.064 218.067 585.878 212.614 579.055 205.798C572.233 198.787 566.873 190.509 562.975 180.966C559.271 171.423 557.419 161.101 557.419 150C557.419 138.899 559.271 128.577 562.975 119.034C566.873 109.491 572.233 101.311 579.055 94.4944C585.878 87.4831 594.064 82.03 603.615 78.1348C613.361 74.0449 623.984 72 635.485 72C646.985 72 657.51 74.0449 667.061 78.1348C676.613 82.03 684.799 87.4831 691.621 94.4944C698.444 101.311 703.706 109.491 707.41 119.034C711.308 128.577 713.257 138.899 713.257 150ZM681.973 150C681.973 142.21 680.901 135.101 678.757 128.674C676.613 122.052 673.494 116.404 669.401 111.73C665.502 106.861 660.629 103.161 654.782 100.629C649.129 97.9026 642.697 96.5393 635.485 96.5393C628.078 96.5393 621.45 97.9026 615.603 100.629C609.95 103.161 605.077 106.861 600.984 111.73C597.085 116.404 594.064 122.052 591.92 128.674C589.776 135.101 588.704 142.21 588.704 150C588.704 157.79 589.776 164.996 591.92 171.618C594.064 178.045 597.085 183.693 600.984 188.562C605.077 193.236 609.95 196.936 615.603 199.663C621.45 202.195 628.078 203.461 635.485 203.461C642.697 203.461 649.129 202.195 654.782 199.663C660.629 196.936 665.502 193.236 669.401 188.562C673.494 183.693 676.613 178.045 678.757 171.618C680.901 164.996 681.973 157.79 681.973 150Z" fill="white"/>
<path d="M888.255 83.1011C887.086 87.3858 885.039 93.1311 882.116 100.337C879.387 107.348 876.17 115.236 872.467 124C868.764 132.764 864.67 142.015 860.187 151.753C855.899 161.296 851.513 170.644 847.03 179.798C842.742 188.757 838.551 197.228 834.458 205.213C830.559 213.004 827.148 219.528 824.224 224.787H792.94C789.431 218.554 785.728 211.738 781.829 204.337C778.126 196.742 774.325 189.146 770.427 181.551C766.723 173.76 763.117 166.067 759.609 158.472C756.1 150.876 752.786 143.865 749.668 137.438C746.744 130.816 744.113 124.974 741.774 119.91C739.629 114.846 737.973 110.951 736.803 108.225C735.634 105.498 734.464 102.577 733.294 99.4607C732.125 96.3446 731.54 93.4232 731.54 90.6966C731.54 87.191 732.71 83.9775 735.049 81.0562C737.388 78.1348 741.384 76.6742 747.036 76.6742C750.935 76.6742 753.956 77.0637 756.1 77.8427C758.244 78.6217 759.414 79.1086 759.609 79.3034C762.922 88.4569 766.723 98.4869 771.011 109.393C775.495 120.3 779.978 131.109 784.461 141.82C789.139 152.337 793.622 162.464 797.91 172.202C802.199 181.745 805.999 189.828 809.313 196.449C811.652 191.97 814.673 185.64 818.377 177.461C822.275 169.086 826.271 159.933 830.364 150C834.653 140.067 838.941 129.843 843.229 119.326C847.517 108.809 851.318 99.1685 854.632 90.4045C856.191 86.1198 858.14 82.809 860.479 80.4719C862.818 77.9401 866.717 76.6742 872.175 76.6742C876.853 76.6742 880.556 77.5506 883.285 79.3034C886.209 81.0562 887.866 82.3221 888.255 83.1011Z" fill="white"/>
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/.storybook/public/novu-logo-light.svg
Tamaño: 5637 bytes
Lenguaje detectado: SVG

### CONTENIDO ORIGINAL ###

<svg width="1049" height="300" viewBox="0 0 1049 300" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M231 120.241C231 128.307 221.208 132.301 215.567 126.536L100.084 8.50548C115.699 2.9969 132.5 0 150 0C179.836 0 207.638 8.711 231 23.7285V120.241ZM273 64.1228V120.241C273 165.946 217.51 188.577 185.546 155.908L61.3582 28.9807C24.1534 56.2779 0 100.318 0 150C0 181.941 9.98339 211.55 27 235.877V180.059C27 134.354 82.4899 111.723 114.454 144.392L238.471 271.145C275.773 243.857 300 199.758 300 150C300 118.059 290.017 88.45 273 64.1228ZM84.433 173.764L199.697 291.571C184.144 297.031 167.419 300 150 300C120.164 300 92.3624 291.289 69 276.272V180.059C69 171.993 78.7923 167.999 84.433 173.764Z" fill="url(#paint0_linear_1301_3067)"/>
<path d="M487.303 223.326V140.944C487.303 126.727 483.892 115.918 477.07 108.517C470.248 101.116 459.527 97.4157 444.908 97.4157C434.967 97.4157 427.073 98.3895 421.225 100.337C415.378 102.09 411.674 103.356 410.115 104.135V223.326H380V84.8539C380.78 84.4644 382.924 83.588 386.432 82.2247C389.941 80.8614 394.619 79.4007 400.467 77.8427C406.314 76.2846 413.136 74.9213 420.933 73.7528C428.73 72.5843 437.306 72 446.662 72C457.383 72 467.129 73.4607 475.9 76.382C484.672 79.1086 492.079 83.1011 498.121 88.3596C504.359 93.618 509.134 99.9476 512.448 107.348C515.761 114.749 517.418 123.124 517.418 132.472V223.326H487.303Z" fill="black"/>
<path d="M713.257 150C713.257 161.101 711.308 171.423 707.41 180.966C703.706 190.509 698.444 198.787 691.621 205.798C684.799 212.614 676.613 218.067 667.061 222.157C657.51 226.052 646.985 228 635.485 228C623.984 228 613.361 226.052 603.615 222.157C594.064 218.067 585.878 212.614 579.055 205.798C572.233 198.787 566.873 190.509 562.975 180.966C559.271 171.423 557.419 161.101 557.419 150C557.419 138.899 559.271 128.577 562.975 119.034C566.873 109.491 572.233 101.311 579.055 94.4944C585.878 87.4831 594.064 82.03 603.615 78.1348C613.361 74.0449 623.984 72 635.485 72C646.985 72 657.51 74.0449 667.061 78.1348C676.613 82.03 684.799 87.4831 691.621 94.4944C698.444 101.311 703.706 109.491 707.41 119.034C711.308 128.577 713.257 138.899 713.257 150ZM681.973 150C681.973 142.21 680.901 135.101 678.757 128.674C676.613 122.052 673.494 116.404 669.401 111.73C665.502 106.861 660.629 103.161 654.782 100.629C649.129 97.9026 642.697 96.5393 635.485 96.5393C628.078 96.5393 621.45 97.9026 615.603 100.629C609.95 103.161 605.077 106.861 600.984 111.73C597.085 116.404 594.064 122.052 591.92 128.674C589.776 135.101 588.704 142.21 588.704 150C588.704 157.79 589.776 164.996 591.92 171.618C594.064 178.045 597.085 183.693 600.984 188.562C605.077 193.236 609.95 196.936 615.603 199.663C621.45 202.195 628.078 203.461 635.485 203.461C642.697 203.461 649.129 202.195 654.782 199.663C660.629 196.936 665.502 193.236 669.401 188.562C673.494 183.693 676.613 178.045 678.757 171.618C680.901 164.996 681.973 157.79 681.973 150Z" fill="black"/>
<path d="M888.255 83.1011C887.086 87.3858 885.039 93.1311 882.115 100.337C879.387 107.348 876.17 115.236 872.467 124C868.764 132.764 864.67 142.015 860.187 151.753C855.899 161.296 851.513 170.644 847.03 179.798C842.742 188.757 838.551 197.228 834.458 205.213C830.559 213.004 827.148 219.528 824.224 224.787H792.94C789.431 218.554 785.728 211.738 781.829 204.337C778.126 196.742 774.325 189.146 770.427 181.551C766.723 173.76 763.117 166.067 759.609 158.472C756.1 150.876 752.786 143.865 749.668 137.438C746.744 130.816 744.113 124.974 741.774 119.91C739.629 114.846 737.973 110.951 736.803 108.225C735.634 105.498 734.464 102.577 733.295 99.4607C732.125 96.3446 731.54 93.4232 731.54 90.6966C731.54 87.191 732.71 83.9775 735.049 81.0562C737.388 78.1348 741.384 76.6742 747.036 76.6742C750.935 76.6742 753.956 77.0637 756.1 77.8427C758.244 78.6217 759.414 79.1086 759.609 79.3034C762.922 88.4569 766.723 98.4869 771.011 109.393C775.495 120.3 779.978 131.109 784.461 141.82C789.139 152.337 793.622 162.464 797.91 172.202C802.199 181.745 805.999 189.828 809.313 196.449C811.652 191.97 814.673 185.64 818.377 177.461C822.275 169.086 826.271 159.933 830.364 150C834.653 140.067 838.941 129.843 843.229 119.326C847.517 108.809 851.318 99.1685 854.632 90.4045C856.191 86.1198 858.14 82.809 860.479 80.4719C862.818 77.9401 866.717 76.6742 872.175 76.6742C876.853 76.6742 880.556 77.5506 883.285 79.3034C886.209 81.0562 887.866 82.3221 888.255 83.1011Z" fill="black"/>
<path d="M1018.88 90.4045C1018.88 85.7303 1020.25 82.3221 1022.98 80.1798C1025.71 77.8427 1029.61 76.6742 1034.67 76.6742C1037.99 76.6742 1040.91 77.0637 1043.44 77.8427C1046.17 78.6217 1048.03 79.206 1049 79.5955V223.326C1047.64 223.715 1045.2 224.105 1041.69 224.494C1038.38 224.884 1034.28 225.273 1029.41 225.663C1024.54 226.247 1019.18 226.637 1013.33 226.831C1007.48 227.221 1001.54 227.416 995.495 227.416C977.757 227.416 963.333 225.273 952.223 220.989C941.307 216.704 932.633 210.472 926.201 202.292C918.209 191.97 914.213 178.24 914.213 161.101V90.4045C914.213 85.7303 915.578 82.3221 918.307 80.1798C921.035 77.8427 924.934 76.6742 930.002 76.6742C933.315 76.6742 936.239 77.0637 938.773 77.8427C941.502 78.6217 943.354 79.206 944.328 79.5955V157.888C944.328 172.689 948.032 183.79 955.439 191.191C963.041 198.592 975.808 202.292 993.74 202.292C1000.56 202.292 1006.02 202.097 1010.11 201.708C1014.4 201.124 1017.33 200.637 1018.88 200.247V90.4045Z" fill="black"/>
<defs>
<linearGradient id="paint0_linear_1301_3067" x1="300" y1="0" x2="3.57628e-05" y2="300" gradientUnits="userSpaceOnUse">
<stop offset="0.231667" stop-color="#FF884D"/>
<stop offset="0.801667" stop-color="#E300BD"/>
</linearGradient>
</defs>
</svg>


### ANALISIS AUTOMATICO (ESPAÑOL) ###

<svg width="1049" height="300" viewBox="0 0 1049 300" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M231 120.241C231 128.307 221.208 132.301 215.567 126.536L100.084 8.50548C115.699 2.9969 132.5 0 150 0C179.836 0 207.638 8.711 231 23.7285V120.241ZM273 64.1228V120.241C273 165.946 217.51 188.577 185.546 155.908L61.3582 28.9807C24.1534 56.2779 0 100.318 0 150C0 181.941 9.98339 211.55 27 235.877V180.059C27 134.354 82.4899 111.723 114.454 144.392L238.471 271.145C275.773 243.857 300 199.758 300 150C300 118.059 290.017 88.45 273 64.1228ZM84.433 173.764L199.697 291.571C184.144 297.031 167.419 300 150 300C120.164 300 92.3624 291.289 69 276.272V180.059C69 171.993 78.7923 167.999 84.433 173.764Z" fill="url(#paint0_linear_1301_3067)"/>
<path d="M487.303 223.326V140.944C487.303 126.727 483.892 115.918 477.07 108.517C470.248 101.116 459.527 97.4157 444.908 97.4157C434.967 97.4157 427.073 98.3895 421.225 100.337C415.378 102.09 411.674 103.356 410.115 104.135V223.326H380V84.8539C380.78 84.4644 382.924 83.588 386.432 82.2247C389.941 80.8614 394.619 79.4007 400.467 77.8427C406.314 76.2846 413.136 74.9213 420.933 73.7528C428.73 72.5843 437.306 72 446.662 72C457.383 72 467.129 73.4607 475.9 76.382C484.672 79.1086 492.079 83.1011 498.121 88.3596C504.359 93.618 509.134 99.9476 512.448 107.348C515.761 114.749 517.418 123.124 517.418 132.472V223.326H487.303Z" fill="black"/>
<path d="M713.257 150C713.257 161.101 711.308 171.423 707.41 180.966C703.706 190.509 698.444 198.787 691.621 205.798C684.799 212.614 676.613 218.067 667.061 222.157C657.51 226.052 646.985 228 635.485 228C623.984 228 613.361 226.052 603.615 222.157C594.064 218.067 585.878 212.614 579.055 205.798C572.233 198.787 566.873 190.509 562.975 180.966C559.271 171.423 557.419 161.101 557.419 150C557.419 138.899 559.271 128.577 562.975 119.034C566.873 109.491 572.233 101.311 579.055 94.4944C585.878 87.4831 594.064 82.03 603.615 78.1348C613.361 74.0449 623.984 72 635.485 72C646.985 72 657.51 74.0449 667.061 78.1348C676.613 82.03 684.799 87.4831 691.621 94.4944C698.444 101.311 703.706 109.491 707.41 119.034C711.308 128.577 713.257 138.899 713.257 150ZM681.973 150C681.973 142.21 680.901 135.101 678.757 128.674C676.613 122.052 673.494 116.404 669.401 111.73C665.502 106.861 660.629 103.161 654.782 100.629C649.129 97.9026 642.697 96.5393 635.485 96.5393C628.078 96.5393 621.45 97.9026 615.603 100.629C609.95 103.161 605.077 106.861 600.984 111.73C597.085 116.404 594.064 122.052 591.92 128.674C589.776 135.101 588.704 142.21 588.704 150C588.704 157.79 589.776 164.996 591.92 171.618C594.064 178.045 597.085 183.693 600.984 188.562C605.077 193.236 609.95 196.936 615.603 199.663C621.45 202.195 628.078 203.461 635.485 203.461C642.697 203.461 649.129 202.195 654.782 199.663C660.629 196.936 665.502 193.236 669.401 188.562C673.494 183.693 676.613 178.045 678.757 171.618C680.901 164.996 681.973 157.79 681.973 150Z" fill="black"/>
<path d="M888.255 83.1011C887.086 87.3858 885.039 93.1311 882.115 100.337C879.387 107.348 876.17 115.236 872.467 124C868.764 132.764 864.67 142.015 860.187 151.753C855.899 161.296 851.513 170.644 847.03 179.798C842.742 188.757 838.551 197.228 834.458 205.213C830.559 213.004 827.148 219.528 824.224 224.787H792.94C789.431 218.554 785.728 211.738 781.829 204.337C778.126 196.742 774.325 189.146 770.427 181.551C766.723 173.76 763.117 166.067 759.609 158.472C756.1 150.876 752.786 143.865 749.668 137.438C746.744 130.816 744.113 124.974 741.774 119.91C739.629 114.846 737.973 110.951 736.803 108.225C735.634 105.498 734.464 102.577 733.295 99.4607C732.125 96.3446 731.54 93.4232 731.54 90.6966C731.54 87.191 732.71 83.9775 735.049 81.0562C737.388 78.1348 741.384 76.6742 747.036 76.6742C750.935 76.6742 753.956 77.0637 756.1 77.8427C758.244 78.6217 759.414 79.1086 759.609 79.3034C762.922 88.4569 766.723 98.4869 771.011 109.393C775.495 120.3 779.978 131.109 784.461 141.82C789.139 152.337 793.622 162.464 797.91 172.202C802.199 181.745 805.999 189.828 809.313 196.449C811.652 191.97 814.673 185.64 818.377 177.461C822.275 169.086 826.271 159.933 830.364 150C834.653 140.067 838.941 129.843 843.229 119.326C847.517 108.809 851.318 99.1685 854.632 90.4045C856.191 86.1198 858.14 82.809 860.479 80.4719C862.818 77.9401 866.717 76.6742 872.175 76.6742C876.853 76.6742 880.556 77.5506 883.285 79.3034C886.209 81.0562 887.866 82.3221 888.255 83.1011Z" fill="black"/>
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/global.styles.ts
Tamaño: 1459 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineGlobalStyles } from '@pandacss/dev';

export const GLOBAL_CSS = defineGlobalStyles({
  body: {
    // text styles
    fontFamily: 'system',
    fontWeight: 'regular',
    letterSpacing: '0',
    fontSize: '88',
    textDecoration: 'none',
    color: 'typography.text.main',
    // this is for reverse compatibility with legacy global styles
    lineHeight: '[1.15]',

    backgroundColor: 'surface.page',
    overflow: 'hidden',
    scrollbarWidth: '{sizes.scrollbar.width}',
    scrollbarColor: '{colors.scrollbar.color}',
    /* SAFARI SCROLLBAR SUPPORT - remove after Safari supports `scrollbar-width` and `scrollbar-color` */
    '::-webkit-scrollbar': {
      width: '{sizes.scrollbar.track}',
      height: '{sizes.scrollbar.track}',
    },
    '::-webkit-scrollbar-thumb': {
      // For this calculation, see: https://stackoverflow.com/questions/11691718/css-webkit-scrollbar-and-safari
      border: `calc(({sizes.scrollbar.track} - {sizes.scrollbar.thumb}) / 2) solid {colors.scrollbar.track}`,
      borderRadius: '{sizes.scrollbar.thumb}',
      backgroundClip: 'padding-box',
      backgroundColor: '{colors.scrollbar.thumb}',
    },
    '::-webkit-scrollbar-track': {
      backgroundColor: '{colors.scrollbar.track}',
    },
    '::-webkit-scrollbar-corner': {
      backgroundColor: '{colors.scrollbar.track}',
    },
    /* END SAFARI SCROLLBAR SUPPORT */
  },
  a: {
    textDecoration: 'none',
    color: 'inherit',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/index.css
Tamaño: 183 bytes
Lenguaje detectado: CSS

### CONTENIDO ORIGINAL ###

@layer reset, base, mantine, tokens, recipes, utilities;

@import "@mantine/core/styles.layer.css";
@import "@mantine/tiptap/styles.layer.css";
@import "../styled-system/styles.css";


### ANALISIS AUTOMATICO (ESPAÑOL) ###

@layer reset, base, mantine, tokens, recipes, utilities;
@import "@mantine/core/styles.layer.css";
@import "@mantine/tiptap/styles.layer.css";
@import "../styled-system/styles.css";
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/index.ts
Tamaño: 233 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './components';
export * from './global.styles';
export * from './hooks';
export * from './ingredients';
export * from './json-schema-components/JsonSchemaForm';
export * from './panda-preset';
export * from './types';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/panda-preset.ts
Tamaño: 4836 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { definePreset } from '@pandacss/dev';
import {
  BUTTON_RECIPE,
  CHECKBOX_RECIPE,
  CODE_BLOCK_RECIPE,
  INPUT_EDITOR_WIDGET_RECIPE,
  INPUT_RECIPE,
  JSON_SCHEMA_FORM_ARRAY_TOOLBAR_RECIPE,
  JSON_SCHEMA_FORM_SECTION_RECIPE,
  LOADING_OVERLAY_RECIPE,
  SELECT_RECIPE,
  TABS_RECIPE,
  TEXT_RECIPE,
  TITLE_RECIPE,
  VARIABLE_SUGGESTION_LIST_RECIPE,
} from './recipes';
import { BORDER_TOKENS, BORDER_WIDTH_TOKENS } from './tokens/borders.tokens';
import { COLOR_PALETTE_TOKENS, LEGACY_COLOR_TOKENS } from './tokens/colors.tokens';
import { GRADIENT_TOKENS, LEGACY_GRADIENT_TOKENS } from './tokens/gradients.tokens';
import { LEGACY_OPACITY_TOKENS, OPACITY_TOKENS } from './tokens/opacity.tokens';
import { LEGACY_RADIUS_TOKENS, RADIUS_TOKENS } from './tokens/radius.tokens';
import { COLOR_SEMANTIC_TOKENS, LEGACY_COLOR_SEMANTIC_TOKENS } from './tokens/semanticColors.tokens';
import { SEMANTIC_OPACITY_TOKENS } from './tokens/semanticOpacity.tokens';
import { SEMANTIC_RADIUS_TOKENS } from './tokens/semanticRadius.tokens';
import { SEMANTIC_SIZES_TOKENS } from './tokens/semanticSizes.tokens';
import { SEMANTIC_SPACING_TOKENS } from './tokens/semanticSpacing.tokens';
import { SEMANTIC_FONT_SIZE_TOKENS, SEMANTIC_LINE_HEIGHT_TOKENS } from './tokens/semanticTypography.tokens';
import { LEGACY_SHADOW_TOKENS } from './tokens/shadow.tokens';
import { SIZES_TOKENS } from './tokens/sizes.tokens';
import { SPACING_TOKENS } from './tokens/spacing.tokens';
import { TEXT_STYLES } from './tokens/textStyles.tokens';
import {
  FONT_FAMILY_TOKENS,
  FONT_SIZE_TOKENS,
  FONT_WEIGHT_TOKENS,
  LEGACY_FONT_FAMILY_TOKENS,
  LETTER_SPACING_TOKENS,
  LINE_HEIGHT_TOKENS,
} from './tokens/typography.tokens';
import { Z_INDEX_TOKENS } from './tokens/zIndex.tokens';

/**
 * This defines all Novu tokens into a single preset to be used in our various apps (and design-system).
 * https://panda-css.com/docs/customization/presets
 *
 * Future-looking note: this preset and any other associated files may be a good candidate for moving into
 * a standalone package depending on how we interface with Supernova (our design token tool), and if we want
 * the definitions to be separate from token definitions.
 */
export const novuPandaPreset = definePreset({
  theme: {
    tokens: {
      sizes: SIZES_TOKENS,
      spacing: SPACING_TOKENS,
      colors: {
        ...COLOR_PALETTE_TOKENS,
        ...LEGACY_COLOR_TOKENS,
      },
      // typography tokens
      fonts: {
        ...FONT_FAMILY_TOKENS,
        ...LEGACY_FONT_FAMILY_TOKENS,
      },
      fontSizes: FONT_SIZE_TOKENS,
      lineHeights: LINE_HEIGHT_TOKENS,
      fontWeights: FONT_WEIGHT_TOKENS,
      letterSpacings: LETTER_SPACING_TOKENS,
      radii: {
        ...RADIUS_TOKENS,
        ...LEGACY_RADIUS_TOKENS,
      },
      borderWidths: BORDER_WIDTH_TOKENS,
      borders: BORDER_TOKENS,
      zIndex: Z_INDEX_TOKENS,
      opacity: {
        ...OPACITY_TOKENS,
        ...LEGACY_OPACITY_TOKENS,
      },
    },
    semanticTokens: {
      sizes: SEMANTIC_SIZES_TOKENS,
      spacing: SEMANTIC_SPACING_TOKENS,
      colors: {
        ...COLOR_SEMANTIC_TOKENS,
        ...LEGACY_COLOR_SEMANTIC_TOKENS,
      },
      fontSizes: SEMANTIC_FONT_SIZE_TOKENS,
      lineHeights: SEMANTIC_LINE_HEIGHT_TOKENS,
      radii: SEMANTIC_RADIUS_TOKENS,
      shadows: LEGACY_SHADOW_TOKENS,
      gradients: {
        ...GRADIENT_TOKENS,
        ...LEGACY_GRADIENT_TOKENS,
      },
      opacity: SEMANTIC_OPACITY_TOKENS,
    },
    textStyles: TEXT_STYLES,
    extend: {
      recipes: {
        text: TEXT_RECIPE,
        title: TITLE_RECIPE,
        button: BUTTON_RECIPE,
        tabs: TABS_RECIPE,
        input: INPUT_RECIPE,
        select: SELECT_RECIPE,
        checkbox: CHECKBOX_RECIPE,
        codeBlock: CODE_BLOCK_RECIPE,
        loadingOverlay: LOADING_OVERLAY_RECIPE,
        jsonSchemaFormSection: JSON_SCHEMA_FORM_SECTION_RECIPE,
        jsonSchemaFormArrayToolbar: JSON_SCHEMA_FORM_ARRAY_TOOLBAR_RECIPE,
        variableSuggestionList: VARIABLE_SUGGESTION_LIST_RECIPE,
        inputEditorWidget: INPUT_EDITOR_WIDGET_RECIPE,
      },
    },
  },
  conditions: {
    extend: {
      // Mantine uses *-error.
      error: '&:is(:error, [data-error], [aria-error])',
      groupError: '.group:is(:error, [data-error], [aria-error]) &',
      /** Mantine uses hover*ed*, so extend the selector to support it */
      hover: '&:is(:hover, [data-hover], [data-hovered])',
      /** apply hover only when element or child is not disabled */
      hoverNotDisabled: '&:is(:hover, [data-hover], [data-hovered])&:not(:has(:disabled))',
    },
  },
  staticCss: {
    css: [
      {
        properties: {
          // Must generate color modes statically to ensure they're available
          colorPalette: ['mode.local', 'mode.cloud'],
        },
      },
    ],
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/component-audit/ComponentAuditTable.stories.tsx
Tamaño: 1116 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { css } from '../../styled-system/css';
import { ComponentAuditTable } from './ComponentAuditTable';

import scanJson from './component-scans/scan.json';

export default {
  title: 'ComponentAudit',
  component: ComponentAuditTable,
  argTypes: {},
} as Meta<typeof ComponentAuditTable>;

const TableWrapper = ({ children }: { children: React.ReactNode }) => {
  return (
    <div
      className={css({
        overflowX: 'auto',
        maxWidth: '[100%]',
        overflowY: 'auto',
        maxHeight: '[95dvh]',
      })}
    >
      {children}
    </div>
  );
};

const Template: StoryFn<typeof ComponentAuditTable> = ({ ...args }) => (
  <>
    <h3 className={css({ color: 'typography.text.main' })}>
      If no data is appearing below, please run `pnpm audit-components` in your terminal in the `design-system`
      directory
    </h3>
    <br />
    <TableWrapper>
      <ComponentAuditTable data={scanJson ?? {}} />
    </TableWrapper>
  </>
);

export const ComponentAudit = Template.bind({});
ComponentAudit.args = {};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { css } from '../../styled-system/css';
import { ComponentAuditTable } from './ComponentAuditTable';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/component-audit/ComponentAuditTable.tsx
Tamaño: 7157 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import React, { useMemo, useState } from 'react';
import { css } from '../../styled-system/css';

interface JsonData {
  [key: string]: {
    instances: number;
    props: {
      [key: string]: number | string[];
    };
    srcPkg: string;
  };
}

interface ComponentAuditTableProps {
  data: JsonData;
  className?: string;
}

type SortableKey = keyof Omit<JsonData[string], 'props'> | 'name';

export const ComponentAuditTable: React.FC<ComponentAuditTableProps> = ({ data: jsonData, className }) => {
  const [expandedRows, setExpandedRows] = useState<string[]>([]);
  const [sortColumn, setSortColumn] = useState<SortableKey | null>(null);
  const [sortOrder, setSortOrder] = useState<'asc' | 'desc' | null>(null);

  const data = useMemo(() => {
    return Object.entries(jsonData).map(([key, value]) => ({ ...value, name: key.split('/')[1] }));
  }, [jsonData]);

  const toggleRow = (name: string) => {
    setExpandedRows((prevState) =>
      prevState.includes(name) ? prevState.filter((row) => row !== name) : [...prevState, name]
    );
  };

  const sortData = (key: SortableKey) => {
    if (sortColumn === key) {
      setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    } else {
      setSortColumn(key);
      setSortOrder('asc');
    }
  };

  const getSortIcon = (key: SortableKey) => {
    if (sortColumn !== key) return null;
    if (sortOrder === 'asc') return '⬆️';
    if (sortOrder === 'desc') return '⬇️';

    return null;
  };

  const sortedData = sortColumn
    ? data.sort((a, b) => {
        const aValue = a[sortColumn];
        const bValue = b[sortColumn];

        if (typeof aValue === 'string' && typeof bValue === 'string') {
          return sortOrder === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
        }

        if (typeof aValue === 'number' && typeof bValue === 'number') {
          return sortOrder === 'asc' ? aValue - bValue : bValue - aValue;
        }

        return 0;
      })
    : data;

  return (
    <table
      className={`${css({ width: '[100%]', borderCollapse: 'collapse', color: 'typography.text.main' })} ${
        className ?? ''
      }`}
    >
      <thead>
        <tr className={css({ bg: 'surface.popover', fontSize: '100', fontWeight: 'strong' })}>
          <th
            className={css({
              py: '[2]',
              px: '25',
              textAlign: 'left',
              borderBottom: 'solid',
              borderColor: 'typography.text.secondary',
              cursor: 'pointer',
            })}
            onClick={() => sortData('name')}
          >
            Name {getSortIcon('name')}
          </th>
          <th
            className={css({
              py: '[2]',
              px: '25',
              textAlign: 'left',
              borderBottom: 'solid',
              borderColor: 'typography.text.secondary',
              cursor: 'pointer',
            })}
            onClick={() => sortData('instances')}
          >
            Instance Count {getSortIcon('instances')}
          </th>
          <th
            className={css({
              py: '[2]',
              px: '25',
              textAlign: 'left',
              borderBottom: 'solid',
              borderColor: 'typography.text.secondary',
              cursor: 'pointer',
            })}
            onClick={() => sortData('srcPkg')}
          >
            Source {getSortIcon('srcPkg')}
          </th>
          <th
            className={css({
              py: '[2]',
              px: '25',
              textAlign: 'left',
              borderBottom: 'solid',
              borderColor: 'typography.text.secondary',
            })}
          >
            Props
          </th>
        </tr>
      </thead>
      <tbody>
        {sortedData.map(({ name, instances, props, srcPkg }) => (
          <React.Fragment key={`${srcPkg}-${name}`}>
            <tr className={css({ bg: 'surface.page', _even: { bg: { base: '[#DDDDDD]', _dark: '[#222233]' } } })}>
              <td
                className={css({
                  py: '[2]',
                  px: '25',
                  borderBottom: 'solid',
                  borderColor: 'typography.text.secondary',
                })}
              >
                {name}
              </td>
              <td
                className={css({
                  py: '[2]',
                  px: '25',
                  borderBottom: 'solid',
                  borderColor: 'typography.text.secondary',
                })}
              >
                {instances}
              </td>
              <td
                className={css({
                  py: '[2]',
                  px: '25',
                  borderBottom: 'solid',
                  borderColor: 'typography.text.secondary',
                })}
              >
                {srcPkg}
              </td>
              <td
                className={css({
                  py: '[2]',
                  px: '25',
                  borderBottom: 'solid',
                  borderColor: 'typography.text.secondary',
                  maxW: '[300px]',
                  textOverflow: 'ellipsis',
                })}
              >
                <span
                  className={css({
                    textDecoration: 'underline',
                    _hover: { color: 'typography.text.feedback.info' },
                    cursor: 'pointer',
                  })}
                  onClick={() => toggleRow(name)}
                >
                  {Object.entries(props)
                    .slice(0, 3)
                    .map(([prop, value]) => `${prop}: ${typeof value === 'number' ? value : value.join(', ')}`)
                    .join(', ')}
                  {Object.keys(props).length > 3 && '...'}
                </span>
              </td>
            </tr>
            {expandedRows.includes(name) && (
              <tr>
                <td colSpan={4} className={css({ py: '[2]', px: '25' })}>
                  <div
                    className={css({
                      display: 'grid',
                      gridTemplateColumns: '[repeat(auto-fit, minmax(150px, 1fr))]',
                      gap: '25',
                    })}
                  >
                    {Object.entries(props).map(([prop, value]) => (
                      <div
                        key={prop}
                        className={css({
                          bg: 'surface.popover',
                          px: '25',
                          py: '[2]',
                          display: 'grid',
                          gridTemplateColumns: '[max-content 1fr]',
                          alignItems: 'center',
                          gap: '25',
                        })}
                      >
                        <span className={css({ fontWeight: 'strong' })}>{prop}:</span>
                        <span>{typeof value === 'number' ? value : value.join(', ')}</span>
                      </div>
                    ))}
                  </div>
                </td>
              </tr>
            )}
          </React.Fragment>
        ))}
      </tbody>
    </table>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React, { useMemo, useState } from 'react';
import { css } from '../../styled-system/css';
interface JsonData {
[key: string]: {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/NovuiProvider.tsx
Tamaño: 504 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { MantineProvider } from '@mantine/core';
import { FC, PropsWithChildren } from 'react';
import { IconProvider } from '../icons/IconProvider';
import { MANTINE_THEME } from './mantine-theme.config';

type INovuiProviderProps = PropsWithChildren;

/** Used to export a v7 Mantine provider */
export const NovuiProvider: FC<INovuiProviderProps> = ({ children }) => {
  return (
    <MantineProvider theme={MANTINE_THEME}>
      <IconProvider>{children}</IconProvider>
    </MantineProvider>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { MantineProvider } from '@mantine/core';
import { FC, PropsWithChildren } from 'react';
import { IconProvider } from '../icons/IconProvider';
import { MANTINE_THEME } from './mantine-theme.config';
/** Used to export a v7 Mantine provider */
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/index.ts
Tamaño: 320 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './button';
export * from './checkbox';
export * from './code-block';
export * from './input';
export * from './loader';
export * from './NovuiProvider';
export * from './select';
export * from './table';
export * from './tabs';
export * from './text';
export * from './textarea';
export * from './title';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/mantine-theme.config.ts
Tamaño: 2843 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MantineColorsTuple, MantineThemeOverride } from '@mantine/core';
import { Token, token } from '../../styled-system/tokens';
import { COLOR_PALETTE_TOKENS } from '../tokens/colors.tokens';

/**
 * Generates a Mantine color tuple for the given Panda color "family"
 */
const generateMantineColorTokens = (colorFamily: keyof typeof COLOR_PALETTE_TOKENS): MantineColorsTuple => {
  return Object.keys(COLOR_PALETTE_TOKENS[colorFamily]).map((paletteNumber) =>
    token(`colors.${colorFamily}.${paletteNumber}.dark` as Token)
  ) as unknown as MantineColorsTuple;
};

/** Maps Panda token values to a mantine theme config */
export const MANTINE_THEME: MantineThemeOverride = {
  // colors
  white: token('colors.legacy.white'),
  black: token('colors.legacy.black'),
  primaryColor: 'gradient',
  primaryShade: 6,
  colors: {
    gray: generateMantineColorTokens('mauve'),
    yellow: generateMantineColorTokens('amber'),
    blue: generateMantineColorTokens('blue'),
    green: generateMantineColorTokens('green'),
    red: generateMantineColorTokens('red'),
    // must have a tuple of 10 strings, but replace the value at primaryShade with our gradient
    gradient: ['', '', '', '', '', '', token('gradients.horizontal'), '', '', ''],
  },

  // typography
  fontFamily: token('fonts.system'),
  fontFamilyMonospace: token('fonts.mono'),
  lineHeights: {
    sm: token('lineHeights.100'),
    md: token('lineHeights.125'),
    lg: token('lineHeights.150'),
    // missing 175
    xl: token('lineHeights.200'),
  },
  headings: {
    fontFamily: token('fonts.system'),
    fontWeight: token('fontWeights.strong'),
    sizes: {
      // page title
      h1: {
        fontSize: token('fontSizes.150'),
        lineHeight: token('lineHeights.200'),
      },
      // section title
      h2: {
        fontSize: token('fontSizes.125'),
        lineHeight: token('lineHeights.175'),
      },
      // subsection title
      h3: {
        fontSize: token('fontSizes.100'),
        lineHeight: token('lineHeights.150'),
      },
    },
  },
  fontSizes: {
    xs: token('fontSizes.75'),
    sm: token('fontSizes.88'),
    md: token('fontSizes.100'),
    lg: token('fontSizes.125'),
    xl: token('fontSizes.150'),
  },

  // TODO: these are guesses for how they match up
  spacing: {
    xs: token('spacing.25'),
    sm: token('spacing.50'),
    md: token('spacing.100'),
    lg: token('spacing.150'),
    xl: token('spacing.200'),
    xxl: token('spacing.250'),
    xxxl: token('spacing.300'),
  },
  radius: {
    xs: token('radii.xs'),
    sm: token('radii.s'),
    md: token('radii.m'),
    lg: token('radii.l'),
  },
  defaultRadius: 'md',
  shadows: {
    // TODO: this makes no sense except for md
    sm: token('shadows.light'),
    md: token('shadows.medium'),
    lg: token('shadows.dark'),
    xl: token('shadows.color'),
  },
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - generateMantineColorTokens(colorFamily: keyof typeof COLOR_PALETTE_TOKENS): MantineColorsTuple)
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/button/Button.const.ts
Tamaño: 1019 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ButtonProps as ExternalButtonProps, ButtonVariant as ExternalButtonVariant } from '@mantine/core';
import { type ButtonVariant } from '../../../styled-system/recipes';
import { IconSize } from '../../icons';

export const BUTTON_SIZE_TO_ICON_SIZE: Record<ButtonVariant['size'], IconSize> = {
  xs: '16',
  sm: '20',
  md: '20',
  lg: '20',
};

// Note: for right now, these are equivalent, but we haven't agreed on our size tokens (caps, one letter, etc)
export const BUTTON_SIZE_TO_EXTERNAL_BUTTON_SIZE: Record<ButtonVariant['size'], ExternalButtonProps['size']> = {
  xs: 'xs',
  sm: 'sm',
  md: 'md',
  lg: 'lg',
};

// Note: for right now, these are identical, but we may adjust them later
export const BUTTON_VARIANT_TO_EXTERNAL_BUTTON_VARIANT: Record<ButtonVariant['variant'], ExternalButtonVariant> = {
  filled: 'filled',
  outline: 'outline',
  transparent: 'transparent',
};

export const DEFAULT_VARIANT: ButtonVariant['variant'] = 'filled';
export const DEFAULT_SIZE: ButtonVariant['size'] = 'md';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/button/Button.stories.tsx
Tamaño: 4612 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { Grid } from '../../../styled-system/jsx';
import { IconOutlineInfo, IconSettings } from '../../icons';
import { Title } from '../title';
import { Button } from './Button';

export default {
  title: 'Components/Button',
  component: Button,
  argTypes: {
    size: {
      options: ['xs', 'sm', 'md', 'lg'],
      control: { type: 'select' },
    },
    fullWidth: {
      type: 'boolean',
    },
  },
} as Meta<typeof Button>;

const Template: StoryFn<typeof Button> = ({ ...args }) => {
  return (
    <Grid gridTemplateColumns="5">
      <Title variant="subsection">Default</Title>
      <Button {...args}>Test</Button>
      <Button {...args} Icon={IconSettings}>
        Test
      </Button>
      <Button {...args} Icon={IconSettings} disabled>
        Test
      </Button>
      <Button {...args} Icon={IconSettings} loading>
        Test
      </Button>

      <Title variant="subsection">Filled</Title>
      <Button {...args} variant="filled">
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="filled">
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="filled" disabled>
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="filled" loading>
        Test
      </Button>

      <Title variant="subsection">Transparent</Title>
      <Button {...args} variant="transparent">
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="transparent">
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="transparent" disabled>
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="transparent" loading>
        Test
      </Button>

      <Title variant="subsection">Outline</Title>
      <Button {...args} variant="outline">
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="outline">
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="outline" disabled>
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="outline" loading>
        Test
      </Button>
    </Grid>
  );
};

export const Default = Template.bind({});

const SizeTemplate: StoryFn<typeof Button> = ({ ...args }) => {
  return (
    <Grid gridTemplateColumns="5">
      <Title variant="subsection"></Title>
      <Title variant="subsection">xs</Title>
      <Title variant="subsection">sm</Title>
      <Title variant="subsection">md</Title>
      <Title variant="subsection">lg</Title>

      <Title variant="subsection">Default</Title>
      <Button {...args} Icon={IconOutlineInfo} size="xs">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="sm">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="md">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="lg">
        Button copy
      </Button>

      <Title variant="subsection">Filled</Title>
      <Button {...args} Icon={IconOutlineInfo} size="xs" variant="filled">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="sm" variant="filled">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="md" variant="filled">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="lg" variant="filled">
        Button copy
      </Button>

      <Title variant="subsection">Transparent</Title>
      <Button {...args} Icon={IconOutlineInfo} size="xs" variant="transparent">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="sm" variant="transparent">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="md" variant="transparent">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="lg" variant="transparent">
        Button copy
      </Button>

      <Title variant="subsection">Outline</Title>
      <Button {...args} Icon={IconOutlineInfo} size="xs" variant="outline">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="sm" variant="outline">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="md" variant="outline">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="lg" variant="outline">
        Button copy
      </Button>
    </Grid>
  );
};

export const Sizes = SizeTemplate.bind({});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { Grid } from '../../../styled-system/jsx';
import { IconOutlineInfo, IconSettings } from '../../icons';
import { Title } from '../title';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/button/Button.tsx
Tamaño: 2565 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Button as ExternalButton, ButtonProps as ExternalButtonProps } from '@mantine/core';
import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type ButtonVariant, button } from '../../../styled-system/recipes';
import { JsxStyleProps } from '../../../styled-system/types';
import { IconType } from '../../icons';
import { CoreProps, CorePropsWithChildren } from '../../types';
import { forwardRefWithAs, PolymorphicComponentPropWithRef, PolymorphicRef } from '../../types/props-helpers';
import {
  BUTTON_SIZE_TO_EXTERNAL_BUTTON_SIZE,
  BUTTON_SIZE_TO_ICON_SIZE,
  BUTTON_VARIANT_TO_EXTERNAL_BUTTON_VARIANT,
  DEFAULT_SIZE,
  DEFAULT_VARIANT,
} from './Button.const';

export interface ButtonCoreProps
  extends CorePropsWithChildren,
    React.ButtonHTMLAttributes<HTMLButtonElement>,
    Pick<ExternalButtonProps, 'loading'> {
  Icon?: IconType;
  loading?: boolean;
}

type ButtonDefaultElement = 'button';

export type ButtonProps<C extends React.ElementType = ButtonDefaultElement> = PolymorphicComponentPropWithRef<
  C,
  JsxStyleProps & Partial<ButtonVariant> & CoreProps & ButtonCoreProps
>;

type PolymorphicComponent = <C extends React.ElementType = ButtonDefaultElement>(
  props: ButtonProps<C>
) => JSX.Element | null;

export const Button: PolymorphicComponent = forwardRefWithAs<
  ButtonDefaultElement,
  JsxStyleProps & Partial<ButtonVariant> & CoreProps & ButtonCoreProps
>(
  <C extends React.ElementType = ButtonDefaultElement>(
    { variant = DEFAULT_VARIANT, size = DEFAULT_SIZE, ...props }: ButtonProps<C>,
    ref?: PolymorphicRef<C>
  ) => {
    const [variantProps, buttonProps] = button.splitVariantProps({ ...props, variant, size });
    const [cssProps, localProps] = splitCssProps(buttonProps);
    const { className, as, Icon, children, ...otherProps } = localProps;
    const styles = button(variantProps);

    return (
      <ExternalButton
        ref={ref}
        component={as ?? 'button'}
        size={BUTTON_SIZE_TO_EXTERNAL_BUTTON_SIZE[size]}
        variant={BUTTON_VARIANT_TO_EXTERNAL_BUTTON_VARIANT[variant]}
        leftSection={
          Icon ? (
            <Icon title="button-icon" size={variant === 'transparent' ? '20' : BUTTON_SIZE_TO_ICON_SIZE[size]} />
          ) : undefined
        }
        classNames={styles}
        className={cx(css(cssProps), className)}
        fullWidth={Boolean(variantProps.fullWidth)}
        {...otherProps}
      >
        {children}
      </ExternalButton>
    );
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Button as ExternalButton, ButtonProps as ExternalButtonProps } from '@mantine/core';
import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type ButtonVariant, button } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/button/IconButton.stories.tsx
Tamaño: 1611 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { Grid } from '../../../styled-system/jsx';
import { Icon123, IconSettings } from '../../icons';
import { Title } from '../title';
import { IconButton } from './IconButton';

export default {
  title: 'Components/IconButton',
  component: IconButton,
  argTypes: {},
} as Meta<typeof IconButton>;

const Template: StoryFn<typeof IconButton> = ({ ...args }) => {
  return (
    <Grid gridTemplateColumns="4">
      <Title variant="subsection">Default</Title>
      <IconButton {...args} Icon={IconSettings} />
      <IconButton {...args} Icon={IconSettings} disabled />
      <IconButton {...args} Icon={IconSettings} loading />

      <Title variant="subsection">Transparent</Title>
      <IconButton {...args} Icon={IconSettings} variant="transparent" />
      <IconButton {...args} Icon={IconSettings} variant="transparent" disabled />
      <IconButton {...args} Icon={IconSettings} variant="transparent" loading />

      <Title variant="subsection">Filled</Title>
      <IconButton {...args} Icon={IconSettings} variant="filled" />
      <IconButton {...args} Icon={IconSettings} variant="filled" disabled />
      <IconButton {...args} Icon={IconSettings} variant="filled" loading />

      <Title variant="subsection">Outline</Title>
      <IconButton {...args} Icon={IconSettings} variant="outline" />
      <IconButton {...args} Icon={IconSettings} variant="outline" disabled />
      <IconButton {...args} Icon={IconSettings} variant="outline" loading />
    </Grid>
  );
};
export const Default = Template.bind({});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { Grid } from '../../../styled-system/jsx';
import { Icon123, IconSettings } from '../../icons';
import { Title } from '../title';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/button/IconButton.tsx
Tamaño: 2558 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { ActionIcon, ActionIconStylesNames, ButtonVariant as ExternalButtonVariant } from '@mantine/core';
import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type ButtonVariant, button } from '../../../styled-system/recipes';
import { token } from '../../../styled-system/tokens';
import { JsxStyleProps } from '../../../styled-system/types';
import { IconType } from '../../icons';
import { CoreProps } from '../../types';
import { forwardRefWithAs, PolymorphicComponentPropWithRef, PolymorphicRef } from '../../types/props-helpers';
import { BUTTON_SIZE_TO_ICON_SIZE, DEFAULT_SIZE } from './Button.const';

interface IIconButtonProps {
  Icon: IconType;
  loading?: boolean;
}

type IconButtonDefaultElement = 'button';

export type IconButtonProps<C extends React.ElementType = IconButtonDefaultElement> = PolymorphicComponentPropWithRef<
  C,
  JsxStyleProps & Partial<ButtonVariant> & CoreProps & IIconButtonProps
>;

const DEFAULT_VARIANT: ButtonVariant['variant'] = 'transparent';

type PolymorphicComponent = <C extends React.ElementType = IconButtonDefaultElement>(
  props: IconButtonProps<C>
) => JSX.Element | null;

/**
 * A button with only an Icon.
 *
 * TODO: there are not specifications for these in the Design System, so this just follows the Button recipe.
 */
export const IconButton: PolymorphicComponent = forwardRefWithAs<
  IconButtonDefaultElement,
  JsxStyleProps & Partial<ButtonVariant> & CoreProps & IIconButtonProps
>(
  <C extends React.ElementType = IconButtonDefaultElement>(
    { variant = DEFAULT_VARIANT, ...props }: IconButtonProps<C>,
    ref?: PolymorphicRef<C>
  ) => {
    const [variantProps, buttonProps] = button.splitVariantProps({ ...props, variant });
    const [cssProps, localProps] = splitCssProps(buttonProps);
    const { className, as, loading, Icon, ...otherProps } = localProps;
    const styles = button(variantProps);

    return (
      <ActionIcon
        ref={ref}
        component={as ?? 'button'}
        classNames={styles}
        className={cx(css(cssProps), className)}
        variant={variantProps.variant as ExternalButtonVariant}
        loading={loading}
        {...otherProps}
      >
        <Icon
          title={props.title || 'action-icon'}
          color={variant === 'filled' ? token('colors.button.icon.filled') : undefined}
          size={BUTTON_SIZE_TO_ICON_SIZE[(variantProps.size as ButtonVariant['size']) ?? DEFAULT_SIZE]}
        />
      </ActionIcon>
    );
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { ActionIcon, ActionIconStylesNames, ButtonVariant as ExternalButtonVariant } from '@mantine/core';
import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type ButtonVariant, button } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/button/index.ts
Tamaño: 56 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Button';
export * from './IconButton';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/checkbox/Checkbox.stories.tsx
Tamaño: 881 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Group } from '@mantine/core';
import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { Checkbox } from './Checkbox';

export default {
  title: 'Components/Checkbox',
  component: Checkbox,
  argTypes: {},
} as Meta<typeof Checkbox>;

const Template: StoryFn<typeof Checkbox> = ({ ...args }) => <Checkbox {...args} />;

export const Default = Template.bind({});
Default.args = {
  label: 'Checkbox Label',
};

export const States = () => (
  <Group style={{ display: 'flex', flexDirection: 'column', alignItems: 'unset' }}>
    <Checkbox label="Checked checkbox" defaultChecked />
  </Group>
);

export const Disabled = () => (
  <Group style={{ display: 'flex', flexDirection: 'column', alignItems: 'unset' }}>
    <Checkbox label="Checked checkbox" defaultChecked disabled />
    <Checkbox label="Checked checkbox" disabled />
  </Group>
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Group } from '@mantine/core';
import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { Checkbox } from './Checkbox';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/checkbox/Checkbox.tsx
Tamaño: 1420 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Checkbox as ExternalCheckbox } from '@mantine/core';
import { ChangeEventHandler, forwardRef } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { checkbox } from '../../../styled-system/recipes';
import { JsxStyleProps } from '../../../styled-system/types';
import { CoreProps, LocalizedMessage, LocalizedString } from '../../types';
import { PolymorphicRef } from '../../types/props-helpers';

export type CheckboxProps = JsxStyleProps &
  CoreProps & {
    label?: LocalizedMessage;
    description?: LocalizedMessage;
    placeholder?: LocalizedString;
    error?: LocalizedMessage;

    required?: boolean;
    readOnly?: boolean;
    disabled?: boolean;

    checked?: boolean;
    defaultChecked?: boolean;
    onChange?: ChangeEventHandler<HTMLInputElement>;
  };

export const Checkbox = forwardRef(({ ...props }: CheckboxProps, ref?: PolymorphicRef<'input'>) => {
  const [variantProps, inputProps] = checkbox.splitVariantProps({ ...props });
  const [cssProps, localProps] = splitCssProps(inputProps);
  const { onChange, className, ...otherProps } = localProps;
  const classNames = checkbox(variantProps);

  return (
    <ExternalCheckbox
      ref={ref}
      classNames={classNames}
      className={cx(css(cssProps), className)}
      onChange={onChange}
      size="md"
      {...otherProps}
    />
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Checkbox as ExternalCheckbox } from '@mantine/core';
import { ChangeEventHandler, forwardRef } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { checkbox } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/checkbox/index.ts
Tamaño: 28 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Checkbox';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/code-block/CodeBlock.stories.tsx
Tamaño: 886 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { CodeBlock } from './CodeBlock';

export default {
  title: 'Components/CodeBlock',
  component: CodeBlock,
  argTypes: {},
} as Meta<typeof CodeBlock>;

const Template: StoryFn<typeof CodeBlock> = ({ ...args }) => <CodeBlock {...args} />;

const apiKey = 'TH!Si$ASup3RSeCreTAP!KEy';
const bridgeUrl = 'https://your-bridge-url';

export const PrimaryUse = Template.bind({});
PrimaryUse.args = {
  language: 'yaml',
  code: `name: Deploy Workflow State to Novu

  on:
    workflow_dispatch:
  
  jobs:
    deploy:
      runs-on: ubuntu-latest
      steps:
        - name: Checkout code
          uses: actions/checkout@v2
  
        - name: Sync State to Novu
          uses: novuhq/actions-novu-sync@v0.0.4
          with:
            novu-api-key: ${apiKey}
            bridge-url: ${bridgeUrl}`,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { CodeBlock } from './CodeBlock';
export default {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/code-block/CodeBlock.tsx
Tamaño: 2201 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { CodeHighlight as ExternalCode, CodeHighlightProps as ExternalCodeProps } from '@mantine/code-highlight';
import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { CodeBlockVariantProps, codeBlock } from '../../../styled-system/recipes';
import type { JsxStyleProps } from '../../../styled-system/types';
import { CoreProps } from '../../types';
import { forwardRefWithAs, PolymorphicComponentPropWithRef, PolymorphicRef } from '../../types/props-helpers';

// TODO: use @mantine/code-highlight/styles.layer.css instead
import '@mantine/code-highlight/styles.css';

export type CodeBlockCoreProps = Pick<ExternalCodeProps, 'language' | 'code' | 'withCopyButton'>;

type CodeBlockElement = 'div';

const DEFAULT_CODE_BLOCK_ELEMENT: CodeBlockElement = 'div';

export type CodeBlockProps<C extends React.ElementType> = PolymorphicComponentPropWithRef<
  C,
  JsxStyleProps & CodeBlockVariantProps & CoreProps & CodeBlockCoreProps
>;

type PolymorphicComponent = <C extends React.ElementType = CodeBlockElement>(
  props: CodeBlockProps<C>
) => JSX.Element | null;

/**
 * @deprecated This is not actually deprecated but needs more work to be styled properly and align with our use cases.
 *
 * Issues:
 * - switching between color modes and maintaining readable code
 * - no line numbers are built-in to Highlight JS
 *
 */
export const CodeBlock: PolymorphicComponent = forwardRefWithAs<
  CodeBlockElement,
  JsxStyleProps & CodeBlockVariantProps & CoreProps & CodeBlockCoreProps
>(<C extends React.ElementType = CodeBlockElement>(props: CodeBlockProps<C>, ref?: PolymorphicRef<C>) => {
  const [variantProps, codeBlockProps] = codeBlock.splitVariantProps(props);
  const [cssProps, localProps] = splitCssProps(codeBlockProps);
  const { className, as, code, ...otherProps } = localProps;
  const classNames = codeBlock(variantProps);
  const Component = props.as || DEFAULT_CODE_BLOCK_ELEMENT;

  return (
    <ExternalCode
      ref={ref}
      component={Component}
      classNames={classNames}
      className={cx(css(cssProps), className)}
      code={code}
      {...otherProps}
    />
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { CodeHighlight as ExternalCode, CodeHighlightProps as ExternalCodeProps } from '@mantine/code-highlight';
import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { CodeBlockVariantProps, codeBlock } from '../../../styled-system/recipes';
// TODO: use @mantine/code-highlight/styles.layer.css instead
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/code-block/index.ts
Tamaño: 29 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './CodeBlock';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/input/Input.stories.tsx
Tamaño: 2330 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { stack } from '../../../styled-system/patterns/stack';
import { IconContentCopy } from '../../icons';
import { Button } from '../button';
import { Input } from './Input';

export default {
  title: 'Components/Input',
  component: Input,
  argTypes: {
    value: {
      table: {
        disable: true,
      },
    },
    onChange: {
      table: {
        disable: true,
      },
    },
    error: {
      type: 'string',
    },
    variant: {
      options: ['preventLayoutShift', undefined],
      control: {
        type: 'select',
      },
    },
  },
} as Meta<typeof Input>;

const Template: StoryFn<typeof Input> = ({ ...args }) => <Input {...args} />;

export const PrimaryUse = Template.bind({});
PrimaryUse.args = {
  label: 'Notification Name',
  placeholder: 'Notification name goes here...',
  required: true,
};

export const Everything = Template.bind({});
Everything.args = {
  label: 'Notification Name',
  description: 'Will be used as identifier',
  placeholder: 'Notification name goes here...',
  rightSection: <IconContentCopy />,
  error: 'Not Good!',
};

export const Nothing = Template.bind({});
Nothing.args = {};

export const WithDescription = Template.bind({});
WithDescription.args = {
  label: 'Notification Name',
  description: 'Will be used as identifier',
  placeholder: 'Notification name goes here...',
};

export const WithIcon = Template.bind({});
WithIcon.args = {
  label: 'Notification Name',
  value: 'e297cdd6cf29ea8f566c06da18ccf151',
  rightSection: <IconContentCopy />,
};

export const Error = Template.bind({});
Error.args = {
  label: 'Your Email',
  value: 'NotGood@email.com',
  error: 'Not Good!',
};

const FormTemplate: StoryFn<typeof Input> = ({ ...args }) => {
  return (
    <form noValidate onSubmit={(event) => event.preventDefault()}>
      <Input variant="preventLayoutShift" {...args} />
      <Input variant="preventLayoutShift" {...args} />
      <Input variant="preventLayoutShift" {...args} placeholder="This won't have an error" error={undefined} />
      <Input variant="preventLayoutShift" {...args} />
      <Button type="submit">Submit</Button>
    </form>
  );
};

export const InForm = FormTemplate.bind({});
InForm.args = {
  label: 'Your Email',
  required: true,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { stack } from '../../../styled-system/patterns/stack';
import { IconContentCopy } from '../../icons';
import { Button } from '../button';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/input/Input.tsx
Tamaño: 1988 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { TextInput as ExternalTextInput, type InputProps as ExternalTextInputProps } from '@mantine/core';
import { ChangeEventHandler, forwardRef } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { InputVariant, input } from '../../../styled-system/recipes';
import { JsxStyleProps } from '../../../styled-system/types';
import { IconErrorOutline } from '../../icons';
import { CoreProps, LocalizedMessage, LocalizedString } from '../../types';
import { PolymorphicRef } from '../../types/props-helpers';

export type TextInputType = 'text' | 'password' | 'email' | 'search' | 'tel';
export const DEFAULT_TEXT_INPUT_TYPE: TextInputType = 'text';

export interface IInputProps
  extends JsxStyleProps,
    CoreProps,
    Pick<ExternalTextInputProps, 'rightSection'>,
    Partial<InputVariant> {
  label?: LocalizedMessage;
  description?: LocalizedMessage;
  placeholder?: LocalizedString;
  error?: LocalizedMessage;
  type?: TextInputType;

  required?: boolean;
  readOnly?: boolean;
  disabled?: boolean;

  value?: string;
  defaultValue?: string;
  onChange?: ChangeEventHandler<HTMLInputElement>;
}

export const Input = forwardRef(
  ({ type = DEFAULT_TEXT_INPUT_TYPE, ...props }: IInputProps, ref?: PolymorphicRef<'input'>) => {
    const [variantProps, inputProps] = input.splitVariantProps({ ...props, type });
    const [cssProps, localProps] = splitCssProps(inputProps);
    const { onChange, className, rightSection, ...otherProps } = localProps;
    const classNames = input(variantProps);

    return (
      <ExternalTextInput
        ref={ref}
        onChange={(event) => onChange?.(event)}
        autoComplete="off"
        classNames={classNames}
        className={cx(css(cssProps), className)}
        rightSection={otherProps.error ? <IconErrorOutline title="input error indicator" /> : rightSection}
        variant={undefined}
        {...otherProps}
      />
    );
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { TextInput as ExternalTextInput, type InputProps as ExternalTextInputProps } from '@mantine/core';
import { ChangeEventHandler, forwardRef } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { InputVariant, input } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/input/index.ts
Tamaño: 25 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Input';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/loader/LoadingOverlay.stories.tsx
Tamaño: 2197 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { css } from '../../../styled-system/css';
import { Box } from '../../../styled-system/jsx';
import { stack } from '../../../styled-system/patterns/stack';
import { Button } from '../button';
import { Input } from '../input';
import { Text } from '../text';
import { Title } from '../title';
import { LoadingOverlay } from './LoadingOverlay';

export default {
  title: 'Components/LoadingOverlay',
  component: LoadingOverlay,
  argTypes: {
    type: {
      options: ['bars', 'oval', 'dots'],
      control: {
        type: 'radio',
      },
    },
  },
} as Meta<typeof LoadingOverlay>;

const Template: StoryFn<typeof LoadingOverlay> = ({ ...args }) => (
  <>
    <LoadingOverlay {...args} />{' '}
    <form noValidate onSubmit={(event) => event.preventDefault()} className={stack()}>
      <Title>Here is some text</Title>
      <Text>And some more!</Text>
      <Input />
      <Input />
      <Input placeholder="This won't have an error" error={undefined} />
      <Input />
      <Button type="submit">Submit</Button>
    </form>
  </>
);

export const FullPage = Template.bind({});
FullPage.args = {};

const InComponentTemplate: StoryFn<typeof LoadingOverlay> = ({ ...args }) => (
  <>
    <form
      noValidate
      onSubmit={(event) => event.preventDefault()}
      className={stack({
        maxWidth: '[500px]',
        border: 'solid',
        borderColor: 'input.border',
        padding: '150',
        borderRadius: '100',
        position: 'relative',
      })}
    >
      <LoadingOverlay {...args} />
      <Title>Here is some text</Title>
      <Text>And some more!</Text>
      <Input label="Input" />
      <Input label="Input" />
      <Input label="Input" placeholder="This won't have an error" error={undefined} />
      <Input label="Input" />
      <Button type="submit">Submit</Button>
    </form>
    <div className={stack({ mt: '150' })}>
      <Title>Here is some stuff outside the component!</Title>
      <Text>It should not be overlaid</Text>
      <Input label="Input" />
    </div>
  </>
);

export const InComponent = InComponentTemplate.bind({});
InComponent.args = {};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { css } from '../../../styled-system/css';
import { Box } from '../../../styled-system/jsx';
import { stack } from '../../../styled-system/patterns/stack';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/loader/LoadingOverlay.tsx
Tamaño: 2803 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { LoaderProps as ExternalLoaderProps, LoadingOverlay as ExternalLoadingOverlay } from '@mantine/core';
import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type LoadingOverlayVariant, loadingOverlay } from '../../../styled-system/recipes';
import { token, ZIndexToken } from '../../../styled-system/tokens';
import { JsxStyleProps } from '../../../styled-system/types';
import { IconSize } from '../../icons';
import { CoreProps } from '../../types';
import { forwardRefWithAs, PolymorphicComponentPropWithRef, PolymorphicRef } from '../../types/props-helpers';

export type LoaderSize = IconSize | '64';

const DEFAULT_SIZE: LoaderSize = '64';
const DEFAULT_Z_INDEX: ZIndexToken = 'overlay';

type LoadingOverlayCoreProps = {
  isVisible?: boolean;
  size?: LoaderSize;
  zIndex?: ZIndexToken;
} & Pick<ExternalLoaderProps, 'type'>;

type LoadingOverlayDefaultElement = 'div';
const DEFAULT_ELEMENT: LoadingOverlayDefaultElement = 'div';

export type LoadingOverlayProps<C extends React.ElementType = LoadingOverlayDefaultElement> =
  PolymorphicComponentPropWithRef<
    C,
    JsxStyleProps & Partial<LoadingOverlayVariant> & CoreProps & LoadingOverlayCoreProps
  >;

type PolymorphicComponent = <C extends React.ElementType = LoadingOverlayDefaultElement>(
  props: LoadingOverlayProps<C>
) => JSX.Element | null;

/**
 * Loader with overlay.
 *
 * TODO: Add support for container-scoped loader. For now, only full-page works.
 * To work around this, use position: relative in the parent component
 */
export const LoadingOverlay: PolymorphicComponent = forwardRefWithAs<
  LoadingOverlayDefaultElement,
  JsxStyleProps & Partial<LoadingOverlayVariant> & CoreProps & LoadingOverlayCoreProps
>(
  <C extends React.ElementType = LoadingOverlayDefaultElement>(
    { variant, isVisible = true, size = DEFAULT_SIZE, zIndex = DEFAULT_Z_INDEX, ...props }: LoadingOverlayProps<C>,
    ref?: PolymorphicRef<C>
  ) => {
    const [variantProps, loadingOverlayProps] = loadingOverlay.splitVariantProps({
      ...props,
      variant,
      isVisible,
      size,
      zIndex,
    });
    const [cssProps, localProps] = splitCssProps(loadingOverlayProps);
    const { className, as, type, ...otherProps } = localProps;
    const classNames = loadingOverlay(variantProps);

    if (!isVisible) {
      return null;
    }

    return (
      <ExternalLoadingOverlay
        ref={ref}
        component={as ?? DEFAULT_ELEMENT}
        classNames={classNames}
        className={cx(css(cssProps), className)}
        loading
        visible={isVisible}
        loaderProps={{ type, size }}
        // @ts-expect-error
        zIndex={token(`zIndex.${zIndex}`)}
        {...otherProps}
      />
    );
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { LoaderProps as ExternalLoaderProps, LoadingOverlay as ExternalLoadingOverlay } from '@mantine/core';
import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type LoadingOverlayVariant, loadingOverlay } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/loader/index.ts
Tamaño: 34 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './LoadingOverlay';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/select/Select.stories.tsx
Tamaño: 1347 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { IconBakeryDining, IconRamenDining } from '../../icons';
import { Select } from './Select';

export default {
  title: 'Components/Select',
  component: Select,
  argTypes: {},
} as Meta<typeof Select>;

const Template: StoryFn<typeof Select> = ({ ...args }) => <Select {...args} />;

const data = [
  { value: 'Arial', label: 'Arial' },
  { value: 'Helvetica', label: 'Helvetica' },
  { value: 'Verdana', label: 'Verdana' },
  { value: 'Optima', label: 'Optima' },
  { value: 'Lato', label: 'Lato' },
  { value: 'sans-serif', label: 'sans-serif' },
  { value: 'blitz', label: 'Blitz.js' },
];

export const PrimaryUse = Template.bind({});
PrimaryUse.args = {
  label: 'Font Family',
  data,
  placeholder: 'Select something',
};

export const WithIcon = Template.bind({});
WithIcon.args = {
  label: 'Font Family',
  data,
  description: 'Will be used as the main font-family in the in-app widget',
  placeholder: 'Select something',
  icon: <IconRamenDining size={'32'} />,
};

export const Everything = Template.bind({});
Everything.args = {
  label: 'Font Family',
  data,
  description: 'Will be used as the main font-family in the in-app widget',
  placeholder: 'Select something',
  error: 'There is a fire!',
  icon: <IconBakeryDining size={'32'} />,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { IconBakeryDining, IconRamenDining } from '../../icons';
import { Select } from './Select';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/select/Select.tsx
Tamaño: 2305 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Select as ExternalSelect, Loader } from '@mantine/core';
import { forwardRef, ReactNode } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { select } from '../../../styled-system/recipes';
import { token } from '../../../styled-system/tokens';
import { JsxStyleProps } from '../../../styled-system/types';
import { IconArrowDropDown } from '../../icons';
import { CoreProps, LocalizedMessage, LocalizedString } from '../../types';
import { PolymorphicRef } from '../../types/props-helpers';

export type SelectItem<TItem extends string = string> = {
  value: TItem;
  label: LocalizedString;
  selected?: boolean;
  disabled?: boolean;
};

export type SelectCoreProps<TItem extends string = string> = CoreProps & {
  data: SelectItem[];
  value?: TItem | null;
  defaultValue?: TItem | null;
  label?: LocalizedMessage;
  error?: LocalizedMessage;
  placeholder?: LocalizedString;
  description?: LocalizedMessage;

  onChange?: (value: TItem | null) => void;
  onDropdownOpen?: () => void;
  onDropdownClose?: () => void;

  disabled?: boolean;
  required?: boolean;
  readOnly?: boolean;
  loading?: boolean;
  allowDeselect?: boolean;
  withinPortal?: boolean;

  /** max number of options displayed -- defaults to Infinity */
  limit?: number;
  icon?: ReactNode;
};

export type SelectProps = JsxStyleProps & SelectCoreProps;

export const Select = forwardRef((props: SelectProps, ref?: PolymorphicRef<'input'>) => {
  const [variantProps, selectProps] = select.splitVariantProps(props);
  const [cssProps, localProps] = splitCssProps(selectProps);
  const { onChange, className, icon, loading, ...otherProps } = localProps;
  const selectClassNames = select(variantProps);

  const rightSection = loading ? (
    // TODO: replace with our own loader
    <Loader color={token('colors.icon.main')} size={'24'} />
  ) : (
    (icon ?? <IconArrowDropDown title="select-dropdown-icon" size="32" />)
  );

  return (
    <ExternalSelect
      ref={ref}
      onChange={(event) => onChange?.(event)}
      autoComplete="off"
      rightSection={rightSection}
      rightSectionWidth="auto"
      classNames={selectClassNames}
      className={cx(css(cssProps), className)}
      {...otherProps}
    />
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Select as ExternalSelect, Loader } from '@mantine/core';
import { forwardRef, ReactNode } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { select } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/select/index.ts
Tamaño: 26 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Select';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/table/Table.stories.tsx
Tamaño: 1835 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Badge, Switch } from '@mantine/core';
import { Meta, StoryFn } from '@storybook/react';
import { ColumnDef } from '@tanstack/react-table';
import React, { useState } from 'react';
import { IconOutlineAdd } from '../../icons';
import { Button } from '../Button';
import { Table } from './Table';

export default {
  title: 'Components/Table',
  component: Table,
  argTypes: {
    data: {
      control: false,
    },
    columns: {
      control: false,
    },
  },
} as Meta<typeof Table>;

const SwitchCell = (props) => {
  const [status, setStatus] = useState(props.status);
  const switchHandler = () => {
    setStatus((prev) => (prev === 'Enabled' ? 'Disabled' : 'Enabled'));
  };

  return <Switch label={status} onChange={switchHandler} checked={status === 'Enabled'} />;
};

const BadgeCell = (props) => {
  return (
    <Badge variant="outline" size="md" radius="xs">
      {props.getValue()}
    </Badge>
  );
};

interface IExampleData {
  name: string;
  category: string;
  creationDate: string;
  status: string;
}

const columns: ColumnDef<IExampleData>[] = [
  { accessorKey: 'name', header: 'Name' },
  { accessorKey: 'category', header: 'Category', cell: BadgeCell },
  { accessorKey: 'creationDate', header: 'Date Created' },
  { accessorKey: 'status', header: 'Status', cell: SwitchCell },
];

const data: IExampleData[] = [
  { name: 'Great', category: 'Fun', status: 'Disabled', creationDate: '01/01/2021 16:36' },
  { name: 'Whats up?', category: 'Done', status: 'Enabled', creationDate: '01/01/2021 16:36' },
];

const Template: StoryFn<typeof Table> = ({ ...args }) => (
  <>
    <Button Icon={IconOutlineAdd} variant="transparent" py="50">
      Add row
    </Button>
    <Table columns={columns} data={data} {...args} />
  </>
);

export const PrimaryUse = Template.bind({});
PrimaryUse.args = {};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Badge, Switch } from '@mantine/core';
import { Meta, StoryFn } from '@storybook/react';
import { ColumnDef } from '@tanstack/react-table';
import React, { useState } from 'react';
import { IconOutlineAdd } from '../../icons';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/table/Table.styles.ts
Tamaño: 1528 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { type TableStylesNames } from '@mantine/core';
import { css } from '../../../styled-system/css';

const tableStyles: Partial<Record<TableStylesNames, string>> = {
  tr: css({
    '& td': {
      textOverflow: 'ellipsis',
    },
  }),
  table: css({
    borderCollapse: 'collapse',
    borderSpacingX: '125',
    textStyle: 'text.main',
    '& tr td:first-of-type': {
      pr: '200',
    },
    '& tr th:first-of-type': {
      pr: '200',
    },
    '& tr td:last-child': {
      pr: '200',
    },
    '& tr th:last-child': {
      pr: '200',
    },
    '& thead tr': {
      borderBottom: 'solid',
      borderColor: 'table.header.border',
    },
    '& thead tr th': {
      fontWeight: 'regular',
      textAlign: 'left',
      color: 'typography.text.tertiary',
      borderBottom: 'none',
      borderSpacing: '0',
      py: '75',
    },
    '& tbody tr td': {
      // TODO: replace with token value
      maxWidth: '[100px]',
      // TODO: replace with token value
      height: '[80px]',

      color: 'typography.text.main',
      borderBottom: 'solid',
      borderColor: 'table.row.border',
    },
    '& tbody tr[data-disabled="true"]:hover': {
      cursor: 'default',
    },
    '& tbody tr[data-disabled="false"]:hover': {
      cursor: 'pointer',
    },
    '& tbody tr:last-of-type td': {
      borderBottom: 'solid',
      borderColor: 'table.bottom.border',
    },
    _hover: {
      '& tbody tr:hover': {
        bg: 'table.row.surface.hover',
      },
    },
  }),
};

export default tableStyles;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default  tableStyles

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/table/Table.tsx
Tamaño: 2822 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Table as ExternalTable } from '@mantine/core';
import {
  createColumnHelper as _createColumnHelper,
  CellContext,
  ColumnDefTemplate,
  flexRender,
  getCoreRowModel,
  Row,
  useReactTable,
} from '@tanstack/react-table';
import React, { useMemo } from 'react';
import { CoreProps } from '../../types';

import classes from './Table.styles';

export type IRow<TRow extends object = {}> = Row<TRow>;

/** Component used to render the contents of a cell */
export type CellRendererComponent<TRow, TCellValue> = ColumnDefTemplate<CellContext<TRow, TCellValue>>;

/** Helper for type-safe column definitions */
export const createColumnHelper = _createColumnHelper;

export interface ITableProps<TRow extends object> extends CoreProps {
  columns?: any[];
  data?: TRow[];
  isLoading?: boolean;
  pagination?: any;
  noDataPlaceholder?: React.ReactNode;
  loadingItems?: number;
  hasMore?: boolean;
  onRowClick?: (row: Row<TRow>) => void;
  onRowSelect?: (row: Row<TRow>) => void;
}

/**
 * Table component
 *
 */
export function Table<TRow extends object>({
  columns: userColumns,
  data: userData,
  isLoading = false,
  noDataPlaceholder,
  loadingItems = 10,
  onRowClick,
  onRowSelect,
  ...props
}: ITableProps<TRow>) {
  const columns = useMemo(() => userColumns?.map((col) => ({ ...col })), [userColumns]);
  const data = useMemo(() => (userData || [])?.map((row) => ({ ...row })), [userData]);
  const fakeData = useMemo(() => Array.from({ length: loadingItems }).map((_, index) => ({ index })), [loadingItems]);

  const table = useReactTable<TRow>({
    columns,
    data: isLoading ? (fakeData as TRow[]) : data,
    getCoreRowModel: getCoreRowModel(),
  });

  return (
    <ExternalTable classNames={classes} highlightOnHover {...props}>
      <thead>
        {table.getHeaderGroups().map((headerGroup, i) => {
          return (
            <tr key={headerGroup.id}>
              {headerGroup.headers.map((header) => {
                return <th key={header.id}>{flexRender(header.column.columnDef.header, header.getContext())}</th>;
              })}
            </tr>
          );
        })}
      </thead>
      <tbody>
        {table.getRowModel().rows.map((row) => {
          return (
            <tr
              key={row.id}
              onClick={(e) => {
                e.stopPropagation();
                if (!isLoading && onRowClick) {
                  onRowClick(row);
                }
              }}
              className={classes.tr}
              data-disabled={isLoading || !onRowClick}
            >
              {row.getVisibleCells().map((cell) => {
                return <td key={cell.id}>{flexRender(cell.column.columnDef.cell, cell.getContext())}</td>;
              })}
            </tr>
          );
        })}
      </tbody>
    </ExternalTable>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Table as ExternalTable } from '@mantine/core';
import {
createColumnHelper as _createColumnHelper,
CellContext,
ColumnDefTemplate,
/** Component used to render the contents of a cell */
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/table/index.ts
Tamaño: 25 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Table';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/tabs/Tabs.stories.tsx
Tamaño: 1540 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react';
import React, { ReactNode } from 'react';
import { IconOutlineCode, IconOutlineMiscellaneousServices, IconOutlineVisibility } from '../../icons';
import { LocalizedMessage } from '../../types';

import { Tabs } from './Tabs';

export default {
  title: 'Components/Tabs',

  component: Tabs,

  argTypes: {
    colorPalette: {
      options: ['mode.cloud', 'mode.local'],
      control: { type: 'select' },
    },
  },
} as Meta<typeof Tabs>;

const Template: StoryFn<typeof Tabs> = ({ ...args }) => <Tabs {...args} />;

enum TestTabEnum {
  PREVIEW = 'preview',
  CODE = 'code',
  RANDOM = 'random',
}

const LABELS: Record<TestTabEnum, LocalizedMessage> = {
  [TestTabEnum.PREVIEW]: 'Preview',
  [TestTabEnum.CODE]: 'Code',
  [TestTabEnum.RANDOM]: 'Random',
};

const ICONS: Record<TestTabEnum, ReactNode> = {
  [TestTabEnum.PREVIEW]: <IconOutlineVisibility />,
  [TestTabEnum.CODE]: <IconOutlineCode />,
  [TestTabEnum.RANDOM]: <IconOutlineMiscellaneousServices />,
};

export const Default = Template.bind({});
Default.args = {
  tabConfigs: Object.values(TestTabEnum).map((value) => ({
    value,
    label: LABELS[value],
    content: LABELS[value],
  })),
  defaultValue: TestTabEnum.CODE,
};

export const HorizontalTabMenuWithIcon = Template.bind({});
HorizontalTabMenuWithIcon.args = {
  tabConfigs: Object.values(TestTabEnum).map((value) => ({
    value,
    label: LABELS[value],
    content: LABELS[value],
    icon: ICONS[value],
  })),
  defaultValue: TestTabEnum.RANDOM,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react';
import React, { ReactNode } from 'react';
import { IconOutlineCode, IconOutlineMiscellaneousServices, IconOutlineVisibility } from '../../icons';
import { LocalizedMessage } from '../../types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/tabs/Tabs.tsx
Tamaño: 2107 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Tabs as ExternalTabs, type TabsProps as ExternalTabsProps } from '@mantine/core';
import { forwardRef, ReactNode } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { tabs } from '../../../styled-system/recipes';
import { JsxStyleProps } from '../../../styled-system/types';
import { CoreProps, LocalizedMessage } from '../../types';
import { PolymorphicRef } from '../../types/props-helpers';

interface ITabProps<TTabType extends string = string> {
  value: TTabType;
  label: LocalizedMessage;
  content?: ReactNode;
  icon?: ReactNode;
}

export interface ITabsProps<TTabType extends string = string>
  extends JsxStyleProps,
    CoreProps,
    Pick<ExternalTabsProps, 'keepMounted'> {
  value?: TTabType;
  defaultValue?: TTabType;
  onTabChange?: (tab: TTabType) => void;
  tabConfigs: ITabProps[];
}

export const Tabs = forwardRef(
  <TTabType extends string = string>(props: ITabsProps<TTabType>, ref?: PolymorphicRef<'div'>) => {
    const [variantProps, tabsProps] = tabs.splitVariantProps({ ...props });
    const [cssProps, localProps] = splitCssProps(tabsProps);
    const { onTabChange, className, tabConfigs, ...otherProps } = localProps;
    const styles = tabs(variantProps);

    return (
      <ExternalTabs
        ref={ref}
        onChange={(newTab: string) => onTabChange?.(newTab as TTabType)}
        orientation="horizontal"
        variant="default"
        classNames={styles}
        className={cx(css(cssProps), className)}
        {...otherProps}
      >
        <ExternalTabs.List>
          {tabConfigs.map((menuTab, i) => (
            <ExternalTabs.Tab value={menuTab.value} leftSection={menuTab.icon} key={`tab-${menuTab.value}`}>
              {menuTab.label}
            </ExternalTabs.Tab>
          ))}
        </ExternalTabs.List>
        {tabConfigs.map((menuTab, i) => (
          <ExternalTabs.Panel value={menuTab.value} key={`tab-panel-${menuTab.value}`}>
            {menuTab.content}
          </ExternalTabs.Panel>
        ))}
      </ExternalTabs>
    );
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Tabs as ExternalTabs, type TabsProps as ExternalTabsProps } from '@mantine/core';
import { forwardRef, ReactNode } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { tabs } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/tabs/index.ts
Tamaño: 24 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Tabs';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/text/Text.stories.tsx
Tamaño: 714 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta } from '@storybook/react';
import React from 'react';
import { Flex } from '../../../styled-system/jsx';
import { Text } from './Text';

export default {
  title: 'Components/Text',
  component: Text,
  argTypes: {},
} as Meta<typeof Text>;

export const all = () => (
  <Flex direction="column" gap="100">
    <Text>Default Body</Text>
    <Text as="span">Default Body as span</Text>
    <Text variant="main">Main text</Text>
    <Text variant="main" fontWeight={'strong'} color="typography.text.feedback.success">
      Success text
    </Text>
    <Text variant="secondary">Secondary text</Text>
    <Text variant="strong">Strong text</Text>
    <Text variant="mono">Mono text</Text>
  </Flex>
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta } from '@storybook/react';
import React from 'react';
import { Flex } from '../../../styled-system/jsx';
import { Text } from './Text';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/text/Text.tsx
Tamaño: 1264 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type TextVariantProps, text } from '../../../styled-system/recipes';
import type { JsxStyleProps } from '../../../styled-system/types';
import { CoreProps } from '../../types';
import { forwardRefWithAs, PolymorphicComponentPropWithRef, PolymorphicRef } from '../../types/props-helpers';

export type TextProps<C extends React.ElementType> = PolymorphicComponentPropWithRef<
  C,
  JsxStyleProps & TextVariantProps & CoreProps
>;

type PolymorphicComponent = <C extends React.ElementType = 'p'>(props: TextProps<C>) => JSX.Element | null;

export const Text: PolymorphicComponent = forwardRefWithAs<'p', JsxStyleProps & TextVariantProps & CoreProps>(
  <C extends React.ElementType = 'p'>(props: TextProps<C>, ref?: PolymorphicRef<C>) => {
    const [variantProps, textProps] = text.splitVariantProps(props);
    const [cssProps, localProps] = splitCssProps(textProps);
    const { className, as, ...otherProps } = localProps;
    const styles = text(variantProps);
    const Component = props.as || 'p';

    return <Component ref={ref} className={cx(styles, css(cssProps), className)} {...otherProps} />;
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type TextVariantProps, text } from '../../../styled-system/recipes';
import type { JsxStyleProps } from '../../../styled-system/types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/text/index.ts
Tamaño: 24 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Text';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/textarea/Textarea.tsx
Tamaño: 1707 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Textarea as ExternalTextarea, type TextareaProps as ExternalTextareaProps } from '@mantine/core';
import { ChangeEventHandler, forwardRef } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { InputVariant, input } from '../../../styled-system/recipes';
import { JsxStyleProps } from '../../../styled-system/types';
import { CoreProps, LocalizedMessage, LocalizedString } from '../../types';
import { PolymorphicRef } from '../../types/props-helpers';
import { DEFAULT_TEXT_INPUT_TYPE, TextInputType } from '../input';

export interface TextareaProps
  extends JsxStyleProps,
    CoreProps,
    Pick<ExternalTextareaProps, 'leftSection' | 'minRows' | 'maxRows'>,
    Partial<InputVariant> {
  label?: LocalizedMessage;
  description?: LocalizedMessage;
  placeholder?: LocalizedString;
  error?: LocalizedMessage;
  type?: TextInputType;

  required?: boolean;
  readOnly?: boolean;
  disabled?: boolean;

  value?: string;
  defaultValue?: string;
  onChange?: ChangeEventHandler<HTMLTextAreaElement>;
}

export const Textarea = forwardRef((props: TextareaProps, ref?: PolymorphicRef<'textarea'>) => {
  const [variantProps, inputProps] = input.splitVariantProps(props);
  const [cssProps, localProps] = splitCssProps(inputProps);
  const { onChange, className, ...otherProps } = localProps;
  const styles = input(variantProps);

  return (
    <ExternalTextarea
      ref={ref}
      onChange={(event) => onChange?.(event)}
      autoComplete="off"
      classNames={styles}
      className={cx(css(cssProps), className)}
      minRows={1}
      maxRows={4}
      autosize
      {...otherProps}
    />
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Textarea as ExternalTextarea, type TextareaProps as ExternalTextareaProps } from '@mantine/core';
import { ChangeEventHandler, forwardRef } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { InputVariant, input } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/textarea/index.ts
Tamaño: 28 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Textarea';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/title/Title.stories.tsx
Tamaño: 680 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta } from '@storybook/react';
import React from 'react';
import { Flex } from '../../../styled-system/jsx';
import { Title } from './Title';

export default {
  title: 'Components/Title',
  component: Title,
  argTypes: {},
} as Meta<typeof Title>;

export const all = () => (
  <Flex direction="column" gap="100">
    <Title>Default title</Title>
    <Title variant="page">Page title</Title>
    <Title variant="section">Section title</Title>
    <Title variant="subsection">Subsection title</Title>
    <Title color="typography.text.feedback.success" textDecoration="underline">
      Styled Title
    </Title>
    <Title as="span">Title as span</Title>
  </Flex>
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta } from '@storybook/react';
import React from 'react';
import { Flex } from '../../../styled-system/jsx';
import { Title } from './Title';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/title/Title.tsx
Tamaño: 1668 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import React, { type ElementType } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type TitleVariantProps, title } from '../../../styled-system/recipes';
import type { JsxStyleProps } from '../../../styled-system/types';
import { CoreProps, ExtractGeneric } from '../../types';
import { forwardRefWithAs, PolymorphicComponentPropWithRef, PolymorphicRef } from '../../types/props-helpers';

export type TitleProps<C extends React.ElementType> = PolymorphicComponentPropWithRef<
  C,
  JsxStyleProps & TitleVariantProps & CoreProps
>;

export type TitleVariant = ExtractGeneric<TitleVariantProps['variant']>;

const VARIANT_ELEMENT_LOOKUP: Record<TitleVariant, Extract<ElementType, 'h1' | 'h2' | 'h3'>> = {
  page: 'h1',
  section: 'h2',
  subsection: 'h3',
};

const DEFAULT_VARIANT: TitleVariant = 'page';

type PolymorphicComponent = <C extends React.ElementType = 'h1'>(props: TitleProps<C>) => JSX.Element | null;

export const Title: PolymorphicComponent = forwardRefWithAs<'h1', JsxStyleProps & TitleVariantProps & CoreProps>(
  <C extends React.ElementType = 'h1'>(props: TitleProps<C>, ref?: PolymorphicRef<C>) => {
    const [variantProps, titleProps] = title.splitVariantProps(props);
    const [cssProps, localProps] = splitCssProps(titleProps);
    const { className, as, ...otherProps } = localProps;
    const styles = title(variantProps);
    const Component = props.as || VARIANT_ELEMENT_LOOKUP[(variantProps.variant as TitleVariant) ?? DEFAULT_VARIANT];

    return <Component ref={ref} className={cx(styles, css(cssProps), className)} {...otherProps} />;
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React, { type ElementType } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type TitleVariantProps, title } from '../../../styled-system/recipes';
import type { JsxStyleProps } from '../../../styled-system/types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/title/index.ts
Tamaño: 25 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Title';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/hooks/index.ts
Tamaño: 55 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { useDebouncedCallback } from '@mantine/hooks';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/icons/Icon.const.ts
Tamaño: 114 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IconSize } from './Icon.types';

/**
 * Style Props
 */
export const DEFAULT_ICON_SIZE: IconSize = '20';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/icons/Icon.md
Tamaño: 525 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

# Icon

## Background

This group of icons comes from the Material Icons by means of the [react-icons](https://react-icons.github.io/react-icons/icons/md/) package.

### A11y Context

`title` is mandatory to ensure that we are acknowledging a11y as a priority.

## Use

To use an Icon, simply use the [react-icons docs](https://react-icons.github.io/react-icons/icons/md/) for names with "Icon" as a prefix instead of "Md". Alternatively, you can refer to our Storybook!

E.g. instead of using `<Md10k />`, use `<Icon10k />`


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# Icon
## Background
This group of icons comes from the Material Icons by means of the [react-icons](https://react-icons.github.io/react-icons/icons/md/) package.
### A11y Context
## Use
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/icons/Icon.stories.tsx
Tamaño: 1957 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { ActionIcon, Code, Grid, Group, Input } from '@mantine/core';
import { Meta, StoryFn } from '@storybook/react';
import React, { useState } from 'react';
import { styled, VStack } from '../../styled-system/jsx';
import { text } from '../../styled-system/recipes';
import { DEFAULT_ICON_SIZE } from './Icon.const';
import { IconSize, IIconProps } from './Icon.types';
import * as allIcons from './icon-registry';

export default {
  title: 'Icons/Icons',
  args: {
    size: DEFAULT_ICON_SIZE as IconSize,
    color: undefined,
  },
  argTypes: {
    color: { control: 'color' },
  },
} as Meta<IIconProps>;

const Text = styled('p', text);

const IconsWrapper = ({ color, size }: IIconProps) => {
  const [search, setSearch] = useState('');
  const [iconName, setIconName] = useState('IconName');

  return (
    <div style={{ width: '100%', height: '100%', margin: 'auto', overflowY: 'auto' }}>
      <Code block mb={20}>
        {`import { ${iconName} } from '@novu/novui'
     
<${iconName} /> `}
      </Code>
      <Input placeholder="Search" value={search} onChange={(e) => setSearch(e.target.value)} />
      <Grid align="center" gutter="xs" style={{ padding: '10px', paddingTop: '20px', paddingBottom: '20px' }}>
        {Object.entries(allIcons).map(([name, Icon]) => {
          if (name.includes(search.toLowerCase())) {
            return (
              <Grid.Col key={name} span={3}>
                <VStack gap={'75'}>
                  <ActionIcon variant="transparent" onClick={() => setIconName(name)}>
                    <Icon color={color} size={size} />
                  </ActionIcon>
                  <Text fontSize="75">{name}</Text>
                </VStack>
              </Grid.Col>
            );
          }

          return null;
        })}
      </Grid>
    </div>
  );
};

const Template: StoryFn<IIconProps> = ({ ...args }) => <IconsWrapper {...args} />;

export const Icons = Template.bind({});
Icons.args = {};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { ActionIcon, Code, Grid, Group, Input } from '@mantine/core';
import { Meta, StoryFn } from '@storybook/react';
import React, { useState } from 'react';
import { styled, VStack } from '../../styled-system/jsx';
import { text } from '../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/icons/Icon.types.ts
Tamaño: 943 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CSSProperties, SVGAttributes } from 'react';

/** Icon Size in pixels (to be replaced with values directly from Design System) */
export type IconSize = '16' | '20' | '24' | '32' | '40';

/** A temporary type that accepts a typical CSS color until we have our strict Design System types defined */
type UnsafeIconColor = CSSProperties['color'];

export interface IIconStyleProps {
  /**
   * Default: '20px'.
   *
   * The actual display size in pixels.
   */
  size?: IconSize;
  /**
   * Default: B60
   *
   * WARNING: this is only to be used with colors from the design system, and will later be enforced more strictly
   */
  color?: UnsafeIconColor;
}

export interface IIconProps extends Omit<SVGAttributes<SVGElement>, 'color'>, IIconStyleProps {
  /** Description for accessibility. This is mandatory so that we make a11y a priority with icons */
  title: string;
}
export type IconType = (props: IIconProps) => JSX.Element;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - IconType(props: IIconProps))
Declaraciones 'export' encontradas:
- export  type
- export  interface
- export  interface
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/icons/IconProvider.tsx
Tamaño: 550 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { PropsWithChildren } from 'react';
import { IconContext } from 'react-icons';
import { css } from '../../styled-system/css';
import { DEFAULT_ICON_SIZE } from './Icon.const';

const iconClassName = css({
  verticalAlign: 'middle',
  color: 'typography.text.secondary',
});

export const IconProvider: React.FC<PropsWithChildren<{}>> = ({ children }) => {
  return (
    <IconContext.Provider
      value={{
        size: DEFAULT_ICON_SIZE,
        className: iconClassName,
      }}
    >
      {children}
    </IconContext.Provider>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { PropsWithChildren } from 'react';
import { IconContext } from 'react-icons';
import { css } from '../../styled-system/css';
import { DEFAULT_ICON_SIZE } from './Icon.const';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/icons/icon-registry.ts
Tamaño: 280296 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###


### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/icons/react-icons.d.ts
Tamaño: 579 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { IconSize, IconType as NovuIconType, IIconProps } from './Icon.types';

/** Override Icon types */

declare module 'react-icons' {
  export type IconType = NovuIconType;

  // avoid declaration merging by using type instead of interface below
  export type IconBaseProps = IIconProps;
  export type IconContextProps = {
    color?: IconColor;
    size?: IconSize;
    className?: string;
    attr?: React.SVGAttributes<SVGElement>;
  };

  export declare const DefaultContext: IconContextProps;
  export declare const IconContext: React.Context<IconContextProps>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  declare
- export  declare

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/ingredients/README.md
Tamaño: 625 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

# Ingredients

An _ingredient_ is not a built-in concept in Panda, but rather our own. It represents a reusable piece of styling (especially within recipes) that may not be able to be used via other built-in approaches.

We generate Ingredients using `css.raw({ /* ... */ })` such that we get type-safe use of the token system while outputting raw JavaScript objects (in the form of `SystemStyleObject`) that can then be used in recipes or directly into a className with `css()`.

### Caveats

Ingredients **should not** have dynamic / conditional logic that prevents Panda from being able to generate the styles statically.


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# Ingredients
An _ingredient_ is not a built-in concept in Panda, but rather our own. It represents a reusable piece of styling (especially within recipes) that may not be able to be used via other built-in approaches.
We generate Ingredients using `css.raw({ /* ... */ })` such that we get type-safe use of the token system while outputting raw JavaScript objects (in the form of `SystemStyleObject`) that can then be used in recipes or directly into a className with `css()`.
### Caveats
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/ingredients/colorPaletteGradient.ingredient.ts
Tamaño: 623 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineStyles } from '@pandacss/dev';

export const colorPaletteGradientHorizontal = defineStyles({
  bgGradient: `to-r !important`,
  gradientFrom: 'colorPalette.start !important',
  gradientTo: 'colorPalette.end !important',
});

export const colorPaletteGradientText = defineStyles({
  ...colorPaletteGradientHorizontal,
  backgroundClip: 'text',
  WebkitBackgroundClip: 'text',
  WebkitTextFillColor: 'transparent',
});

export const colorPaletteGradientVertical = defineStyles({
  bgGradient: `to-b !important`,
  gradientFrom: 'colorPalette.start !important',
  gradientTo: 'colorPalette.end !important',
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/ingredients/index.ts
Tamaño: 51 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './colorPaletteGradient.ingredient';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/JsonSchemaForm.stories.tsx
Tamaño: 5654 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { RJSFSchema } from '@rjsf/utils';
import { Meta, StoryFn } from '@storybook/react';
import React, { FormEventHandler } from 'react';
import { css } from '../../styled-system/css';
import { HStack } from '../../styled-system/jsx';
import { Button, Title } from '../components';
import { IconOutlineSave } from '../icons';
import { JsonSchemaForm } from './JsonSchemaForm';

export default {
  title: 'Components/JsonSchemaForm',
  component: JsonSchemaForm,
  argTypes: {},
} as Meta<typeof JsonSchemaForm>;

const VARIABLES = [
  'ctrl.a',
  'ctrl.b',
  'ctrl.c',
  'ctrl.d',
  'ctrl.e',
  'payload.var',
  'payload.obj.var',
  'fakeAutocomplete.foo',
  'fakeAutocomplete.bar',
  'fakeAutocomplete.fizz',
  'fakeAutocomplete.buzz',
  'fakeAutocomplete.croissants',
  'fakeAutocomplete.olympics',
  'fakeAutocomplete.aReallyLongStringThatShouldOverflowFromTheContainer',
];

const Template: StoryFn<typeof JsonSchemaForm> = ({ colorPalette, ...args }) => {
  const onSubmit: FormEventHandler<HTMLFormElement> = (event) => {
    event.preventDefault();
    alert('Saving! (but not actually...)');
  };

  return (
    <form onSubmit={onSubmit} className={css({ colorPalette })}>
      <HStack justifyContent="space-between" mb="50">
        <Title variant="subsection">Step controls</Title>
        <Button type="submit" size="sm" Icon={IconOutlineSave}>
          Save
        </Button>
      </HStack>
      <JsonSchemaForm {...args} variables={VARIABLES} />
    </form>
  );
};
export const ExampleForm = Template.bind({});

const schema: RJSFSchema = {
  type: 'object',
  title: 'Example form',
  definitions: {
    locations: {
      enum: ['New York', 'Amsterdam', 'Hong Kong'],
    },
  },
  properties: {
    checkbox: {
      type: 'boolean',
      title: 'Checkbox field',
      default: true,
    },
    text: {
      type: 'string',
      title: 'Text field',
      default: 'lorem ipsum',
    },
    stringFormats: {
      type: 'object',
      title: 'Simple object',
      properties: {
        country: {
          type: 'string',
          title: 'Country',
          default: `Hello {{${VARIABLES[0]}}}, my name is {{invalid}} yo`,
        },
        address: {
          type: 'string',
          title: 'Address',
        },
        location: {
          title: 'Location',
          $ref: '#/definitions/locations',
        },
        anotherObject: {
          type: 'object',
          title: 'Nested example',
          properties: {
            isResidential: {
              type: 'boolean',
              title: 'Is residential?',
            },
            addressType: {
              type: 'string',
              title: 'Address type',
            },
            doubleNestedArray: {
              title: 'Double nested array',
              description: 'An array nested twice',
              type: 'array',
              items: {
                type: 'string',
              },
              minItems: 1,
            },
          },
        },
      },
      required: ['address'],
    },
    strings: {
      type: 'array',
      title: 'Simple String Array',
      description: 'This is a simple string array',
      items: {
        type: 'string',
        default: 'a string indeed',
      },
      minItems: 1,
    },
    booleans: {
      type: 'array',
      title: 'Simple Boolean Array',
      description: 'This is a simple array',
      items: {
        type: 'boolean',
        default: true,
      },
      minItems: 1,
    },
    users: {
      type: 'array',
      title: 'Array of objects',
      items: {
        type: 'object',
        properties: {
          name: {
            type: 'string',
            title: 'Name',
            default: 'John Doe',
          },
          age: { type: 'integer', default: 22, title: 'Age' },
          birthday: {
            type: 'string',
            title: 'Birthday',
            pattern: '\\d{2}-\\d{1,2}',
          },
        },
        required: ['name'],
      },
      minItems: 1,
    },
  },
};

ExampleForm.args = {
  schema,
  formData: { money: 43 },
};

const MATCH_DESIGNS_SCHEMA: RJSFSchema = {
  type: 'object',
  title: 'Email content',
  properties: {
    TeamImage: {
      title: 'TeamImage',
      required: undefined,
      type: 'string',
      default: 'https://react-email-demo-bdj5iju9r-resend.vercel',
    },
    Text: {
      type: 'array',
      title: 'Text',
      minItems: 2,
      items: {
        title: 'InvitedByUsername',
        type: 'string',
      },
    },
    ShowFootage: {
      type: 'boolean',
      title: 'ShowFootage',
      default: true,
    },
  },
};

export const MatchDesigns = Template.bind({});
MatchDesigns.args = {
  schema: MATCH_DESIGNS_SCHEMA,
};

const ARRAY_DESIGNS_SCHEMA: RJSFSchema = {
  type: 'array',
  minItems: 2,
  items: {
    type: 'array',
    title: 'Phone numbers',
    minItems: 2,
    items: {
      type: 'object',
      title: 'Digits',
      properties: {
        strokes: {
          title: 'Strokes',
          type: 'array',
          minItems: 2,
          items: {
            type: 'integer',
          },
        },
      },
    },
  },
};

export const ArrayDesigns = Template.bind({});
ArrayDesigns.args = {
  schema: ARRAY_DESIGNS_SCHEMA,
};

const SIMPLE_AUTOCOMPLETE_SCHEMA: RJSFSchema = {
  type: 'object',
  title: 'Simple autocomplete',
  properties: {
    country: {
      type: 'string',
      title: 'Name',
      default: `Hello {{${VARIABLES[0]}}}, {{ ${VARIABLES[1]} | upcase }} {{invalidRef}} {{badSyntax`,
    },
  },
};

export const SimpleAutocomplete = Template.bind({});
SimpleAutocomplete.args = {
  schema: SIMPLE_AUTOCOMPLETE_SCHEMA,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { RJSFSchema } from '@rjsf/utils';
import { Meta, StoryFn } from '@storybook/react';
import React, { FormEventHandler } from 'react';
import { css } from '../../styled-system/css';
import { HStack } from '../../styled-system/jsx';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/JsonSchemaForm.tsx
Tamaño: 3085 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import Form, { FormProps } from '@rjsf/core';
import { RegistryWidgetsType, UiSchema } from '@rjsf/utils';
import validator from '@rjsf/validator-ajv8';
import { css, cx } from '../../styled-system/css';
import { splitCssProps } from '../../styled-system/jsx';
import { JsxStyleProps } from '../../styled-system/types';

import { CoreProps } from '../types';
import { JSON_SCHEMA_FORM_ID_DELIMITER } from './constants';
import { ArrayFieldItemTemplate, ArrayFieldTemplate, ArrayFieldTitleTemplate } from './templates/ArrayFieldTemplate';
import { AddButton, MoveDownButton, MoveUpButton, RemoveButton } from './templates/IconButton';
import { ObjectFieldTemplate } from './templates/ObjectFieldTemplate';
import { CheckboxWidget, InputEditorWidget, SelectWidget } from './widgets';
import { InputWidget } from './widgets/InputWidget';
import { TextareaWidget } from './widgets/TextareaWidget';

const WIDGETS: RegistryWidgetsType = {
  CheckboxWidget,
  SelectWidget,
  TextWidget: InputEditorWidget,
  URLWidget: InputEditorWidget,
  EmailWidget: InputEditorWidget,
};

/** @deprecated TODO: delete after Autocomplete is fully released */
const LEGACY_WIDGETS: RegistryWidgetsType = {
  CheckboxWidget,
  SelectWidget,
  TextWidget: TextareaWidget,
  URLWidget: InputWidget,
  EmailWidget: InputWidget,
};

const UI_SCHEMA: UiSchema = {
  'ui:globalOptions': { addable: true, copyable: false, label: true, orderable: true },
  'ui:options': {
    hideError: true,
    submitButtonOptions: {
      norender: true,
    },
  },
};

export type JsonSchemaFormProps<TFormData = any> = JsxStyleProps &
  CoreProps &
  Pick<FormProps<TFormData>, 'onChange' | 'onSubmit' | 'onBlur' | 'schema' | 'formData' | 'tagName'> & {
    variables?: string[];
  };

/**
 * Specialized form editor for data passed as JSON.
 */
export function JsonSchemaForm<TFormData = {}>(props: JsonSchemaFormProps<TFormData>) {
  const [cssProps, { className, variables, ...formProps }] = splitCssProps(props);

  const isAutocompleteEnabled = Boolean(variables && variables.length > 0);

  return (
    <Form
      tagName={'fieldset'}
      className={cx(
        css({
          // default elements to hide
          '& .control-label, & .field-description': {
            display: 'none',
          },
          // hide raw text errors
          '& .panel.panel-danger.errors': {
            display: 'none',
          },
        }),
        css(cssProps),
        className
      )}
      // @ts-expect-error
      uiSchema={UI_SCHEMA}
      widgets={isAutocompleteEnabled ? WIDGETS : LEGACY_WIDGETS}
      // @ts-expect-error
      validator={validator}
      liveValidate
      autoComplete={'false'}
      formContext={{ variables }}
      idSeparator={JSON_SCHEMA_FORM_ID_DELIMITER}
      templates={{
        // @ts-expect-error
        ArrayFieldTitleTemplate,
        ArrayFieldTemplate,
        ArrayFieldItemTemplate,
        ObjectFieldTemplate,
        // @ts-expect-error
        ButtonTemplates: { MoveDownButton, AddButton, RemoveButton, MoveUpButton },
      }}
      {...formProps}
    />
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import Form, { FormProps } from '@rjsf/core';
import { RegistryWidgetsType, UiSchema } from '@rjsf/utils';
import validator from '@rjsf/validator-ajv8';
import { css, cx } from '../../styled-system/css';
import { splitCssProps } from '../../styled-system/jsx';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/constants.ts
Tamaño: 1232 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export const JSON_SCHEMA_FORM_ID_DELIMITER = '~~~';

// Backwards compatibility, for allowing usage of variables without namespace (e.g. `{{name}}` instead of `{{payload.name}}`)
export const PAYLOAD_NAMESPACE = 'payload';

export const AUTOCOMPLETE_OPEN_TAG = '{{';
export const AUTOCOMPLETE_CLOSE_TAG = '}}';

export const LIQUID_FILTER_CHAR = '|';

export const VARIABLE_HTML_TAG_NAME = 'autocomplete-variable';

export const AUTOCOMPLETE_REGEX = new RegExp(`${AUTOCOMPLETE_OPEN_TAG}(.*?(.*?))${AUTOCOMPLETE_CLOSE_TAG}`, 'm');

export const VALID_VARIABLE_REGEX = new RegExp(`${AUTOCOMPLETE_OPEN_TAG}([^{}]*?)${AUTOCOMPLETE_CLOSE_TAG}`, 'g');

// To get initial invalid syntax of {{..} or {{..<space>
export const INVALID_VARIABLE_REGEX = new RegExp(
  `(${AUTOCOMPLETE_OPEN_TAG}[^{}|\\s]*[}|\\s](?!})|{{[^{}]*}(?!}})|{{[^{}]*$)`,
  'g'
);

export const VARIABLE_HTML_ERROR_STATE_REGEX = /data-error="([A-Z_])+"/gi;

export enum VariableErrorCode {
  INVALID_SYNTAX = 'INVALID_SYNTAX',
  INVALID_NAME = 'INVALID_NAME',
}

export const VARIABLE_ERROR_MESSAGES: Record<VariableErrorCode, string> = {
  [VariableErrorCode.INVALID_SYNTAX]: 'Incorrect variable syntax',
  [VariableErrorCode.INVALID_NAME]: 'Invalid variable name',
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  enum
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/context.ts
Tamaño: 431 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createContextAndHook } from '../utils';

export type InputAutocompleteContextValue = { variablesSet: Set<string> };

const [InputAutocompleteContext, _useInputAutocompleteContext] =
  createContextAndHook<InputAutocompleteContextValue>('InputAutocompleteContext');

export const InputAutocompleteContextProvider = InputAutocompleteContext.Provider;
export const useInputAutocompleteContext = _useInputAutocompleteContext;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/shared.tsx
Tamaño: 2138 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { FC, MouseEventHandler } from 'react';
import { cva, cx } from '../../styled-system/css';
import { hstack } from '../../styled-system/patterns';
import { token } from '../../styled-system/tokens';
import { Title } from '../components';
import { IconExpandLess, IconExpandMore } from '../icons';
import { CoreProps, CorePropsWithChildren } from '../types';

export const FormGroupTitle: FC<CorePropsWithChildren> = ({ children, ...titleProps }) => {
  return (
    <Title variant="subsection" color="typography.text.secondary" {...titleProps}>
      {children}
    </Title>
  );
};

type SectionTitleToggleProps = CoreProps &
  Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, 'onClick' | 'children' | 'title'> & {
    onToggle: () => void;
    isExpanded: boolean;
    sectionDepth: number;
    sectionTitle?: React.ReactNode;
  };

const toggleButtonRecipe = cva({
  base: {
    gap: 'margins.icons.Icon20-txt',

    cursor: 'pointer',
    _disabled: {
      cursor: 'default',
    },
    '&:hover:not(:disabled)': {
      opacity: 'hover',
    },
  },
  variants: {
    isExpanded: {
      true: { marginBottom: '100' },
      false: {},
    },
  },
});

export const SectionTitleToggle: FC<SectionTitleToggleProps> = ({
  onToggle,
  isExpanded,
  sectionDepth,
  sectionTitle,
  ...buttonProps
}) => {
  const handleToggle: MouseEventHandler<HTMLButtonElement> = (event) => {
    event.preventDefault();
    onToggle();
  };

  const shouldShowToggle = sectionDepth > 0;

  if (!sectionTitle && !shouldShowToggle) {
    return null;
  }

  return (
    <button
      onClick={handleToggle}
      disabled={!shouldShowToggle}
      className={cx(hstack(), toggleButtonRecipe({ isExpanded: isExpanded || !shouldShowToggle }))}
      {...buttonProps}
    >
      {!shouldShowToggle ? (
        sectionTitle
      ) : (
        <>
          {isExpanded ? (
            <IconExpandLess title="expand-less-section-icon" color={token('colors.typography.text.main')} />
          ) : (
            <IconExpandMore title="expand-more-section-icon" />
          )}
          {sectionTitle}
        </>
      )}
    </button>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { FC, MouseEventHandler } from 'react';
import { cva, cx } from '../../styled-system/css';
import { hstack } from '../../styled-system/patterns';
import { token } from '../../styled-system/tokens';
import { Title } from '../components';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/useExpandToggle.tsx
Tamaño: 259 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { useState } from 'react';

export const useExpandToggle = (defaultValue: boolean = true) => {
  const [isExpanded, setExpanded] = useState<boolean>(defaultValue);

  return [isExpanded, () => setExpanded((prevExpanded) => !prevExpanded)] as const;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { useState } from 'react';
export const useExpandToggle = (defaultValue: boolean = true) => {
const [isExpanded, setExpanded] = useState<boolean>(defaultValue);
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/utils.ts
Tamaño: 3028 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { JsonSchemaFormSectionVariant } from '../../styled-system/recipes';
import {
  AUTOCOMPLETE_CLOSE_TAG,
  AUTOCOMPLETE_OPEN_TAG,
  INVALID_VARIABLE_REGEX,
  JSON_SCHEMA_FORM_ID_DELIMITER,
  PAYLOAD_NAMESPACE,
  VALID_VARIABLE_REGEX,
  VARIABLE_HTML_ERROR_STATE_REGEX,
  VARIABLE_HTML_TAG_NAME,
  VariableErrorCode,
} from './constants';

/** determine the tree depth of a JsonSchemaForm section with the given sectionId */
export function calculateSectionDepth({ sectionId }: { sectionId: string }): number {
  return sectionId.split(JSON_SCHEMA_FORM_ID_DELIMITER).length - 1;
}

export function getVariantFromDepth(depth: number): JsonSchemaFormSectionVariant['depth'] {
  return depth % 2 === 0 ? 'even' : 'odd';
}

export const cleanVariableMatch = (variableMatch?: string): string => {
  if (!variableMatch) {
    return '';
  }

  return variableMatch.replace(AUTOCOMPLETE_OPEN_TAG, '').replace(AUTOCOMPLETE_CLOSE_TAG, '').split('|')[0].trim();
};

const VARIABLE_ERROR_CODE_SET = new Set(Object.values(VariableErrorCode));
export const checkIsValidVariableErrorCode = (input?: string) => {
  if (!input) {
    return false;
  }

  return VARIABLE_ERROR_CODE_SET.has(input as VariableErrorCode);
};

export const getInitContentWithVariableNodeView = (inputString: string, variablesSet: Set<string>) => {
  if (!inputString) {
    return inputString;
  }

  let result = inputString.toString().replace(VALID_VARIABLE_REGEX, (match, validContent) => {
    const cleanedMatch = cleanVariableMatch(match);
    const isValidVariable = variablesSet.has(cleanedMatch);

    return `<${VARIABLE_HTML_TAG_NAME} data-label="${validContent}" data-id="${validContent}" ${
      !isValidVariable ? `data-error="${VariableErrorCode.INVALID_NAME}"` : ''
    }></${VARIABLE_HTML_TAG_NAME}>`;
  });

  result = result?.replace(INVALID_VARIABLE_REGEX, (match) => {
    return `<${VARIABLE_HTML_TAG_NAME} data-label="${match}" data-id="${match}" data-error="${VariableErrorCode.INVALID_SYNTAX}"></${VARIABLE_HTML_TAG_NAME}>`;
  });

  return result;
};

/** Parse editor HTML and extract valid error codes from variable references (if any) */
export const extractErrorCodesFromHtmlContent = (htmlContent?: string): Set<string> | undefined => {
  if (!htmlContent) {
    return;
  }

  const errorCodes = htmlContent
    .match(VARIABLE_HTML_ERROR_STATE_REGEX)
    ?.map((str) => str.match(/"(.*?)"/i)?.[0]?.replaceAll('"', ''))
    ?.filter((code) => checkIsValidVariableErrorCode(code));

  return errorCodes ? new Set(errorCodes) : undefined;
};

// Backwards compatibility, for allowing usage of variables without namespace (e.g. `{{name}}` instead of `{{payload.name}}`)
export const getDeprecatedPayloadVariables = (variables: string[]): string[] => {
  return variables
    .filter((variable: string) => variable.startsWith(`${PAYLOAD_NAMESPACE}.`))
    .map(getVariableWithoutNamespace);
};

export const getVariableWithoutNamespace = (variableName: string): string => {
  return variableName.split('.').splice(1).join('.');
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - calculateSectionDepth({ sectionId }: { sectionId: string })
 - getVariantFromDepth(depth: number)
Asignaciones con arrow functions encontradas (posibles funciones):
 - cleanVariableMatch(variableMatch?: string): string)
 - checkIsValidVariableErrorCode(input?: string))
 - getInitContentWithVariableNodeView(inputString: string, variablesSet: Set<string>))
 - result(inputString.toString().replace(VALID_VARIABLE_REGEX, (match, validContent))
 - result(result?.replace(INVALID_VARIABLE_REGEX, (match))
 - extractErrorCodesFromHtmlContent(htmlContent?: string): Set<string> | undefined)
 - errorCodes(htmlContent
    .match(VARIABLE_HTML_ERROR_STATE_REGEX)
    ?.map((str))
 - getDeprecatedPayloadVariables(variables: string[]): string[])
 - getVariableWithoutNamespace(variableName: string): string)
Declaraciones 'export' encontradas:
- export function calculateSectionDepth
- export function getVariantFromDepth
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/templates/ArrayFieldTemplate.tsx
Tamaño: 3758 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import {
  ArrayFieldTemplateItemType,
  ArrayFieldTemplateProps,
  ArrayFieldTitleProps,
  getTemplate,
  getUiOptions,
} from '@rjsf/utils';
import { css } from '../../../styled-system/css';
import { Box } from '../../../styled-system/jsx';
import { jsonSchemaFormArrayToolbar, jsonSchemaFormSection } from '../../../styled-system/recipes';
import { FormGroupTitle, SectionTitleToggle } from '../shared';
import { useExpandToggle } from '../useExpandToggle';
import { calculateSectionDepth, getVariantFromDepth } from '../utils';

export function ArrayFieldTemplate(props: ArrayFieldTemplateProps) {
  const [isExpanded, toggleExpanded] = useExpandToggle();

  const { canAdd, disabled, idSchema, uiSchema, items, onAddClick, readonly, registry, required, title, schema } =
    props;
  const {
    ButtonTemplates: { AddButton },
  } = registry.templates;
  const uiOptions = getUiOptions(uiSchema);
  const ArrayFieldTitleTemplate = getTemplate('ArrayFieldTitleTemplate', registry, uiOptions);
  const ArrayFieldItemTemplate = getTemplate('ArrayFieldItemTemplate', registry, uiOptions);

  const sectionDepth = calculateSectionDepth({ sectionId: props.idSchema.$id });
  const depthVariant = getVariantFromDepth(sectionDepth);

  const sectionClassNames = jsonSchemaFormSection({
    depth: depthVariant,
  });

  return (
    <Box className={sectionClassNames.sectionRoot}>
      <SectionTitleToggle
        onToggle={toggleExpanded}
        isExpanded={isExpanded}
        sectionDepth={sectionDepth}
        sectionTitle={
          uiOptions.title || title ? (
            <ArrayFieldTitleTemplate
              idSchema={idSchema}
              title={uiOptions.title || title}
              schema={schema}
              uiSchema={uiSchema}
              required={required}
              registry={registry}
            />
          ) : undefined
        }
      />
      {isExpanded ? (
        <>
          {items.map(({ key, ...itemProps }) => {
            return <ArrayFieldItemTemplate key={key} {...itemProps} />;
          })}
          {canAdd && (
            <AddButton
              onClick={onAddClick}
              disabled={disabled || readonly}
              registry={registry}
              className={css({ mt: '150' })}
            />
          )}
        </>
      ) : null}
    </Box>
  );
}

export function ArrayFieldTitleTemplate({ title }: ArrayFieldTitleProps) {
  return <FormGroupTitle>{title}</FormGroupTitle>;
}

export function ArrayFieldItemTemplate(props: ArrayFieldTemplateItemType) {
  const {
    children,
    disabled,
    hasMoveDown,
    hasMoveUp,
    hasRemove,
    index,
    onDropIndexClick,
    onReorderClick,
    readonly,
    registry,
    schema,
  } = props;
  const { MoveDownButton, MoveUpButton, RemoveButton } = registry.templates.ButtonTemplates;

  const toolbarClassNames = jsonSchemaFormArrayToolbar({
    itemType: typeof schema.type === 'object' ? schema.type[0] : schema.type,
  });

  return (
    <div className={toolbarClassNames.toolbarWrapper}>
      {children}
      <div role="toolbar" className={toolbarClassNames.toolbar}>
        {(hasMoveUp || hasMoveDown) && (
          <MoveUpButton
            disabled={disabled || readonly || !hasMoveUp}
            onClick={onReorderClick(index, index - 1)}
            registry={registry}
          />
        )}
        {(hasMoveUp || hasMoveDown) && (
          <MoveDownButton
            disabled={disabled || readonly || !hasMoveDown}
            onClick={onReorderClick(index, index + 1)}
            registry={registry}
          />
        )}
        {hasRemove && (
          <RemoveButton disabled={disabled || readonly} onClick={onDropIndexClick(index)} registry={registry} />
        )}
      </div>
    </div>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import {
ArrayFieldTemplateItemType,
ArrayFieldTemplateProps,
ArrayFieldTitleProps,
getTemplate,
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/templates/IconButton.tsx
Tamaño: 1140 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { IconButtonProps } from '@rjsf/utils';
import { css, cx } from '../../../styled-system/css';
import { Button, IconButton } from '../../components';
import { IconAdd, IconArrowDownward, IconArrowUpward, IconOutlineDeleteOutline } from '../../icons/icon-registry';

type Props = Omit<IconButtonProps, 'color' | 'translate' | 'iconType' | 'icon'>;

export function RemoveButton(props: Props) {
  return <IconButton {...props} Icon={IconOutlineDeleteOutline} title="remove" />;
}

export function MoveUpButton(props: Props) {
  return <IconButton {...props} Icon={IconArrowUpward} title="move-up" />;
}

export function MoveDownButton(props: Props) {
  return <IconButton {...props} Icon={IconArrowDownward} title="move-down" />;
}

export function AddButton({ className, ...props }: Props) {
  return (
    <Button
      {...props}
      variant={'transparent'}
      size="md"
      Icon={IconAdd}
      className={cx(
        css({
          '& span': {
            color: 'typography.text.main',
            WebkitTextFillColor: 'unset',
          },
        }),
        className
      )}
    >
      Add item
    </Button>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { IconButtonProps } from '@rjsf/utils';
import { css, cx } from '../../../styled-system/css';
import { Button, IconButton } from '../../components';
import { IconAdd, IconArrowDownward, IconArrowUpward, IconOutlineDeleteOutline } from '../../icons/icon-registry';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/templates/ObjectFieldTemplate.tsx
Tamaño: 1238 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { ObjectFieldTemplateProps } from '@rjsf/utils';
import { Box } from '../../../styled-system/jsx';
import { jsonSchemaFormSection } from '../../../styled-system/recipes';
import { FormGroupTitle, SectionTitleToggle } from '../shared';
import { useExpandToggle } from '../useExpandToggle';
import { calculateSectionDepth, getVariantFromDepth } from '../utils';

export function ObjectFieldTemplate(props: ObjectFieldTemplateProps) {
  const [isExpanded, toggleExpanded] = useExpandToggle();

  const sectionDepth = calculateSectionDepth({ sectionId: props.idSchema.$id });
  const depthVariant = getVariantFromDepth(sectionDepth);

  const sectionClassNames = jsonSchemaFormSection({
    depth: depthVariant,
  });

  return (
    <Box className={sectionClassNames.sectionRoot}>
      <SectionTitleToggle
        onToggle={toggleExpanded}
        isExpanded={isExpanded}
        sectionDepth={sectionDepth}
        sectionTitle={props.title ? <FormGroupTitle>{props.title}</FormGroupTitle> : undefined}
      ></SectionTitleToggle>
      {isExpanded ? (
        <>
          {props.properties.map((element) => (
            <Box key={element.name}>{element.content}</Box>
          ))}
        </>
      ) : null}
    </Box>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { ObjectFieldTemplateProps } from '@rjsf/utils';
import { Box } from '../../../styled-system/jsx';
import { jsonSchemaFormSection } from '../../../styled-system/recipes';
import { FormGroupTitle, SectionTitleToggle } from '../shared';
import { useExpandToggle } from '../useExpandToggle';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/CheckboxWidget.tsx
Tamaño: 443 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { WidgetProps } from '@rjsf/utils';
import { Checkbox } from '../../components/checkbox/Checkbox';

export const CheckboxWidget = (props: WidgetProps) => {
  return (
    <Checkbox
      checked={typeof props.value === 'undefined' ? false : props.value}
      description={props.schema.description}
      onChange={({ target }) => props.onChange(target.checked)}
      required={props.required}
      label={props.label}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { WidgetProps } from '@rjsf/utils';
import { Checkbox } from '../../components/checkbox/Checkbox';
export const CheckboxWidget = (props: WidgetProps) => {
return (
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/InputEditorWidget.tsx
Tamaño: 6033 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Input } from '@mantine/core';
import { RichTextEditor } from '@mantine/tiptap';
import { ErrorSchema, WidgetProps } from '@rjsf/utils';
import Document from '@tiptap/extension-document';
import HistoryExtension from '@tiptap/extension-history';
import Paragraph from '@tiptap/extension-paragraph';
import Text from '@tiptap/extension-text';
import { Editor, type Extensions, ReactRenderer, useEditor } from '@tiptap/react';
import { useEffect, useMemo, useRef } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { input, inputEditorWidget } from '../../../styled-system/recipes';
import { AUTOCOMPLETE_OPEN_TAG, VARIABLE_ERROR_MESSAGES } from '../constants';
import { InputAutocompleteContextProvider } from '../context';
import {
  extractErrorCodesFromHtmlContent,
  getDeprecatedPayloadVariables,
  getInitContentWithVariableNodeView,
} from '../utils';
import { CustomMention } from './customMentionExtension';
import { SuggestionListExtension, SuggestionListStorage } from './SuggestionListExtension';
import { SuggestionListRef, VariableItem, VariableSuggestionList } from './VariableSuggestionList';

const inputEditorClassNames = inputEditorWidget();

const DEFAULT_EDITOR_EXTENSIONS: Extensions = [Document, Paragraph, Text, HistoryExtension];

export const InputEditorWidget = (props: WidgetProps) => {
  const { value, label, formContext, onChange, required, readonly, rawErrors } = props;

  const [variantProps, inputProps] = input.splitVariantProps({});
  const [cssProps] = splitCssProps(inputProps);
  const classNames = input(variantProps);

  const reactRenderer = useRef<ReactRenderer<SuggestionListRef>>(null);

  const { variables = [] } = formContext;
  const [variablesList, variablesSet] = useMemo<[VariableItem[], Set<string>]>(() => {
    const variableDisplayList = variables?.map((variable: string) => {
      return { label: variable, id: variable };
    });

    return [variableDisplayList, new Set([...variables, ...getDeprecatedPayloadVariables(variables)])];
  }, [variables]);

  const extensions = useMemo(() => {
    if (!variablesList || variablesList.length === 0) {
      return DEFAULT_EDITOR_EXTENSIONS;
    }

    return DEFAULT_EDITOR_EXTENSIONS.concat([
      SuggestionListExtension,
      CustomMention().configure({
        suggestion: {
          items: ({ editor, query }) => {
            const { suggestions } = editor.storage.SuggestionListStorage as SuggestionListStorage;

            return suggestions?.filter((item) => item.label.toLowerCase().includes(query.toLowerCase().trim()));
          },
          char: AUTOCOMPLETE_OPEN_TAG,
          decorationTag: 'span',
          decorationClass: 'suggestion',
          allowSpaces: true,
          allowedPrefixes: null,
          render() {
            return {
              onStart: (onStartProps) => {
                reactRenderer.current = new ReactRenderer(VariableSuggestionList, {
                  props: onStartProps,
                  editor: onStartProps.editor,
                });
              },
              onUpdate(onUpdateProps) {
                reactRenderer.current?.updateProps(onUpdateProps);
              },
              onKeyDown(onKeyDownProps) {
                if (!reactRenderer.current?.ref) {
                  return false;
                }

                return reactRenderer.current?.ref.onKeyDown(onKeyDownProps);
              },
              onExit() {
                reactRenderer.current?.destroy();
              },
            };
          },
        },
      }),
    ]);
  }, [variablesList]);

  const handleEditorUpdateWithValidation = ({ editor }: { editor: Editor }) => {
    const content = editor.isEmpty ? undefined : editor.getText();
    const htmlContent = editor.isEmpty ? undefined : editor.getHTML();

    // extract error messages from HTML and convert to user-friendly messages
    const parsedErrorCodes = extractErrorCodesFromHtmlContent(htmlContent);

    const errorMessages: string[] | undefined =
      parsedErrorCodes && parsedErrorCodes.size > 0
        ? [...parsedErrorCodes.values()].map((code) => VARIABLE_ERROR_MESSAGES[code])
        : undefined;

    onChange(content, { __errors: errorMessages } as ErrorSchema);
  };

  const editor = useEditor({
    extensions,
    content: '',
    editable: !readonly,
    parseOptions: {},
    onFocus: () => {
      reactRenderer.current?.ref?.focus();
    },
    onBlur: () => {
      reactRenderer.current?.ref?.blur();
    },
    onUpdate: ({ editor: editorInstance }) => {
      handleEditorUpdateWithValidation({ editor: editorInstance });
    },
  });

  // keep the suggestion list popover synced with the component state
  useEffect(() => {
    if (editor) {
      editor.storage.SuggestionListStorage.suggestions = variablesList;
    }
  }, [variablesList, editor]);

  useEffect(() => {
    if (editor) {
      const output = getInitContentWithVariableNodeView(value?.toString(), variablesSet);

      // Set timeout is for a known tiptap error with setting content on initial render https://github.com/ueberdosis/tiptap/issues/3764
      const timeoutId = setTimeout(() => {
        editor.commands.setContent(output);
        // validate on initial render
        handleEditorUpdateWithValidation({ editor });
      });

      return () => {
        clearTimeout(timeoutId);
      };
    }
  }, [variablesSet]);

  return (
    <InputAutocompleteContextProvider value={{ value: { variablesSet } }}>
      <Input.Wrapper
        classNames={classNames}
        className={cx('group', css(cssProps))}
        required={required}
        label={label}
        description={props.schema.description}
        error={rawErrors?.length > 0 && rawErrors.join(', ')}
      >
        <RichTextEditor classNames={inputEditorClassNames} editor={editor} spellCheck={false}>
          <RichTextEditor.Content />
        </RichTextEditor>
      </Input.Wrapper>
    </InputAutocompleteContextProvider>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Input } from '@mantine/core';
import { RichTextEditor } from '@mantine/tiptap';
import { ErrorSchema, WidgetProps } from '@rjsf/utils';
import Document from '@tiptap/extension-document';
import HistoryExtension from '@tiptap/extension-history';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/InputWidget.tsx
Tamaño: 838 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { getInputProps, WidgetProps } from '@rjsf/utils';
import { Input, TextInputType } from '../../components/input/Input';

/**
 * @deprecated
 * Use `InputEditorWidget` instead
 */
export const InputWidget = (props: WidgetProps) => {
  const { type, value, label, schema, onChange, options, required, readonly, rawErrors, disabled } = props;
  const inputProps = getInputProps(schema, type, options);

  return (
    <Input
      description={props.schema.description}
      onChange={(event) => {
        event.preventDefault();
        onChange(event.target.value);
      }}
      value={value || value === 0 ? value : ''}
      required={required}
      label={label}
      type={inputProps.type as TextInputType}
      error={rawErrors?.length > 0 && rawErrors}
      readOnly={readonly}
      disabled={disabled}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { getInputProps, WidgetProps } from '@rjsf/utils';
import { Input, TextInputType } from '../../components/input/Input';
/**
* @deprecated
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/SelectWidget.tsx
Tamaño: 729 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { WidgetProps } from '@rjsf/utils';
import { Select } from '../../components';

export const SelectWidget = (props: WidgetProps) => {
  const { options, label, required, disabled, readonly, value, schema, onChange, rawErrors } = props;
  const data = options.enumOptions.map((option) => {
    return {
      label: option.label,
      value: String(option.value),
    };
  });

  return (
    <Select
      description={schema.description}
      onChange={onChange}
      value={typeof value === 'undefined' || !value ? null : String(value)}
      required={required}
      label={label}
      data={data}
      disabled={disabled}
      readOnly={readonly}
      error={rawErrors?.length > 0 && rawErrors}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { WidgetProps } from '@rjsf/utils';
import { Select } from '../../components';
export const SelectWidget = (props: WidgetProps) => {
const { options, label, required, disabled, readonly, value, schema, onChange, rawErrors } = props;
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/SuggestionListExtension.tsx
Tamaño: 361 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Extension } from '@tiptap/react';

import { VariableItem } from './VariableSuggestionList';

export type SuggestionListStorage = {
  suggestions: VariableItem[];
};
export const SuggestionListExtension = Extension.create<{}, SuggestionListStorage>({
  name: 'SuggestionListStorage',
  addStorage() {
    return {
      suggestions: [],
    };
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Extension } from '@tiptap/react';
import { VariableItem } from './VariableSuggestionList';
export type SuggestionListStorage = {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/TextareaWidget.tsx
Tamaño: 835 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { getInputProps, WidgetProps } from '@rjsf/utils';
import { Textarea, TextInputType } from '../../components';

/**
 * @deprecated
 * Use `InputEditorWidget` instead
 */
export const TextareaWidget = (props: WidgetProps) => {
  const { type, value, label, schema, onChange, options, required, readonly, rawErrors, disabled } = props;
  const inputProps = getInputProps(schema, type, options);

  return (
    <Textarea
      description={props.schema.description}
      onChange={(event) => {
        event.preventDefault();
        onChange(event.target.value);
      }}
      value={value || value === 0 ? value : ''}
      required={required}
      label={label}
      type={inputProps.type as TextInputType}
      error={rawErrors?.length > 0 && rawErrors}
      readOnly={readonly}
      disabled={disabled}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { getInputProps, WidgetProps } from '@rjsf/utils';
import { Textarea, TextInputType } from '../../components';
/**
* @deprecated
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/Variable.tsx
Tamaño: 3056 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { NodeViewContent, NodeViewProps, NodeViewWrapper } from '@tiptap/react';
import { ChangeEvent, FocusEvent, useEffect, useState } from 'react';
import {
  AUTOCOMPLETE_CLOSE_TAG,
  AUTOCOMPLETE_OPEN_TAG,
  AUTOCOMPLETE_REGEX,
  LIQUID_FILTER_CHAR,
  VariableErrorCode,
} from '../constants';
import { useInputAutocompleteContext } from '../context';

export function Variable({ editor, node, updateAttributes, ...props }: NodeViewProps) {
  const [errorCode, setErrorCode] = useState<VariableErrorCode | undefined>();

  const { variablesSet } = useInputAutocompleteContext();

  const updateVariableAttributes = (label: string, newErrorCode?: VariableErrorCode) => {
    updateAttributes({ label, error: newErrorCode });
    setErrorCode(newErrorCode);
  };

  // Initialize error state after validating variable
  useEffect(() => {
    if (variablesSet && variablesSet.size > 0 && !getValidatedVariable(node.attrs.label, variablesSet)) {
      setErrorCode(VariableErrorCode.INVALID_NAME);
    }
  }, [node.attrs.label, variablesSet]);

  // In case of an invalid variable input, set content to be the label variable which will include the whole invalid variable
  const renderedNodeViewContent = !node.attrs.label.includes(AUTOCOMPLETE_OPEN_TAG)
    ? `${AUTOCOMPLETE_OPEN_TAG}${node.attrs.label}${AUTOCOMPLETE_CLOSE_TAG}`
    : `${node.attrs.label}`;

  return (
    <NodeViewWrapper as={'span'} contentEditable={'false'} suppressContentEditableWarning>
      <NodeViewContent
        as={'span'}
        className={'suggestion'}
        contentEditable
        suppressContentEditableWarning
        data-error={errorCode}
        onInput={(event: ChangeEvent<HTMLInputElement>) => {
          const text = event.target.innerText;
          const variable = getValidatedVariable(text, variablesSet);

          if (variable) {
            updateVariableAttributes(variable);

            return;
          }

          // remove empty node
          if (text.length === 0) {
            props.deleteNode();
            editor.commands.focus();
          }
        }}
        onBlur={(event: FocusEvent<HTMLInputElement>) => {
          const text = event.target.innerText;
          const variable = getValidatedVariable(text, variablesSet);

          if (variable) {
            updateVariableAttributes(variable);
          } else {
            updateVariableAttributes(text, VariableErrorCode.INVALID_NAME);
          }
        }}
      >
        {renderedNodeViewContent}
      </NodeViewContent>
    </NodeViewWrapper>
  );
}
/**
 * Get the variable name from input text if a valid reference exists. Otherwise, returns undefined.
 */
function getValidatedVariable(text: string = '', possibleVariables: Set<string>) {
  const variableContent = text.includes(AUTOCOMPLETE_OPEN_TAG) ? text.match(AUTOCOMPLETE_REGEX)?.[1] : text;

  if (!variableContent) {
    return;
  }

  const variableName = variableContent.split(LIQUID_FILTER_CHAR)[0].trim();

  if (!possibleVariables.has(variableName)) {
    return;
  }

  return variableContent;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { NodeViewContent, NodeViewProps, NodeViewWrapper } from '@tiptap/react';
import { ChangeEvent, FocusEvent, useEffect, useState } from 'react';
import {
AUTOCOMPLETE_CLOSE_TAG,
AUTOCOMPLETE_OPEN_TAG,
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/VariableSuggestionList.tsx
Tamaño: 4644 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Combobox, useCombobox, VisuallyHidden } from '@mantine/core';
import { SuggestionKeyDownProps, type SuggestionProps } from '@tiptap/suggestion';
import React, { forwardRef, useEffect, useImperativeHandle } from 'react';
import { createPortal } from 'react-dom';
import { variableSuggestionList } from '../../../styled-system/recipes';
import { Text } from '../../components';
import { AUTOCOMPLETE_CLOSE_TAG, AUTOCOMPLETE_OPEN_TAG, VariableErrorCode } from '../constants';
import { useInputAutocompleteContext } from '../context';
import { cleanVariableMatch } from '../utils';

export type VariableItem = {
  id: string;
  label: string;
};

export type SuggestionListRef = {
  onKeyDown: (props: SuggestionKeyDownProps) => boolean;
  focus: () => void;
  blur: () => void;
  close: () => void;
};

type SuggestionListProps = SuggestionProps<VariableItem>;

const suggestionListClassNames = variableSuggestionList();

export const VariableSuggestionList = forwardRef<SuggestionListRef, SuggestionListProps>(
  ({ clientRect, command, query, items }, ref) => {
    const combobox = useCombobox({
      defaultOpened: true,
      onDropdownOpen: () => combobox.selectFirstOption(),
    });

    const { variablesSet } = useInputAutocompleteContext();

    useEffect(() => {
      combobox.selectFirstOption();
    }, [items]);

    // called on entering the AUTOCOMPLETE_CLOSE_TAG or onBlur of the variable entry
    const customVariableLabel = () => {
      // ensure query has closing characters
      if (!query.endsWith(AUTOCOMPLETE_CLOSE_TAG)) {
        command({ label: `${AUTOCOMPLETE_OPEN_TAG}${query}`, id: '', error: VariableErrorCode.INVALID_SYNTAX });

        return;
      }

      // extract variable name without special closing characters
      const variableName = cleanVariableMatch(query);
      const cleanedQuery = query.slice(0, -AUTOCOMPLETE_CLOSE_TAG.length);

      // set error if the variable is not a valid reference
      if (!variablesSet.has(variableName)) {
        command({ label: cleanedQuery, id: '', error: VariableErrorCode.INVALID_NAME });

        return;
      }

      // happy path -- valid variable reference
      return command({ label: cleanedQuery, id: variableName });
    };

    const options = items?.map((item) => (
      <Combobox.Option value={item.id} key={item.id}>
        {item.label}
      </Combobox.Option>
    ));

    useImperativeHandle(ref, () => ({
      close: () => {
        combobox.closeDropdown();
      },
      focus: () => {
        combobox.openDropdown();
      },
      blur: () => {
        customVariableLabel();
      },
      onKeyDown: ({ event }) => {
        if (event.key === 'Escape') {
          combobox.closeDropdown();

          return true;
        }
        if (event.key === 'ArrowDown') {
          combobox.selectNextOption();

          return true;
        }
        if (event.key === 'ArrowRight') {
          customVariableLabel();

          return true;
        }
        if (event.code === 'Space') {
          // don't allow Space to close variable entry if the user hasn't typed the closing tag
          if (!query.endsWith(AUTOCOMPLETE_CLOSE_TAG)) {
            return false;
          }
          customVariableLabel();

          return true;
        }
        if (event.key === 'ArrowUp') {
          combobox.selectPreviousOption();

          return true;
        }

        if (event.key === 'Enter') {
          combobox.clickSelectedOption();

          return true;
        }

        return false;
      },
    }));

    const handleCommand = (id: string) => {
      const foundItem = items.find((item) => item.id === id);
      if (!foundItem) {
        return;
      }

      command(foundItem);
    };

    return createPortal(
      <Combobox
        store={combobox}
        classNames={suggestionListClassNames}
        withinPortal={false}
        onOptionSubmit={(suggestionId) => {
          handleCommand(suggestionId);
          combobox.closeDropdown();
        }}
      >
        <Combobox.DropdownTarget>
          <VisuallyHidden
            style={{
              position: 'absolute',
              top: clientRect?.()?.bottom,
              left: clientRect?.()?.left,
            }}
          />
        </Combobox.DropdownTarget>
        <Combobox.Dropdown>
          <Combobox.Options>
            {options.length > 0 ? (
              options
            ) : (
              <Combobox.Empty>
                <Text>Nothing found</Text>
              </Combobox.Empty>
            )}
          </Combobox.Options>
        </Combobox.Dropdown>
      </Combobox>,
      document.body
    );
  }
);
