
      controlValuesRepositoryMock.findOne.resolves(mockControlValuesEntity as any);
      getLayoutUseCase.execute.resolves(mockLayoutDto as any);
    });

    it('should skip layout rendering when skipLayoutRendering is true', async () => {
      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Skip Layout Test',
          body: simpleBodyContent,
          layoutId: 'test_layout_id',
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: { name: 'John' },
        },
        workflowId: mockDbWorkflow._id,
        skipLayoutRendering: true,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.body).to.include('Step content John');
      expect(result.body).to.not.include('class="layout"');
      expect(result.body).to.not.include('<html>');
      expect(result.body).to.not.include('<body>');

      // Verify that layout was fetched but not applied
      expect(getLayoutUseCase.execute.calledOnce).to.be.true;
      expect(controlValuesRepositoryMock.findOne.calledOnce).to.be.true;
    });

    it('should log the execution details when jobId is provided', async () => {
      const mockJob: JobEntity = {
        _id: 'test_job_id',
        _environmentId: 'fake_env_id',
        _organizationId: 'fake_org_id',
        subscriberId: 'fake_subscriber_id',
        providerId: 'fake_provider_id',
        transactionId: 'fake_transaction_id',
        type: StepTypeEnum.EMAIL,
        status: JobStatusEnum.PENDING,
        identifier: 'fake_identifier',
        payload: {},
        overrides: {},
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        step: {
          _id: 'fake_step_id',
          name: 'fake_step_name',
          _templateId: 'fake_template_id',
          active: true,
          replyCallback: {
            active: true,
            url: 'fake_url',
          },
        },
        _notificationId: 'fake_notification_id',
        _subscriberId: 'fake_subscriber_id',
        _userId: 'fake_user_id',
        _templateId: 'fake_template_id',
      };
      jobRepositoryMock.findOne.resolves(mockJob as any);
      createExecutionDetailsMock.execute.resolves();

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Skip Layout Test',
          body: simpleBodyContent,
          layoutId: 'test_layout_id',
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: { name: 'John' },
        },
        workflowId: mockDbWorkflow._id,
        jobId: mockJob._id,
        stepId: 'fake_step_id',
      };

      await emailOutputRendererUsecase.execute(renderCommand);

      expect(getLayoutUseCase.execute.calledOnce).to.be.true;
      expect(controlValuesRepositoryMock.findOne.calledOnce).to.be.true;
      expect(jobRepositoryMock.findOne.calledOnce).to.be.true;
      expect(jobRepositoryMock.findOne.firstCall.args[0]._id).to.equal(mockJob._id);
      expect(jobRepositoryMock.findOne.firstCall.args[0]._environmentId).to.equal('fake_env_id');
      expect(createExecutionDetailsMock.execute.calledOnce).to.be.true;
      expect(createExecutionDetailsMock.execute.firstCall.args[0].jobId).to.equal(mockJob._id);
      expect(createExecutionDetailsMock.execute.firstCall.args[0].detail).to.equal(DetailEnum.LAYOUT_SELECTED);
      expect(createExecutionDetailsMock.execute.firstCall.args[0].source).to.equal(ExecutionDetailsSourceEnum.INTERNAL);
      expect(createExecutionDetailsMock.execute.firstCall.args[0].status).to.equal(ExecutionDetailsStatusEnum.PENDING);
      expect(createExecutionDetailsMock.execute.firstCall.args[0].isTest).to.be.false;
      expect(createExecutionDetailsMock.execute.firstCall.args[0].isRetry).to.be.false;
      expect(createExecutionDetailsMock.execute.firstCall.args[0].raw).to.equal(
        JSON.stringify({ name: 'test_layout_name', layoutId: 'test_layout_id' })
      );
    });

    it('should apply layout rendering when skipLayoutRendering is false', async () => {
      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Apply Layout Test',
          body: simpleBodyContent,
          layoutId: 'test_layout_id',
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: { name: 'John' },
        },
        workflowId: mockDbWorkflow._id,
        skipLayoutRendering: false,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.body).to.include('Step content John');
      expect(result.body).to.include('class="layout"');
      expect(result.body).to.include('<html>');
      expect(result.body).to.include('<body>');

      expect(getLayoutUseCase.execute.calledOnce).to.be.true;
      expect(controlValuesRepositoryMock.findOne.calledOnce).to.be.true;
    });

    it('should apply layout rendering when skipLayoutRendering is undefined', async () => {
      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Default Layout Test',
          body: simpleBodyContent,
          layoutId: 'test_layout_id',
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: { name: 'John' },
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.body).to.include('Step content John');
      expect(result.body).to.include('class="layout"');
      expect(result.body).to.include('<html>');
      expect(result.body).to.include('<body>');

      expect(getLayoutUseCase.execute.calledOnce).to.be.true;
      expect(controlValuesRepositoryMock.findOne.calledOnce).to.be.true;
    });

    it('should skip layout rendering with maily content when skipLayoutRendering is true', async () => {
      const mailyStepContent = JSON.stringify({
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            content: [
              {
                type: 'text',
                text: 'Hello {{payload.name}}',
              },
            ],
          },
        ],
      });

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Skip Layout Maily Test',
          body: mailyStepContent,
          layoutId: 'test_layout_id',
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: { name: 'John' },
        },
        workflowId: mockDbWorkflow._id,
        skipLayoutRendering: true,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.body).to.include('Hello John');
      expect(result.body).to.not.include('class="layout"');
      expect(result.body).to.not.include('<html>');

      // Should still process the maily content and apply liquid templating
      expect(result.body).to.not.include('{{payload.name}}');
    });

    it('should properly clean content even when skipping layout rendering', async () => {
      const bodyWithDoctype = '<!DOCTYPE html><p>Content {{payload.name}}</p><!--$-->';

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Clean Content Test',
          body: bodyWithDoctype,
          layoutId: 'test_layout_id',
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: { name: 'John' },
        },
        workflowId: mockDbWorkflow._id,
        skipLayoutRendering: true,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.body).to.include('Content John');
      expect(result.body).to.not.include('<!DOCTYPE');
      expect(result.body).to.not.include('<!--$-->');
      expect(result.body).to.not.include('class="layout"');
    });

    it('should handle skipLayoutRendering when no layout controls exist', async () => {
      controlValuesRepositoryMock.findOne.resolves(null);

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'No Layout Test',
          body: simpleBodyContent,
          layoutId: 'non_existent_layout_id',
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: { name: 'John' },
        },
        workflowId: mockDbWorkflow._id,
        skipLayoutRendering: true,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.body).to.include('Step content John');
      expect(result.body).to.not.include('class="layout"');

      // Should still attempt to fetch layout but gracefully handle null result
      expect(getLayoutUseCase.execute.calledOnce).to.be.true;
      expect(controlValuesRepositoryMock.findOne.calledOnce).to.be.true;
    });
  });

  describe('Layout functionality', () => {
    const simpleBodyContent = '<p>Step content {{payload.name}}</p>';
    const layoutContent = '<html><body><div class="layout">{{content}}</div></body></html>';

    let mockControlValuesEntity: any;
    let mockLayoutDto: any;

    beforeEach(() => {
      // Reset mocks
      mockControlValuesEntity = {
        controls: {
          email: {
            body: layoutContent,
          },
        },
      };

      mockLayoutDto = {
        _id: 'default_layout_id',
        isDefault: true,
      };

      // Set default stub returns
      controlValuesRepositoryMock.findOne.resolves(mockControlValuesEntity as any);
      getLayoutUseCase.execute.resolves(mockLayoutDto as any);
    });

    afterEach(() => {
      sinon.restore();
    });

    describe('when layouts feature flag is enabled', () => {
      it('should render with specified layout when layoutId is provided', async () => {
        const renderCommand: EmailOutputRendererCommand = {
          environmentId: 'fake_env_id',
          organizationId: 'fake_org_id',
          controlValues: {
            subject: 'Layout Test',
            body: simpleBodyContent,
            layoutId: 'test_layout_id',
          },
          fullPayloadForRender: {
            ...mockFullPayload,
            payload: { name: 'John' },
          },
          workflowId: mockDbWorkflow._id,
          stepId: 'fake_step_id',
        };
        getLayoutUseCase.execute.resolves({ _id: 'test_layout_id', isDefault: false } as any);

        const result = await emailOutputRendererUsecase.execute(renderCommand);

        expect(result.body).to.include('class="layout"');
        expect(result.body).to.include('Step content John');
        expect(result.body).to.include('<html>');
        expect(result.body).to.include('<body>');

        // Verify repository was called with correct parameters
        expect(controlValuesRepositoryMock.findOne.calledOnce).to.be.true;
        expect(controlValuesRepositoryMock.findOne.firstCall.args[0]).to.deep.eq({
          _organizationId: 'fake_org_id',
          _environmentId: 'fake_env_id',
          _layoutId: 'test_layout_id',
          level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
        });

        expect(getLayoutUseCase.execute.called).to.be.true;
      });

      it('should not use layout when layoutId is null', async () => {
        const renderCommand: EmailOutputRendererCommand = {
          environmentId: 'fake_env_id',
          organizationId: 'fake_org_id',
          controlValues: {
            subject: 'Layout Test',
            body: simpleBodyContent,
            layoutId: null,
          },
          fullPayloadForRender: {
            ...mockFullPayload,
            payload: { name: 'John' },
          },
          workflowId: mockDbWorkflow._id,
          stepId: 'fake_step_id',
        };

        const result = await emailOutputRendererUsecase.execute(renderCommand);

        expect(result.body).to.not.include('class="layout"');
        expect(result.body).to.include('Step content John');
        expect(result.body).to.not.include('<html>');

        expect(getLayoutUseCase.execute.calledOnce).to.be.false;
        expect(controlValuesRepositoryMock.findOne.calledOnce).to.be.false;
      });

      it('should render without layout when no layout controls are found', async () => {
        controlValuesRepositoryMock.findOne.resolves(null);
        getLayoutUseCase.execute.resolves({ _id: 'non_existent_layout_id' } as any);

        const renderCommand: EmailOutputRendererCommand = {
          environmentId: 'fake_env_id',
          organizationId: 'fake_org_id',
          controlValues: {
            subject: 'Layout Test',
            body: simpleBodyContent,
            layoutId: 'non_existent_layout_id',
          },
          fullPayloadForRender: {
            ...mockFullPayload,
            payload: { name: 'John' },
          },
          workflowId: mockDbWorkflow._id,
          stepId: 'fake_step_id',
        };

        const result = await emailOutputRendererUsecase.execute(renderCommand);

        expect(result.body).to.include('Step content John');
        expect(result.body).to.not.include('class="layout"');
        expect(result.body).to.not.include('<html>');

        // Verify repository was called but returned null
        expect(controlValuesRepositoryMock.findOne.calledOnce).to.be.true;
      });

      it('should clean step content before injecting into layout', async () => {
        const bodyWithDoctype = '<!DOCTYPE html><p>Content</p><!--/$-->';

        const renderCommand: EmailOutputRendererCommand = {
          environmentId: 'fake_env_id',
          organizationId: 'fake_org_id',
          controlValues: {
            subject: 'Layout Test',
            body: bodyWithDoctype,
            layoutId: 'test_layout_id',
          },
          fullPayloadForRender: {
            ...mockFullPayload,
            payload: { name: 'John' },
          },
          workflowId: mockDbWorkflow._id,
          stepId: 'fake_step_id',
        };

        const result = await emailOutputRendererUsecase.execute(renderCommand);

        expect(result.body).to.include('class="layout"');
        expect(result.body).to.include('<p>Content</p>');
        expect(result.body).to.not.include('<!DOCTYPE');
        expect(result.body).to.not.include('<!--/$-->');
      });

      it('should handle layout with liquid variables in layout content', async () => {
        const layoutWithVariables =
          '<html><body><h1>{{payload.title}}</h1><div class="layout">{{content}}</div></body></html>';

        controlValuesRepositoryMock.findOne.resolves({
          _id: 'test_layout_id',
          _organizationId: 'fake_org_id',
          _environmentId: 'fake_env_id',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
          priority: 0,
          controls: {
            email: {
              body: layoutWithVariables,
            },
          },
        });

        const renderCommand: EmailOutputRendererCommand = {
          environmentId: 'fake_env_id',
          organizationId: 'fake_org_id',
          controlValues: {
            subject: 'Layout Test',
            body: simpleBodyContent,
            layoutId: 'test_layout_id',
          },
          fullPayloadForRender: {
            ...mockFullPayload,
            payload: { name: 'John', title: 'Welcome' },
          },
          workflowId: mockDbWorkflow._id,
          stepId: 'fake_step_id',
        };

        const result = await emailOutputRendererUsecase.execute(renderCommand);

        expect(result.body).to.include('<h1>Welcome</h1>');
        expect(result.body).to.include('class="layout"');
        expect(result.body).to.include('Step content John');
      });

      it('should handle maily content in layout', async () => {
        const mailyLayoutContent = JSON.stringify({
          type: 'doc',
          content: [
            {
              type: 'paragraph',
              content: [
                {
                  type: 'text',
                  text: 'Layout: ',
                },
                {
                  type: 'variable',
                  attrs: {
                    id: 'content',
                  },
                },
              ],
            },
          ],
        });

        controlValuesRepositoryMock.findOne.resolves({
          _id: 'test_layout_id',
          _organizationId: 'fake_org_id',
          _environmentId: 'fake_env_id',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
          priority: 0,
          controls: {
            email: {
              body: mailyLayoutContent,
            },
          },
        });

        const mailyStepContent = JSON.stringify({
          type: 'doc',
          content: [
            {
              type: 'paragraph',
              content: [
                {
                  type: 'text',
                  text: 'Hello {{payload.name}}',
                },
              ],
            },
          ],
        });

        const renderCommand: EmailOutputRendererCommand = {
          environmentId: 'fake_env_id',
          organizationId: 'fake_org_id',
          controlValues: {
            subject: 'Layout Test',
            body: mailyStepContent,
            layoutId: 'test_layout_id',
          },
          fullPayloadForRender: {
            ...mockFullPayload,
            payload: { name: 'John' },
          },
          workflowId: mockDbWorkflow._id,
          stepId: 'fake_step_id',
        };

        const result = await emailOutputRendererUsecase.execute(renderCommand);

        expect(result.body).to.include('Layout:');
        expect(result.body).to.include('Hello John');
      });

      it('should handle layout with no email content', async () => {
        controlValuesRepositoryMock.findOne.resolves({
          _id: 'test_layout_id',
          _organizationId: 'fake_org_id',
          _environmentId: 'fake_env_id',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
          priority: 0,
          controls: {
            email: {},
          },
        });

        const renderCommand: EmailOutputRendererCommand = {
          environmentId: 'fake_env_id',
          organizationId: 'fake_org_id',
          controlValues: {
            subject: 'Layout Test',
            body: simpleBodyContent,
            layoutId: 'test_layout_id',
          },
          fullPayloadForRender: {
            ...mockFullPayload,
            payload: { name: 'John' },
          },
          workflowId: mockDbWorkflow._id,
          stepId: 'fake_step_id',
        };

        const result = await emailOutputRendererUsecase.execute(renderCommand);

        // Should render empty layout content
        expect(result.body).to.not.include('Step content John');
        expect(result.body).to.not.include('class="layout"');
      });

      it('should pass correct repository query parameters for specific layout', async () => {
        const renderCommand: EmailOutputRendererCommand = {
          environmentId: 'fake_env_id',
          organizationId: 'fake_org_id',
          controlValues: {
            subject: 'Layout Test',
            body: simpleBodyContent,
            layoutId: 'specific_layout_id',
          },
          fullPayloadForRender: {
            ...mockFullPayload,
            payload: { name: 'John' },
          },
          workflowId: mockDbWorkflow._id,
          stepId: 'fake_step_id',
        };

        getLayoutUseCase.execute.resolves({ _id: 'specific_layout_id', isDefault: false } as any);

        await emailOutputRendererUsecase.execute(renderCommand);

        expect(controlValuesRepositoryMock.findOne.calledOnce).to.be.true;
        expect(controlValuesRepositoryMock.findOne.firstCall.args[0]).to.deep.eq({
          _organizationId: 'fake_org_id',
          _environmentId: 'fake_env_id',
          _layoutId: 'specific_layout_id',
          level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
        });
      });

      it('should not call layout repository when layoutId is null', async () => {
        const renderCommand: EmailOutputRendererCommand = {
          environmentId: 'fake_env_id',
          organizationId: 'fake_org_id',
          controlValues: {
            subject: 'Layout Test',
            body: simpleBodyContent,
            layoutId: null,
          },
          fullPayloadForRender: {
            ...mockFullPayload,
            payload: { name: 'John' },
          },
          workflowId: mockDbWorkflow._id,
          stepId: 'fake_step_id',
        };

        const result = await emailOutputRendererUsecase.execute(renderCommand);

        expect(getLayoutUseCase.execute.called).to.be.false;
        expect(controlValuesRepositoryMock.findOne.called).to.be.false;
        expect(result.body).to.include('Step content John');
        expect(result.body).to.not.include('class="layout"');
      });

      it('should not call layout repository when layoutId is undefined', async () => {
        const renderCommand: EmailOutputRendererCommand = {
          environmentId: 'fake_env_id',
          organizationId: 'fake_org_id',
          controlValues: {
            subject: 'Layout Test',
            body: simpleBodyContent,
          },
          fullPayloadForRender: {
            ...mockFullPayload,
            payload: { name: 'John' },
          },
          workflowId: mockDbWorkflow._id,
          stepId: 'fake_step_id',
        };

        const result = await emailOutputRendererUsecase.execute(renderCommand);

        expect(getLayoutUseCase.execute.called).to.be.false;
        expect(controlValuesRepositoryMock.findOne.called).to.be.false;
        expect(result.body).to.include('Step content John');
        expect(result.body).to.not.include('class="layout"');
      });

      it('should handle layout controls entity with missing email controls', async () => {
        controlValuesRepositoryMock.findOne.resolves({
          _id: 'test_layout_id',
          _organizationId: 'fake_org_id',
          _environmentId: 'fake_env_id',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
          priority: 0,
          controls: {
            // no email property
          },
        });

        const renderCommand: EmailOutputRendererCommand = {
          environmentId: 'fake_env_id',
          organizationId: 'fake_org_id',
          controlValues: {
            subject: 'Layout Test',
            body: simpleBodyContent,
            layoutId: 'test_layout_id',
          },
          fullPayloadForRender: {
            ...mockFullPayload,
            payload: { name: 'John' },
          },
          workflowId: mockDbWorkflow._id,
          stepId: 'fake_step_id',
        };

        const result = await emailOutputRendererUsecase.execute(renderCommand);

        // Should handle missing email controls gracefully
        expect(result.body).to.not.include('Step content John');
        expect(result.body).to.not.include('class="layout"');
      });
    });
  });

  describe('Layout override functionality', () => {
    const simpleBodyContent = '<p>Step content {{payload.name}}</p>';
    const layoutContent = '<html><body><div class="layout">{{content}}</div></body></html>';

    let mockControlValuesEntity: any;
    let mockLayoutDto: any;

    beforeEach(() => {
      mockControlValuesEntity = {
        controls: {
          email: {
            body: layoutContent,
          },
        },
      };

      mockLayoutDto = {
        _id: 'test_layout_id',
        isDefault: false,
        name: 'test_layout_name',
        layoutId: 'test_layout_id',
      };

      controlValuesRepositoryMock.findOne.resolves(mockControlValuesEntity as any);
      getLayoutUseCase.execute.resolves(mockLayoutDto as any);
    });

    it('should use step-level layout override (highest priority)', async () => {
      const mockJob: JobEntity = {
        _id: 'test_job_id',
        _environmentId: 'fake_env_id',
        _organizationId: 'fake_org_id',
        subscriberId: 'fake_subscriber_id',
        providerId: 'fake_provider_id',
        transactionId: 'fake_transaction_id',
        type: StepTypeEnum.EMAIL,
        status: JobStatusEnum.PENDING,
        identifier: 'fake_identifier',
        payload: {},
        overrides: {
          steps: {
            current_step_id: {
              layoutId: 'step_override_layout_id',
            },
          },
          channels: {
            email: {
              layoutId: 'channel_override_layout_id',
            },
          },
          layoutIdentifier: 'deprecated_layout_id',
        },
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        step: {
          _id: 'current_step_id',
          name: 'fake_step_name',
          _templateId: 'fake_template_id',
          active: true,
          replyCallback: {
            active: true,
            url: 'fake_url',
          },
        },
        _notificationId: 'fake_notification_id',
        _subscriberId: 'fake_subscriber_id',
        _userId: 'fake_user_id',
        _templateId: 'fake_template_id',
      };

      jobRepositoryMock.findOne.resolves(mockJob as any);
      createExecutionDetailsMock.execute.resolves();

      // Mock the layout for the step override
      getLayoutUseCase.execute.resolves({
        _id: 'step_override_layout_id',
        isDefault: false,
        name: 'step_override_layout_name',
        layoutId: 'step_override_layout_id',
      } as any);

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Step Override Test',
          body: simpleBodyContent,
          layoutId: 'original_layout_id', // This should be overridden
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: { name: 'John' },
        },
        workflowId: mockDbWorkflow._id,
        jobId: mockJob._id,
        stepId: 'current_step_id',
      };

      await emailOutputRendererUsecase.execute(renderCommand);

      // Verify that getLayoutUseCase was called with the step override layout ID
      expect(getLayoutUseCase.execute.calledOnce).to.be.true;
      const layoutCommand = getLayoutUseCase.execute.firstCall.args[0];
      expect(layoutCommand.layoutIdOrInternalId).to.equal('step_override_layout_id');
    });

    it('should use channel-level layout override when no step override exists', async () => {
      const mockJob: JobEntity = {
        _id: 'test_job_id',
        _environmentId: 'fake_env_id',
        _organizationId: 'fake_org_id',
        subscriberId: 'fake_subscriber_id',
        providerId: 'fake_provider_id',
        transactionId: 'fake_transaction_id',
        type: StepTypeEnum.EMAIL,
        status: JobStatusEnum.PENDING,
        identifier: 'fake_identifier',
        payload: {},
        overrides: {
          channels: {
            email: {
              layoutId: 'channel_override_layout_id',
            },
          },
          layoutIdentifier: 'deprecated_layout_id',
        },
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        step: {
          _id: 'current_step_id',
          name: 'fake_step_name',
          _templateId: 'fake_template_id',
          active: true,
          replyCallback: {
            active: true,
            url: 'fake_url',
          },
        },
        _notificationId: 'fake_notification_id',
        _subscriberId: 'fake_subscriber_id',
        _userId: 'fake_user_id',
        _templateId: 'fake_template_id',
      };

      jobRepositoryMock.findOne.resolves(mockJob as any);
      createExecutionDetailsMock.execute.resolves();

      // Mock the layout for the channel override
      getLayoutUseCase.execute.resolves({
        _id: 'channel_override_layout_id',
        isDefault: false,
        name: 'channel_override_layout_name',
        layoutId: 'channel_override_layout_id',
      } as any);

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Channel Override Test',
          body: simpleBodyContent,
          layoutId: 'original_layout_id', // This should be overridden
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: { name: 'John' },
        },
        workflowId: mockDbWorkflow._id,
        jobId: mockJob._id,
        stepId: 'current_step_id',
      };

      await emailOutputRendererUsecase.execute(renderCommand);

      // Verify that getLayoutUseCase was called with the channel override layout ID
      expect(getLayoutUseCase.execute.calledOnce).to.be.true;
      const layoutCommand = getLayoutUseCase.execute.firstCall.args[0];
      expect(layoutCommand.layoutIdOrInternalId).to.equal('channel_override_layout_id');
    });

    it('should use deprecated layoutIdentifier override when no step or channel override exists', async () => {
      const mockJob: JobEntity = {
        _id: 'test_job_id',
        _environmentId: 'fake_env_id',
        _organizationId: 'fake_org_id',
        subscriberId: 'fake_subscriber_id',
        providerId: 'fake_provider_id',
        transactionId: 'fake_transaction_id',
        type: StepTypeEnum.EMAIL,
        status: JobStatusEnum.PENDING,
        identifier: 'fake_identifier',
        payload: {},
        overrides: {
          layoutIdentifier: 'deprecated_layout_id',
        },
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        step: {
          _id: 'current_step_id',
          name: 'fake_step_name',
          _templateId: 'fake_template_id',
          active: true,
          replyCallback: {
            active: true,
            url: 'fake_url',
          },
        },
        _notificationId: 'fake_notification_id',
        _subscriberId: 'fake_subscriber_id',
        _userId: 'fake_user_id',
        _templateId: 'fake_template_id',
      };

      jobRepositoryMock.findOne.resolves(mockJob as any);
      createExecutionDetailsMock.execute.resolves();

      // Mock the layout for the deprecated override
      getLayoutUseCase.execute.resolves({
        _id: 'deprecated_layout_id',
        isDefault: false,
        name: 'deprecated_layout_name',
        layoutId: 'deprecated_layout_id',
      } as any);

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Deprecated Override Test',
          body: simpleBodyContent,
          layoutId: 'original_layout_id', // This should be overridden
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: { name: 'John' },
        },
        workflowId: mockDbWorkflow._id,
        jobId: mockJob._id,
        stepId: 'current_step_id',
      };

      await emailOutputRendererUsecase.execute(renderCommand);

      // Verify that getLayoutUseCase was called with the deprecated override layout ID
      expect(getLayoutUseCase.execute.calledOnce).to.be.true;
      const layoutCommand = getLayoutUseCase.execute.firstCall.args[0];
      expect(layoutCommand.layoutIdOrInternalId).to.equal('deprecated_layout_id');
    });

    it('should use step configuration layout when no overrides exist', async () => {
      const mockJob: JobEntity = {
        _id: 'test_job_id',
        _environmentId: 'fake_env_id',
        _organizationId: 'fake_org_id',
        subscriberId: 'fake_subscriber_id',
        providerId: 'fake_provider_id',
        transactionId: 'fake_transaction_id',
        type: StepTypeEnum.EMAIL,
        status: JobStatusEnum.PENDING,
        identifier: 'fake_identifier',
        payload: {},
        overrides: {}, // No overrides
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        step: {
          _id: 'current_step_id',
          name: 'fake_step_name',
          _templateId: 'fake_template_id',
          active: true,
          replyCallback: {
            active: true,
            url: 'fake_url',
          },
        },
        _notificationId: 'fake_notification_id',
        _subscriberId: 'fake_subscriber_id',
        _userId: 'fake_user_id',
        _templateId: 'fake_template_id',
      };

      jobRepositoryMock.findOne.resolves(mockJob as any);
      createExecutionDetailsMock.execute.resolves();

      // Mock the layout for the step configuration
      getLayoutUseCase.execute.resolves({
        _id: 'original_layout_id',
        isDefault: false,
        name: 'original_layout_name',
        layoutId: 'original_layout_id',
      } as any);

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'No Override Test',
          body: simpleBodyContent,
          layoutId: 'original_layout_id', // This should be used
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: { name: 'John' },
        },
        workflowId: mockDbWorkflow._id,
        jobId: mockJob._id,
        stepId: 'current_step_id',
      };

      await emailOutputRendererUsecase.execute(renderCommand);

      // Verify that getLayoutUseCase was called with the original layout ID
      expect(getLayoutUseCase.execute.calledOnce).to.be.true;
      const layoutCommand = getLayoutUseCase.execute.firstCall.args[0];
      expect(layoutCommand.layoutIdOrInternalId).to.equal('original_layout_id');
    });

    it('should skip layout when override is explicitly set to null', async () => {
      const mockJob: JobEntity = {
        _id: 'test_job_id',
        _environmentId: 'fake_env_id',
        _organizationId: 'fake_org_id',
        subscriberId: 'fake_subscriber_id',
        providerId: 'fake_provider_id',
        transactionId: 'fake_transaction_id',
        type: StepTypeEnum.EMAIL,
        status: JobStatusEnum.PENDING,
        identifier: 'fake_identifier',
        payload: {},
        overrides: {
          steps: {
            current_step_id: {
              layoutId: null, // Explicitly no layout
            },
          },
        },
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        step: {
          _id: 'current_step_id',
          name: 'fake_step_name',
          _templateId: 'fake_template_id',
          active: true,
          replyCallback: {
            active: true,
            url: 'fake_url',
          },
        },
        _notificationId: 'fake_notification_id',
        _subscriberId: 'fake_subscriber_id',
        _userId: 'fake_user_id',
        _templateId: 'fake_template_id',
      };

      jobRepositoryMock.findOne.resolves(mockJob as any);
      createExecutionDetailsMock.execute.resolves();

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Null Override Test',
          body: simpleBodyContent,
          layoutId: 'original_layout_id', // This should be ignored due to null override
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: { name: 'John' },
        },
        workflowId: mockDbWorkflow._id,
        jobId: mockJob._id,
        stepId: 'current_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      // Verify that no layout was applied
      expect(result.body).to.include('Step content John');
      expect(result.body).to.not.include('class="layout"');
      expect(result.body).to.not.include('<html>');

      // getLayoutUseCase should not be called when override is null
      expect(getLayoutUseCase.execute.called).to.be.false;
      expect(controlValuesRepositoryMock.findOne.called).to.be.false;
    });

    it('should prioritize step override over channel and deprecated overrides', async () => {
      const mockJob: JobEntity = {
        _id: 'test_job_id',
        _environmentId: 'fake_env_id',
        _organizationId: 'fake_org_id',
        subscriberId: 'fake_subscriber_id',
        providerId: 'fake_provider_id',
        transactionId: 'fake_transaction_id',
        type: StepTypeEnum.EMAIL,
        status: JobStatusEnum.PENDING,
        identifier: 'fake_identifier',
        payload: {},
        overrides: {
          steps: {
            current_step_id: {
              layoutId: 'step_priority_layout_id', // Highest priority
            },
          },
          channels: {
            email: {
              layoutId: 'channel_priority_layout_id', // Lower priority
            },
          },
          layoutIdentifier: 'deprecated_priority_layout_id', // Lowest priority
        },
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        step: {
          _id: 'current_step_id',
          name: 'fake_step_name',
          _templateId: 'fake_template_id',
          active: true,
          replyCallback: {
            active: true,
            url: 'fake_url',
          },
        },
        _notificationId: 'fake_notification_id',
        _subscriberId: 'fake_subscriber_id',
        _userId: 'fake_user_id',
        _templateId: 'fake_template_id',
      };

      jobRepositoryMock.findOne.resolves(mockJob as any);
      createExecutionDetailsMock.execute.resolves();

      // Mock the layout for the step override (highest priority)
      getLayoutUseCase.execute.resolves({
        _id: 'step_priority_layout_id',
        isDefault: false,
        name: 'step_priority_layout_name',
        layoutId: 'step_priority_layout_id',
      } as any);

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Priority Test',
          body: simpleBodyContent,
          layoutId: 'original_layout_id',
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: { name: 'John' },
        },
        workflowId: mockDbWorkflow._id,
        jobId: mockJob._id,
        stepId: 'current_step_id',
      };

      await emailOutputRendererUsecase.execute(renderCommand);

      // Verify that the step override was used (highest priority)
      expect(getLayoutUseCase.execute.calledOnce).to.be.true;
      const layoutCommand = getLayoutUseCase.execute.firstCall.args[0];
      expect(layoutCommand.layoutIdOrInternalId).to.equal('step_priority_layout_id');
    });

    it('should handle step override by step internal ID when step._id differs from stepId', async () => {
      const mockJob: JobEntity = {
        _id: 'test_job_id',
        _environmentId: 'fake_env_id',
        _organizationId: 'fake_org_id',
        subscriberId: 'fake_subscriber_id',
        providerId: 'fake_provider_id',
        transactionId: 'fake_transaction_id',
        type: StepTypeEnum.EMAIL,
        status: JobStatusEnum.PENDING,
        identifier: 'fake_identifier',
        payload: {},
        overrides: {
          steps: {
            different_step_id: {
              layoutId: 'step_id_override_layout_id',
            },
          },
        },
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        step: {
          _id: 'step_internal_id', // Different from stepId
          name: 'fake_step_name',
          _templateId: 'fake_template_id',
          active: true,
          replyCallback: {
            active: true,
            url: 'fake_url',
          },
        },
        _notificationId: 'fake_notification_id',
        _subscriberId: 'fake_subscriber_id',
        _userId: 'fake_user_id',
        _templateId: 'fake_template_id',
      };

      jobRepositoryMock.findOne.resolves(mockJob as any);
      createExecutionDetailsMock.execute.resolves();

      // Mock the layout for the stepId override
      getLayoutUseCase.execute.resolves({
        _id: 'step_id_override_layout_id',
        isDefault: false,
        name: 'step_id_override_layout_name',
        layoutId: 'step_id_override_layout_id',
      } as any);

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Step ID Override Test',
          body: simpleBodyContent,
          layoutId: 'original_layout_id',
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: { name: 'John' },
        },
        workflowId: mockDbWorkflow._id,
        jobId: mockJob._id,
        stepId: 'different_step_id', // This should be used for override lookup
      };

      await emailOutputRendererUsecase.execute(renderCommand);

      // Verify that the stepId override was used
      expect(getLayoutUseCase.execute.calledOnce).to.be.true;
      const layoutCommand = getLayoutUseCase.execute.firstCall.args[0];
      expect(layoutCommand.layoutIdOrInternalId).to.equal('step_id_override_layout_id');
    });
  });

  describe('Novu branding functionality', () => {
    const simpleHtmlBody = '<p>Test email content</p>';

    it('should add Novu branding when removeNovuBranding is false', async () => {
      getOrganizationSettingsMock.execute.resolves({
        removeNovuBranding: false,
        defaultLocale: 'en_US',
      });

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Branding Test',
          body: simpleHtmlBody,
        },
        fullPayloadForRender: mockFullPayload,
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.body).to.include('Test email content');
      expect(result.body).to.include('data-novu-branding');
      expect(result.body.length).to.be.greaterThan(simpleHtmlBody.length);
    });

    it('should not add Novu branding when removeNovuBranding is true', async () => {
      getOrganizationSettingsMock.execute.resolves({
        removeNovuBranding: true,
        defaultLocale: 'en_US',
      });

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Branding Test',
          body: simpleHtmlBody,
        },
        fullPayloadForRender: mockFullPayload,
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.body).to.equal(simpleHtmlBody);
    });

    it('should properly insert branding into HTML with body tag', async () => {
      getOrganizationSettingsMock.execute.resolves({
        removeNovuBranding: false,
        defaultLocale: 'en_US',
      });

      const htmlWithBodyTag = '<html><body><p>Content</p></body></html>';
      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Body Tag Test',
          body: htmlWithBodyTag,
        },
        fullPayloadForRender: mockFullPayload,
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.body).to.include('<p>Content</p>');
      expect(result.body).to.include('</body>');
      expect(result.body).to.include('data-novu-branding');
      // Branding should be inserted before the closing body tag
      const brandingIndex = result.body.indexOf('data-novu-branding');
      const bodyCloseIndex = result.body.indexOf('</body>');
      expect(brandingIndex).to.be.lessThan(bodyCloseIndex);
    });
  });

  describe('Gmail clipping prevention', () => {
    beforeEach(() => {
      getOrganizationSettingsMock.execute.resolves({
        removeNovuBranding: false,
        defaultLocale: 'en_US',
      });
    });

    it('should convert paragraphs with only whitespace to empty paragraphs', async () => {
      const mockTipTapNode: MailyJSONContent = {
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            content: [
              {
                type: 'text',
                text: 'Hello World',
              },
            ],
          },
          {
            type: 'paragraph',
            // Empty paragraph that Maily renderer will add space to
          },
          {
            type: 'paragraph',
            content: [
              {
                type: 'text',
                text: 'End content',
              },
            ],
          },
        ],
      };

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Gmail Clipping Test',
          body: JSON.stringify(mockTipTapNode),
        },
        fullPayloadForRender: mockFullPayload,
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.body).to.include('Hello World');
      expect(result.body).to.include('End content');

      // Should not contain paragraphs with only basic whitespace
      expect(result.body).to.not.match(/<p[^>]*>\s+<\/p>/);

      // Should contain empty paragraphs instead
      expect(result.body).to.match(/<p[^>]*><\/p>/);
    });

    it('should preserve paragraph styling when cleaning whitespace', async () => {
      // Simulate HTML that would be generated by Maily with styled empty paragraphs
      const htmlWithWhitespaceParas = `<p style="margin:0 0 20px 0">Content before</p><p style="margin:0 0 20px 0;color:#374151"> </p><p style="margin:0 0 20px 0">Content after</p>`;

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Styling Test',
          body: htmlWithWhitespaceParas,
        },
        fullPayloadForRender: mockFullPayload,
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.body).to.include('Content before');
      expect(result.body).to.include('Content after');

      // Should preserve styles but remove whitespace content
      expect(result.body).to.include('style="margin:0 0 20px 0;color:#374151"></p>');

      // Should not contain basic whitespace content
      expect(result.body).to.not.include('> </p>');
    });

    it('should not modify paragraphs with actual text content', async () => {
      const htmlWithMixedContent = `<p>This has real content</p><p> </p><p>This also has real content with spaces</p><p>More real content</p>`;

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Mixed Content Test',
          body: htmlWithMixedContent,
        },
        fullPayloadForRender: mockFullPayload,
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      // Should preserve all actual text content
      expect(result.body).to.include('This has real content');
      expect(result.body).to.include('This also has real content with spaces');
      expect(result.body).to.include('More real content');

      // Should have converted whitespace-only paragraphs to empty ones
      expect(result.body).to.not.include('> </p>');
      expect(result.body).to.include('<p></p>');
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - setupTranslationMocks(moduleRef: sinon.SinonStubbedInstance<ModuleRef>)
Asignaciones con arrow functions encontradas (posibles funciones):
 - translateStub(sinon.stub(Translate.prototype, 'execute').callsFake(async (command: any))
 - get(sinon.stub().callsFake((token))
 - emailOutputRendererUsecase(new EmailOutputRendererUsecase(
      getOrganizationSettingsMock as any,
      moduleRef as any,
  ...)
 - mockDbWorkflow({
    _id: 'fake_workflow_id',
    _organizationId: 'fake_org_id',
    _environmentId: 'fake_env_id'...)
 - result(await emailOutputRendererUsecase.execute(renderCommand);

      expect(result).to.deep.equal({
     ...)
 - result(await emailOutputRendererUsecase.execute(renderCommand);

      expect(result).to.have.property('sub...)
 - result(await emailOutputRendererUsecase.execute(renderCommand);

      expect(result).to.have.property('sub...)
 - result(await emailOutputRendererUsecase.execute(renderCommand);

      expect(result).to.have.property('sub...)
 - result(await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.subject).to.equal('Ord...)
 - resultWithPartialData(await emailOutputRendererUsecase.execute(renderCommandWithPartialData);

      expect(resultWithPart...)
 - MailyJSONContent({
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            con...)
 - result(await emailOutputRendererUsecase.execute(renderCommand);

          expect(result.body).to.include('...)
 - MailyJSONContent({
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            con...)
 - result(await emailOutputRendererUsecase.execute(renderCommand);

          expect(result.body).to.include('...)
 - result(await emailOutputRendererUsecase.execute(renderCommand);
      expect(result.body).to.not.include('S...)
 - matches(result.body.match(/This is an author:/g);
      expect(matches).to.have.length(2);
    });

    it('...)
 - result(await emailOutputRendererUsecase.execute(renderCommand);
      expect(result.body).to.include('John'...)
 - result(await emailOutputRendererUsecase.execute(renderCommand);

      // Should only create 2 items as ite...)
 - matches(result.body.match(/Item item/g);
      expect(matches).to.have.length(3);
    });
  });

  describe(...)
 - target("_blank"');
      expect(result.body).to.include('>here</a>');
    });

    it('should handle image ...)
 - src("https://example.com/image.jpg"');
    });

    it('should handle marks attrs href', async ())
 - href("https://example.com"');
    });
  });

  describe('enhanceContentVariable functionality', ())
 - result(await emailOutputRendererUsecase.execute(renderCommand);

      // The content variable should be pr...)
 - result(await emailOutputRendererUsecase.execute(renderCommand);

      // Regular variables should be proce...)
 - class("layout">{{content}}</div></body></html>';

    let mockControlValuesEntity: any;
    let mockLayout...)
 - mockLayoutDto({
        _id: 'test_layout_id',
        isDefault: false,
        name: 'test_layout_name',
       ...)
 - class("layout"');
      expect(result.body).to.not.include('<html>');
      expect(result.body).to.not.inc...)
 - EmailOutputRendererCommand({
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues...)
 - class("layout"');
      expect(result.body).to.include('<html>');
      expect(result.body).to.include('<b...)
 - class("layout"');
      expect(result.body).to.include('<html>');
      expect(result.body).to.include('<b...)
 - class("layout"');
      expect(result.body).to.not.include('<html>');

      // Should still process the m...)
 - class("layout"');
    });

    it('should handle skipLayoutRendering when no layout controls exist', async...)
 - class("layout"');

      // Should still attempt to fetch layout but gracefully handle null result
      e...)
 - class("layout">{{content}}</div></body></html>';

    let mockControlValuesEntity: any;
    let mockLayout...)
 - mockLayoutDto({
        _id: 'default_layout_id',
        isDefault: true,
      };

      // Set default stub ret...)
 - class("layout"');
        expect(result.body).to.include('Step content John');
        expect(result.body)...)
 - class("layout"');
        expect(result.body).to.include('Step content John');
        expect(result.body)...)
 - class("layout"');
        expect(result.body).to.not.include('<html>');

        // Verify repository was ...)
 - class("layout"');
        expect(result.body).to.include('<p>Content</p>');
        expect(result.body).to...)
 - class("layout"');
        expect(result.body).to.include('Step content John');
      });

      it('should...)
 - result(await emailOutputRendererUsecase.execute(renderCommand);

        expect(result.body).to.include('La...)
 - class("layout"');
      });

      it('should pass correct repository query parameters for specific layout...)
 - EmailOutputRendererCommand({
          environmentId: 'fake_env_id',
          organizationId: 'fake_org_id',
          control...)
 - class("layout"');
      });

      it('should not call layout repository when layoutId is undefined', asyn...)
 - class("layout"');
      });

      it('should handle layout controls entity with missing email controls', ...)
 - class("layout"');
      });
    });
  });

  describe('Layout override functionality', ())
 - class("layout">{{content}}</div></body></html>';

    let mockControlValuesEntity: any;
    let mockLayout...)
 - mockLayoutDto({
        _id: 'test_layout_id',
        isDefault: false,
        name: 'test_layout_name',
       ...)
 - layoutCommand(getLayoutUseCase.execute.firstCall.args[0];
      expect(layoutCommand.layoutIdOrInternalId).to.equa...)
 - layoutCommand(getLayoutUseCase.execute.firstCall.args[0];
      expect(layoutCommand.layoutIdOrInternalId).to.equa...)
 - layoutCommand(getLayoutUseCase.execute.firstCall.args[0];
      expect(layoutCommand.layoutIdOrInternalId).to.equa...)
 - layoutCommand(getLayoutUseCase.execute.firstCall.args[0];
      expect(layoutCommand.layoutIdOrInternalId).to.equa...)
 - class("layout"');
      expect(result.body).to.not.include('<html>');

      // getLayoutUseCase should no...)
 - layoutCommand(getLayoutUseCase.execute.firstCall.args[0];
      expect(layoutCommand.layoutIdOrInternalId).to.equa...)
 - layoutCommand(getLayoutUseCase.execute.firstCall.args[0];
      expect(layoutCommand.layoutIdOrInternalId).to.equa...)
 - simpleHtmlBody('<p>Test email content</p>';

    it('should add Novu branding when removeNovuBranding is false', as...)
 - result(await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.body).to.include('Test...)
 - result(await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.body).to.equal(simpleH...)
 - bodyCloseIndex(result.body.indexOf('</body>');
      expect(brandingIndex).to.be.lessThan(bodyCloseIndex);
    });
...)
 - result(await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.body).to.include('Hell...)
 - style("margin:0 0 20px 0;color:#374151"></p>');

      // Should not contain basic whitespace content
    ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/output-renderers/email-output-renderer.usecase.ts
TamaÃ±o: 25629 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { JSONContent as MailyJSONContent, render as mailyRender } from '@maily-to/render';
import { Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import {
  CreateExecutionDetails,
  CreateExecutionDetailsCommand,
  DetailEnum,
  EmailControlType,
  InstrumentUsecase,
  LayoutControlType,
  PinoLogger,
  sanitizeHTML,
} from '@novu/application-generic';
import {
  ControlValuesEntity,
  ControlValuesRepository,
  JobEntity,
  JobRepository,
  LocalizationResourceEnum,
  OrganizationEntity,
} from '@novu/dal';
import { createLiquidEngine } from '@novu/framework/internal';
import {
  ControlValuesLevelEnum,
  EmailRenderOutput,
  ExecutionDetailsSourceEnum,
  ExecutionDetailsStatusEnum,
  LAYOUT_CONTENT_VARIABLE,
  LAYOUT_PREVIEW_EMAIL_STEP,
} from '@novu/shared';
import { Liquid } from 'liquidjs';
import { GetLayoutCommand, GetLayoutUseCase } from '../../../layouts-v2/usecases/get-layout';
import { GetOrganizationSettingsCommand } from '../../../organization/usecases/get-organization-settings/get-organization-settings.command';
import { GetOrganizationSettings } from '../../../organization/usecases/get-organization-settings/get-organization-settings.usecase';
import { MailyAttrsEnum } from '../../../shared/helpers/maily.types';
import {
  hasShow,
  isButtonNode,
  isImageNode,
  isLinkNode,
  isRepeatNode,
  isVariableNode,
  replaceMailyNodesByCondition,
  wrapMailyInLiquid,
} from '../../../shared/helpers/maily-utils';
import { removeBrandingFromHtml } from '../../../shared/utils/html';
import { BaseTranslationRendererUsecase } from './base-translation-renderer.usecase';
import { NOVU_BRANDING_HTML } from './novu-branding-html';
import { FullPayloadForRender, RenderCommand } from './render-command';

type MailyJSONMarks = NonNullable<MailyJSONContent['marks']>[number];

export class EmailOutputRendererCommand extends RenderCommand {
  environmentId: string;
  organizationId: string;
  workflowId?: string;
  locale?: string;
  skipLayoutRendering?: boolean;
  jobId?: string;
  stepId: string;
  layoutId?: string;
}

function isJsonString(str: string): boolean {
  try {
    JSON.parse(str);
  } catch (e) {
    return false;
  }

  return true;
}

@Injectable()
export class EmailOutputRendererUsecase extends BaseTranslationRendererUsecase {
  private readonly liquidEngine: Liquid;

  constructor(
    private getOrganizationSettings: GetOrganizationSettings,
    protected moduleRef: ModuleRef,
    protected logger: PinoLogger,
    private controlValuesRepository: ControlValuesRepository,
    private getLayoutUseCase: GetLayoutUseCase,
    private jobRepository: JobRepository,
    private createExecutionDetails: CreateExecutionDetails
  ) {
    super(moduleRef, logger);
    this.liquidEngine = createLiquidEngine();
  }

  @InstrumentUsecase()
  async execute(renderCommand: EmailOutputRendererCommand): Promise<EmailRenderOutput> {
    const {
      body,
      subject: controlSubject,
      disableOutputSanitization,
      layoutId: stepLayoutId,
    } = renderCommand.controlValues as EmailControlType;

    if (!body || typeof body !== 'string') {
      /**
       * Force type mapping in case undefined control.
       * This passes responsibility to framework to throw type validation exceptions
       * rather than handling invalid types here.
       */

      return {
        subject: controlSubject as string,
        body: body as string,
      };
    }

    const {
      fullPayloadForRender,
      environmentId,
      organizationId,
      workflowId,
      locale,
      skipLayoutRendering,
      jobId,
      stepId,
      layoutId: layoutIdForPreview,
      organization,
    } = renderCommand;

    // Step 1: Apply translations to subject (already liquid-interpolated)
    const translatedSubject = await this.processSubjectTranslations(
      controlSubject as string,
      fullPayloadForRender,
      environmentId,
      organizationId,
      workflowId,
      locale,
      organization
    );

    // Step 2: Process body content (with translations applied before rendering)
    const renderedHtml = await this.renderWithLayout({
      body,
      stepLayoutId,
      payload: fullPayloadForRender,
      environmentId,
      organizationId,
      workflowId,
      locale,
      skipLayoutRendering,
      jobId,
      stepId,
      organization,
      layoutIdForPreview,
    });

    // Step 3: Add Novu branding
    const htmlWithBranding = await this.appendNovuBranding(renderedHtml, organizationId);
    const cleanedHtml = this.cleanupRenderedHtml(htmlWithBranding);

    // Step 4: Sanitize output if needed
    if (disableOutputSanitization) {
      return { subject: translatedSubject, body: cleanedHtml };
    }

    const sanitizedSubject = sanitizeHTML(translatedSubject);
    const sanitizedBody = sanitizeHTML(cleanedHtml);

    return {
      subject: sanitizedSubject,
      body: sanitizedBody,
    };
  }

  private async getOverrideLayoutId({
    job,
    stepId,
  }: {
    job: JobEntity;
    stepId: string;
  }): Promise<string | null | undefined> {
    const { overrides, step } = job;
    let layoutIdentifier: string | null | undefined;

    // Step 1: Check step-level override (highest priority)
    const id = overrides?.steps?.[step._id ?? ''] ? step._id : stepId;
    const stepOverrides = overrides?.steps?.[id ?? ''];
    if (stepOverrides?.layoutId !== undefined) {
      layoutIdentifier = stepOverrides.layoutId;
    }
    // Step 2: Check channel-level override for email
    else if (overrides?.channels?.email?.layoutId !== undefined) {
      layoutIdentifier = overrides.channels.email.layoutId;
    }
    // Step 3: Check deprecated layoutIdentifier (backward compatibility)
    else if (overrides?.layoutIdentifier) {
      layoutIdentifier = overrides.layoutIdentifier;
    }

    // If no override is specified, return undefined (use step configuration)
    if (layoutIdentifier === undefined) {
      return undefined;
    }

    // If explicitly set to null, return null (no layout)
    if (layoutIdentifier === null) {
      return null;
    }

    return layoutIdentifier;
  }

  private async renderWithLayout({
    body,
    stepLayoutId,
    payload,
    environmentId,
    organizationId,
    workflowId,
    locale,
    skipLayoutRendering,
    jobId,
    stepId,
    organization,
    layoutIdForPreview,
  }: {
    body: string;
    stepLayoutId?: string | null;
    payload: FullPayloadForRender;
    environmentId: string;
    organizationId: string;
    workflowId?: string;
    locale?: string;
    skipLayoutRendering?: boolean;
    jobId?: string;
    stepId: string;
    organization?: OrganizationEntity;
    layoutIdForPreview?: string;
  }): Promise<string> {
    let job: JobEntity | null = null;
    let overrideLayoutId: string | null | undefined;
    if (jobId) {
      job = await this.jobRepository.findOne({
        _id: jobId,
        _environmentId: environmentId,
      });
      if (job) {
        overrideLayoutId = await this.getOverrideLayoutId({ job, stepId });
      }
    }

    const overriddenStepLayoutId = overrideLayoutId || (overrideLayoutId === null ? null : stepLayoutId);

    let layoutControlsEntity: ControlValuesEntity | null = null;
    // if the step control values have a layoutId then find layout controls entity
    if (overriddenStepLayoutId) {
      try {
        const layout = await this.getLayoutUseCase.execute(
          GetLayoutCommand.create({
            layoutIdOrInternalId: overriddenStepLayoutId,
            environmentId,
            organizationId,
            skipAdditionalFields: true,
          })
        );
        layoutControlsEntity = await this.controlValuesRepository.findOne({
          _organizationId: organizationId,
          _environmentId: environmentId,
          _layoutId: layout._id,
          level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
        });
        if (job) {
          this.createExecutionDetails
            .execute(
              CreateExecutionDetailsCommand.create({
                ...CreateExecutionDetailsCommand.getDetailsFromJob(job),
                detail: DetailEnum.LAYOUT_SELECTED,
                source: ExecutionDetailsSourceEnum.INTERNAL,
                status: ExecutionDetailsStatusEnum.PENDING,
                isTest: false,
                isRetry: false,
                raw: JSON.stringify({ name: layout.name, layoutId: layout.layoutId }),
              })
            )
            .catch((promiseError) => {
              this.logger.error({ error: promiseError }, 'Failed to create execution details');
            });
        }
      } catch (error) {
        if (job) {
          this.createExecutionDetails
            .execute(
              CreateExecutionDetailsCommand.create({
                ...CreateExecutionDetailsCommand.getDetailsFromJob(job),
                detail: DetailEnum.LAYOUT_NOT_FOUND,
                source: ExecutionDetailsSourceEnum.INTERNAL,
                status: ExecutionDetailsStatusEnum.FAILED,
                isTest: false,
                isRetry: false,
                raw: JSON.stringify({
                  layoutId: overriddenStepLayoutId,
                  error: error.message,
                }),
              })
            )
            .catch((promiseError) => {
              this.logger.error({ error: promiseError }, 'Failed to create execution details');
            });
        }
        throw error;
      }
    }

    const isLayoutRendering = stepId === LAYOUT_PREVIEW_EMAIL_STEP && !!layoutIdForPreview;
    const stepBodyHtml = await this.processBodyContent({
      body,
      payload,
      environmentId,
      organizationId,
      resourceId: isLayoutRendering ? layoutIdForPreview : workflowId,
      resourceType: isLayoutRendering ? LocalizationResourceEnum.LAYOUT : LocalizationResourceEnum.WORKFLOW,
      locale,
      noHtmlWrappingTags: !!layoutControlsEntity,
      organization,
    });

    const cleanedStepBodyHtml = stepBodyHtml
      .replace(/<!DOCTYPE.*?>/g, '')
      .replace(/<!--\$-->/g, '')
      .replace(/<!--\/\$-->/g, '')
      .replace(/<!--[\s\S]*?-->/g, '');

    if (!layoutControlsEntity || skipLayoutRendering || isLayoutRendering) {
      return cleanedStepBodyHtml;
    }

    const layoutControlValues = layoutControlsEntity.controls as LayoutControlType;

    return this.processBodyContent({
      body: layoutControlValues.email?.body ?? '',
      payload: {
        ...payload,
        [LAYOUT_CONTENT_VARIABLE]: removeBrandingFromHtml(cleanedStepBodyHtml.replace(/\n/g, '')),
      },
      environmentId,
      organizationId,
      resourceId: overriddenStepLayoutId ?? undefined,
      resourceType: LocalizationResourceEnum.LAYOUT,
      locale,
    });
  }

  private enhanceContentVariable(body: string) {
    return JSON.stringify(
      replaceMailyNodesByCondition(
        body,
        (node) => node.type === 'variable' && node.attrs?.id === LAYOUT_CONTENT_VARIABLE,
        (node) =>
          ({
            ...node,
            attrs: {
              ...node.attrs,
              shouldDangerouslySetInnerHTML: true,
            },
          }) satisfies MailyJSONContent
      )
    );
  }

  private async processBodyContent({
    body,
    payload,
    environmentId,
    organizationId,
    resourceId,
    resourceType,
    locale,
    noHtmlWrappingTags,
    organization,
  }: {
    body: string;
    payload: FullPayloadForRender;
    environmentId: string;
    organizationId: string;
    resourceId?: string;
    resourceType?: LocalizationResourceEnum;
    locale?: string;
    noHtmlWrappingTags?: boolean;
    organization?: OrganizationEntity;
  }): Promise<string> {
    if (typeof body === 'object' || (typeof body === 'string' && isJsonString(body))) {
      const escapedPayloadForJson = this.deepEscapePayloadStrings(payload);
      const liquifiedMaily = wrapMailyInLiquid(this.enhanceContentVariable(body));
      const transformedMaily = await this.transformMailyContent(liquifiedMaily, escapedPayloadForJson);
      const translatedMaily = await this.processMailyTranslations({
        mailyContent: transformedMaily,
        variables: escapedPayloadForJson,
        environmentId,
        organizationId,
        resourceId,
        resourceType,
        locale,
        organization,
      });
      const parsedMaily = await this.parseMailyContentByLiquid(translatedMaily, escapedPayloadForJson);

      return await mailyRender(parsedMaily, { noHtmlWrappingTags });
    } else {
      // For simple text body, apply translations directly
      const processedHtml = await this.processTextTranslations({
        text: body,
        variables: payload,
        environmentId,
        organizationId,
        resourceId,
        resourceType,
        locale,
        organization,
      });

      return processedHtml;
    }
  }

  private async processSubjectTranslations(
    subject: string,
    variables: FullPayloadForRender,
    environmentId: string,
    organizationId: string,
    workflowId?: string,
    locale?: string,
    organization?: OrganizationEntity
  ): Promise<string> {
    return this.processStringTranslations({
      content: subject,
      variables,
      environmentId,
      organizationId,
      resourceId: workflowId,
      resourceType: LocalizationResourceEnum.WORKFLOW,
      locale,
      organization,
    });
  }

  private async processMailyTranslations({
    mailyContent,
    variables,
    environmentId,
    organizationId,
    resourceId,
    resourceType,
    locale,
    organization,
  }: {
    mailyContent: MailyJSONContent;
    variables: FullPayloadForRender;
    environmentId: string;
    organizationId: string;
    resourceId?: string;
    resourceType?: LocalizationResourceEnum;
    locale?: string;
    organization?: OrganizationEntity;
  }): Promise<MailyJSONContent> {
    const contentString = JSON.stringify(mailyContent);
    const translatedContent = await this.processStringTranslations({
      content: contentString,
      variables,
      environmentId,
      organizationId,
      resourceId,
      resourceType,
      locale,
      organization,
    });

    return JSON.parse(translatedContent);
  }

  private async processTextTranslations({
    text,
    variables,
    environmentId,
    organizationId,
    resourceId,
    resourceType,
    locale,
    organization,
  }: {
    text: string;
    variables: FullPayloadForRender;
    environmentId: string;
    organizationId: string;
    resourceId?: string;
    resourceType?: LocalizationResourceEnum;
    locale?: string;
    organization?: OrganizationEntity;
  }): Promise<string> {
    const translatedText = await this.processStringTranslations({
      content: text,
      variables,
      environmentId,
      organizationId,
      resourceId,
      resourceType,
      locale,
      organization,
    });

    return await this.liquidEngine.parseAndRender(translatedText, variables);
  }

  private async parseMailyContentByLiquid(
    mailyContent: MailyJSONContent,
    variables: FullPayloadForRender
  ): Promise<MailyJSONContent> {
    const parsedString = await this.liquidEngine.parseAndRender(JSON.stringify(mailyContent), variables);

    return JSON.parse(parsedString);
  }

  private async transformMailyContent(
    node: MailyJSONContent,
    variables: FullPayloadForRender,
    parent?: MailyJSONContent
  ) {
    const queue: Array<{ node: MailyJSONContent; parent?: MailyJSONContent }> = [{ node, parent }];

    while (queue.length > 0) {
      const current = queue.shift()!;

      if (hasShow(current.node)) {
        const shouldShow = await this.handleShowNode(current.node, variables, current.parent);

        if (!shouldShow) {
          continue;
        }
      }

      if (isRepeatNode(current.node)) {
        await this.handleEachNode(current.node, variables, current.parent);
      }

      if (isVariableNode(current.node)) {
        this.processVariableNodeTypes(current.node);
      }

      if (current.node.content) {
        for (const childNode of current.node.content) {
          queue.push({ node: childNode, parent: current.node });
        }
      }
    }

    return node;
  }

  private async handleShowNode(
    node: MailyJSONContent & { attrs: { [MailyAttrsEnum.SHOW_IF_KEY]: string } },
    variables: FullPayloadForRender,
    parent?: MailyJSONContent
  ): Promise<boolean> {
    const shouldShow = await this.evaluateShowCondition(variables, node);
    if (!shouldShow && parent?.content) {
      parent.content = parent.content.filter((pNode) => pNode !== node);
    }

    delete (node.attrs as Record<string, string>)[MailyAttrsEnum.SHOW_IF_KEY];

    return shouldShow;
  }

  private async handleEachNode(
    node: MailyJSONContent & { attrs: { [MailyAttrsEnum.EACH_KEY]: string } },
    variables: FullPayloadForRender,
    parent?: MailyJSONContent
  ): Promise<void> {
    const newContent = await this.multiplyForEachNode(node, variables);

    if (parent?.content) {
      const nodeIndex = parent.content.indexOf(node);
      parent.content = [...parent.content.slice(0, nodeIndex), ...newContent, ...parent.content.slice(nodeIndex + 1)];
    } else {
      node.content = newContent;
    }
  }

  private async evaluateShowCondition(
    variables: FullPayloadForRender,
    node: MailyJSONContent & { attrs: { [MailyAttrsEnum.SHOW_IF_KEY]: string } }
  ): Promise<boolean> {
    const { [MailyAttrsEnum.SHOW_IF_KEY]: showIfKey } = node.attrs;
    const parsedShowIfValue = await this.liquidEngine.parseAndRender(showIfKey, variables);

    return this.stringToBoolean(parsedShowIfValue);
  }

  private processVariableNodeTypes(node: MailyJSONContent) {
    node.type = 'text'; // set 'variable' to 'text' to for Liquid to recognize it
    node.text = node.attrs?.id || '';
  }

  /**
   * For 'each' node, multiply the content by the number of items in the iterable array
   * and add indexes to the placeholders. If iterations attribute is set, limits the number
   * of iterations to that value, otherwise renders all items.
   *
   * @example
   * node:
   * {
   *   type: 'each',
   *   attrs: {
   *     each: '{{ payload.comments }}',
   *     iterations: 2 // Optional - limits to first 2 items only
   *   },
   *   content: [
   *     { type: 'variable', text: '{{ payload.comments.author }}' }
   *   ]
   * }
   *
   * variables:
   * { payload: { comments: [{ author: 'John Doe' }, { author: 'Jane Doe' }] } }
   *
   * result:
   * [
   *   { type: 'text', text: '{{ payload.comments[0].author }}' },
   *   { type: 'text', text: '{{ payload.comments[1].author }}' }
   * ]
   *
   */
  private async multiplyForEachNode(
    node: MailyJSONContent & { attrs: { [MailyAttrsEnum.EACH_KEY]: string } },
    variables: FullPayloadForRender
  ): Promise<MailyJSONContent[]> {
    const iterablePath = node.attrs[MailyAttrsEnum.EACH_KEY];
    const iterations = node.attrs[MailyAttrsEnum.ITERATIONS_KEY];
    const forEachNodes = node.content || [];
    const iterableArray = await this.getIterableArray(iterablePath, variables);
    const limitedIterableArray = iterations ? iterableArray.slice(0, iterations) : iterableArray;

    return limitedIterableArray.flatMap((_, index) => this.processForEachNodes(forEachNodes, iterablePath, index));
  }

  private async getIterableArray(iterablePath: string, variables: FullPayloadForRender): Promise<unknown[]> {
    const iterableArrayString = await this.liquidEngine.parseAndRender(iterablePath, variables);

    try {
      const parsedArray = JSON.parse(iterableArrayString.replace(/'/g, '"'));

      if (!Array.isArray(parsedArray)) {
        throw new Error(`Iterable "${iterablePath}" is not an array`);
      }

      return parsedArray;
    } catch (error) {
      throw new Error(`Failed to parse iterable value for "${iterablePath}": ${error.message}`);
    }
  }

  private processForEachNodes(
    nodes: MailyJSONContent[],
    iterablePath: string,
    index: number
  ): Array<MailyJSONContent | MailyJSONMarks> {
    return nodes.map((node) => {
      const processedNode = { ...node };

      if (isVariableNode(processedNode)) {
        this.processVariableNodeTypes(processedNode);
        if (processedNode.text) {
          processedNode.text = this.addIndexToLiquidExpression(processedNode.text, iterablePath, index);
        }

        return processedNode;
      }

      if (isButtonNode(processedNode)) {
        if (processedNode.attrs?.text) {
          processedNode.attrs.text = this.addIndexToLiquidExpression(processedNode.attrs.text, iterablePath, index);
        }

        if (processedNode.attrs?.url) {
          processedNode.attrs.url = this.addIndexToLiquidExpression(processedNode.attrs.url, iterablePath, index);
        }

        return processedNode;
      }

      if (isImageNode(processedNode)) {
        if (processedNode.attrs?.src) {
          processedNode.attrs.src = this.addIndexToLiquidExpression(processedNode.attrs.src, iterablePath, index);
        }

        if (processedNode.attrs?.externalLink) {
          processedNode.attrs.externalLink = this.addIndexToLiquidExpression(
            processedNode.attrs.externalLink,
            iterablePath,
            index
          );
        }

        return processedNode;
      }

      if (isLinkNode(processedNode)) {
        if (processedNode.attrs?.href) {
          processedNode.attrs.href = this.addIndexToLiquidExpression(processedNode.attrs.href, iterablePath, index);
        }

        return processedNode;
      }

      if (processedNode.content?.length) {
        processedNode.content = this.processForEachNodes(processedNode.content, iterablePath, index);
      }

      if (processedNode.marks?.length) {
        processedNode.marks = this.processForEachNodes(
          processedNode.marks,
          iterablePath,
          index
        ) as Array<MailyJSONMarks>;
      }

      return processedNode;
    });
  }

  /**
   * Add the index to the liquid expression if it doesn't already have an array index
   *
   * @example
   * text: '{{ payload.comments.author }}'
   * iterablePath: '{{ payload.comments }}'
   * index: 0
   * result: '{{ payload.comments[0].author }}'
   */
  private addIndexToLiquidExpression(text: string, iterablePath: string, index: number): string {
    const cleanPath = iterablePath.replace(/\{\{|\}\}/g, '').trim();
    const liquidMatch = text.match(/\{\{\s*(.*?)\s*\}\}/);

    if (!liquidMatch) return text;

    const [path, ...filters] = liquidMatch[1].split('|').map((part) => part.trim());
    if (path.includes('[')) return text;

    const newPath = path.replace(cleanPath, `${cleanPath}[${index}]`);

    return filters.length ? `{{ ${newPath} | ${filters.join(' | ')} }}` : `{{ ${newPath} }}`;
  }

  private stringToBoolean(value: string): boolean {
    const normalized = value.toLowerCase().trim();
    if (normalized === 'false' || normalized === 'null' || normalized === 'undefined') return false;

    try {
      return Boolean(JSON.parse(normalized));
    } catch {
      return Boolean(normalized);
    }
  }

  private async appendNovuBranding(html: string, organizationId: string): Promise<string> {
    try {
      const { removeNovuBranding } = await this.getOrganizationSettings.execute(
        GetOrganizationSettingsCommand.create({
          organizationId,
        })
      );

      if (removeNovuBranding) {
        return html;
      }

      return this.insertBrandingHtml(html);
    } catch (error) {
      // If there's any error fetching organization, return original HTML to avoid breaking emails
      return html;
    }
  }

  private insertBrandingHtml(html: string): string {
    const matches = [...html.matchAll(/<\/body>/gi)];

    if (matches.length === 0) {
      if (html?.trim()) {
        return html + NOVU_BRANDING_HTML;
      } else {
        return html;
      }
    }

    const lastIndex = matches[matches.length - 1].index!;

    return html.slice(0, lastIndex) + NOVU_BRANDING_HTML + html.slice(lastIndex);
  }

  private deepEscapePayloadStrings(payload: FullPayloadForRender): FullPayloadForRender {
    return this.deepEscapeObject(payload) as FullPayloadForRender;
  }

  private deepEscapeObject(obj: unknown): unknown {
    if (obj === null || obj === undefined) {
      return obj;
    }

    if (typeof obj === 'string') {
      return this.escapeStringForJson(obj);
    }

    if (typeof obj === 'number' || typeof obj === 'boolean') {
      return obj;
    }

    if (Array.isArray(obj)) {
      return obj.map((item) => this.deepEscapeObject(item));
    }

    if (typeof obj === 'object') {
      const escapedObj: Record<string, unknown> = {};
      for (const [key, value] of Object.entries(obj)) {
        escapedObj[key] = this.deepEscapeObject(value);
      }

      return escapedObj;
    }

    return obj;
  }

  private escapeStringForJson(str: string): string {
    return str
      .replace(/\\/g, '\\\\') // Escape backslashes
      .replace(/"/g, '\\"') // Escape quotes
      .replace(/\n/g, '\\n') // Escape newlines
      .replace(/\r/g, '\\r') // Escape carriage returns
      .replace(/\t/g, '\\t'); // Escape tabs
  }

  private cleanupRenderedHtml(html: string): string {
    /*
     * Convert paragraphs that contain only whitespace characters to empty paragraphs to prevent Gmail clipping.
     * Gmail's clipping algorithm detects trailing whitespace content and marks emails as "message clipped".
     * This preserves the intended spacing while removing the problematic whitespace content.
     */
    return html.replace(/<p([^>]*)>\s+<\/p>/g, '<p$1></p>');
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - isJsonString(str: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - layoutControlsEntity(await this.controlValuesRepository.findOne({
          _organizationId: organizationId,
          _e...)
 - layoutControlValues(layoutControlsEntity.controls as LayoutControlType;

    return this.processBodyContent({
      body...)
 - content(parent.content.filter((pNode))
 - limitedIterableArray(iterations ? iterableArray.slice(0, iterations) : iterableArray;

    return limitedIterableArray.fl...)
 - parsedArray(JSON.parse(iterableArrayString.replace(/'/g, '"'));

      if (!Array.isArray(parsedArray)) {
      ...)
Declaraciones 'export' encontradas:
- export class EmailOutputRendererCommand
- export class EmailOutputRendererUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/output-renderers/in-app-output-renderer.usecase.ts
TamaÃ±o: 1824 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { InstrumentUsecase, PinoLogger, sanitizeHtmlInObject } from '@novu/application-generic';
import { LocalizationResourceEnum, NotificationTemplateEntity } from '@novu/dal';
import { InAppRenderOutput } from '@novu/shared';
import { BaseTranslationRendererUsecase } from './base-translation-renderer.usecase';
import { RenderCommand } from './render-command';

export class InAppOutputRendererCommand extends RenderCommand {
  dbWorkflow: NotificationTemplateEntity;
  locale?: string;
}

@Injectable()
export class InAppOutputRendererUsecase extends BaseTranslationRendererUsecase {
  constructor(
    protected moduleRef: ModuleRef,
    protected logger: PinoLogger
  ) {
    super(moduleRef, logger);
  }

  @InstrumentUsecase()
  async execute(renderCommand: InAppOutputRendererCommand): Promise<InAppRenderOutput> {
    const { skip, disableOutputSanitization, ...outputControls } = renderCommand.controlValues ?? {};
    const { _environmentId, _organizationId, _id: workflowId } = renderCommand.dbWorkflow;

    const translatedControls = await this.processTranslations({
      controls: outputControls,
      variables: renderCommand.fullPayloadForRender,
      environmentId: _environmentId,
      organizationId: _organizationId,
      resourceId: workflowId,
      resourceType: LocalizationResourceEnum.WORKFLOW,
      locale: renderCommand.locale,
      resourceEntity: renderCommand.dbWorkflow,
      organization: renderCommand.organization,
    });

    if (disableOutputSanitization) {
      return translatedControls as any;
    }

    const { data, ...restOutputControls } = translatedControls;

    return {
      ...sanitizeHtmlInObject(restOutputControls),
      ...(data ? { data } : {}),
    } as any;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class InAppOutputRendererCommand
- export class InAppOutputRendererUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/output-renderers/index.ts
TamaÃ±o: 329 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './base-translation-renderer.usecase';
export * from './chat-output-renderer.usecase';
export * from './email-output-renderer.usecase';
export * from './in-app-output-renderer.usecase';
export * from './push-output-renderer.usecase';
export * from './render-command';
export * from './sms-output-renderer.usecase';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/output-renderers/novu-branding-html.ts
TamaÃ±o: 1033 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/**
 * This is the HTML for the Novu branding image.
 * Should be in par with the actual React component we show in the dashboard preview:
 * @see apps/dashboard/src/components/workflow-editor/steps/email/novu-branding.tsx
 */
export const NOVU_BRANDING_HTML = `
<table align="center" width="100%" border="0" cellpadding="0" cellspacing="0" role="presentation" style="max-width:600px;min-width:300px;width:100%;" data-novu-branding>
  <tbody>
    <tr style="width:100%">
      <td align="center" style="padding:16px 0 24px 0;">
        <a href="https://go.novu.co/powered?utm_source=email" target="_blank" rel="noopener noreferrer" style="text-decoration:none;">
          <img src="https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/powered-by-novu.png" alt="Powered by Novu" title="This email was sent using Novu - Open-source notification infrastructure" width="125" height="12" style="display:block;max-width:100%;height:auto;cursor:pointer;" />
        </a>
      </td>
    </tr>
  </tbody>
</table>
`;


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/output-renderers/push-output-renderer.usecase.ts
TamaÃ±o: 1548 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { InstrumentUsecase, PinoLogger } from '@novu/application-generic';
import { LocalizationResourceEnum, NotificationTemplateEntity } from '@novu/dal';
import { PushRenderOutput } from '@novu/shared';
import { BaseTranslationRendererUsecase } from './base-translation-renderer.usecase';
import { RenderCommand } from './render-command';

export class PushOutputRendererCommand extends RenderCommand {
  dbWorkflow: NotificationTemplateEntity;
  locale?: string;
}

@Injectable()
export class PushOutputRendererUsecase extends BaseTranslationRendererUsecase {
  constructor(
    protected moduleRef: ModuleRef,
    protected logger: PinoLogger
  ) {
    super(moduleRef, logger);
  }

  @InstrumentUsecase()
  async execute(renderCommand: PushOutputRendererCommand): Promise<PushRenderOutput> {
    const { skip, ...outputControls } = renderCommand.controlValues ?? {};
    const { _environmentId, _organizationId, _id: workflowId } = renderCommand.dbWorkflow;

    const translatedControls = await this.processTranslations({
      controls: outputControls,
      variables: renderCommand.fullPayloadForRender,
      environmentId: _environmentId,
      organizationId: _organizationId,
      resourceId: workflowId,
      resourceType: LocalizationResourceEnum.WORKFLOW,
      locale: renderCommand.locale,
      organization: renderCommand.organization,
      resourceEntity: renderCommand.dbWorkflow,
    });

    return translatedControls as any;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class PushOutputRendererCommand
- export class PushOutputRendererUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/output-renderers/render-command.ts
TamaÃ±o: 748 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { OrganizationEntity } from '@novu/dal';
import type { ContextResolved } from '@novu/framework/internal';
import { LAYOUT_CONTENT_VARIABLE } from '@novu/shared';

export class RenderCommand extends BaseCommand {
  controlValues: Record<string, unknown>;
  fullPayloadForRender: FullPayloadForRender;
  organization?: OrganizationEntity;
}
export class FullPayloadForRender {
  workflow?: Record<string, unknown>;
  subscriber: Record<string, unknown>;
  payload: Record<string, unknown>;
  context?: ContextResolved;
  steps: Record<string, unknown>; // step.stepId.unknown
  // this variable is used to pass the layout content to the renderer
  [LAYOUT_CONTENT_VARIABLE]?: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class RenderCommand
- export class FullPayloadForRender

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/output-renderers/sms-output-renderer.usecase.ts
TamaÃ±o: 1543 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { InstrumentUsecase, PinoLogger } from '@novu/application-generic';
import { LocalizationResourceEnum, NotificationTemplateEntity } from '@novu/dal';
import { SmsRenderOutput } from '@novu/shared';
import { BaseTranslationRendererUsecase } from './base-translation-renderer.usecase';
import { RenderCommand } from './render-command';

export class SmsOutputRendererCommand extends RenderCommand {
  dbWorkflow: NotificationTemplateEntity;
  locale?: string;
}

@Injectable()
export class SmsOutputRendererUsecase extends BaseTranslationRendererUsecase {
  constructor(
    protected moduleRef: ModuleRef,
    protected logger: PinoLogger
  ) {
    super(moduleRef, logger);
  }

  @InstrumentUsecase()
  async execute(renderCommand: SmsOutputRendererCommand): Promise<SmsRenderOutput> {
    const { skip, ...outputControls } = renderCommand.controlValues ?? {};
    const { _environmentId, _organizationId, _id: workflowId } = renderCommand.dbWorkflow;

    const translatedControls = await this.processTranslations({
      controls: outputControls,
      variables: renderCommand.fullPayloadForRender,
      environmentId: _environmentId,
      organizationId: _organizationId,
      resourceId: workflowId,
      resourceType: LocalizationResourceEnum.WORKFLOW,
      locale: renderCommand.locale,
      resourceEntity: renderCommand.dbWorkflow,
      organization: renderCommand.organization,
    });

    return translatedControls as any;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class SmsOutputRendererCommand
- export class SmsOutputRendererUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/output-renderers/throttle-output-renderer.usecase.ts
TamaÃ±o: 729 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { ThrottleRenderOutput } from '@novu/shared';
import { RenderCommand } from './render-command';

@Injectable()
export class ThrottleOutputRendererUsecase {
  @InstrumentUsecase()
  execute(renderCommand: RenderCommand): ThrottleRenderOutput {
    const { skip: _skip, ...outputControls } = renderCommand.controlValues ?? {};

    return {
      type: outputControls.type,
      amount: outputControls.amount,
      unit: outputControls.unit,
      dynamicKey: outputControls.dynamicKey,
      threshold: outputControls.threshold,
      throttleKey: outputControls.throttleKey,
    } as ThrottleRenderOutput;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class ThrottleOutputRendererUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/regenerate-api-keys/regenerate-api-keys.usecase.ts
TamaÃ±o: 1428 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { decryptApiKey, encryptApiKey } from '@novu/application-generic';

import { EnvironmentRepository } from '@novu/dal';
import { createHash } from 'crypto';
import { ApiKeyDto } from '../../dtos/api-key.dto';
import { GenerateUniqueApiKey } from '../generate-unique-api-key/generate-unique-api-key.usecase';
import { GetApiKeysCommand } from '../get-api-keys/get-api-keys.command';

@Injectable()
export class RegenerateApiKeys {
  constructor(
    private environmentRepository: EnvironmentRepository,
    private generateUniqueApiKey: GenerateUniqueApiKey
  ) {}

  async execute(command: GetApiKeysCommand): Promise<ApiKeyDto[]> {
    const environment = await this.environmentRepository.findOne({ _id: command.environmentId });

    if (!environment) {
      throw new BadRequestException(`Environment id: ${command.environmentId} not found`);
    }

    const key = await this.generateUniqueApiKey.execute();
    const encryptedApiKey = encryptApiKey(key);
    const hashedApiKey = createHash('sha256').update(key).digest('hex');

    const environments = await this.environmentRepository.updateApiKey(
      command.environmentId,
      encryptedApiKey,
      command.userId,
      hashedApiKey
    );

    return environments.map((item) => {
      return {
        _userId: item._userId,
        key: decryptApiKey(item.key),
      };
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - environments(await this.environmentRepository.updateApiKey(
      command.environmentId,
      encryptedApiKey,
 ...)
Declaraciones 'export' encontradas:
- export class RegenerateApiKeys

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/update-environment/update-environment.command.ts
TamaÃ±o: 612 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsMongoId, IsOptional, IsString } from 'class-validator';
import { OrganizationCommand } from '../../../shared/commands/organization.command';

export class UpdateEnvironmentCommand extends OrganizationCommand {
  @IsDefined()
  @IsMongoId()
  environmentId: string;

  @IsOptional()
  @IsString()
  name?: string;

  @IsOptional()
  @IsString()
  identifier?: string;

  @IsOptional()
  @IsString()
  @IsMongoId()
  _parentId?: string;

  @IsOptional()
  @IsString()
  color?: string;

  @IsOptional()
  dns?: { inboundParseDomain?: string };

  @IsOptional()
  bridge?: { url?: string };
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class UpdateEnvironmentCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/update-environment/update-environment.e2e-ee.ts
TamaÃ±o: 870 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { UpdateEnvironmentRequestDto } from '../../dtos/update-environment-request.dto';

describe('Update Environment - /environments (PUT)', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should update bridge data correctly', async () => {
    const updatePayload: UpdateEnvironmentRequestDto = {
      name: 'Development',
      bridge: { url: 'http://example.com' },
    };

    await session.testAgent.put(`/v1/environments/${session.environment._id}`).send(updatePayload).expect(200);
    const { body } = await session.testAgent.get('/v1/environments/me');

    expect(body.data.name).to.eq(updatePayload.name);
    expect(body.data.echo.url).to.equal(updatePayload.bridge?.url);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should update bridge data correctly'...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/update-environment/update-environment.e2e.ts
TamaÃ±o: 866 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { UpdateEnvironmentRequestDto } from '../../dtos/update-environment-request.dto';

describe('Update Environment - /environments (PUT)', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should update environment entity correctly', async () => {
    const updatePayload: UpdateEnvironmentRequestDto = {
      name: 'New Name',
      identifier: 'New Identifier',
    };

    await session.testAgent.put(`/v1/environments/${session.environment._id}`).send(updatePayload).expect(200);
    const { body } = await session.testAgent.get('/v1/environments/me');

    expect(body.data.name).to.eq(updatePayload.name);
    expect(body.data.identifier).to.equal(updatePayload.identifier);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should update environment entity cor...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/update-environment/update-environment.usecase.ts
TamaÃ±o: 2304 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, UnauthorizedException, UnprocessableEntityException } from '@nestjs/common';
import { EnvironmentEntity, EnvironmentRepository } from '@novu/dal';
import { EnvironmentEnum, PROTECTED_ENVIRONMENTS } from '@novu/shared';
import { UpdateEnvironmentCommand } from './update-environment.command';

@Injectable()
export class UpdateEnvironment {
  constructor(private environmentRepository: EnvironmentRepository) {}

  async execute(command: UpdateEnvironmentCommand) {
    const environment = await this.environmentRepository.findOne({
      _id: command.environmentId,
      _organizationId: command.organizationId,
    });

    if (!environment) {
      throw new UnauthorizedException('Environment not found');
    }

    // Prevent renaming Development or Production environments
    if (command.name && command.name !== '' && PROTECTED_ENVIRONMENTS.includes(environment.name as EnvironmentEnum)) {
      throw new UnprocessableEntityException('Cannot update the name of Development or Production environments');
    }

    const updatePayload: Partial<EnvironmentEntity> = {};

    if (command.name && command.name !== '') {
      const normalizedName = command.name.trim();
      if (PROTECTED_ENVIRONMENTS?.map((env) => env.toLowerCase()).includes(normalizedName.toLowerCase())) {
        throw new UnprocessableEntityException('Environment name cannot be Development or Production');
      }

      updatePayload.name = normalizedName;
    }
    if (command._parentId && command.name !== '') {
      updatePayload._parentId = command._parentId;
    }

    if (command.identifier && command.name !== '') {
      updatePayload.identifier = command.identifier;
    }

    if (command.color) {
      updatePayload.color = command.color;
    }

    if (command.dns && command.dns.inboundParseDomain && command.dns.inboundParseDomain !== '') {
      updatePayload[`dns.inboundParseDomain`] = command.dns.inboundParseDomain;
    }

    if (command.bridge) {
      updatePayload['echo.url'] = command.bridge?.url || '';
      updatePayload['bridge.url'] = command.bridge?.url || '';
    }

    return await this.environmentRepository.update(
      {
        _id: command.environmentId,
        _organizationId: command.organizationId,
      },
      { $set: updatePayload }
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - normalizedName(command.name.trim();
      if (PROTECTED_ENVIRONMENTS?.map((env))
Declaraciones 'export' encontradas:
- export class UpdateEnvironment

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/environments.controller.ts
TamaÃ±o: 4427 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  ClassSerializerInterceptor,
  Controller,
  Get,
  HttpCode,
  Param,
  Post,
  UseInterceptors,
} from '@nestjs/common';
import { ApiExcludeEndpoint, ApiOperation, ApiParam, ApiTags } from '@nestjs/swagger';
import { RequirePermissions, SkipPermissionsCheck } from '@novu/application-generic';
import { PermissionsEnum, UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { SdkGroupName, SdkMethodName } from '../shared/framework/swagger/sdk.decorators';
import { UserSession } from '../shared/framework/user.decorator';
import {
  DiffEnvironmentRequestDto,
  DiffEnvironmentResponseDto,
  PublishEnvironmentRequestDto,
  PublishEnvironmentResponseDto,
} from './dtos';
import { GetEnvironmentTagsDto } from './dtos/get-environment-tags.dto';
import { DiffEnvironmentCommand } from './usecases/diff-environment/diff-environment.command';
import { DiffEnvironmentUseCase } from './usecases/diff-environment/diff-environment.usecase';
import { GetEnvironmentTags, GetEnvironmentTagsCommand } from './usecases/get-environment-tags';
import { PublishEnvironmentCommand } from './usecases/publish-environment/publish-environment.command';
import { PublishEnvironmentUseCase } from './usecases/publish-environment/publish-environment.usecase';

@ApiCommonResponses()
@Controller({ path: `/environments`, version: '2' })
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiTags('Environments')
@SdkGroupName('Environments')
export class EnvironmentsController {
  constructor(
    private getEnvironmentTagsUsecase: GetEnvironmentTags,
    private publishEnvironmentUseCase: PublishEnvironmentUseCase,
    private diffEnvironmentUseCase: DiffEnvironmentUseCase
  ) {}

  @Get('/:environmentId/tags')
  @ApiOperation({
    summary: 'Get environment tags',
    description:
      'Retrieve all unique tags used in workflows within the specified environment. These tags can be used for filtering workflows.',
  })
  @ApiParam({
    name: 'environmentId',
    description: 'Environment internal ID (MongoDB ObjectId) or identifier',
    type: String,
    example: '6615943e7ace93b0540ae377',
  })
  @ApiResponse(GetEnvironmentTagsDto, 200, true)
  @SdkMethodName('getTags')
  @ExternalApiAccessible()
  @SkipPermissionsCheck()
  async getEnvironmentTags(
    @UserSession() user: UserSessionData,
    @Param('environmentId') environmentIdOrIdentifier: string
  ): Promise<GetEnvironmentTagsDto[]> {
    return await this.getEnvironmentTagsUsecase.execute(
      GetEnvironmentTagsCommand.create({
        environmentIdOrIdentifier,
        userId: user._id,
        organizationId: user.organizationId,
      })
    );
  }

  @Post('/:targetEnvironmentId/publish')
  @HttpCode(200)
  @ApiOperation({ summary: 'Publish all workflows from source to target environment' })
  @ApiResponse(PublishEnvironmentResponseDto)
  @ExternalApiAccessible()
  @ApiExcludeEndpoint()
  @RequirePermissions(PermissionsEnum.ENVIRONMENT_WRITE)
  async publishEnvironment(
    @UserSession() user: UserSessionData,
    @Param('targetEnvironmentId') targetEnvironmentId: string,
    @Body() body: PublishEnvironmentRequestDto
  ): Promise<PublishEnvironmentResponseDto> {
    return await this.publishEnvironmentUseCase.execute(
      PublishEnvironmentCommand.create({
        user,
        sourceEnvironmentId: body.sourceEnvironmentId,
        targetEnvironmentId,
        dryRun: body.dryRun,
        resources: body.resources,
      })
    );
  }

  @Post('/:targetEnvironmentId/diff')
  @HttpCode(200)
  @ApiOperation({ summary: 'Compare workflows between source and target environments' })
  @ApiResponse(DiffEnvironmentResponseDto)
  @ExternalApiAccessible()
  @ApiExcludeEndpoint()
  @RequirePermissions(PermissionsEnum.ENVIRONMENT_WRITE)
  async diffEnvironment(
    @UserSession() user: UserSessionData,
    @Param('targetEnvironmentId') targetEnvironmentId: string,
    @Body() body: DiffEnvironmentRequestDto
  ): Promise<DiffEnvironmentResponseDto> {
    return await this.diffEnvironmentUseCase.execute(
      DiffEnvironmentCommand.create({
        user,
        sourceEnvironmentId: body.sourceEnvironmentId,
        targetEnvironmentId,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class EnvironmentsController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/environments.module.ts
TamaÃ±o: 983 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { SharedModule } from '../shared/shared.module';
import { WorkflowModule } from '../workflows-v2/workflow.module';
import { EnvironmentsController } from './environments.controller';
import { DependencyAnalyzerService, EnvironmentValidationService } from './services';
import { DiffEnvironmentUseCase } from './usecases/diff-environment/diff-environment.usecase';
import { GetEnvironmentTags } from './usecases/get-environment-tags';
import { PublishEnvironmentUseCase } from './usecases/publish-environment/publish-environment.usecase';
import { SyncModule } from './usecases/sync-strategies/sync.module';

@Module({
  imports: [SharedModule, WorkflowModule, SyncModule],
  controllers: [EnvironmentsController],
  providers: [
    GetEnvironmentTags,
    PublishEnvironmentUseCase,
    DiffEnvironmentUseCase,
    EnvironmentValidationService,
    DependencyAnalyzerService,
  ],
  exports: [],
})
export class EnvironmentsModule {}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class EnvironmentsModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/dtos/diff-environment.dto.ts
TamaÃ±o: 7729 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsBoolean, IsDateString, IsEnum, IsNumber, IsOptional, IsString, ValidateNested } from 'class-validator';
import { DependencyReasonEnum, ResourceTypeEnum } from '../types/sync.types';

export class DiffEnvironmentRequestDto {
  @ApiPropertyOptional({
    description: 'Source environment ID to compare from. Defaults to the Development environment if not provided.',
    example: '507f1f77bcf86cd799439011',
  })
  @IsOptional()
  @IsString()
  sourceEnvironmentId?: string;
}

export class UserInfoDto {
  @ApiProperty({ description: 'User ID' })
  @IsString()
  _id: string;

  @ApiProperty({ type: 'string', description: 'User first name' })
  @IsString()
  firstName: string;

  @ApiPropertyOptional({ type: 'string', description: 'User last name' })
  @IsOptional()
  @IsString()
  lastName?: string | null;

  @ApiPropertyOptional({ type: 'string', description: 'User external ID' })
  @IsOptional()
  @IsString()
  externalId?: string;
}

export class ResourceInfoDto {
  @ApiPropertyOptional({
    description: 'Resource ID (workflow ID or step ID)',
    nullable: true,
    example: 'welcome-email-workflow',
  })
  @IsOptional()
  @IsString()
  id: string | null;

  @ApiPropertyOptional({
    description: 'Resource name (workflow name or step name)',
    nullable: true,
    example: 'Welcome Email Workflow',
  })
  @IsOptional()
  @IsString()
  name: string | null;

  @ApiPropertyOptional({
    description: 'User who last updated the resource',
    type: () => UserInfoDto,
    nullable: true,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => UserInfoDto)
  updatedBy?: UserInfoDto | null;

  @ApiPropertyOptional({
    description: 'When the resource was last updated',
    type: 'string',
    format: 'date-time',
    nullable: true,
    example: '2024-01-15T10:30:00.000Z',
  })
  @IsOptional()
  @IsDateString()
  updatedAt?: string | null;
}

export class ResourceDiffDto {
  @ApiPropertyOptional({
    description: 'Source resource information',
    type: () => ResourceInfoDto,
    nullable: true,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => ResourceInfoDto)
  sourceResource?: ResourceInfoDto | null;

  @ApiPropertyOptional({
    description: 'Target resource information',
    type: () => ResourceInfoDto,
    nullable: true,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => ResourceInfoDto)
  targetResource?: ResourceInfoDto | null;

  @ApiProperty({
    description: 'Type of resource',
    enum: [...Object.values(ResourceTypeEnum)],
    enumName: 'ResourceTypeEnum',
    example: 'workflow',
  })
  @IsEnum(ResourceTypeEnum)
  resourceType: ResourceTypeEnum;

  @ApiProperty({
    description: 'Type of change',
    enum: ['added', 'modified', 'deleted', 'unchanged', 'moved'],
  })
  @IsEnum(['added', 'modified', 'deleted', 'unchanged', 'moved'])
  action: 'added' | 'modified' | 'deleted' | 'unchanged' | 'moved';

  @ApiPropertyOptional({
    type: 'object',
    description: 'Detailed changes (only for modified resources)',
    properties: {
      previous: {
        type: 'object',
        description: 'Previous state of the resource (null for added resources)',
        additionalProperties: true,
        nullable: true,
      },
      new: {
        type: 'object',
        description: 'New state of the resource (null for deleted resources)',
        additionalProperties: true,
        nullable: true,
      },
    },
  })
  diffs?: {
    previous: Record<string, any> | null;
    new: Record<string, any> | null;
  };

  // Step-specific fields
  @ApiPropertyOptional({ description: 'Step type (only for step resources)' })
  @IsOptional()
  @IsString()
  stepType?: string;

  @ApiPropertyOptional({ description: 'Previous index in steps array (for moved/deleted steps)' })
  @IsOptional()
  @IsNumber()
  previousIndex?: number;

  @ApiPropertyOptional({ description: 'New index in steps array (for moved/added steps)' })
  @IsOptional()
  @IsNumber()
  newIndex?: number;
}

export class DiffSummaryDto {
  @ApiProperty({ description: 'Number of added resources (workflows and steps)' })
  @IsNumber()
  added: number;

  @ApiProperty({ description: 'Number of modified resources (workflows and steps)' })
  @IsNumber()
  modified: number;

  @ApiProperty({ description: 'Number of deleted resources (workflows and steps)' })
  @IsNumber()
  deleted: number;

  @ApiProperty({ description: 'Number of unchanged resources (workflows and steps)' })
  @IsNumber()
  unchanged: number;
}

export class ResourceDependencyDto {
  @ApiProperty({
    description: 'Type of dependent resource',
    enum: [...Object.values(ResourceTypeEnum)],
    enumName: 'ResourceTypeEnum',
    example: 'layout',
  })
  @IsEnum(ResourceTypeEnum)
  resourceType: ResourceTypeEnum;

  @ApiProperty({
    description: 'ID of the dependent resource',
    example: 'layout-id-123',
  })
  @IsString()
  resourceId: string;

  @ApiProperty({
    description: 'Name of the dependent resource',
    example: 'Email Layout Template',
  })
  @IsString()
  resourceName: string;

  @ApiProperty({
    description: 'Whether this dependency blocks the operation',
    example: true,
  })
  @IsBoolean()
  isBlocking: boolean;

  @ApiProperty({
    description: 'Reason for the dependency',
    enum: [...Object.values(DependencyReasonEnum)],
    enumName: 'DependencyReasonEnum',
    example: 'LAYOUT_REQUIRED_FOR_WORKFLOW',
  })
  @IsEnum(DependencyReasonEnum)
  reason: DependencyReasonEnum;
}

export class ResourceDiffResultDto {
  @ApiProperty({
    description: 'Type of resource being compared',
    enum: [...Object.values(ResourceTypeEnum)],
    enumName: 'ResourceTypeEnum',
    example: 'workflow',
  })
  @IsEnum(ResourceTypeEnum)
  resourceType: ResourceTypeEnum;

  @ApiPropertyOptional({
    description: 'Source resource information',
    type: () => ResourceInfoDto,
    nullable: true,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => ResourceInfoDto)
  sourceResource?: ResourceInfoDto | null;

  @ApiPropertyOptional({
    description: 'Target resource information',
    type: () => ResourceInfoDto,
    nullable: true,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => ResourceInfoDto)
  targetResource?: ResourceInfoDto | null;

  @ApiProperty({
    description: 'List of specific changes for this resource',
    type: [ResourceDiffDto],
  })
  changes: ResourceDiffDto[];

  @ApiProperty({
    description: 'Summary of changes for this resource',
    type: DiffSummaryDto,
  })
  summary: DiffSummaryDto;

  @ApiPropertyOptional({
    description: 'Dependencies that affect this resource',
    type: [ResourceDependencyDto],
  })
  @IsOptional()
  @ValidateNested({ each: true })
  @Type(() => ResourceDependencyDto)
  dependencies?: ResourceDependencyDto[];
}

export class EnvironmentDiffSummaryDto {
  @ApiProperty({ description: 'Total number of entities compared' })
  @IsNumber()
  totalEntities: number;

  @ApiProperty({ description: 'Total number of changes detected' })
  @IsNumber()
  totalChanges: number;

  @ApiProperty({ description: 'Whether any changes were detected' })
  @IsBoolean()
  hasChanges: boolean;
}

export class DiffEnvironmentResponseDto {
  @ApiProperty({ description: 'Source environment ID' })
  @IsString()
  sourceEnvironmentId: string;

  @ApiProperty({ description: 'Target environment ID' })
  @IsString()
  targetEnvironmentId: string;

  @ApiProperty({ type: [ResourceDiffResultDto], description: 'Diff resources by resource type' })
  resources: ResourceDiffResultDto[];

  @ApiProperty({ type: EnvironmentDiffSummaryDto, description: 'Overall summary' })
  summary: EnvironmentDiffSummaryDto;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class DiffEnvironmentRequestDto
- export class UserInfoDto
- export class ResourceInfoDto
- export class ResourceDiffDto
- export class DiffSummaryDto
- export class ResourceDependencyDto
- export class ResourceDiffResultDto
- export class EnvironmentDiffSummaryDto
- export class DiffEnvironmentResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/dtos/get-environment-tags.dto.ts
TamaÃ±o: 204 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsDefined, IsString } from 'class-validator';

export class GetEnvironmentTagsDto {
  @ApiProperty()
  @IsDefined()
  @IsString()
  name: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class GetEnvironmentTagsDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/dtos/index.ts
TamaÃ±o: 127 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './diff-environment.dto';
export * from './get-environment-tags.dto';
export * from './publish-environment.dto';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/dtos/publish-environment.dto.ts
TamaÃ±o: 3977 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsArray, IsBoolean, IsEnum, IsNumber, IsOptional, IsString, Max, Min, ValidateNested } from 'class-validator';
import { ResourceTypeEnum } from '../types/sync.types';

export class ResourceToPublishDto {
  @ApiProperty({
    description: 'Type of resource to publish',
    enum: Object.values(ResourceTypeEnum),
    enumName: 'ResourceTypeEnum',
    example: ResourceTypeEnum.WORKFLOW,
  })
  @IsEnum(ResourceTypeEnum)
  resourceType: ResourceTypeEnum;

  @ApiProperty({
    description: 'Unique identifier of the resource to publish',
    example: 'workflow-id-1',
  })
  @IsString()
  resourceId: string;
}

export class PublishEnvironmentRequestDto {
  @ApiPropertyOptional({
    description: 'Source environment ID to sync from. Defaults to the Development environment if not provided.',
    example: '507f1f77bcf86cd799439011',
  })
  @IsOptional()
  @IsString()
  sourceEnvironmentId?: string;

  @ApiPropertyOptional({
    description: 'Perform a dry run without making actual changes',
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  dryRun?: boolean;

  @ApiPropertyOptional({
    description: 'Array of specific resources to publish. If not provided, all resources will be published.',
    type: [ResourceToPublishDto],
    example: [
      { resourceType: 'workflow', resourceId: 'workflow-id-1' },
      { resourceType: 'layout', resourceId: 'layout-id-1' },
    ],
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => ResourceToPublishDto)
  resources?: ResourceToPublishDto[];
}

export class SyncedWorkflowDto {
  @ApiProperty({ description: 'Resource type' })
  resourceType: string;

  @ApiProperty({ description: 'Workflow ID' })
  resourceId: string;

  @ApiProperty({ description: 'Workflow name' })
  resourceName: string;

  @ApiProperty({ description: 'Sync action performed' })
  action: 'created' | 'updated' | 'skipped' | 'deleted';
}

export class FailedWorkflowDto {
  @ApiProperty({ description: 'Resource type' })
  resourceType: string;

  @ApiProperty({ description: 'Workflow ID' })
  resourceId: string;

  @ApiProperty({ description: 'Workflow name' })
  resourceName: string;

  @ApiProperty({ description: 'Error message' })
  error: string;

  @ApiPropertyOptional({ description: 'Error stack trace' })
  stack?: string;
}

export class SkippedWorkflowDto {
  @ApiProperty({ description: 'Resource type' })
  resourceType: string;

  @ApiProperty({ description: 'Workflow ID' })
  resourceId: string;

  @ApiProperty({ description: 'Workflow name' })
  resourceName: string;

  @ApiProperty({ description: 'Reason for skipping' })
  reason: string;
}

export class SyncResultDto {
  @ApiProperty({ description: 'Resource type that was synced' })
  resourceType: string;

  @ApiProperty({ type: [SyncedWorkflowDto], description: 'Successfully synced workflows' })
  successful: SyncedWorkflowDto[];

  @ApiProperty({ type: [FailedWorkflowDto], description: 'Failed workflow syncs' })
  failed: FailedWorkflowDto[];

  @ApiProperty({ type: [SkippedWorkflowDto], description: 'Skipped workflows' })
  skipped: SkippedWorkflowDto[];

  @ApiProperty({ description: 'Total number of workflows processed' })
  totalProcessed: number;
}

export class PublishSummaryDto {
  @ApiProperty({ description: 'Number of resources processed' })
  resources: number;

  @ApiProperty({ description: 'Number of successful syncs' })
  successful: number;

  @ApiProperty({ description: 'Number of failed syncs' })
  failed: number;

  @ApiProperty({ description: 'Number of skipped resources' })
  skipped: number;
}

export class PublishEnvironmentResponseDto {
  @ApiProperty({ type: [SyncResultDto], description: 'Sync results by resource type' })
  results: SyncResultDto[];

  @ApiProperty({ type: PublishSummaryDto, description: 'Summary of the sync operation' })
  summary: PublishSummaryDto;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class ResourceToPublishDto
- export class PublishEnvironmentRequestDto
- export class SyncedWorkflowDto
- export class FailedWorkflowDto
- export class SkippedWorkflowDto
- export class SyncResultDto
- export class PublishSummaryDto
- export class PublishEnvironmentResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/e2e/environments-v2-diff.e2e.ts
TamaÃ±o: 20779 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { CreateWorkflowDto, WorkflowCreationSourceEnum } from '@novu/api/models/components';
import { EnvironmentRepository, LocalizationResourceEnum } from '@novu/dal';
import { ApiServiceLevelEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { LayoutCreationSourceEnum } from '../../layouts-v2/types';
import { initNovuClassSdkInternalAuth } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Environment Diff - /v2/environments/:targetEnvironmentId/diff (POST) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  const environmentRepository = new EnvironmentRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdkInternalAuth(session);
  });

  async function getProductionEnvironment() {
    const prodEnv = await environmentRepository.findOne({
      _parentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    if (!prodEnv) {
      throw new Error('Production environment not found');
    }

    return prodEnv;
  }

  describe('Workflow Diff Tests', () => {
    it('should return empty diff when environments are identical after creating and publishing a workflow', async () => {
      const prodEnv = await getProductionEnvironment();

      const workflowData = {
        name: 'Test Workflow for Empty Diff',
        workflowId: 'test-workflow-empty-diff',
        description: 'This is a test workflow to validate empty diff after publishing',
        active: true,
        steps: [
          {
            name: 'Email Step',
            type: 'email' as const,
            controlValues: {
              subject: 'Test Subject',
              body: 'Test email content',
            },
          },
        ],
        source: WorkflowCreationSourceEnum.Editor,
      };

      await novuClient.workflows.create(workflowData);

      await session.testAgent
        .post(`/v2/environments/${prodEnv._id}/publish`)
        .send({
          sourceEnvironmentId: session.environment._id,
          dryRun: false,
        })
        .expect(200);

      const { body } = await session.testAgent
        .post(`/v2/environments/${prodEnv._id}/diff`)
        .send({
          sourceEnvironmentId: session.environment._id,
        })
        .expect(200);

      expect(body.data.sourceEnvironmentId).to.equal(session.environment._id);
      expect(body.data.targetEnvironmentId).to.equal(prodEnv._id);
      expect(body.data.resources).to.be.an('array');
      expect(body.data.resources.length).to.equal(0);
      expect(body.data.summary.totalEntities).to.equal(0);
      expect(body.data.summary.totalChanges).to.equal(0);
      expect(body.data.summary.hasChanges).to.equal(false);
    });

    it('should use development environment as default source when sourceEnvironmentId is not provided', async () => {
      const prodEnv = await getProductionEnvironment();

      // Create a workflow in the development environment using the SDK
      const workflowData = {
        name: 'Test Workflow for Diff',
        workflowId: 'test-workflow-diff',
        description: 'This is a test workflow for diff',
        active: true,
        steps: [
          {
            name: 'Email Step',
            type: 'email' as const,
            controlValues: {
              subject: 'Test Subject',
              body: 'Test email content',
            },
          },
        ],
        source: WorkflowCreationSourceEnum.Editor,
      };

      const { result: workflow } = await novuClient.workflows.create(workflowData);

      // Wait a bit for the workflow to be fully created
      await new Promise<void>((resolve) => {
        setTimeout(resolve, 100);
      });

      // Test diff without providing sourceEnvironmentId - should default to development
      const { body } = await session.testAgent
        .post(`/v2/environments/${prodEnv._id}/diff`)
        .send({}) // No sourceEnvironmentId provided
        .expect(200);

      expect(body.data.sourceEnvironmentId).to.equal(session.environment._id); // Should default to dev environment
      expect(body.data.targetEnvironmentId).to.equal(prodEnv._id);
      expect(body.data.resources).to.be.an('array');
      expect(body.data.summary.totalEntities).to.equal(1); // Should find the workflow we created
      expect(body.data.summary.hasChanges).to.equal(true); // Should show changes since prod is empty
    });

    describe('Layout-Workflow Dependencies', () => {
      beforeEach(async () => {
        await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

        const prodEnv = await getProductionEnvironment();

        const defaultLayout = {
          layoutId: 'default-layout',
          name: 'Default Layout',
          source: LayoutCreationSourceEnum.DASHBOARD,
        };

        await novuClient.layouts.create(defaultLayout);
        await session.testAgent
          .post(`/v2/environments/${prodEnv._id}/publish`)
          .send({
            sourceEnvironmentId: session.environment._id,
            dryRun: false,
          })
          .expect(200);
      });

      it('should handle layout-workflow dependencies properly in diff when layout is removed after publishing', async () => {
        await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.PRO);
        const prodEnv = await getProductionEnvironment();

        // Step 1: Create a new layout in development environment
        const layoutData = {
          layoutId: 'test-layout-dependency',
          name: 'Test Layout for Dependencies',
          source: LayoutCreationSourceEnum.DASHBOARD,
        };

        const { result: layout } = await novuClient.layouts.create(layoutData);

        const workflowData = {
          name: 'Test Workflow with Layout Dependency',
          workflowId: 'test-workflow-with-layout-dependency',
          description: 'Workflow that depends on the test layout',
          active: true,
          steps: [
            {
              name: 'Email Step with Layout',
              type: 'email' as const,
              controlValues: {
                subject: 'Test Subject with Layout',
                body: 'Test email content with layout',
                layoutId: layout.layoutId,
              },
            },
          ],
          source: WorkflowCreationSourceEnum.Editor,
        };

        await novuClient.workflows.create(workflowData);

        await session.testAgent
          .post(`/v2/environments/${prodEnv._id}/publish`)
          .send({
            sourceEnvironmentId: session.environment._id,
            dryRun: false,
          })
          .expect(200);

        await novuClient.layouts.delete(layout.layoutId);

        const diffResult = await session.testAgent
          .post(`/v2/environments/${prodEnv._id}/diff`)
          .send({
            sourceEnvironmentId: session.environment._id,
          })
          .expect(200);

        // Find the workflow and layout in the diff results
        const workflowResource = diffResult.body.data.resources.find(
          (resource: any) => resource.resourceType === 'workflow'
        );
        const layoutResource = diffResult.body.data.resources.find(
          (resource: any) => resource.resourceType === 'layout'
        );

        expect(workflowResource).to.exist;
        expect(workflowResource.targetResource?.name).to.equal('Test Workflow with Layout Dependency');
        // Workflow should not have dependencies - it can function without the specific layout
        expect(workflowResource.dependencies).to.not.exist;

        expect(layoutResource).to.exist;
        expect(layoutResource.targetResource?.name).to.equal('Test Layout for Dependencies');
        expect(layoutResource.sourceResource).to.be.null; // Layout was deleted from source

        /*
         * Verify dependencies are properly identified - the layout should be blocked from deletion
         * because it's still being used by workflows in the target environment
         */
        expect(layoutResource.dependencies).to.be.an('array');
        expect(layoutResource.dependencies.length).to.be.greaterThan(0);

        const workflowDependency = layoutResource.dependencies.find((dep: any) => dep.resourceType === 'workflow');

        expect(workflowDependency.resourceName).to.equal('Test Workflow with Layout Dependency');
        expect(workflowDependency.isBlocking).to.equal(true);
        expect(workflowDependency.reason).to.be.equal('LAYOUT_REQUIRED_FOR_WORKFLOW');
      });

      it('should show workflow blocked by layout dependency when both are new resources', async () => {
        await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.PRO);
        const prodEnv = await getProductionEnvironment();

        // Step 1: Create a new layout in development environment
        const layoutData = {
          layoutId: 'new-layout-for-blocking-test',
          name: 'New Layout for Blocking Test',
          source: LayoutCreationSourceEnum.DASHBOARD,
        };

        const { result: layout } = await novuClient.layouts.create(layoutData);

        // Step 2: Create a workflow that depends on the new layout
        const workflowData: CreateWorkflowDto = {
          name: 'New Workflow with New Layout Dependency',
          workflowId: 'new-workflow-with-new-layout-dependency',
          description: 'New workflow that depends on a new layout',
          active: true,
          steps: [
            {
              name: 'Email Step with New Layout',
              type: 'email' as const,
              controlValues: {
                subject: 'Test Subject with New Layout',
                body: 'Test email content with new layout',
                layoutId: layout.layoutId,
              },
            },
          ],
          source: WorkflowCreationSourceEnum.Editor,
        };

        await novuClient.workflows.create(workflowData);

        // Step 3: Get diff between dev and prod (both resources are new)
        const diffResult = await session.testAgent
          .post(`/v2/environments/${prodEnv._id}/diff`)
          .send({
            sourceEnvironmentId: session.environment._id,
          })
          .expect(200);

        // Find the workflow and layout in the diff results
        const workflowResource = diffResult.body.data.resources.find(
          (resource) =>
            resource.resourceType === 'workflow' &&
            resource.sourceResource?.id === 'new-workflow-with-new-layout-dependency'
        );
        const layoutResource = diffResult.body.data.resources.find(
          (resource) =>
            resource.resourceType === 'layout' && resource.sourceResource?.id === 'new-layout-for-blocking-test'
        );

        expect(workflowResource).to.exist;
        expect(workflowResource.sourceResource?.name).to.equal('New Workflow with New Layout Dependency');
        expect(workflowResource.targetResource).to.be.null; // New in source, doesn't exist in target

        expect(layoutResource).to.exist;
        expect(layoutResource.sourceResource?.name).to.equal('New Layout for Blocking Test');
        expect(layoutResource.targetResource).to.be.null; // New in source, doesn't exist in target

        // Verify workflow has dependency on the layout
        expect(workflowResource.dependencies).to.be.an('array');
        expect(workflowResource.dependencies.length).to.be.greaterThan(0);

        const layoutDependency = workflowResource.dependencies.find(
          (dep) => dep.resourceType === 'layout' && dep.resourceId === layout.layoutId
        );

        expect(layoutDependency).to.exist;
        expect(layoutDependency.resourceName).to.equal('New Layout for Blocking Test');
        expect(layoutDependency.isBlocking).to.equal(true);
        expect(layoutDependency.reason).to.equal('LAYOUT_REQUIRED_FOR_WORKFLOW');
      });

      it('should only show dependency on new layout when workflow changes layouts', async () => {
        const prodEnv = await getProductionEnvironment();

        // Create two layouts
        const oldLayout = await novuClient.layouts.create({
          layoutId: 'old-layout',
          name: 'Old Layout',
          source: LayoutCreationSourceEnum.DASHBOARD,
        });

        const newLayout = await novuClient.layouts.create({
          layoutId: 'new-layout',
          name: 'New Layout',
          source: LayoutCreationSourceEnum.DASHBOARD,
        });

        // Create workflow with old layout
        const workflow = await novuClient.workflows.create({
          name: 'Test Workflow Layout Change',
          workflowId: 'test-workflow-layout-change',
          active: true,
          steps: [
            {
              name: 'Email Step',
              type: 'email' as const,
              controlValues: {
                subject: 'Test',
                body: 'Test',
                layoutId: oldLayout.result.layoutId,
              },
            },
          ],
          source: WorkflowCreationSourceEnum.Editor,
        });

        // Publish to prod
        await session.testAgent
          .post(`/v2/environments/${prodEnv._id}/publish`)
          .send({ sourceEnvironmentId: session.environment._id, dryRun: false })
          .expect(200);

        // Update workflow to use new layout
        await novuClient.workflows.update(
          {
            ...workflow.result,
            steps: [
              {
                name: 'Email Step',
                type: 'email' as const,
                controlValues: {
                  subject: 'Test',
                  body: 'Test',
                  layoutId: newLayout.result.layoutId,
                },
              },
            ],
          },
          workflow.result.workflowId
        );

        // Check diff - should only show dependency on new layout
        const { body } = await session.testAgent
          .post(`/v2/environments/${prodEnv._id}/diff`)
          .send({ sourceEnvironmentId: session.environment._id })
          .expect(200);

        const workflowResource = body.data.resources.find(
          (resource) =>
            resource.resourceType === 'workflow' && resource.sourceResource?.id === 'test-workflow-layout-change'
        );

        expect(workflowResource.dependencies).to.have.length(1);
        expect(workflowResource.dependencies[0].resourceId).to.equal('new-layout');
      });
    });
  });

  describe('Localization Group Diff Tests', () => {
    beforeEach(async () => {
      // Set organization service level to business to avoid payment required errors
      await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);
    });

    it('should detect localization group modifications when translation content changes', async () => {
      const prodEnv = await getProductionEnvironment();

      // Create a workflow with translations enabled
      const workflowData = {
        name: 'Test Workflow with Translations',
        workflowId: 'test-workflow-translations',
        description: 'Test workflow for localization diff',
        active: true,
        isTranslationEnabled: true,
        steps: [
          {
            name: 'In-App Step',
            type: 'in_app' as const,
            controlValues: {
              body: 'Original content',
            },
          },
        ],
        source: WorkflowCreationSourceEnum.Editor,
      };

      const { result: workflow } = await novuClient.workflows.create(workflowData);

      // Create initial translation in development environment
      const initialTranslation = {
        resourceId: workflow.workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: {
          'welcome.title': 'Welcome',
          'welcome.message': 'Hello there!',
          'button.submit': 'Submit',
        },
      };

      await session.testAgent.post('/v2/translations').send(initialTranslation).expect(200);

      // Publish to production environment
      await session.testAgent
        .post(`/v2/environments/${prodEnv._id}/publish`)
        .send({
          sourceEnvironmentId: session.environment._id,
          dryRun: false,
        })
        .expect(200);

      // Modify translation content in development environment
      const modifiedTranslation = {
        resourceId: workflow.workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: {
          'welcome.title': 'Welcome Updated',
          'welcome.message': 'Hello there! Updated message.',
          'button.submit': 'Submit Now',
          'new.key': 'New content added',
        },
      };

      await session.testAgent.post('/v2/translations').send(modifiedTranslation).expect(200);

      const { body } = await session.testAgent
        .post(`/v2/environments/${prodEnv._id}/diff`)
        .send({
          sourceEnvironmentId: session.environment._id,
        })
        .expect(200);

      // Find localization group resource in diff
      const localizationGroupResource = body.data.resources.find((resource) => resource.resourceType === 'workflow');

      expect(localizationGroupResource).to.exist;
      expect(localizationGroupResource.sourceResource).to.exist;
      expect(localizationGroupResource.targetResource).to.exist;
      expect(localizationGroupResource.summary.modified).to.be.greaterThan(0);

      // Verify changes array contains the modification
      expect(localizationGroupResource.changes).to.be.an('array');
      expect(localizationGroupResource.changes.length).to.be.greaterThan(0);

      const change = localizationGroupResource.changes[0];
      expect(change.resourceType).to.equal('localization_group');
      expect(change.action).to.equal('modified');
      expect(change.diffs).to.exist;
      expect(change.diffs.new.translations.en_US).to.deep.equal(modifiedTranslation.content);
      expect(change.diffs.previous.translations.en_US).to.deep.equal(initialTranslation.content);
    });

    it('should detect localization group when new locale is added', async () => {
      const prodEnv = await getProductionEnvironment();

      // Create a workflow with translations enabled
      const workflowData = {
        name: 'Test Workflow Locale Addition',
        workflowId: 'test-workflow-locale-addition',
        active: true,
        isTranslationEnabled: true,
        steps: [
          {
            name: 'In-App Step',
            type: 'in_app' as const,
            controlValues: {
              body: 'Test content',
            },
          },
        ],
        source: WorkflowCreationSourceEnum.Editor,
      };

      const { result: workflow } = await novuClient.workflows.create(workflowData);

      // Create initial English translation
      await session.testAgent
        .post('/v2/translations')
        .send({
          resourceId: workflow.workflowId,
          resourceType: LocalizationResourceEnum.WORKFLOW,
          locale: 'en_US',
          content: {
            'welcome.title': 'Welcome',
            'welcome.message': 'Hello!',
          },
        })
        .expect(200);

      // Publish to production
      await session.testAgent
        .post(`/v2/environments/${prodEnv._id}/publish`)
        .send({
          sourceEnvironmentId: session.environment._id,
          dryRun: false,
        })
        .expect(200);

      // Add Spanish translation in development
      await session.testAgent
        .post('/v2/translations')
        .send({
          resourceId: workflow.workflowId,
          resourceType: LocalizationResourceEnum.WORKFLOW,
          locale: 'es_ES',
          content: {
            'welcome.title': 'Bienvenido',
            'welcome.message': 'Â¡Hola!',
          },
        })
        .expect(200);

      // Get diff
      const { body } = await session.testAgent
        .post(`/v2/environments/${prodEnv._id}/diff`)
        .send({
          sourceEnvironmentId: session.environment._id,
        })
        .expect(200);

      // Find localization group resource
      const localizationGroupResource = body.data.resources.find((resource) => resource.resourceType === 'workflow');

      expect(localizationGroupResource).to.exist;
      expect(localizationGroupResource.summary.modified).to.be.greaterThan(0);

      // Verify new locale is detected in changes
      const change = localizationGroupResource.changes[0];
      expect(change.diffs.new.locales).to.include('es_ES');
      expect(change.diffs.new.translations.es_ES).to.exist;
      expect(change.diffs.previous.locales).to.not.include('es_ES');
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - getProductionEnvironment()
Asignaciones con arrow functions encontradas (posibles funciones):
 - environmentRepository(new EnvironmentRepository();

  beforeEach(async ())
 - prodEnv(await environmentRepository.findOne({
      _parentId: session.environment._id,
      _organizationI...)
 - defaultLayout({
          layoutId: 'default-layout',
          name: 'Default Layout',
          source: LayoutCr...)
 - workflowResource(diffResult.body.data.resources.find(
          (resource: any))
 - layoutResource(diffResult.body.data.resources.find(
          (resource: any))
 - workflowDependency(layoutResource.dependencies.find((dep: any))
 - workflowResource(diffResult.body.data.resources.find(
          (resource))
 - layoutResource(diffResult.body.data.resources.find(
          (resource))
 - layoutDependency(workflowResource.dependencies.find(
          (dep))
 - workflowResource(body.data.resources.find(
          (resource))
 - localizationGroupResource(body.data.resources.find((resource))
 - change(localizationGroupResource.changes[0];
      expect(change.resourceType).to.equal('localization_group...)
 - localizationGroupResource(body.data.resources.find((resource))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/e2e/environments-v2-publish.e2e.ts
TamaÃ±o: 16039 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { CreateWorkflowDto, WorkflowCreationSourceEnum, WorkflowResponseDto } from '@novu/api/models/components';
import { EnvironmentRepository, NotificationTemplateRepository } from '@novu/dal';
import { EmailBlockTypeEnum, ResourceOriginEnum, StepTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdkInternalAuth } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Environment Publish - /v2/environments/:targetEnvironmentId/publish (POST) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  const environmentRepository = new EnvironmentRepository();
  const workflowRepository = new NotificationTemplateRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdkInternalAuth(session);
  });

  it('should return validation error for same source and target environment', async () => {
    const { body } = await session.testAgent
      .post(`/v2/environments/${session.environment._id}/publish`)
      .send({
        sourceEnvironmentId: session.environment._id,
      })
      .expect(400);

    expect(body.message).to.contain('Source and target environments cannot be the same');
  });

  it('should return validation error for invalid environment IDs', async () => {
    const { body } = await session.testAgent
      .post(`/v2/environments/invalid-id/publish`)
      .send({
        sourceEnvironmentId: 'invalid-id',
      })
      .expect(400);

    expect(body.message).to.contain('Invalid environment ID format');
  });

  it('should publish workflows successfully', async () => {
    // Get the production environment (automatically created with the session)
    const prodEnv = await environmentRepository.findOne({
      _parentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    if (!prodEnv) {
      throw new Error('Production environment not found');
    }

    // Create a workflow in the dev environment using the SDK
    const workflowData = {
      name: 'Test Workflow Publish',
      workflowId: 'test-workflow-publish',
      description: 'This is a test workflow for publishing',
      active: true,
      steps: [
        {
          name: 'Email Step',
          type: 'email' as const,
          controlValues: {
            subject: 'Test Subject for Publish',
            body: 'Test email content for publish',
          },
        },
      ],
      source: WorkflowCreationSourceEnum.Editor,
    };

    const { result: workflow } = await novuClient.workflows.create(workflowData);

    // Wait a bit for the workflow to be fully created
    await new Promise<void>((resolve) => {
      setTimeout(resolve, 100);
    });

    // Test actual publish (not dry run)
    const { body } = await session.testAgent
      .post(`/v2/environments/${prodEnv._id}/publish`)
      .send({
        sourceEnvironmentId: session.environment._id,
        dryRun: false,
      })
      .expect(200);

    expect(body.data.summary.resources).to.equal(1);
    expect(body.data.summary.successful).to.equal(1);
    expect(body.data.summary.failed).to.equal(0);
    expect(body.data.summary.skipped).to.equal(0);

    // Verify the workflow was actually created in the production environment
    const publishedWorkflow = await workflowRepository.findOne({
      _environmentId: prodEnv._id,
      _organizationId: session.organization._id,
      triggers: { $elemMatch: { identifier: workflow.workflowId } },
    });

    expect(publishedWorkflow).to.be.ok;
    expect(publishedWorkflow?.name).to.equal('Test Workflow Publish');
  });

  it('should use development environment as default source when sourceEnvironmentId is not provided', async () => {
    const prodEnv = await environmentRepository.findOne({
      _parentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    if (!prodEnv) {
      throw new Error('Production environment not found');
    }

    const workflowData = {
      name: 'Test Workflow Default Source',
      workflowId: 'test-workflow-default-source',
      description: 'This is a test workflow for default source',
      active: true,
      steps: [
        {
          name: 'Email Step',
          type: 'email' as const,
          controlValues: {
            subject: 'Test Subject Default',
            body: 'Test email content default',
          },
        },
      ],
      source: WorkflowCreationSourceEnum.Editor,
    };

    const { result: workflow } = await novuClient.workflows.create(workflowData);

    const { body } = await session.testAgent
      .post(`/v2/environments/${prodEnv._id}/publish`)
      .send({
        dryRun: true, // Use dry run to avoid side effects
      }) // No sourceEnvironmentId provided
      .expect(200);

    expect(body.data.summary.resources).to.equal(1);
    expect(body.data.summary.successful).to.equal(0);
    expect(body.data.summary.failed).to.equal(0);
    expect(body.data.summary.skipped).to.equal(1);
  });

  it('should publish specific workflows when resources is provided', async () => {
    // Get the production environment
    const prodEnv = await environmentRepository.findOne({
      _parentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    if (!prodEnv) {
      throw new Error('Production environment not found');
    }

    // Create multiple workflows in the dev environment
    const workflow1Data = {
      name: 'Test Workflow 1',
      workflowId: 'test-workflow-1',
      description: 'First test workflow',
      active: true,
      steps: [
        {
          name: 'Email Step 1',
          type: 'email' as const,
          controlValues: {
            subject: 'Test Subject 1',
            body: 'Test email content 1',
          },
        },
      ],
      source: WorkflowCreationSourceEnum.Editor,
    };

    const workflow2Data = {
      name: 'Test Workflow 2',
      workflowId: 'test-workflow-2',
      description: 'Second test workflow',
      active: true,
      steps: [
        {
          name: 'Email Step 2',
          type: 'email' as const,
          controlValues: {
            subject: 'Test Subject 2',
            body: 'Test email content 2',
          },
        },
      ],
      source: WorkflowCreationSourceEnum.Editor,
    };

    const { result: workflow1 } = await novuClient.workflows.create(workflow1Data);
    const { result: workflow2 } = await novuClient.workflows.create(workflow2Data);

    // Wait for workflows to be created
    await new Promise<void>((resolve) => {
      setTimeout(resolve, 100);
    });

    // Test selective publish - only publish the first workflow
    const { body } = await session.testAgent
      .post(`/v2/environments/${prodEnv._id}/publish`)
      .send({
        sourceEnvironmentId: session.environment._id,
        dryRun: false,
        resources: [
          {
            resourceType: 'workflow',
            resourceId: workflow1.workflowId,
          },
        ],
      })
      .expect(200);

    expect(body.data.summary.resources).to.equal(1);
    expect(body.data.summary.successful).to.equal(1);
    expect(body.data.summary.failed).to.equal(0);
    expect(body.data.summary.skipped).to.equal(0);

    // Verify only the first workflow was published
    const publishedWorkflow1 = await workflowRepository.findOne({
      _environmentId: prodEnv._id,
      _organizationId: session.organization._id,
      triggers: { $elemMatch: { identifier: workflow1.workflowId } },
    });

    const publishedWorkflow2 = await workflowRepository.findOne({
      _environmentId: prodEnv._id,
      _organizationId: session.organization._id,
      triggers: { $elemMatch: { identifier: workflow2.workflowId } },
    });

    expect(publishedWorkflow1).to.be.ok;
    expect(publishedWorkflow1?.name).to.equal('Test Workflow 1');
    expect(publishedWorkflow2).to.be.null; // Should not exist
  });

  it('should publish multiple resources of different types when resources contains mixed types', async () => {
    const prodEnv = await environmentRepository.findOne({
      _parentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    if (!prodEnv) {
      throw new Error('Production environment not found');
    }

    // Create two workflows instead of workflow + layout to avoid layout creation issues
    const workflow1Data = {
      name: 'Mixed Type Test Workflow 1',
      workflowId: 'mixed-type-workflow-1',
      description: 'First workflow for mixed type test',
      active: true,
      steps: [
        {
          name: 'Email Step 1',
          type: 'email' as const,
          controlValues: {
            subject: 'Mixed Type Subject 1',
            body: 'Mixed type email content 1',
          },
        },
      ],
      source: WorkflowCreationSourceEnum.Editor,
    };

    const workflow2Data = {
      name: 'Mixed Type Test Workflow 2',
      workflowId: 'mixed-type-workflow-2',
      description: 'Second workflow for mixed type test',
      active: true,
      steps: [
        {
          name: 'Email Step 2',
          type: 'email' as const,
          controlValues: {
            subject: 'Mixed Type Subject 2',
            body: 'Mixed type email content 2',
          },
        },
      ],
      source: WorkflowCreationSourceEnum.Editor,
    };

    const { result: workflow1 } = await novuClient.workflows.create(workflow1Data);
    const { result: workflow2 } = await novuClient.workflows.create(workflow2Data);

    await new Promise<void>((resolve) => {
      setTimeout(resolve, 100);
    });

    // Test selective publish with multiple workflows
    const { body } = await session.testAgent
      .post(`/v2/environments/${prodEnv._id}/publish`)
      .send({
        sourceEnvironmentId: session.environment._id,
        dryRun: false,
        resources: [
          {
            resourceType: 'workflow',
            resourceId: workflow1.workflowId,
          },
          {
            resourceType: 'workflow',
            resourceId: workflow2.workflowId,
          },
        ],
      })
      .expect(200);

    expect(body.data.summary.resources).to.equal(2);
    expect(body.data.summary.successful).to.equal(2);
    expect(body.data.summary.failed).to.equal(0);
    expect(body.data.summary.skipped).to.equal(0);

    // Verify both workflows were published
    const publishedWorkflow1 = await workflowRepository.findOne({
      _environmentId: prodEnv._id,
      _organizationId: session.organization._id,
      triggers: { $elemMatch: { identifier: workflow1.workflowId } },
    });

    const publishedWorkflow2 = await workflowRepository.findOne({
      _environmentId: prodEnv._id,
      _organizationId: session.organization._id,
      triggers: { $elemMatch: { identifier: workflow2.workflowId } },
    });

    expect(publishedWorkflow1).to.be.ok;
    expect(publishedWorkflow1?.name).to.equal('Mixed Type Test Workflow 1');
    expect(publishedWorkflow2).to.be.ok;
    expect(publishedWorkflow2?.name).to.equal('Mixed Type Test Workflow 2');
  });

  it('should work correctly in dry run mode with selective publishing', async () => {
    const prodEnv = await environmentRepository.findOne({
      _parentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    if (!prodEnv) {
      throw new Error('Production environment not found');
    }

    // Create a workflow
    const workflowData = {
      name: 'Dry Run Test Workflow',
      workflowId: 'dry-run-test-workflow',
      description: 'Workflow for dry run test',
      active: true,
      steps: [
        {
          name: 'Email Step',
          type: 'email' as const,
          controlValues: {
            subject: 'Dry Run Subject',
            body: 'Dry run email content',
          },
        },
      ],
      source: WorkflowCreationSourceEnum.Editor,
    };

    const { result: workflow } = await novuClient.workflows.create(workflowData);

    await new Promise<void>((resolve) => {
      setTimeout(resolve, 100);
    });

    // Test selective publish in dry run mode
    const { body } = await session.testAgent
      .post(`/v2/environments/${prodEnv._id}/publish`)
      .send({
        sourceEnvironmentId: session.environment._id,
        dryRun: true,
        resources: [
          {
            resourceType: 'workflow',
            resourceId: workflow.workflowId,
          },
        ],
      })
      .expect(200);

    expect(body.data.summary.resources).to.equal(1);
    expect(body.data.summary.successful).to.equal(0);
    expect(body.data.summary.failed).to.equal(0);
    expect(body.data.summary.skipped).to.equal(1);

    // Verify the workflow was NOT actually published (dry run)
    const publishedWorkflow = await workflowRepository.findOne({
      _environmentId: prodEnv._id,
      _organizationId: session.organization._id,
      triggers: { $elemMatch: { identifier: workflow.workflowId } },
    });

    expect(publishedWorkflow).to.be.null;
  });

  it('should return error when resources contains unsupported resource type', async () => {
    const prodEnv = await environmentRepository.findOne({
      _parentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    if (!prodEnv) {
      throw new Error('Production environment not found');
    }

    // Test with unsupported resource type
    const { body } = await session.testAgent
      .post(`/v2/environments/${prodEnv._id}/publish`)
      .send({
        sourceEnvironmentId: session.environment._id,
        dryRun: false,
        resources: [
          {
            resourceType: 'unsupported_type',
            resourceId: 'some-id',
          },
        ],
      })
      .expect(422); // Changed from 400 to 422 as it's a validation error

    expect(body.message).to.contain('Validation Error');
  });

  it('should fall back to full publish when resources is empty array', async () => {
    const prodEnv = await environmentRepository.findOne({
      _parentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    if (!prodEnv) {
      throw new Error('Production environment not found');
    }

    // Create a workflow
    const workflowData = {
      name: 'Fallback Test Workflow',
      workflowId: 'fallback-test-workflow',
      description: 'Workflow for fallback test',
      active: true,
      steps: [
        {
          name: 'Email Step',
          type: 'email' as const,
          controlValues: {
            subject: 'Fallback Subject',
            body: 'Fallback email content',
          },
        },
      ],
      source: WorkflowCreationSourceEnum.Editor,
    };

    const { result: workflow } = await novuClient.workflows.create(workflowData);

    await new Promise<void>((resolve) => {
      setTimeout(resolve, 100);
    });

    // Test with empty resources array (should fall back to full publish)
    const { body } = await session.testAgent
      .post(`/v2/environments/${prodEnv._id}/publish`)
      .send({
        sourceEnvironmentId: session.environment._id,
        dryRun: true, // Use dry run to avoid side effects
        resources: [], // Empty array
      })
      .expect(200);

    // Should process all available resources (fallback to full publish)
    expect(body.data.summary.resources).to.equal(1);
    expect(body.data.summary.skipped).to.equal(1); // Dry run skips
  });

  /*
   * Continue with the rest of the tests, updating all .post('/v2/environments/publish') calls
   * to use the new format .post(`/v2/environments/${targetEnvId}/publish`)
   * and removing targetEnvironmentId from the request body
   */

  async function createWorkflow(workflow: CreateWorkflowDto): Promise<WorkflowResponseDto> {
    const { result: createWorkflowBody } = await novuClient.workflows.create(workflow);

    return createWorkflowBody;
  }
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - createWorkflow(workflow: CreateWorkflowDto)
Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowRepository(new NotificationTemplateRepository();

  beforeEach(async ())
 - novuClient(initNovuClassSdkInternalAuth(session);
  });

  it('should return validation error for same source a...)
 - publishedWorkflow(await workflowRepository.findOne({
      _environmentId: prodEnv._id,
      _organizationId: session...)
 - publishedWorkflow2(await workflowRepository.findOne({
      _environmentId: prodEnv._id,
      _organizationId: session...)
 - publishedWorkflow2(await workflowRepository.findOne({
      _environmentId: prodEnv._id,
      _organizationId: session...)
 - publishedWorkflow(await workflowRepository.findOne({
      _environmentId: prodEnv._id,
      _organizationId: session...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/e2e/get-environment-tags.e2e.ts
TamaÃ±o: 4698 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { EnvironmentRepository, NotificationTemplateRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { expectSdkExceptionGeneric, initNovuClassSdkInternalAuth } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Get Environment Tags - /v2/environments/:environmentIdOrIdentifier/tags (GET) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  const environmentRepository = new EnvironmentRepository();
  const notificationTemplateRepository = new NotificationTemplateRepository();

  before(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdkInternalAuth(session);
  });

  it('should return correct tags for the environment using environment ID', async () => {
    await notificationTemplateRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _creatorId: session.user._id,
      name: 'Test Template 1',
      tags: ['tag1-by-id', 'tag2-by-id'],
      steps: [],
      triggers: [{ identifier: 'test-trigger-id-1', type: 'event' }],
    });
    await notificationTemplateRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _creatorId: session.user._id,
      name: 'Test Template 2',
      tags: ['tag2-by-id', 'tag3-by-id', null, '', undefined],
      steps: [],
      triggers: [{ identifier: 'test-trigger-id-2', type: 'event' }],
    });

    const response = await novuClient.environments.getTags(session.environment._id);

    expect(response.result).to.be.an('array');
    expect(response.result).to.deep.include({ name: 'tag1-by-id' });
    expect(response.result).to.deep.include({ name: 'tag2-by-id' });
    expect(response.result).to.deep.include({ name: 'tag3-by-id' });
  });

  it('should return correct tags for the environment using environment identifier', async () => {
    await notificationTemplateRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _creatorId: session.user._id,
      name: 'Test Template 3',
      tags: ['identifier-tag1', 'identifier-tag2'],
      steps: [],
      triggers: [{ identifier: 'test-trigger-identifier-1', type: 'event' }],
    });
    await notificationTemplateRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _creatorId: session.user._id,
      name: 'Test Template 4',
      tags: ['identifier-tag2', 'identifier-tag3'],
      steps: [],
      triggers: [{ identifier: 'test-trigger-identifier-2', type: 'event' }],
    });

    // Use the environment identifier instead of the _id
    const response = await novuClient.environments.getTags(session.environment.identifier);

    expect(response.result).to.be.an('array');
    expect(response.result).to.deep.include({ name: 'identifier-tag1' });
    expect(response.result).to.deep.include({ name: 'identifier-tag2' });
    expect(response.result).to.deep.include({ name: 'identifier-tag3' });
  });

  // Note: Testing empty tags scenarios is covered by the error cases,
  // so we don't need separate tests that create new environments

  it('should throw NotFoundException for non-existent environment ID', async () => {
    const nonExistentId = '60a5f2f2f2f2f2f2f2f2f2f2';
    const { error } = await expectSdkExceptionGeneric(() => novuClient.environments.getTags(nonExistentId));

    expect(error?.statusCode).to.equal(404);
    expect(error?.message).to.equal(`Environment ${nonExistentId} not found`);
  });

  it('should throw NotFoundException for non-existent environment identifier', async () => {
    const nonExistentIdentifier = 'non-existent-identifier';
    const { error } = await expectSdkExceptionGeneric(() => novuClient.environments.getTags(nonExistentIdentifier));

    expect(error?.statusCode).to.equal(404);
    expect(error?.message).to.equal(`Environment ${nonExistentIdentifier} not found`);
  });

  it('should throw NotFoundException when environment identifier belongs to different organization', async () => {
    /*
     * For this test, we'll test with a fake identifier that doesn't exist
     * since the identifier lookup includes organization filtering
     */
    const fakeIdentifier = 'fake-different-org-identifier';

    const { error } = await expectSdkExceptionGeneric(() => novuClient.environments.getTags(fakeIdentifier));

    expect(error?.statusCode).to.equal(404);
    expect(error?.message).to.equal(`Environment ${fakeIdentifier} not found`);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - notificationTemplateRepository(new NotificationTemplateRepository();

  before(async ())
 - novuClient(initNovuClassSdkInternalAuth(session);
  });

  it('should return correct tags for the environment u...)
 - response(await novuClient.environments.getTags(session.environment._id);

    expect(response.result).to.be.a...)
 - response(await novuClient.environments.getTags(session.environment.identifier);

    expect(response.result)....)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/services/dependency-analyzer.service.ts
TamaÃ±o: 12740 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { PinoLogger } from '@novu/application-generic';
import { ControlValuesRepository, LayoutRepository, NotificationTemplateRepository } from '@novu/dal';
import { ControlValuesLevelEnum, StepTypeEnum } from '@novu/shared';
import { WorkflowDataContainer } from '../../shared/containers/workflow-data.container';
import { WorkflowResponseDto } from '../../workflows-v2/dtos/workflow-response.dto';
import {
  DependencyReasonEnum,
  IDiffResult,
  IResourceDependency,
  IResourceDiff,
  ResourceTypeEnum,
} from '../types/sync.types';

@Injectable()
export class DependencyAnalyzerService {
  constructor(
    private logger: PinoLogger,
    private controlValuesRepository: ControlValuesRepository,
    private layoutRepository: LayoutRepository,
    private workflowRepository: NotificationTemplateRepository
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async analyzeDependencies(
    resources: IDiffResult[],
    sourceEnvId: string,
    targetEnvId: string,
    organizationId: string,
    workflowDataContainer?: WorkflowDataContainer
  ): Promise<Map<string, IResourceDependency[]>> {
    if (!workflowDataContainer) {
      throw new Error('WorkflowDataContainer is required for dependency analysis');
    }
    const dependencyMap = new Map<string, IResourceDependency[]>();

    // Create map of layout resources for quick lookup by ID
    const layoutResourceByIdMap = new Map<string, IDiffResult>();

    resources.forEach((resource) => {
      if (resource.resourceType === ResourceTypeEnum.LAYOUT) {
        if (resource.sourceResource?.id) {
          layoutResourceByIdMap.set(resource.sourceResource.id, resource);
        }
        // Handle deleted layouts (targetResource exists but sourceResource is null)
        if (resource.targetResource?.id && !resource.sourceResource) {
          layoutResourceByIdMap.set(resource.targetResource.id, resource);
        }
      }
    });

    this.logger.debug(`Found ${layoutResourceByIdMap.size} layouts by ID`);

    // Get all workflow resources for batched processing
    const workflowResources = resources.filter(
      (resource) => resource.resourceType === ResourceTypeEnum.WORKFLOW && resource.sourceResource?.id
    );

    if (workflowResources.length > 0) {
      // Use pre-loaded workflow data from container
      for (const resource of workflowResources) {
        this.logger.debug(
          `Analyzing dependencies for workflow: ${resource.sourceResource!.name} (${resource.sourceResource!.id})`
        );

        const workflowDto = workflowDataContainer.getWorkflowDto(resource.sourceResource?.id!, sourceEnvId);

        const dependencies = await this.getWorkflowDependencies(
          resource,
          layoutResourceByIdMap,
          targetEnvId,
          organizationId,
          workflowDto
        );

        if (dependencies.length > 0) {
          this.logger.debug(`Found ${dependencies.length} dependencies for workflow ${resource.sourceResource!.name}`);
          dependencyMap.set(resource.sourceResource?.id!, dependencies);
        }
      }
    }

    // Analyze reverse dependencies: layouts that are being deleted but are still used by workflows in target
    for (const resource of resources) {
      if (
        resource.resourceType === ResourceTypeEnum.LAYOUT &&
        resource.targetResource?.id &&
        !resource.sourceResource
      ) {
        this.logger.debug(
          `Analyzing reverse dependencies for deleted layout: ${resource.targetResource.name} (${resource.targetResource.id})`
        );

        const reverseDependencies = await this.getLayoutReverseDependencies(resource, targetEnvId, organizationId);

        if (reverseDependencies.length > 0) {
          this.logger.debug(
            `Found ${reverseDependencies.length} reverse dependencies for layout ${resource.targetResource.name}`
          );
          dependencyMap.set(resource.targetResource.id, reverseDependencies);
        }
      }
    }

    return dependencyMap;
  }

  async getWorkflowDependencies(
    workflowDiff: IDiffResult,
    layoutResourceByIdMap: Map<string, IDiffResult>,
    targetEnvId: string,
    organizationId: string,
    workflowDto?: WorkflowResponseDto
  ): Promise<IResourceDependency[]> {
    const dependencies: IResourceDependency[] = [];
    const processedLayoutIds = new Set<string>();

    try {
      if (workflowDiff.changes) {
        this.logger.debug(`Analyzing ${workflowDiff.changes.length} changes in workflow`);

        for (const change of workflowDiff.changes) {
          const isStepChange = change.resourceType === ResourceTypeEnum.STEP;
          const isEmailStep = change.stepType === StepTypeEnum.EMAIL;

          if (isStepChange && isEmailStep) {
            const layoutIds = this.extractLayoutIdsFromStepChange(change);

            for (const layoutId of layoutIds) {
              if (processedLayoutIds.has(layoutId)) continue;
              processedLayoutIds.add(layoutId);

              const dependency = await this.createLayoutDependency(
                layoutId,
                layoutResourceByIdMap,
                targetEnvId,
                organizationId
              );

              if (dependency) {
                this.logger.debug(
                  `Created dependency: workflow -> layout ${dependency.resourceName} (blocking: ${dependency.isBlocking})`
                );
                dependencies.push(dependency);
              }
            }
          }
        }
      }

      // Extract layout dependencies from workflow DTO steps
      if (workflowDto?.steps) {
        for (const step of workflowDto.steps) {
          // Check for layout ID in control values
          const controlValues = step.controlValues as Record<string, unknown> | undefined;
          const controlsValues = (step.controls as { values?: Record<string, unknown> })?.values;
          const layoutId = controlValues?.layoutId || controlsValues?.layoutId;

          if (!layoutId || typeof layoutId !== 'string' || processedLayoutIds.has(layoutId)) continue;
          processedLayoutIds.add(layoutId);

          const dependency = await this.createLayoutDependency(
            layoutId as string,
            layoutResourceByIdMap,
            targetEnvId,
            organizationId
          );

          if (dependency) {
            this.logger.debug(
              `Created dependency from step ${step.name}: workflow -> layout ${dependency.resourceName} (blocking: ${dependency.isBlocking})`
            );
            dependencies.push(dependency);
          }
        }
      }
    } catch (error) {
      this.logger.error(
        `Failed to analyze dependencies for workflow ${workflowDiff.sourceResource?.name || 'unknown'}`,
        error
      );
    }

    return dependencies;
  }

  async getLayoutReverseDependencies(
    deletedLayoutDiff: IDiffResult,
    targetEnvId: string,
    organizationId: string
  ): Promise<IResourceDependency[]> {
    const reverseDependencies: IResourceDependency[] = [];

    try {
      if (!deletedLayoutDiff.targetResource?.id) {
        return reverseDependencies;
      }

      const layoutId = deletedLayoutDiff.targetResource.id;
      this.logger.debug(`Checking if deleted layout ${layoutId} is still used by workflows in target environment`);

      // Find workflows in target environment that use this layout
      const controlValues = await this.controlValuesRepository.find({
        _environmentId: targetEnvId,
        _organizationId: organizationId,
        level: ControlValuesLevelEnum.STEP_CONTROLS,
        'controls.layoutId': layoutId,
      });

      this.logger.debug(
        `Found ${controlValues.length} control values using deleted layout ${layoutId} in target environment`
      );

      // Create blocking dependencies for each workflow using this layout
      const processedWorkflowIds = new Set<string>();

      for (const controlValue of controlValues) {
        const workflowId = controlValue._workflowId;
        if (!workflowId || processedWorkflowIds.has(workflowId)) continue;
        processedWorkflowIds.add(workflowId);

        // Fetch the actual workflow to get its name
        const workflow = await this.workflowRepository.findOne({
          _environmentId: targetEnvId,
          _organizationId: organizationId,
          _id: workflowId,
        });

        if (!workflow) {
          this.logger.warn(`Workflow ${workflowId} not found in target environment`);
          continue;
        }

        // Create a dependency showing this layout cannot be deleted because it's used by a workflow in target
        const dependency: IResourceDependency = {
          resourceType: ResourceTypeEnum.WORKFLOW,
          resourceId: workflow.triggers?.[0]?.identifier!,
          resourceName: workflow.name,
          isBlocking: true,
          reason: DependencyReasonEnum.LAYOUT_REQUIRED_FOR_WORKFLOW,
        };

        this.logger.debug(
          `Created blocking dependency: layout ${layoutId} -> workflow ${workflowId} (layout cannot be deleted)`
        );
        reverseDependencies.push(dependency);
      }
    } catch (error) {
      this.logger.error(
        `Failed to analyze reverse dependencies for deleted layout ${deletedLayoutDiff.targetResource?.name || 'unknown'}`,
        error
      );
    }

    return reverseDependencies;
  }

  extractLayoutIdsFromStepChange(stepChange: IResourceDiff): string[] {
    const layoutIds: string[] = [];

    // Check current/new layout ID - this is what the workflow actually depends on
    const newLayoutId = stepChange.diffs?.new?.controlValues?.layoutId;

    if (newLayoutId && typeof newLayoutId === 'string') {
      layoutIds.push(newLayoutId);
    }

    /*
     * Note: We intentionally don't include the previous layout ID as a dependency
     * because the workflow is moving away from it and no longer needs it
     */

    return layoutIds;
  }

  async createLayoutDependency(
    layoutId: string,
    layoutResourceByIdMap: Map<string, IDiffResult>,
    targetEnvId: string,
    organizationId: string
  ): Promise<IResourceDependency | null> {
    this.logger.debug(`Creating layout dependency for layoutId: ${layoutId}`);

    const layoutDiff = layoutResourceByIdMap.get(layoutId);

    /*
     * If the layout is being deleted (exists in target but not in source),
     * don't create a dependency for the workflow
     */
    if (layoutDiff?.summary?.deleted && layoutDiff.summary.deleted > 0) {
      this.logger.debug(`Layout ${layoutId} is being deleted - not creating dependency for workflow`);

      return null;
    }

    const targetLayout = await this.layoutRepository.findOne({
      _environmentId: targetEnvId,
      _organizationId: organizationId,
      layoutId,
    });

    this.logger.debug(`Layout ${layoutId} exists in target environment: ${!!targetLayout}`);

    this.logger.debug(
      `Layout ${layoutId} found in diff results: ${!!layoutDiff} (added: ${layoutDiff?.summary?.added || 0})`
    );

    const isBlocking = this.isDependencyBlocking(targetLayout, layoutDiff);
    const reason = isBlocking
      ? DependencyReasonEnum.LAYOUT_REQUIRED_FOR_WORKFLOW
      : DependencyReasonEnum.LAYOUT_EXISTS_IN_TARGET;

    this.logger.debug(
      `Layout dependency ${layoutId} is ${isBlocking ? 'blocking' : 'non-blocking'} (reason: ${reason})`
    );

    return {
      resourceType: ResourceTypeEnum.LAYOUT,
      resourceId: layoutId,
      resourceName: layoutDiff?.sourceResource?.name || layoutId || '',
      isBlocking,
      reason,
    };
  }

  isDependencyBlocking(targetLayout: unknown, layoutDiff?: IDiffResult): boolean {
    // If layout doesn't exist in target and there's a new layout being added, it's blocking
    if (!targetLayout && layoutDiff?.summary?.added && layoutDiff.summary.added > 0) {
      this.logger.debug("Dependency is blocking: layout doesn't exist in target but is being added");

      return true;
    }

    /*
     * If layout is being deleted in the diff, it's NOT blocking for workflows
     * Workflows can function without a specific layout (they can use another layout or null)
     */
    if (layoutDiff?.summary?.deleted && layoutDiff.summary.deleted > 0) {
      this.logger.debug('Layout is being deleted, but workflow can function without it - not blocking');

      return false;
    }

    // If layout doesn't exist in target at all (and not in diff), it's blocking
    if (!targetLayout && !layoutDiff) {
      this.logger.debug("Dependency is blocking: layout doesn't exist in target and not in diff");

      return true;
    }

    this.logger.debug('Dependency is not blocking');

    return false;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - layoutResourceByIdMap(new Map<string, IDiffResult>();

    resources.forEach((resource))
 - workflowResources(resources.filter(
      (resource))
Declaraciones 'export' encontradas:
- export class DependencyAnalyzerService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/services/environment-validation.service.ts
TamaÃ±o: 2112 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { BaseRepository, EnvironmentRepository } from '@novu/dal';
import { EnvironmentEnum, UserSessionData } from '@novu/shared';

export interface IEnvironmentValidationParams {
  sourceEnvironmentId: string;
  targetEnvironmentId: string;
  user: UserSessionData;
}

@Injectable()
export class EnvironmentValidationService {
  constructor(private environmentRepository: EnvironmentRepository) {}

  async validateEnvironments(params: IEnvironmentValidationParams): Promise<void> {
    const { sourceEnvironmentId, targetEnvironmentId, user } = params;

    if (sourceEnvironmentId === targetEnvironmentId) {
      throw new BadRequestException('Source and target environments cannot be the same');
    }

    if (!BaseRepository.isInternalId(sourceEnvironmentId) || !BaseRepository.isInternalId(targetEnvironmentId)) {
      throw new BadRequestException('Invalid environment ID format');
    }

    try {
      const [sourceEnv, targetEnv] = await Promise.all([
        this.environmentRepository.findOne({
          _id: sourceEnvironmentId,
          _organizationId: user.organizationId,
        }),
        this.environmentRepository.findOne({
          _id: targetEnvironmentId,
          _organizationId: user.organizationId,
        }),
      ]);

      if (!sourceEnv) {
        throw new BadRequestException('Source environment not found');
      }

      if (!targetEnv) {
        throw new BadRequestException('Target environment not found');
      }
    } catch (error) {
      if (error.name === 'CastError') {
        throw new BadRequestException('Invalid environment ID format');
      }
      throw error;
    }
  }

  async getDevelopmentEnvironmentId(organizationId: string): Promise<string> {
    const developmentEnvironment = await this.environmentRepository.findOne({
      _organizationId: organizationId,
      name: EnvironmentEnum.DEVELOPMENT,
    });

    if (!developmentEnvironment) {
      throw new BadRequestException('Development environment not found');
    }

    return developmentEnvironment._id;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  interface
- export class EnvironmentValidationService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/services/index.ts
TamaÃ±o: 97 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './dependency-analyzer.service';
export * from './environment-validation.service';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/types/sync.types.ts
TamaÃ±o: 3658 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ClientSession } from '@novu/dal';
import { UserSessionData } from '@novu/shared';

export enum ResourceTypeEnum {
  WORKFLOW = 'workflow',
  STEP = 'step',
  LOCALIZATION_GROUP = 'localization_group',
  LAYOUT = 'layout',
}

export enum DependencyReasonEnum {
  LAYOUT_REQUIRED_FOR_WORKFLOW = 'LAYOUT_REQUIRED_FOR_WORKFLOW',
  LAYOUT_EXISTS_IN_TARGET = 'LAYOUT_EXISTS_IN_TARGET',
}

export interface IResourceDependency {
  resourceType: ResourceTypeEnum;
  resourceId: string;
  resourceName: string;
  isBlocking: boolean;
  reason: DependencyReasonEnum;
}

export interface IResourceToPublish {
  resourceType: ResourceTypeEnum;
  resourceId: string;
}

export interface ISyncOptions {
  dryRun?: boolean;
  batchSize?: number;
  resources?: IResourceToPublish[];
}

export interface ISyncContext {
  sourceEnvironmentId: string;
  targetEnvironmentId: string;
  user: UserSessionData;
  options: ISyncOptions;
  session?: ClientSession | null;
}

export interface ISyncedEntity {
  resourceType: ResourceTypeEnum;
  resourceId: string;
  resourceName: string;
  action: 'created' | 'updated' | 'skipped' | 'deleted';
}

export interface IFailedEntity {
  resourceType: ResourceTypeEnum;
  resourceId: string;
  resourceName: string;
  error: string;
  stack?: string;
}

export interface ISkippedEntity {
  resourceType: ResourceTypeEnum;
  resourceId: string;
  resourceName: string;
  reason: string;
}

export interface ISyncResult {
  resourceType: ResourceTypeEnum;
  successful: ISyncedEntity[];
  failed: IFailedEntity[];
  skipped: ISkippedEntity[];
  totalProcessed: number;
}

export interface IPublishResult {
  results: ISyncResult[];
  summary: {
    resources: number;
    successful: number;
    failed: number;
    skipped: number;
  };
}

export enum DiffActionEnum {
  ADDED = 'added',
  MODIFIED = 'modified',
  DELETED = 'deleted',
  UNCHANGED = 'unchanged',
  MOVED = 'moved',
}

export interface IUserInfo {
  _id: string;
  firstName: string;
  lastName?: string | null;
  externalId?: string;
}

export interface IResourceInfo {
  id: string | null;
  name: string | null;
  updatedBy?: IUserInfo | null;
  updatedAt?: string | null;
}

export interface IResourceDiff {
  sourceResource?: IResourceInfo | null;
  targetResource?: IResourceInfo | null;
  resourceType: ResourceTypeEnum;
  action: DiffActionEnum;
  diffs?: {
    previous: Record<string, any> | null;
    new: Record<string, any> | null;
  };
  // Step-specific fields
  stepType?: string;
  previousIndex?: number;
  newIndex?: number;
}

export interface IDiffResult {
  resourceType: ResourceTypeEnum;
  sourceResource?: IResourceInfo | null;
  targetResource?: IResourceInfo | null;
  changes: IResourceDiff[];
  summary: {
    added: number;
    modified: number;
    deleted: number;
    unchanged: number;
  };
  dependencies?: IResourceDependency[];
}

export interface IEnvironmentDiffResult {
  sourceEnvironmentId: string;
  targetEnvironmentId: string;
  resources: IDiffResult[];
  summary: {
    totalEntities: number;
    totalChanges: number;
    hasChanges: boolean;
  };
}

export interface ISyncStrategy {
  getResourceType(): ResourceTypeEnum;
  execute(context: ISyncContext): Promise<ISyncResult>;
  diff(
    sourceEnvId: string,
    targetEnvId: string,
    organizationId: string,
    userContext: UserSessionData
  ): Promise<IDiffResult[]>;
  getAvailableResourceIds(sourceEnvironmentId: string, organizationId: string): Promise<string[]>;
}

export interface ISyncProgress {
  resourceType: ResourceTypeEnum;
  total: number;
  processed: number;
  failed: number;
  currentEntity?: string;
  estimatedTimeRemaining?: number;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  enum
- export  enum
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface
- export  enum
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/diff-environment/diff-environment.command.ts
TamaÃ±o: 324 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserObjectCommand } from '@novu/application-generic';
import { IsOptional, IsString } from 'class-validator';

export class DiffEnvironmentCommand extends EnvironmentWithUserObjectCommand {
  @IsOptional()
  @IsString()
  sourceEnvironmentId?: string;

  @IsString()
  targetEnvironmentId: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class DiffEnvironmentCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/diff-environment/diff-environment.usecase.ts
TamaÃ±o: 5565 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { InstrumentUsecase, PinoLogger } from '@novu/application-generic';
import {
  BaseRepository,
  ControlValuesRepository,
  NotificationTemplateRepository,
  PreferencesRepository,
} from '@novu/dal';
import { ResourceOriginEnum, ResourceTypeEnum } from '@novu/shared';
import { WorkflowDataContainer } from '../../../shared/containers/workflow-data.container';
import { DependencyAnalyzerService, EnvironmentValidationService } from '../../services';
import { IDiffResult, IEnvironmentDiffResult } from '../../types/sync.types';
import { LayoutSyncStrategy } from '../sync-strategies/layout-sync.strategy';
import { WorkflowSyncStrategy } from '../sync-strategies/workflow-sync.strategy';
import { DiffEnvironmentCommand } from './diff-environment.command';

@Injectable()
export class DiffEnvironmentUseCase {
  constructor(
    private logger: PinoLogger,
    private environmentValidationService: EnvironmentValidationService,
    private workflowSyncStrategy: WorkflowSyncStrategy,
    private layoutSyncStrategy: LayoutSyncStrategy,
    private dependencyAnalyzerService: DependencyAnalyzerService,
    private controlValuesRepository: ControlValuesRepository,
    private workflowRepository: NotificationTemplateRepository,
    private preferencesRepository: PreferencesRepository
  ) {
    this.logger.setContext(this.constructor.name);
  }

  @InstrumentUsecase()
  async execute(command: DiffEnvironmentCommand): Promise<IEnvironmentDiffResult> {
    try {
      if (!BaseRepository.isInternalId(command.targetEnvironmentId)) {
        throw new BadRequestException('Invalid environment ID format');
      }

      const sourceEnvironmentId =
        command.sourceEnvironmentId ||
        (await this.environmentValidationService.getDevelopmentEnvironmentId(command.user.organizationId));

      await this.environmentValidationService.validateEnvironments({
        sourceEnvironmentId,
        targetEnvironmentId: command.targetEnvironmentId,
        user: command.user,
      });

      this.logger.info(`Starting environment diff between ${sourceEnvironmentId} and ${command.targetEnvironmentId}`);

      // Create workflow data container and pre-load workflow data for optimization
      const workflowDataContainer = new WorkflowDataContainer(this.controlValuesRepository, this.preferencesRepository);

      const workflows = await this.workflowRepository.findWithTemplates({
        _environmentId: { $in: [sourceEnvironmentId, command.targetEnvironmentId] },
        origin: ResourceOriginEnum.NOVU_CLOUD,
        type: ResourceTypeEnum.BRIDGE,
        _organizationId: command.user.organizationId,
      });

      this.logger.info(`Pre-loading data for ${workflows.length} workflows before diff`);
      await workflowDataContainer.loadWorkflowsWithControlValues(
        workflows,
        sourceEnvironmentId,
        command.user.organizationId,
        command.targetEnvironmentId
      );

      // Execute diff with workflow container optimization and layout strategy normally
      const [workflowDiffResults, layoutDiffResults] = await Promise.all([
        this.workflowSyncStrategy.diff(
          sourceEnvironmentId,
          command.targetEnvironmentId,
          command.user.organizationId,
          command.user,
          workflowDataContainer
        ),
        this.layoutSyncStrategy.diff(
          sourceEnvironmentId,
          command.targetEnvironmentId,
          command.user.organizationId,
          command.user
        ),
      ]);

      const resources = [...workflowDiffResults, ...layoutDiffResults];

      const dependencyMap = await this.dependencyAnalyzerService.analyzeDependencies(
        resources,
        sourceEnvironmentId,
        command.targetEnvironmentId,
        command.user.organizationId,
        workflowDataContainer
      );

      // Add dependencies to resources
      for (const resource of resources) {
        if (resource.sourceResource?.id && dependencyMap.has(resource.sourceResource.id)) {
          resource.dependencies = dependencyMap.get(resource.sourceResource.id);
        }
        // Check target resource ID for deleted resources (sourceResource is null, targetResource exists)
        if (!resource.sourceResource && resource.targetResource?.id && dependencyMap.has(resource.targetResource.id)) {
          resource.dependencies = dependencyMap.get(resource.targetResource.id);
        }
      }

      const summary = this.calculateSummary(resources);

      this.logger.info(
        `Environment diff completed. Total entities: ${summary.totalEntities}, ` +
          `Total changes: ${summary.totalChanges}, Has changes: ${summary.hasChanges}`
      );

      return {
        sourceEnvironmentId,
        targetEnvironmentId: command.targetEnvironmentId,
        resources,
        summary,
      };
    } catch (error) {
      this.logger.error('Environment diff failed', error);
      throw error;
    }
  }

  private calculateSummary(resources: IDiffResult[]) {
    const summary = {
      totalEntities: 0,
      totalChanges: 0,
      hasChanges: false,
    };

    for (const resource of resources) {
      summary.totalEntities += 1; // Each resource is now a single entity (workflow)

      // Count all changes (both workflow and step level)
      const entitySummary = resource.summary;
      summary.totalChanges += entitySummary.added + entitySummary.modified + entitySummary.deleted;
    }

    summary.hasChanges = summary.totalChanges > 0;

    return summary;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class DiffEnvironmentUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/diff-environment/index.ts
TamaÃ±o: 88 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './diff-environment.command';
export * from './diff-environment.usecase';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/get-environment-tags/get-environment-tags.command.ts
TamaÃ±o: 325 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsNotEmpty } from 'class-validator';

export class GetEnvironmentTagsCommand extends BaseCommand {
  @IsNotEmpty()
  readonly environmentIdOrIdentifier: string;

  @IsNotEmpty()
  readonly organizationId: string;

  @IsNotEmpty()
  readonly userId: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class GetEnvironmentTagsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/get-environment-tags/get-environment-tags.usecase.ts
TamaÃ±o: 2075 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { BaseRepository, EnvironmentEntity, EnvironmentRepository, NotificationTemplateRepository } from '@novu/dal';
import { GetEnvironmentTagsDto } from '../../dtos/get-environment-tags.dto';
import { GetEnvironmentTagsCommand } from './get-environment-tags.command';

@Injectable()
export class GetEnvironmentTags {
  constructor(
    private environmentRepository: EnvironmentRepository,
    private notificationTemplateRepository: NotificationTemplateRepository
  ) {}

  async execute(command: GetEnvironmentTagsCommand): Promise<GetEnvironmentTagsDto[]> {
    const environment = await this.resolveEnvironment(command);

    if (!environment) {
      throw new NotFoundException(`Environment ${command.environmentIdOrIdentifier} not found`);
    }

    const notificationTemplates = await this.notificationTemplateRepository.find({
      _environmentId: environment._id,
      tags: { $exists: true, $type: 'array', $ne: [] },
    });

    const tags = notificationTemplates.flatMap((template) => template.tags);
    const uniqueTags = Array.from(new Set(tags));

    return this.sanitizeTags(uniqueTags);
  }

  private async resolveEnvironment(command: GetEnvironmentTagsCommand): Promise<EnvironmentEntity | null> {
    const isInternalId = BaseRepository.isInternalId(command.environmentIdOrIdentifier);

    if (isInternalId) {
      return await this.environmentRepository.findOne(
        {
          _id: command.environmentIdOrIdentifier,
          _organizationId: command.organizationId,
        },
        '-apiKeys'
      );
    } else {
      const environment = await this.environmentRepository.findEnvironmentByIdentifier(
        command.environmentIdOrIdentifier
      );

      if (environment && environment._organizationId === command.organizationId) {
        return environment;
      }

      return null;
    }
  }

  private sanitizeTags(tags: string[]): GetEnvironmentTagsDto[] {
    return tags.filter((tag) => tag != null && tag !== '').map((tag) => ({ name: tag }));
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - tags(notificationTemplates.flatMap((template))
Declaraciones 'export' encontradas:
- export class GetEnvironmentTags

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/get-environment-tags/index.ts
TamaÃ±o: 96 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-environment-tags.command';
export * from './get-environment-tags.usecase';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/publish-environment/index.ts
TamaÃ±o: 94 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './publish-environment.command';
export * from './publish-environment.usecase';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/publish-environment/publish-environment.command.ts
TamaÃ±o: 743 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserObjectCommand } from '@novu/application-generic';
import { Type } from 'class-transformer';
import { IsArray, IsBoolean, IsEnum, IsOptional, IsString, ValidateNested } from 'class-validator';
import { ResourceTypeEnum } from '../../types/sync.types';

export interface IResourceToPublish {
  resourceType: ResourceTypeEnum;
  resourceId: string;
}

export class PublishEnvironmentCommand extends EnvironmentWithUserObjectCommand {
  @IsOptional()
  @IsString()
  sourceEnvironmentId?: string;

  @IsString()
  targetEnvironmentId: string;

  @IsOptional()
  @IsBoolean()
  dryRun?: boolean;

  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => Object)
  resources?: IResourceToPublish[];
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  interface
- export class PublishEnvironmentCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/publish-environment/publish-environment.usecase.ts
TamaÃ±o: 3734 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { InstrumentUsecase, PinoLogger } from '@novu/application-generic';
import { BaseRepository } from '@novu/dal';
import { EnvironmentValidationService } from '../../services';
import { IPublishResult, ISyncContext, ISyncOptions, ISyncResult, ISyncStrategy } from '../../types/sync.types';
import { LayoutSyncStrategy } from '../sync-strategies/layout-sync.strategy';
import { WorkflowSyncStrategy } from '../sync-strategies/workflow-sync.strategy';
import { PublishEnvironmentCommand } from './publish-environment.command';

const PUBLISH_BATCH_SIZE = 100;

@Injectable()
export class PublishEnvironmentUseCase {
  constructor(
    private logger: PinoLogger,
    private environmentValidationService: EnvironmentValidationService,
    private workflowSyncStrategy: WorkflowSyncStrategy,
    private layoutSyncStrategy: LayoutSyncStrategy
  ) {
    this.logger.setContext(this.constructor.name);
  }

  @InstrumentUsecase()
  async execute(command: PublishEnvironmentCommand): Promise<IPublishResult> {
    try {
      if (!BaseRepository.isInternalId(command.targetEnvironmentId)) {
        throw new BadRequestException('Invalid environment ID format');
      }

      const sourceEnvironmentId =
        command.sourceEnvironmentId ||
        (await this.environmentValidationService.getDevelopmentEnvironmentId(command.user.organizationId));

      await this.environmentValidationService.validateEnvironments({
        sourceEnvironmentId,
        targetEnvironmentId: command.targetEnvironmentId,
        user: command.user,
      });

      const options: ISyncOptions = {
        dryRun: command.dryRun || false,
        batchSize: PUBLISH_BATCH_SIZE,
        resources: command.resources,
      };

      const syncContext: ISyncContext = {
        sourceEnvironmentId,
        targetEnvironmentId: command.targetEnvironmentId,
        user: command.user,
        options,
      };

      this.logger.info(`Starting environment publish from ${sourceEnvironmentId} to ${command.targetEnvironmentId}`);

      const strategies = [this.workflowSyncStrategy, this.layoutSyncStrategy];

      const results = await this.executeSync(strategies, syncContext);

      const summary = this.calculateSummary(results);

      this.logger.info(
        `Environment publish completed. Processed: ${summary.resources}, ` +
          `Successful: ${summary.successful}, Failed: ${summary.failed}, ` +
          `Skipped: ${summary.skipped}`
      );

      return {
        results,
        summary,
      };
    } catch (error) {
      this.logger.error(`Environment publish failed: ${error.message}`);
      throw error;
    }
  }

  private async executeSync(strategies: ISyncStrategy[], context: ISyncContext): Promise<ISyncResult[]> {
    const results: ISyncResult[] = [];

    if (context.options.dryRun) {
      // For dry runs, we don't need transactions
      for (const strategy of strategies) {
        const result = await strategy.execute(context);
        results.push(result);
      }
    } else {
      // For actual sync, use transactions for atomicity
      for (const strategy of strategies) {
        const result = await strategy.execute(context);

        results.push(result);
      }
    }

    return results;
  }

  private calculateSummary(results: ISyncResult[]) {
    const summary = {
      resources: 0,
      successful: 0,
      failed: 0,
      skipped: 0,
    };

    for (const result of results) {
      summary.resources += result.totalProcessed;
      summary.successful += result.successful.length;
      summary.failed += result.failed.length;
      summary.skipped += result.skipped.length;
    }

    return summary;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class PublishEnvironmentUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/index.ts
TamaÃ±o: 85 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './base/base-sync.strategy';
export * from './workflow-sync.strategy';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/layout-sync.strategy.ts
TamaÃ±o: 1381 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { PinoLogger } from '@novu/application-generic';
import { UserSessionData } from '@novu/shared';
import { IDiffResult, ISyncContext, ISyncResult, ResourceTypeEnum } from '../../types/sync.types';
import { BaseSyncStrategy } from './base/base-sync.strategy';
import { LayoutDiffOperation } from './operations/layout-diff.operation';
import { LayoutSyncOperation } from './operations/layout-sync.operation';

@Injectable()
export class LayoutSyncStrategy extends BaseSyncStrategy {
  constructor(
    logger: PinoLogger,
    private layoutSyncOperation: LayoutSyncOperation,
    private layoutDiffOperation: LayoutDiffOperation
  ) {
    super(logger);
  }

  getResourceType(): ResourceTypeEnum {
    return ResourceTypeEnum.LAYOUT;
  }

  async execute(context: ISyncContext): Promise<ISyncResult> {
    return this.layoutSyncOperation.execute(context);
  }

  async diff(
    sourceEnvId: string,
    targetEnvId: string,
    organizationId: string,
    userContext: UserSessionData
  ): Promise<IDiffResult[]> {
    return this.layoutDiffOperation.execute(sourceEnvId, targetEnvId, organizationId, userContext);
  }

  async getAvailableResourceIds(sourceEnvironmentId: string, organizationId: string): Promise<string[]> {
    return this.layoutSyncOperation.getAvailableResourceIds(sourceEnvironmentId, organizationId);
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class LayoutSyncStrategy

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/sync.module.ts
TamaÃ±o: 3216 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { DeletePreferencesUseCase, GetWorkflowByIdsUseCase } from '@novu/application-generic';
import { LayoutsV2Module } from '../../../layouts-v2/layouts.module';
import { DeleteLayoutUseCase } from '../../../layouts-v2/usecases/delete-layout';
import { LayoutSyncToEnvironmentUseCase } from '../../../layouts-v2/usecases/sync-to-environment';
import { OutboundWebhooksModule } from '../../../outbound-webhooks/outbound-webhooks.module';
import { SharedModule } from '../../../shared/shared.module';
import { DeleteWorkflowUseCase } from '../../../workflows-v1/usecases/delete-workflow/delete-workflow.usecase';
import { SyncToEnvironmentUseCase } from '../../../workflows-v2/usecases/sync-to-environment/sync-to-environment.usecase';
import { WorkflowModule } from '../../../workflows-v2/workflow.module';
import {
  WorkflowComparatorAdapter,
  WorkflowDeleteAdapter,
  WorkflowRepositoryAdapter,
  WorkflowSyncAdapter,
} from './adapters';
import { LayoutComparatorAdapter } from './adapters/layout-comparator.adapter';
import { LayoutDeleteAdapter } from './adapters/layout-delete.adapter';
import { LayoutRepositoryAdapter } from './adapters/layout-repository.adapter';
import { LayoutSyncAdapter } from './adapters/layout-sync.adapter';
import { LayoutComparator } from './comparators/layout.comparator';
import { WorkflowComparator } from './comparators/workflow.comparator';
import { LayoutSyncStrategy } from './layout-sync.strategy';
import { LayoutNormalizer } from './normalizers/layout.normalizer';
import { WorkflowNormalizer } from './normalizers/workflow.normalizer';
import { LayoutDiffOperation } from './operations/layout-diff.operation';
import { LayoutRepositoryService } from './operations/layout-repository.service';
import { LayoutSyncOperation } from './operations/layout-sync.operation';
import { WorkflowDiffOperation } from './operations/workflow-diff.operation';
import { WorkflowRepositoryService } from './operations/workflow-repository.service';
import { WorkflowSyncOperation } from './operations/workflow-sync.operation';
import { WorkflowSyncStrategy } from './workflow-sync.strategy';

@Module({
  imports: [SharedModule, WorkflowModule, LayoutsV2Module, OutboundWebhooksModule.forRoot()],
  providers: [
    // Repository services
    WorkflowRepositoryService,
    LayoutRepositoryService,

    // Normalizers
    WorkflowNormalizer,
    LayoutNormalizer,

    // Comparators
    WorkflowComparator,
    LayoutComparator,

    // Adapters
    WorkflowRepositoryAdapter,
    WorkflowSyncAdapter,
    WorkflowDeleteAdapter,
    WorkflowComparatorAdapter,
    LayoutRepositoryAdapter,
    LayoutSyncAdapter,
    LayoutDeleteAdapter,
    LayoutComparatorAdapter,

    // Operations
    WorkflowSyncOperation,
    WorkflowDiffOperation,
    LayoutSyncOperation,
    LayoutDiffOperation,

    // Usecases
    SyncToEnvironmentUseCase,
    DeleteWorkflowUseCase,
    GetWorkflowByIdsUseCase,
    DeletePreferencesUseCase,
    LayoutSyncToEnvironmentUseCase,
    DeleteLayoutUseCase,

    // Strategies
    WorkflowSyncStrategy,
    LayoutSyncStrategy,
  ],
  exports: [WorkflowSyncStrategy, LayoutSyncStrategy],
})
export class SyncModule {}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class SyncModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/workflow-sync.strategy.ts
TamaÃ±o: 1739 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { PinoLogger } from '@novu/application-generic';
import { UserSessionData } from '@novu/shared';
import { WorkflowDataContainer } from '../../../shared/containers/workflow-data.container';
import { IDiffResult, ISyncContext, ISyncResult, ResourceTypeEnum } from '../../types/sync.types';
import { BaseSyncStrategy } from './base/base-sync.strategy';
import { WorkflowDiffOperation } from './operations/workflow-diff.operation';
import { WorkflowSyncOperation } from './operations/workflow-sync.operation';

@Injectable()
export class WorkflowSyncStrategy extends BaseSyncStrategy {
  constructor(
    logger: PinoLogger,
    private workflowSyncOperation: WorkflowSyncOperation,
    private workflowDiffOperation: WorkflowDiffOperation
  ) {
    super(logger);
  }

  getResourceType(): ResourceTypeEnum {
    return ResourceTypeEnum.WORKFLOW;
  }

  async execute(context: ISyncContext): Promise<ISyncResult> {
    return this.workflowSyncOperation.execute(context);
  }

  async diff(
    sourceEnvId: string,
    targetEnvId: string,
    organizationId: string,
    userContext: UserSessionData,
    workflowDataContainer?: WorkflowDataContainer
  ): Promise<IDiffResult[]> {
    if (!workflowDataContainer) {
      throw new Error('WorkflowDataContainer is required for workflow diff operations');
    }

    return this.workflowDiffOperation.execute(
      sourceEnvId,
      targetEnvId,
      organizationId,
      userContext,
      workflowDataContainer
    );
  }

  async getAvailableResourceIds(sourceEnvironmentId: string, organizationId: string): Promise<string[]> {
    return this.workflowSyncOperation.getAvailableResourceIds(sourceEnvironmentId, organizationId);
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class WorkflowSyncStrategy

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/adapters/index.ts
TamaÃ±o: 280 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { WorkflowComparatorAdapter } from './workflow-comparator.adapter';
export { WorkflowDeleteAdapter } from './workflow-delete.adapter';
export { WorkflowRepositoryAdapter } from './workflow-repository.adapter';
export { WorkflowSyncAdapter } from './workflow-sync.adapter';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/adapters/layout-comparator.adapter.ts
TamaÃ±o: 1076 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { LayoutEntity } from '@novu/dal';
import { UserSessionData } from '@novu/shared';
import { WorkflowDataContainer } from '../../../../shared/containers/workflow-data.container';
import { IResourceDiff } from '../../../types/sync.types';
import { IBaseComparator } from '../base/interfaces/base-comparator.interface';
import { LayoutComparator } from '../comparators/layout.comparator';

@Injectable()
export class LayoutComparatorAdapter implements IBaseComparator<LayoutEntity> {
  constructor(private readonly layoutComparator: LayoutComparator) {}

  async compareResources(
    sourceResource: LayoutEntity,
    targetResource: LayoutEntity,
    _: UserSessionData
  ): Promise<{
    resourceChanges: {
      previous: Record<string, unknown> | null;
      new: Record<string, unknown> | null;
    } | null;
    otherDiffs?: IResourceDiff[];
  }> {
    const { layoutChanges } = await this.layoutComparator.compareLayouts(sourceResource, targetResource);

    return {
      resourceChanges: layoutChanges,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class LayoutComparatorAdapter

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/adapters/layout-delete.adapter.ts
TamaÃ±o: 1249 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { LayoutEntity, NotificationTemplateEntity } from '@novu/dal';
import { DeleteLayoutCommand } from '../../../../layouts-v2/usecases/delete-layout/delete-layout.command';
import { DeleteLayoutUseCase } from '../../../../layouts-v2/usecases/delete-layout/delete-layout.use-case';
import { DeleteWorkflowCommand } from '../../../../workflows-v1/usecases/delete-workflow/delete-workflow.command';
import { DeleteWorkflowUseCase } from '../../../../workflows-v1/usecases/delete-workflow/delete-workflow.usecase';
import { ISyncContext } from '../../../types/sync.types';
import { IBaseDeleteService } from '../base/interfaces/base-delete.interface';

@Injectable()
export class LayoutDeleteAdapter implements IBaseDeleteService<LayoutEntity> {
  constructor(private readonly deleteLayoutUseCase: DeleteLayoutUseCase) {}

  async deleteResourceFromTarget(context: ISyncContext, resource: LayoutEntity): Promise<void> {
    await this.deleteLayoutUseCase.execute(
      DeleteLayoutCommand.create({
        layoutIdOrInternalId: resource._id,
        environmentId: context.targetEnvironmentId,
        organizationId: context.user.organizationId,
        userId: context.user._id,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class LayoutDeleteAdapter

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/adapters/layout-repository.adapter.ts
TamaÃ±o: 937 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { LayoutEntity } from '@novu/dal';
import { IBaseRepositoryService } from '../base/interfaces/base-repository.interface';
import { LayoutRepositoryService } from '../operations/layout-repository.service';

@Injectable()
export class LayoutRepositoryAdapter implements IBaseRepositoryService<LayoutEntity> {
  constructor(private readonly layoutRepositoryService: LayoutRepositoryService) {}

  async fetchSyncableResources(environmentId: string, organizationId: string): Promise<LayoutEntity[]> {
    return await this.layoutRepositoryService.fetchSyncableLayouts(environmentId, organizationId);
  }

  createResourceMap(resources: LayoutEntity[]): Map<string, LayoutEntity> {
    return this.layoutRepositoryService.createLayoutMap(resources);
  }

  getResourceIdentifier(resource: LayoutEntity): string {
    return this.layoutRepositoryService.getLayoutIdentifier(resource);
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class LayoutRepositoryAdapter

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/adapters/layout-sync.adapter.ts
TamaÃ±o: 945 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { LayoutEntity } from '@novu/dal';
import {
  LayoutSyncToEnvironmentCommand,
  LayoutSyncToEnvironmentUseCase,
} from '../../../../layouts-v2/usecases/sync-to-environment';
import { ISyncContext } from '../../../types/sync.types';
import { IBaseSyncService } from '../base/interfaces/base-sync.interface';

@Injectable()
export class LayoutSyncAdapter implements IBaseSyncService<LayoutEntity> {
  constructor(private readonly layoutSyncToEnvironmentUseCase: LayoutSyncToEnvironmentUseCase) {}

  async syncResourceToTarget(context: ISyncContext, resource: LayoutEntity): Promise<void> {
    await this.layoutSyncToEnvironmentUseCase.execute(
      LayoutSyncToEnvironmentCommand.create({
        user: { ...context.user, environmentId: context.sourceEnvironmentId },
        layoutIdOrInternalId: resource._id,
        targetEnvironmentId: context.targetEnvironmentId,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class LayoutSyncAdapter

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/adapters/workflow-comparator.adapter.ts
TamaÃ±o: 1307 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { NotificationTemplateEntity } from '@novu/dal';
import { UserSessionData } from '@novu/shared';
import { WorkflowDataContainer } from '../../../../shared/containers/workflow-data.container';
import { IResourceDiff } from '../../../types/sync.types';
import { IBaseComparator } from '../base/interfaces/base-comparator.interface';
import { WorkflowComparator } from '../comparators/workflow.comparator';

@Injectable()
export class WorkflowComparatorAdapter implements IBaseComparator<NotificationTemplateEntity> {
  constructor(private readonly workflowComparator: WorkflowComparator) {}

  async compareResources(
    sourceResource: NotificationTemplateEntity,
    targetResource: NotificationTemplateEntity,
    userContext: UserSessionData,
    workflowDataContainer?: WorkflowDataContainer
  ): Promise<{
    resourceChanges: {
      previous: Record<string, unknown> | null;
      new: Record<string, unknown> | null;
    } | null;
    otherDiffs?: IResourceDiff[];
  }> {
    const { workflowChanges, otherDiffs } = await this.workflowComparator.compareWorkflows(
      sourceResource,
      targetResource,
      userContext,
      workflowDataContainer
    );

    return {
      resourceChanges: workflowChanges,
      otherDiffs,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class WorkflowComparatorAdapter

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/adapters/workflow-delete.adapter.ts
TamaÃ±o: 1060 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { NotificationTemplateEntity } from '@novu/dal';
import { DeleteWorkflowCommand } from '../../../../workflows-v1/usecases/delete-workflow/delete-workflow.command';
import { DeleteWorkflowUseCase } from '../../../../workflows-v1/usecases/delete-workflow/delete-workflow.usecase';
import { ISyncContext } from '../../../types/sync.types';
import { IBaseDeleteService } from '../base/interfaces/base-delete.interface';

@Injectable()
export class WorkflowDeleteAdapter implements IBaseDeleteService<NotificationTemplateEntity> {
  constructor(private readonly deleteWorkflowUseCase: DeleteWorkflowUseCase) {}

  async deleteResourceFromTarget(context: ISyncContext, resource: NotificationTemplateEntity): Promise<void> {
    await this.deleteWorkflowUseCase.execute(
      DeleteWorkflowCommand.create({
        workflowIdOrInternalId: resource._id,
        environmentId: context.targetEnvironmentId,
        organizationId: context.user.organizationId,
        userId: context.user._id,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class WorkflowDeleteAdapter

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/adapters/workflow-repository.adapter.ts
TamaÃ±o: 1037 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { NotificationTemplateEntity } from '@novu/dal';
import { IBaseRepositoryService } from '../base/interfaces/base-repository.interface';
import { WorkflowRepositoryService } from '../operations/workflow-repository.service';

@Injectable()
export class WorkflowRepositoryAdapter implements IBaseRepositoryService<NotificationTemplateEntity> {
  constructor(private readonly workflowRepositoryService: WorkflowRepositoryService) {}

  async fetchSyncableResources(environmentId: string, organizationId: string): Promise<NotificationTemplateEntity[]> {
    return this.workflowRepositoryService.fetchSyncableWorkflows(environmentId, organizationId);
  }

  createResourceMap(resources: NotificationTemplateEntity[]): Map<string, NotificationTemplateEntity> {
    return this.workflowRepositoryService.createWorkflowMap(resources);
  }

  getResourceIdentifier(resource: NotificationTemplateEntity): string {
    return this.workflowRepositoryService.getWorkflowIdentifier(resource);
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class WorkflowRepositoryAdapter

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/adapters/workflow-sync.adapter.ts
TamaÃ±o: 1114 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { NotificationTemplateEntity } from '@novu/dal';
import { SyncToEnvironmentCommand } from '../../../../workflows-v2/usecases/sync-to-environment/sync-to-environment.command';
import { SyncToEnvironmentUseCase } from '../../../../workflows-v2/usecases/sync-to-environment/sync-to-environment.usecase';
import { ISyncContext } from '../../../types/sync.types';
import { IBaseSyncService } from '../base/interfaces/base-sync.interface';

@Injectable()
export class WorkflowSyncAdapter implements IBaseSyncService<NotificationTemplateEntity> {
  constructor(private readonly syncToEnvironmentUseCase: SyncToEnvironmentUseCase) {}

  async syncResourceToTarget(context: ISyncContext, resource: NotificationTemplateEntity): Promise<void> {
    await this.syncToEnvironmentUseCase.execute(
      SyncToEnvironmentCommand.create({
        user: { ...context.user, environmentId: context.sourceEnvironmentId },
        workflowIdOrInternalId: resource._id,
        targetEnvironmentId: context.targetEnvironmentId,
        session: context.session,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class WorkflowSyncAdapter

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/base/base-sync.strategy.ts
TamaÃ±o: 1125 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PinoLogger } from '@novu/application-generic';
import { UserSessionData } from '@novu/shared';
import { IDiffResult, ISyncContext, ISyncResult, ISyncStrategy, ResourceTypeEnum } from '../../../types/sync.types';

export abstract class BaseSyncStrategy implements ISyncStrategy {
  protected readonly BATCH_SIZE = 100;

  constructor(protected logger: PinoLogger) {
    this.logger.setContext(this.constructor.name);
  }

  abstract getResourceType(): ResourceTypeEnum;
  abstract execute(context: ISyncContext): Promise<ISyncResult>;
  abstract diff(
    sourceEnvId: string,
    targetEnvId: string,
    organizationId: string,
    userContext: UserSessionData
  ): Promise<IDiffResult[]>;
  abstract getAvailableResourceIds(sourceEnvironmentId: string, organizationId: string): Promise<string[]>;

  protected async processBatch<T>(
    entities: T[],
    processor: (batch: T[]) => Promise<void>,
    batchSize: number = this.BATCH_SIZE
  ): Promise<void> {
    for (let i = 0; i < entities.length; i += batchSize) {
      const batch = entities.slice(i, i + batchSize);
      await processor(batch);
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - BATCH_SIZE(100;

  constructor(protected logger: PinoLogger) {
    this.logger.setContext(this.constructor.name...)
Declaraciones 'export' encontradas:
- export  abstract

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/base/index.ts
TamaÃ±o: 60 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './interfaces';
export * from './operations';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/base/interfaces/base-comparator.interface.ts
TamaÃ±o: 582 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSessionData } from '@novu/shared';
import { WorkflowDataContainer } from '../../../../../shared/containers/workflow-data.container';
import { IResourceDiff } from '../../../../types/sync.types';

export interface IBaseComparator<T> {
  compareResources(
    sourceResource: T,
    targetResource: T,
    userContext: UserSessionData,
    workflowDataContainer?: WorkflowDataContainer
  ): Promise<{
    resourceChanges: {
      previous: Record<string, unknown> | null;
      new: Record<string, unknown> | null;
    } | null;
    otherDiffs?: IResourceDiff[];
  }>;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/base/interfaces/base-delete.interface.ts
TamaÃ±o: 184 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ISyncContext } from '../../../../types/sync.types';

export interface IBaseDeleteService<T> {
  deleteResourceFromTarget(context: ISyncContext, resource: T): Promise<void>;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/base/interfaces/base-repository.interface.ts
TamaÃ±o: 233 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export interface IBaseRepositoryService<T> {
  fetchSyncableResources(environmentId: string, organizationId: string): Promise<T[]>;
  createResourceMap(resources: T[]): Map<string, T>;
  getResourceIdentifier(resource: T): string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/base/interfaces/base-sync.interface.ts
TamaÃ±o: 178 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ISyncContext } from '../../../../types/sync.types';

export interface IBaseSyncService<T> {
  syncResourceToTarget(context: ISyncContext, resource: T): Promise<void>;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/base/interfaces/index.ts
TamaÃ±o: 253 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { IBaseComparator } from './base-comparator.interface';
export { IBaseDeleteService } from './base-delete.interface';
export { IBaseRepositoryService } from './base-repository.interface';
export { IBaseSyncService } from './base-sync.interface';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/base/operations/base-diff.operation.ts
TamaÃ±o: 8358 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Instrument, PinoLogger } from '@novu/application-generic';
import { UserSessionData } from '@novu/shared';
import { capitalize } from '../../../../../shared/services/helper/helper.service';
import { DiffActionEnum, IDiffResult, IResourceDiff, IUserInfo, ResourceTypeEnum } from '../../../../types/sync.types';
import { DiffResultBuilder } from '../../builders/diff-result.builder';
import { IBaseComparator, IBaseRepositoryService } from '../interfaces';

export abstract class BaseDiffOperation<T> {
  private static readonly BATCH_SIZE = 10;

  constructor(
    protected logger: PinoLogger,
    protected repositoryService: IBaseRepositoryService<T>,
    protected comparator: IBaseComparator<T>
  ) {}

  protected abstract getResourceType(): ResourceTypeEnum;
  protected abstract getResourceName(resource: T): string;
  protected abstract extractUpdatedByInfo(resource: T): IUserInfo | null;
  protected abstract extractUpdatedAtInfo(resource: T): string | null;

  private getStartingDiffMessage(sourceEnvId: string, targetEnvId: string): string {
    return `Starting ${this.getResourceType()} diff between environments ${sourceEnvId} and ${targetEnvId}`;
  }

  private getDiffCompleteFailedMessage(error: string): string {
    return `${capitalize(this.getResourceType())} diff failed: ${error}`;
  }

  @Instrument()
  async execute(
    sourceEnvId: string,
    targetEnvId: string,
    organizationId: string,
    userContext: UserSessionData
  ): Promise<IDiffResult[]> {
    this.logger.info(this.getStartingDiffMessage(sourceEnvId, targetEnvId));

    const resultBuilder = new DiffResultBuilder(this.getResourceType());

    try {
      const [sourceResources, targetResources] = await Promise.all([
        this.repositoryService.fetchSyncableResources(sourceEnvId, organizationId),
        this.repositoryService.fetchSyncableResources(targetEnvId, organizationId),
      ]);

      this.logger.info(
        `Fetched ${sourceResources.length} source resources and ${targetResources.length} target resources`
      );

      await this.processResourceDiffs(sourceResources, targetResources, resultBuilder, userContext);
      await this.processDeletedResources(sourceResources, targetResources, resultBuilder);

      this.logger.info(`Resource diff completed. Processed ${sourceResources.length} resources in batches.`);

      return resultBuilder.build();
    } catch (error) {
      this.logger.error(this.getDiffCompleteFailedMessage(error.message));
      throw error;
    }
  }

  @Instrument()
  private async processResourceDiffs(
    sourceResources: T[],
    targetResources: T[],
    resultBuilder: DiffResultBuilder,
    userContext: UserSessionData
  ): Promise<void> {
    const targetResourceMap = this.repositoryService.createResourceMap(targetResources);

    const batches = this.createBatches(sourceResources, BaseDiffOperation.BATCH_SIZE);

    this.logger.info(
      `Processing ${sourceResources.length} resources in ${batches.length} batches of ${BaseDiffOperation.BATCH_SIZE}`
    );

    for (let i = 0; i < batches.length; i += 1) {
      const batch = batches[i];
      this.logger.debug(`Processing batch ${i + 1}/${batches.length} with ${batch.length} resources`);

      await this.processBatch(batch, targetResourceMap, resultBuilder, userContext);
    }
  }

  @Instrument()
  private async processBatch(
    sourceResources: T[],
    targetResourceMap: Map<string, T>,
    resultBuilder: DiffResultBuilder,
    userContext: UserSessionData
  ): Promise<void> {
    const batchPromises = sourceResources.map(async (sourceResource) => {
      const sourceIdentifier = this.repositoryService.getResourceIdentifier(sourceResource);
      const targetResource = targetResourceMap.get(sourceIdentifier);

      if (!targetResource) {
        await this.handleNewResource(sourceResource, resultBuilder, userContext);

        return;
      }

      try {
        const { resourceChanges, otherDiffs } = await this.comparator.compareResources(
          sourceResource,
          targetResource,
          userContext
        );

        const allDiffs = this.createResourceDiffs(sourceResource, targetResource, resourceChanges, otherDiffs ?? []);

        if (allDiffs.length > 0) {
          resultBuilder.addResourceDiff(
            {
              id: this.repositoryService.getResourceIdentifier(sourceResource),
              name: this.getResourceName(sourceResource),
              updatedBy: this.extractUpdatedByInfo(sourceResource),
              updatedAt: this.extractUpdatedAtInfo(sourceResource),
            },
            {
              id: this.repositoryService.getResourceIdentifier(targetResource),
              name: this.getResourceName(targetResource),
              updatedBy: this.extractUpdatedByInfo(targetResource),
              updatedAt: this.extractUpdatedAtInfo(targetResource),
            },
            allDiffs
          );
        }
      } catch (error) {
        this.logger.error(`Failed to compare resource ${this.getResourceName(sourceResource)}: ${error.message}`);
        throw error;
      }
    });

    await Promise.all(batchPromises);
  }

  private createBatches<U>(items: U[], batchSize: number): U[][] {
    const batches: U[][] = [];

    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }

    return batches;
  }

  private async processDeletedResources(
    sourceResources: T[],
    targetResources: T[],
    resultBuilder: DiffResultBuilder
  ): Promise<void> {
    const sourceResourceMap = this.repositoryService.createResourceMap(sourceResources);

    for (const targetResource of targetResources) {
      const targetIdentifier = this.repositoryService.getResourceIdentifier(targetResource);
      if (!sourceResourceMap.has(targetIdentifier)) {
        resultBuilder.addResourceDeleted({
          id: this.repositoryService.getResourceIdentifier(targetResource),
          name: this.getResourceName(targetResource),
          updatedBy: this.extractUpdatedByInfo(targetResource),
          updatedAt: this.extractUpdatedAtInfo(targetResource),
        });
      }
    }
  }

  protected async handleNewResource(
    sourceResource: T,
    resultBuilder: DiffResultBuilder,
    userContext: UserSessionData
  ): Promise<void> {
    resultBuilder.addResourceAdded({
      id: this.repositoryService.getResourceIdentifier(sourceResource),
      name: this.getResourceName(sourceResource),
      updatedBy: this.extractUpdatedByInfo(sourceResource),
      updatedAt: this.extractUpdatedAtInfo(sourceResource),
    });
  }

  private createResourceDiffs(
    sourceResource: T,
    targetResource: T,
    resourceChanges: {
      previous: Record<string, any> | null;
      new: Record<string, any> | null;
    } | null,
    otherDiffs: IResourceDiff[]
  ): IResourceDiff[] {
    const allDiffs: IResourceDiff[] = [];

    if (resourceChanges) {
      allDiffs.push({
        sourceResource: {
          id: this.repositoryService.getResourceIdentifier(sourceResource),
          name: this.getResourceName(sourceResource),
          updatedBy: this.extractUpdatedByInfo(sourceResource),
          updatedAt: this.extractUpdatedAtInfo(sourceResource),
        },
        targetResource: {
          id: this.repositoryService.getResourceIdentifier(targetResource),
          name: this.getResourceName(targetResource),
          updatedBy: this.extractUpdatedByInfo(targetResource),
          updatedAt: this.extractUpdatedAtInfo(targetResource),
        },
        resourceType: this.getResourceType(),
        action: DiffActionEnum.MODIFIED,
        diffs: resourceChanges,
      });
    }

    const enrichedOtherDiffs = otherDiffs.map((otherDiff) => ({
      ...otherDiff,
      sourceResource: otherDiff.sourceResource
        ? {
            ...otherDiff.sourceResource,
            updatedBy: this.extractUpdatedByInfo(sourceResource),
            updatedAt: this.extractUpdatedAtInfo(sourceResource),
          }
        : null,
      targetResource: otherDiff.targetResource
        ? {
            ...otherDiff.targetResource,
            updatedBy: this.extractUpdatedByInfo(targetResource),
            updatedAt: this.extractUpdatedAtInfo(targetResource),
          }
        : null,
    }));

    allDiffs.push(...enrichedOtherDiffs);

    return allDiffs;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - batchPromises(sourceResources.map(async (sourceResource))
 - enrichedOtherDiffs(otherDiffs.map((otherDiff))
Declaraciones 'export' encontradas:
- export  abstract

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/base/operations/base-sync.operation.ts
TamaÃ±o: 11368 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Instrument, PinoLogger } from '@novu/application-generic';
import { LayoutEntity } from '@novu/dal';
import { capitalize } from '../../../../../shared/services/helper/helper.service';
import { IResourceToPublish, ISyncContext, ISyncResult, ResourceTypeEnum } from '../../../../types/sync.types';
import { SyncResultBuilder } from '../../builders/sync-result.builder';
import { SKIP_REASONS, SYNC_ACTIONS } from '../../constants/sync.constants';
import { IBaseComparator, IBaseDeleteService, IBaseRepositoryService, IBaseSyncService } from '../interfaces';

interface IResourceSyncDecision<T> {
  resource: T;
  targetResource?: T;
  sync: boolean;
  action: 'created' | 'updated' | 'skipped';
  reason?: string;
}

export abstract class BaseSyncOperation<T> {
  private static readonly COMPARISON_BATCH_SIZE = 5;

  constructor(
    protected logger: PinoLogger,
    protected repositoryService: IBaseRepositoryService<T>,
    protected syncService: IBaseSyncService<T>,
    protected deleteService: IBaseDeleteService<T>,
    protected comparator: IBaseComparator<T>
  ) {}

  protected abstract getResourceType(): ResourceTypeEnum;

  protected abstract getResourceName(resource: T): string;

  async getAvailableResourceIds(sourceEnvironmentId: string, organizationId: string): Promise<string[]> {
    const resources = await this.repositoryService.fetchSyncableResources(sourceEnvironmentId, organizationId);

    return resources.map((resource) => this.repositoryService.getResourceIdentifier(resource));
  }

  private getResourceTypeMessage(): string {
    return this.getResourceType().toString().toLowerCase();
  }

  private getStartingSyncMessage(sourceEnvId: string, targetEnvId: string): string {
    return `Starting ${this.getResourceTypeMessage()} sync from environment ${sourceEnvId} to ${targetEnvId}`;
  }

  private getFoundResourcesMessage(count: number): string {
    return `Found ${count} ${this.getResourceTypeMessage()}s to sync`;
  }

  private getDryRunMessage(): string {
    return 'Dry run mode enabled for sync';
  }

  private getSyncCompleteFailedMessage(error: string): string {
    return `${capitalize(this.getResourceTypeMessage())} sync failed: ${error}`;
  }

  private getSyncSuccessMessage(resourceName: string, action: string): string {
    return `${capitalize(this.getResourceTypeMessage())} ${resourceName} sync ${action} successfully`;
  }

  private getSyncSkipMessage(resourceName: string, action: string): string {
    return `${capitalize(this.getResourceTypeMessage())} ${resourceName} sync ${action} skipped`;
  }

  private getSyncFailedMessage(resourceName: string, error: string): string {
    return `${capitalize(this.getResourceTypeMessage())} ${resourceName} sync failed: ${error}`;
  }

  private getDeleteSuccessMessage(resourceName: string): string {
    return `${capitalize(this.getResourceTypeMessage())} ${resourceName} deleted successfully`;
  }

  private getDeleteFailedMessage(resourceName: string, error: string): string {
    return `${capitalize(this.getResourceTypeMessage())} ${resourceName} deletion failed: ${error}`;
  }

  @Instrument()
  async execute(context: ISyncContext): Promise<ISyncResult> {
    this.logger.info(this.getStartingSyncMessage(context.sourceEnvironmentId, context.targetEnvironmentId));

    const resultBuilder = new SyncResultBuilder(this.getResourceType());

    try {
      let sourceResources = await this.repositoryService.fetchSyncableResources(
        context.sourceEnvironmentId,
        context.user.organizationId
      );

      // Filter resources if selective sync is requested
      if (context.options.resources?.length) {
        sourceResources = this.filterResourcesForSelectiveSync(sourceResources, context.options.resources);
      }

      this.logger.info(this.getFoundResourcesMessage(sourceResources.length));

      if (context.options.dryRun) {
        this.logger.info(this.getDryRunMessage());

        sourceResources.forEach((resource) => {
          resultBuilder.addSkipped(
            this.repositoryService.getResourceIdentifier(resource),
            this.getResourceName(resource),
            SKIP_REASONS.DRY_RUN
          );
        });

        return resultBuilder.build();
      }

      await this.syncResources(context, sourceResources, resultBuilder);
      await this.handleDeletedResources(context, sourceResources, resultBuilder);

      return resultBuilder.build();
    } catch (error) {
      this.logger.error(this.getSyncCompleteFailedMessage(error.message));
      throw error;
    }
  }

  private filterResourcesForSelectiveSync(sourceResources: T[], resources: IResourceToPublish[]): T[] {
    const currentResourceType = this.getResourceType();
    const resourceIdsToPublish = new Set(
      resources
        .filter((resource) => resource.resourceType === currentResourceType)
        .map((resource) => resource.resourceId)
    );

    if (resourceIdsToPublish.size === 0) {
      return [];
    }

    return sourceResources.filter((resource) => {
      const resourceId = this.repositoryService.getResourceIdentifier(resource);

      return resourceIdsToPublish.has(resourceId);
    });
  }

  private async syncResources(
    context: ISyncContext,
    sourceResources: T[],
    resultBuilder: SyncResultBuilder
  ): Promise<void> {
    let targetResources = await this.repositoryService.fetchSyncableResources(
      context.targetEnvironmentId,
      context.user.organizationId
    );

    // Filter target resources if selective sync is requested
    if (context.options.resources?.length) {
      targetResources = this.filterResourcesForSelectiveSync(targetResources, context.options.resources);
    }

    const targetResourceMap = this.repositoryService.createResourceMap(targetResources);
    const syncDecisions = await this.determineSyncDecisions(context, sourceResources, targetResourceMap);

    for (const decision of syncDecisions) {
      try {
        if (decision.sync) {
          await this.syncService.syncResourceToTarget(context, decision.resource);
          resultBuilder.addSuccess(
            this.repositoryService.getResourceIdentifier(decision.resource),
            this.getResourceName(decision.resource),
            decision.action as 'created' | 'updated'
          );
          this.logger.info(this.getSyncSuccessMessage(this.getResourceName(decision.resource), decision.action));
        } else {
          resultBuilder.addSkipped(
            this.repositoryService.getResourceIdentifier(decision.resource),
            this.getResourceName(decision.resource),
            decision.reason!
          );
          this.logger.info(this.getSyncSkipMessage(this.getResourceName(decision.resource), decision.action));
        }
      } catch (error) {
        resultBuilder.addFailure(
          this.repositoryService.getResourceIdentifier(decision.resource),
          this.getResourceName(decision.resource),
          error.message,
          error.stack
        );
        this.logger.error(this.getSyncFailedMessage(this.getResourceName(decision.resource), error.message));
        throw error;
      }
    }
  }

  @Instrument()
  private async determineSyncDecisions(
    context: ISyncContext,
    sourceResources: T[],
    targetResourceMap: Map<string, T>
  ): Promise<IResourceSyncDecision<T>[]> {
    const batches = this.createBatches(sourceResources, BaseSyncOperation.COMPARISON_BATCH_SIZE);
    const syncDecisions: IResourceSyncDecision<T>[] = [];

    this.logger.info(
      `Determining sync decisions for ${sourceResources.length} resources in ${batches.length} batches of ${BaseSyncOperation.COMPARISON_BATCH_SIZE}`
    );

    for (let i = 0; i < batches.length; i += 1) {
      const batch = batches[i];
      this.logger.debug(`Processing sync decision batch ${i + 1}/${batches.length} with ${batch.length} resources`);

      const batchDecisions = await this.processSyncDecisionBatch(context, batch, targetResourceMap);
      syncDecisions.push(...batchDecisions);
    }

    return syncDecisions;
  }

  @Instrument()
  private async processSyncDecisionBatch(
    context: ISyncContext,
    sourceResources: T[],
    targetResourceMap: Map<string, T>
  ): Promise<IResourceSyncDecision<T>[]> {
    const batchPromises = sourceResources.map(async (resource) => {
      const sourceIdentifier = this.repositoryService.getResourceIdentifier(resource);
      const targetResource = targetResourceMap.get(sourceIdentifier);

      const decision = await this.shouldSyncResource(context, resource, targetResource);

      return {
        resource,
        targetResource,
        sync: decision.sync,
        action: decision.action,
        reason: decision.reason,
      };
    });

    return Promise.all(batchPromises);
  }

  private createBatches<U>(items: U[], batchSize: number): U[][] {
    const batches: U[][] = [];

    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }

    return batches;
  }

  private async handleDeletedResources(
    context: ISyncContext,
    sourceResources: T[],
    resultBuilder: SyncResultBuilder
  ): Promise<void> {
    let targetResources = await this.repositoryService.fetchSyncableResources(
      context.targetEnvironmentId,
      context.user.organizationId
    );

    // Filter target resources if selective sync is requested
    if (context.options.resources?.length) {
      targetResources = this.filterResourcesForSelectiveSync(targetResources, context.options.resources);
    }

    const sourceResourceMap = this.repositoryService.createResourceMap(sourceResources);

    for (const targetResource of targetResources) {
      try {
        const targetIdentifier = this.repositoryService.getResourceIdentifier(targetResource);
        if (!sourceResourceMap.has(targetIdentifier)) {
          await this.deleteService.deleteResourceFromTarget(context, targetResource);
          resultBuilder.addSuccess(
            this.repositoryService.getResourceIdentifier(targetResource),
            this.getResourceName(targetResource),
            SYNC_ACTIONS.DELETED
          );
          this.logger.info(this.getDeleteSuccessMessage(this.getResourceName(targetResource)));
        }
      } catch (error) {
        resultBuilder.addFailure(
          this.repositoryService.getResourceIdentifier(targetResource),
          this.getResourceName(targetResource),
          error.message,
          error.stack
        );
        this.logger.error(this.getDeleteFailedMessage(this.getResourceName(targetResource), error.message));
      }
    }
  }

  private async shouldSyncResource(
    context: ISyncContext,
    resource: T,
    targetResource?: T
  ): Promise<{ sync: boolean; action: 'created' | 'updated' | 'skipped'; reason?: string }> {
    if (!targetResource) {
      return { sync: true, action: SYNC_ACTIONS.CREATED };
    }

    const { resourceChanges, otherDiffs = [] } = await this.comparator.compareResources(
      resource,
      targetResource,
      context.user
    );
    const hasResourceChanges = resourceChanges !== null;
    const hasOtherChanges = otherDiffs.length > 0;

    if (!hasResourceChanges && !hasOtherChanges) {
      return { sync: false, action: SYNC_ACTIONS.SKIPPED, reason: SKIP_REASONS.NO_CHANGES };
    }

    return { sync: true, action: SYNC_ACTIONS.UPDATED };
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - resources(await this.repositoryService.fetchSyncableResources(sourceEnvironmentId, organizationId);

    retur...)
 - sourceResources(this.filterResourcesForSelectiveSync(sourceResources, context.options.resources);
      }

      thi...)
 - resourceIdsToPublish(new Set(
      resources
        .filter((resource))
 - batchPromises(sourceResources.map(async (resource))
Declaraciones 'export' encontradas:
- export  abstract

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/base/operations/index.ts
TamaÃ±o: 118 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { BaseDiffOperation } from './base-diff.operation';
export { BaseSyncOperation } from './base-sync.operation';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/builders/diff-result.builder.ts
TamaÃ±o: 5674 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  DiffActionEnum,
  IDiffResult,
  IResourceDiff,
  IResourceInfo,
  IUserInfo,
  ResourceTypeEnum,
} from '../../../types/sync.types';

export class DiffResultBuilder {
  private results: IDiffResult[] = [];

  constructor(private readonly resourceType: ResourceTypeEnum) {}

  addResourceDiff(
    sourceResource: IResourceInfo | null,
    targetResource: IResourceInfo | null,
    changes: IResourceDiff[]
  ): this {
    if (changes.length > 0) {
      this.results.push({
        resourceType: this.resourceType,
        sourceResource,
        targetResource,
        changes,
        summary: this.calculateSummaryForResource(sourceResource, targetResource, changes),
      });
    }

    return this;
  }

  addResourceAdded(sourceResource: IResourceInfo): this {
    const diff: IResourceDiff = {
      sourceResource,
      targetResource: null,
      resourceType: this.resourceType,
      action: DiffActionEnum.ADDED,
    };

    this.results.push({
      resourceType: this.resourceType,
      sourceResource,
      targetResource: null,
      changes: [diff],
      summary: this.calculateSummary([diff]),
    });

    return this;
  }

  addResourceDeleted(targetResource: IResourceInfo): this {
    const diff: IResourceDiff = {
      sourceResource: null,
      targetResource,
      resourceType: this.resourceType,
      action: DiffActionEnum.DELETED,
    };

    this.results.push({
      resourceType: this.resourceType,
      sourceResource: null,
      targetResource,
      changes: [diff],
      summary: this.calculateSummary([diff]),
    });

    return this;
  }

  // Legacy methods for backward compatibility
  addWorkflowDiff(
    sourceResourceId: string | null,
    sourceResourceName: string | null,
    targetResourceId: string | null,
    targetResourceName: string | null,
    changes: IResourceDiff[],
    sourceResourceUpdatedBy?: IUserInfo | null,
    targetResourceUpdatedBy?: IUserInfo | null,
    sourceResourceUpdatedAt?: string | null,
    targetResourceUpdatedAt?: string | null
  ): this {
    const sourceResource: IResourceInfo | null =
      sourceResourceId || sourceResourceName
        ? {
            id: sourceResourceId,
            name: sourceResourceName,
            updatedBy: sourceResourceUpdatedBy,
            updatedAt: sourceResourceUpdatedAt,
          }
        : null;

    const targetResource: IResourceInfo | null =
      targetResourceId || targetResourceName
        ? {
            id: targetResourceId,
            name: targetResourceName,
            updatedBy: targetResourceUpdatedBy,
            updatedAt: targetResourceUpdatedAt,
          }
        : null;

    return this.addResourceDiff(sourceResource, targetResource, changes);
  }

  addWorkflowAdded(
    sourceResourceId: string,
    sourceResourceName: string,
    sourceResourceUpdatedBy?: IUserInfo | null,
    sourceResourceUpdatedAt?: string | null
  ): this {
    const sourceResource: IResourceInfo = {
      id: sourceResourceId,
      name: sourceResourceName,
      updatedBy: sourceResourceUpdatedBy,
      updatedAt: sourceResourceUpdatedAt,
    };

    return this.addResourceAdded(sourceResource);
  }

  addWorkflowDeleted(
    targetResourceId: string,
    targetResourceName: string,
    targetResourceUpdatedBy?: IUserInfo | null,
    targetResourceUpdatedAt?: string | null
  ): this {
    const targetResource: IResourceInfo = {
      id: targetResourceId,
      name: targetResourceName,
      updatedBy: targetResourceUpdatedBy,
      updatedAt: targetResourceUpdatedAt,
    };

    return this.addResourceDeleted(targetResource);
  }

  build(): IDiffResult[] {
    return [...this.results];
  }

  getStats() {
    const totalDiffs = this.results.reduce((acc, result) => acc + result.changes.length, 0);
    const summaryTotals = this.results.reduce(
      (acc, result) => ({
        added: acc.added + result.summary.added,
        modified: acc.modified + result.summary.modified,
        deleted: acc.deleted + result.summary.deleted,
        unchanged: acc.unchanged + result.summary.unchanged,
      }),
      { added: 0, modified: 0, deleted: 0, unchanged: 0 }
    );

    return {
      totalResults: this.results.length,
      totalDiffs,
      ...summaryTotals,
    };
  }

  private calculateSummaryForResource(
    sourceResource: IResourceInfo | null,
    targetResource: IResourceInfo | null,
    diffs: IResourceDiff[]
  ) {
    const existsInBothEnvironments = sourceResource && targetResource;

    /*
     * For resources that exist in both environments, treat any changes as a modification
     * of the resource itself, not individual step/sub-resource changes
     */
    if (existsInBothEnvironments && diffs.length > 0) {
      return {
        added: 0,
        modified: 1,
        deleted: 0,
        unchanged: 0,
      };
    }

    // For new or deleted resources, use the traditional counting approach
    return this.calculateSummary(diffs);
  }

  private calculateSummary(diffs: IResourceDiff[]) {
    return diffs.reduce(
      (acc, diffItem) => {
        switch (diffItem.action) {
          case DiffActionEnum.ADDED:
            acc.added += 1;
            break;
          case DiffActionEnum.MODIFIED:
          case DiffActionEnum.MOVED:
            acc.modified += 1;
            break;
          case DiffActionEnum.DELETED:
            acc.deleted += 1;
            break;
          case DiffActionEnum.UNCHANGED:
            acc.unchanged += 1;
            break;
          default:
            break;
        }

        return acc;
      },
      {
        added: 0,
        modified: 0,
        deleted: 0,
        unchanged: 0,
      }
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - totalDiffs(this.results.reduce((acc, result))
 - summaryTotals(this.results.reduce(
      (acc, result))
 - existsInBothEnvironments(sourceResource && targetResource;

    /*
     * For resources that exist in both environments, trea...)
Declaraciones 'export' encontradas:
- export class DiffResultBuilder

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/builders/sync-result.builder.ts
TamaÃ±o: 1956 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IFailedEntity, ISkippedEntity, ISyncedEntity, ISyncResult, ResourceTypeEnum } from '../../../types/sync.types';

export class SyncResultBuilder {
  private successful: ISyncedEntity[] = [];
  private failed: IFailedEntity[] = [];
  private skipped: ISkippedEntity[] = [];

  constructor(private readonly resourceType: ResourceTypeEnum) {}

  addSuccess(resourceId: string, resourceName: string, action: 'created' | 'updated' | 'deleted'): this {
    this.successful.push({
      resourceType: this.resourceType,
      resourceId,
      resourceName,
      action,
    });

    return this;
  }

  addFailure(resourceId: string, resourceName: string, error: string, stack?: string): this {
    this.failed.push({
      resourceType: this.resourceType,
      resourceId,
      resourceName,
      error,
      stack,
    });

    return this;
  }

  addSkipped(resourceId: string, resourceName: string, reason: string): this {
    this.skipped.push({
      resourceType: this.resourceType,
      resourceId,
      resourceName,
      reason,
    });

    return this;
  }

  addSuccessfulEntities(entities: ISyncedEntity[]): this {
    this.successful.push(...entities);

    return this;
  }

  addFailedEntities(entities: IFailedEntity[]): this {
    this.failed.push(...entities);

    return this;
  }

  addSkippedEntities(entities: ISkippedEntity[]): this {
    this.skipped.push(...entities);

    return this;
  }

  build(): ISyncResult {
    return {
      resourceType: this.resourceType,
      successful: [...this.successful],
      failed: [...this.failed],
      skipped: [...this.skipped],
      totalProcessed: this.successful.length + this.failed.length + this.skipped.length,
    };
  }

  getStats() {
    return {
      successful: this.successful.length,
      failed: this.failed.length,
      skipped: this.skipped.length,
      totalProcessed: this.successful.length + this.failed.length + this.skipped.length,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class SyncResultBuilder

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/comparators/layout.comparator.ts
TamaÃ±o: 2249 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { PinoLogger } from '@novu/application-generic';
import { LayoutEntity } from '@novu/dal';
import { diff } from 'deep-object-diff';
import { GetLayoutCommand, GetLayoutUseCase } from '../../../../layouts-v2/usecases/get-layout';
import { LayoutNormalizer } from '../normalizers/layout.normalizer';
import { ILayoutComparison, INormalizedLayout } from '../types/layout-sync.types';

@Injectable()
export class LayoutComparator {
  constructor(
    private logger: PinoLogger,
    private getLayoutUseCase: GetLayoutUseCase,
    private layoutNormalizer: LayoutNormalizer
  ) {}

  async compareLayouts(sourceLayout: LayoutEntity, targetLayout: LayoutEntity): Promise<ILayoutComparison> {
    try {
      if (!sourceLayout || !targetLayout) {
        throw new Error('Source and target layouts must not be null');
      }

      const [sourceLayoutDto, targetLayoutDto] = await Promise.all([
        this.getLayoutUseCase.execute(
          GetLayoutCommand.create({
            layoutIdOrInternalId: sourceLayout._id,
            environmentId: sourceLayout._environmentId,
            organizationId: sourceLayout._organizationId,
          })
        ),
        this.getLayoutUseCase.execute(
          GetLayoutCommand.create({
            layoutIdOrInternalId: targetLayout._id,
            environmentId: targetLayout._environmentId,
            organizationId: targetLayout._organizationId,
          })
        ),
      ]);

      const normalizedSource = this.layoutNormalizer.normalizeLayout(sourceLayoutDto);
      const normalizedTarget = this.layoutNormalizer.normalizeLayout(targetLayoutDto);

      const layoutDifferences = diff(normalizedTarget, normalizedSource);

      let layoutChanges: {
        previous: Partial<INormalizedLayout> | null;
        new: Partial<INormalizedLayout> | null;
      } | null = null;

      if (Object.keys(layoutDifferences).length > 0) {
        layoutChanges = {
          previous: normalizedTarget,
          new: normalizedSource,
        };
      }

      return { layoutChanges };
    } catch (error) {
      this.logger.error({ err: error }, `Failed to compare layouts ${error.message}`);

      return { layoutChanges: null };
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class LayoutComparator

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/comparators/workflow.comparator.ts
TamaÃ±o: 9499 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { Instrument, PinoLogger } from '@novu/application-generic';
import { LocalizationResourceEnum, NotificationTemplateEntity } from '@novu/dal';
import { UserSessionData } from '@novu/shared';
import { diff } from 'deep-object-diff';
import { WorkflowDataContainer } from '../../../../shared/containers/workflow-data.container';
import { GetWorkflowCommand, GetWorkflowUseCase } from '../../../../workflows-v2/usecases/get-workflow';
import { DiffActionEnum, IResourceDiff, ResourceTypeEnum } from '../../../types/sync.types';
import { WorkflowNormalizer } from '../normalizers/workflow.normalizer';
import { WorkflowRepositoryService } from '../operations/workflow-repository.service';
import { INormalizedStep, INormalizedWorkflow, IWorkflowComparison } from '../types/workflow-sync.types';

@Injectable()
export class WorkflowComparator {
  constructor(
    private logger: PinoLogger,
    private getWorkflowUseCase: GetWorkflowUseCase,
    private workflowNormalizer: WorkflowNormalizer,
    private workflowRepositoryService: WorkflowRepositoryService,
    private moduleRef: ModuleRef
  ) {}

  async compareWorkflows(
    sourceWorkflow: NotificationTemplateEntity,
    targetWorkflow: NotificationTemplateEntity,
    userContext: UserSessionData,
    workflowDataContainer?: WorkflowDataContainer
  ): Promise<IWorkflowComparison> {
    try {
      if (!sourceWorkflow || !targetWorkflow) {
        throw new Error('Source and target workflows must not be null');
      }

      // Use WorkflowDataContainer if available for optimized workflow fetching
      const [sourceWorkflowDto, targetWorkflowDto] = await Promise.all([
        this.getWorkflowUseCase.execute(
          GetWorkflowCommand.create({
            user: {
              ...userContext,
              environmentId: sourceWorkflow._environmentId,
            },
            workflowIdOrInternalId: sourceWorkflow._id,
          }),
          workflowDataContainer
        ),
        this.getWorkflowUseCase.execute(
          GetWorkflowCommand.create({
            user: {
              ...userContext,
              environmentId: targetWorkflow._environmentId,
            },
            workflowIdOrInternalId: targetWorkflow._id,
          }),
          workflowDataContainer
        ),
      ]);

      const normalizedSource = this.workflowNormalizer.normalizeWorkflow(sourceWorkflowDto);
      const normalizedTarget = this.workflowNormalizer.normalizeWorkflow(targetWorkflowDto);

      // Separate steps from workflow fields
      const { steps: sourceSteps, ...sourceWithoutSteps } = normalizedSource;
      const { steps: targetSteps, ...targetWithoutSteps } = normalizedTarget;

      const workflowDifferences = diff(targetWithoutSteps, sourceWithoutSteps);

      let workflowChanges: {
        previous: Partial<INormalizedWorkflow> | null;
        new: Partial<INormalizedWorkflow> | null;
      } | null = null;

      if (Object.keys(workflowDifferences).length > 0) {
        workflowChanges = {
          previous: targetWithoutSteps,
          new: sourceWithoutSteps,
        };
      }

      // Compare steps and generate step-level diffs
      const stepDiffs = this.compareStepsAsEntities(sourceSteps, targetSteps);

      // Get localization group diffs for this workflow only if translation is enabled
      const localizationDiffs =
        sourceWorkflow.isTranslationEnabled || targetWorkflow.isTranslationEnabled
          ? await this.getLocalizationDiffs(sourceWorkflow, targetWorkflow, userContext._id)
          : [];

      return { workflowChanges, otherDiffs: [...stepDiffs, ...localizationDiffs] };
    } catch (error) {
      this.logger.error({ err: error }, `Failed to compare workflows ${error.message}`);

      return { workflowChanges: null, otherDiffs: [] };
    }
  }

  @Instrument()
  private async getLocalizationDiffs(
    sourceWorkflow: NotificationTemplateEntity,
    targetWorkflow: NotificationTemplateEntity,
    userId: string
  ): Promise<IResourceDiff[]> {
    try {
      // Use the new DiffTranslationGroups use case from the translation module
      const diffTranslationGroups = this.moduleRef.get(require('@novu/ee-translation')?.DiffTranslationGroups, {
        strict: false,
      });

      if (!diffTranslationGroups) {
        this.logger.debug('Translation module not available, skipping localization diff');

        return [];
      }

      return await diffTranslationGroups.execute({
        sourceEnvironmentId: sourceWorkflow._environmentId,
        targetEnvironmentId: targetWorkflow._environmentId,
        resourceId: this.workflowRepositoryService.getWorkflowIdentifier(sourceWorkflow),
        resourceType: LocalizationResourceEnum.WORKFLOW,
        userId,
        environmentId: sourceWorkflow._environmentId, // Required by EnvironmentWithUserCommand
      });
    } catch (error) {
      this.logger.error(`Failed to diff localization groups for workflow ${sourceWorkflow.name}`, error);

      return [];
    }
  }

  compareStepsAsEntities(sourceSteps: INormalizedStep[], targetSteps: INormalizedStep[]): IResourceDiff[] {
    const stepDiffs: IResourceDiff[] = [];

    const targetStepMap = new Map(targetSteps.map((step, index) => [step.stepId, { step, index }]));

    const processedSteps = new Set<string>();

    sourceSteps.forEach((sourceStep, sourceIndex) => {
      // Skip steps without stepId as they can't be properly compared
      if (!sourceStep.stepId) {
        return;
      }

      const targetStepData = targetStepMap.get(sourceStep.stepId);

      if (!targetStepData) {
        stepDiffs.push(this.createStepAddedDiff(sourceStep, sourceIndex));
      } else {
        const { step: targetStep, index: targetIndex } = targetStepData;
        const stepChanges = this.compareIndividualStep(sourceStep, targetStep);

        if (stepChanges) {
          stepDiffs.push(this.createStepModifiedDiff(sourceStep, targetStep, sourceIndex, targetIndex, stepChanges));
        } else if (sourceIndex !== targetIndex) {
          stepDiffs.push(this.createStepMovedDiff(sourceStep, targetStep, sourceIndex, targetIndex));
        }
      }

      processedSteps.add(sourceStep.stepId);
    });

    targetSteps.forEach((targetStep, targetIndex) => {
      // Skip steps without stepId
      if (!targetStep.stepId) {
        return;
      }

      if (!processedSteps.has(targetStep.stepId)) {
        stepDiffs.push(this.createStepDeletedDiff(targetStep, targetIndex));
      }
    });

    return stepDiffs;
  }

  private compareIndividualStep(
    sourceStep: INormalizedStep,
    targetStep: INormalizedStep
  ): {
    previous: Partial<INormalizedStep> | null;
    new: Partial<INormalizedStep> | null;
  } | null {
    const differences = diff(targetStep, sourceStep);

    if (Object.keys(differences).length === 0) {
      return null;
    }

    return {
      previous: targetStep,
      new: sourceStep,
    };
  }

  private createStepAddedDiff(sourceStep: INormalizedStep, sourceIndex: number): IResourceDiff {
    return {
      sourceResource: {
        id: sourceStep.stepId,
        name: sourceStep.name,
        updatedBy: null,
        updatedAt: null,
      },
      targetResource: null,
      resourceType: ResourceTypeEnum.STEP,
      stepType: sourceStep.type,
      action: DiffActionEnum.ADDED,
      newIndex: sourceIndex,
      diffs: {
        previous: null,
        new: sourceStep,
      },
    };
  }

  private createStepModifiedDiff(
    sourceStep: INormalizedStep,
    targetStep: INormalizedStep,
    sourceIndex: number,
    targetIndex: number,
    stepChanges: {
      previous: Partial<INormalizedStep> | null;
      new: Partial<INormalizedStep> | null;
    }
  ): IResourceDiff {
    return {
      sourceResource: {
        id: sourceStep.stepId,
        name: sourceStep.name,
        updatedBy: null,
        updatedAt: null,
      },
      targetResource: {
        id: targetStep.stepId,
        name: targetStep.name,
        updatedBy: null,
        updatedAt: null,
      },
      resourceType: ResourceTypeEnum.STEP,
      stepType: sourceStep.type,
      action: DiffActionEnum.MODIFIED,
      previousIndex: targetIndex,
      newIndex: sourceIndex,
      diffs: stepChanges,
    };
  }

  private createStepMovedDiff(
    sourceStep: INormalizedStep,
    targetStep: INormalizedStep,
    sourceIndex: number,
    targetIndex: number
  ): IResourceDiff {
    return {
      sourceResource: {
        id: sourceStep.stepId,
        name: sourceStep.name,
        updatedBy: null,
        updatedAt: null,
      },
      targetResource: {
        id: targetStep.stepId,
        name: targetStep.name,
        updatedBy: null,
        updatedAt: null,
      },
      resourceType: ResourceTypeEnum.STEP,
      stepType: sourceStep.type,
      action: DiffActionEnum.MOVED,
      previousIndex: targetIndex,
      newIndex: sourceIndex,
    };
  }

  private createStepDeletedDiff(targetStep: INormalizedStep, targetIndex: number): IResourceDiff {
    return {
      sourceResource: null,
      targetResource: {
        id: targetStep.stepId,
        name: targetStep.name,
        updatedBy: null,
        updatedAt: null,
      },
      resourceType: ResourceTypeEnum.STEP,
      stepType: targetStep.type,
      action: DiffActionEnum.DELETED,
      previousIndex: targetIndex,
      diffs: {
        previous: targetStep,
        new: null,
      },
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - targetStepMap(new Map(targetSteps.map((step, index))
 - processedSteps(new Set<string>();

    sourceSteps.forEach((sourceStep, sourceIndex))
Declaraciones 'export' encontradas:
- export class WorkflowComparator

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/constants/sync.constants.ts
TamaÃ±o: 301 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export const SYNC_CONSTANTS = {
  BATCH_SIZE: 100,
} as const;

export const SYNC_ACTIONS = {
  CREATED: 'created',
  UPDATED: 'updated',
  SKIPPED: 'skipped',
  DELETED: 'deleted',
} as const;

export const SKIP_REASONS = {
  DRY_RUN: 'Dry run mode',
  NO_CHANGES: 'No changes detected',
} as const;


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/normalizers/layout.normalizer.ts
TamaÃ±o: 621 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { LayoutResponseDto } from '../../../../layouts-v2/dtos';
import { INormalizedLayout } from '../types/layout-sync.types';

@Injectable()
export class LayoutNormalizer {
  /**
   * We want to normalize the layout and omit any fields that are autogenerated by the system
   * Or are not relevant for the comparison
   */
  normalizeLayout(layout: LayoutResponseDto): INormalizedLayout {
    const { _id, updatedAt, updatedBy, createdAt, slug, isDefault, origin, type, variables, ...normalizedLayout } =
      layout;

    return {
      ...normalizedLayout,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class LayoutNormalizer

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/normalizers/workflow.normalizer.ts
TamaÃ±o: 1252 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { StepResponseDto } from '../../../../workflows-v2/dtos/step.response.dto';
import { WorkflowResponseDto } from '../../../../workflows-v2/dtos/workflow-response.dto';
import { INormalizedStep, INormalizedWorkflow } from '../types/workflow-sync.types';

@Injectable()
export class WorkflowNormalizer {
  /**
   * We want to normalize the workflow and omit any fields that are autogenerated by the system
   * Or are not relevant for the comparison
   */
  normalizeWorkflow(workflow: WorkflowResponseDto): INormalizedWorkflow {
    const {
      _id,
      slug,
      updatedAt,
      updatedBy,
      lastPublishedAt,
      lastPublishedBy,
      createdAt,
      origin,
      status,
      issues,
      lastTriggeredAt,
      payloadExample,
      steps = [],
      ...normalizedWorkflow
    } = workflow;

    return {
      ...normalizedWorkflow,
      payloadSchema: normalizedWorkflow.payloadSchema ?? null,
      steps: steps.map((step) => this.normalizeStep(step)),
    };
  }

  normalizeStep(step: StepResponseDto): INormalizedStep {
    const { _id, slug, origin, workflowId, workflowDatabaseId, issues, controls, variables, ...normalizedStep } = step;

    return normalizedStep;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class WorkflowNormalizer

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/operations/layout-diff.operation.ts
TamaÃ±o: 1506 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { PinoLogger } from '@novu/application-generic';
import { LayoutEntity } from '@novu/dal';
import { IUserInfo, ResourceTypeEnum } from '../../../types/sync.types';
import { LayoutComparatorAdapter } from '../adapters/layout-comparator.adapter';
import { LayoutRepositoryAdapter } from '../adapters/layout-repository.adapter';
import { BaseDiffOperation } from '../base/operations/base-diff.operation';

@Injectable()
export class LayoutDiffOperation extends BaseDiffOperation<LayoutEntity> {
  constructor(
    protected logger: PinoLogger,
    protected repositoryAdapter: LayoutRepositoryAdapter,
    protected comparatorAdapter: LayoutComparatorAdapter
  ) {
    super(logger, repositoryAdapter, comparatorAdapter);
  }

  protected getResourceType(): ResourceTypeEnum {
    return ResourceTypeEnum.LAYOUT;
  }

  protected getResourceName(resource: LayoutEntity): string {
    return resource.name || resource.identifier || 'Unnamed Layout';
  }

  protected extractUpdatedByInfo(resource: LayoutEntity): IUserInfo | null {
    if (!resource.updatedBy) {
      return null;
    }

    return {
      _id: resource.updatedBy._id,
      firstName: resource.updatedBy.firstName,
      lastName: resource.updatedBy.lastName,
      externalId: resource.updatedBy.externalId,
    };
  }

  protected extractUpdatedAtInfo(resource: LayoutEntity): string | null {
    if (!resource.updatedAt) {
      return null;
    }

    return resource.updatedAt;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class LayoutDiffOperation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/operations/layout-repository.service.ts
TamaÃ±o: 672 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { LayoutEntity, LayoutRepository } from '@novu/dal';

@Injectable()
export class LayoutRepositoryService {
  constructor(private layoutRepository: LayoutRepository) {}

  async fetchSyncableLayouts(environmentId: string, organizationId: string): Promise<LayoutEntity[]> {
    return await this.layoutRepository.findPublishable(environmentId, organizationId);
  }

  getLayoutIdentifier(layout: LayoutEntity): string {
    return layout.identifier;
  }

  createLayoutMap(layouts: LayoutEntity[]): Map<string, LayoutEntity> {
    return new Map(layouts.map((layout) => [this.getLayoutIdentifier(layout), layout]));
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class LayoutRepositoryService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/operations/layout-sync.operation.ts
TamaÃ±o: 1259 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { PinoLogger } from '@novu/application-generic';
import { LayoutEntity } from '@novu/dal';
import { ResourceTypeEnum } from '../../../types/sync.types';
import { LayoutComparatorAdapter } from '../adapters/layout-comparator.adapter';
import { LayoutDeleteAdapter } from '../adapters/layout-delete.adapter';
import { LayoutRepositoryAdapter } from '../adapters/layout-repository.adapter';
import { LayoutSyncAdapter } from '../adapters/layout-sync.adapter';
import { BaseSyncOperation } from '../base/operations/base-sync.operation';

@Injectable()
export class LayoutSyncOperation extends BaseSyncOperation<LayoutEntity> {
  constructor(
    protected logger: PinoLogger,
    protected repositoryAdapter: LayoutRepositoryAdapter,
    protected syncAdapter: LayoutSyncAdapter,
    protected deleteAdapter: LayoutDeleteAdapter,
    protected comparatorAdapter: LayoutComparatorAdapter
  ) {
    super(logger, repositoryAdapter, syncAdapter, deleteAdapter, comparatorAdapter);
  }

  protected getResourceType(): ResourceTypeEnum {
    return ResourceTypeEnum.LAYOUT;
  }

  protected getResourceName(resource: LayoutEntity): string {
    return resource.name || resource.identifier || 'Unnamed Layout';
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class LayoutSyncOperation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/operations/workflow-diff.operation.ts
TamaÃ±o: 12351 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { PinoLogger } from '@novu/application-generic';
import { NotificationTemplateEntity } from '@novu/dal';
import { UserSessionData } from '@novu/shared';
import { WorkflowDataContainer } from '../../../../shared/containers/workflow-data.container';
import { GetWorkflowCommand, GetWorkflowUseCase } from '../../../../workflows-v2/usecases/get-workflow';
import { DiffActionEnum, IDiffResult, IResourceDiff, IUserInfo, ResourceTypeEnum } from '../../../types/sync.types';
import { WorkflowComparatorAdapter, WorkflowRepositoryAdapter } from '../adapters';
import { BaseDiffOperation } from '../base/operations/base-diff.operation';
import { DiffResultBuilder } from '../builders/diff-result.builder';
import { WorkflowNormalizer } from '../normalizers/workflow.normalizer';

@Injectable()
export class WorkflowDiffOperation extends BaseDiffOperation<NotificationTemplateEntity> {
  constructor(
    protected logger: PinoLogger,
    protected repositoryAdapter: WorkflowRepositoryAdapter,
    protected comparatorAdapter: WorkflowComparatorAdapter,
    private workflowNormalizer: WorkflowNormalizer,
    private getWorkflowUseCase: GetWorkflowUseCase
  ) {
    super(logger, repositoryAdapter, comparatorAdapter);
  }

  protected getResourceType(): ResourceTypeEnum {
    return ResourceTypeEnum.WORKFLOW;
  }

  async execute(
    sourceEnvId: string,
    targetEnvId: string,
    organizationId: string,
    userContext: UserSessionData,
    workflowDataContainer?: WorkflowDataContainer
  ): Promise<IDiffResult[]> {
    if (!workflowDataContainer) {
      throw new Error('WorkflowDataContainer is required for workflow diff operations');
    }
    this.logger.info(this.getWorkflowDiffStartMessage(sourceEnvId, targetEnvId));

    const resultBuilder = new DiffResultBuilder(this.getResourceType());

    try {
      const sourceResources = workflowDataContainer.getWorkflowsByEnvironment(sourceEnvId);
      const targetResources = workflowDataContainer.getWorkflowsByEnvironment(targetEnvId);

      this.logger.info(
        `Filtered ${sourceResources.length} source resources and ${targetResources.length} target resources from container`
      );

      await this.processWorkflowResourceDiffs(
        sourceResources,
        targetResources,
        resultBuilder,
        userContext,
        workflowDataContainer
      );
      await this.processDeletedWorkflowResources(sourceResources, targetResources, resultBuilder);

      this.logger.info(`Resource diff completed. Processed ${sourceResources.length} resources in batches.`);

      return resultBuilder.build();
    } catch (error) {
      this.logger.error(this.getWorkflowDiffFailedMessage(error.message));
      throw error;
    }
  }

  private getWorkflowDiffStartMessage(sourceEnvId: string, targetEnvId: string): string {
    return `Starting ${this.getResourceType()} diff between environments ${sourceEnvId} and ${targetEnvId}`;
  }

  private getWorkflowDiffFailedMessage(error: string): string {
    return `${this.getResourceType()} diff failed: ${error}`;
  }

  private async processWorkflowResourceDiffs(
    sourceResources: NotificationTemplateEntity[],
    targetResources: NotificationTemplateEntity[],
    resultBuilder: DiffResultBuilder,
    userContext: UserSessionData,
    workflowDataContainer: WorkflowDataContainer
  ): Promise<void> {
    const targetResourceMap = this.repositoryService.createResourceMap(targetResources);

    const BATCH_SIZE = 10;
    const batches = this.createWorkflowBatches(sourceResources, BATCH_SIZE);

    this.logger.info(`Processing ${sourceResources.length} resources in ${batches.length} batches of ${BATCH_SIZE}`);

    for (let i = 0; i < batches.length; i += 1) {
      const batch = batches[i];
      this.logger.debug(`Processing batch ${i + 1}/${batches.length} with ${batch.length} resources`);

      await this.processWorkflowBatch(batch, targetResourceMap, resultBuilder, userContext, workflowDataContainer);
    }
  }

  private async processWorkflowBatch(
    sourceResources: NotificationTemplateEntity[],
    targetResourceMap: Map<string, NotificationTemplateEntity>,
    resultBuilder: DiffResultBuilder,
    userContext: UserSessionData,
    workflowDataContainer: WorkflowDataContainer
  ): Promise<void> {
    const batchPromises = sourceResources.map(async (sourceResource) => {
      const sourceIdentifier = this.repositoryService.getResourceIdentifier(sourceResource);
      const targetResource = targetResourceMap.get(sourceIdentifier);

      if (!targetResource) {
        await this.handleNewWorkflowResource(sourceResource, resultBuilder, userContext, workflowDataContainer);

        return;
      }

      try {
        const { resourceChanges, otherDiffs } = await this.comparatorAdapter.compareResources(
          sourceResource,
          targetResource,
          userContext,
          workflowDataContainer
        );

        const allDiffs = this.createWorkflowResourceDiffs(
          sourceResource,
          targetResource,
          resourceChanges,
          otherDiffs ?? []
        );

        if (allDiffs.length > 0) {
          resultBuilder.addResourceDiff(
            {
              id: this.repositoryService.getResourceIdentifier(sourceResource),
              name: this.getResourceName(sourceResource),
              updatedBy: this.extractUpdatedByInfo(sourceResource),
              updatedAt: this.extractUpdatedAtInfo(sourceResource),
            },
            {
              id: this.repositoryService.getResourceIdentifier(targetResource),
              name: this.getResourceName(targetResource),
              updatedBy: this.extractUpdatedByInfo(targetResource),
              updatedAt: this.extractUpdatedAtInfo(targetResource),
            },
            allDiffs
          );
        }
      } catch (error) {
        this.logger.error(`Failed to compare resource ${this.getResourceName(sourceResource)}: ${error.message}`);
        throw error;
      }
    });

    await Promise.all(batchPromises);
  }

  private createWorkflowBatches<U>(items: U[], batchSize: number): U[][] {
    const batches: U[][] = [];

    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }

    return batches;
  }

  private async handleNewWorkflowResource(
    sourceResource: NotificationTemplateEntity,
    resultBuilder: DiffResultBuilder,
    userContext: UserSessionData,
    workflowDataContainer: WorkflowDataContainer
  ): Promise<void> {
    const resourceInfo = {
      id: this.repositoryService.getResourceIdentifier(sourceResource),
      name: this.getResourceName(sourceResource),
      updatedBy: this.extractUpdatedByInfo(sourceResource),
      updatedAt: this.extractUpdatedAtInfo(sourceResource),
    };

    // For new workflows, we need to extract steps to analyze dependencies
    const stepDiffs = await this.extractStepsFromNewWorkflow(sourceResource, userContext, workflowDataContainer);

    const allDiffs: IResourceDiff[] = [
      {
        sourceResource: resourceInfo,
        targetResource: null,
        resourceType: this.getResourceType(),
        action: DiffActionEnum.ADDED,
      },
    ];

    // Add step diffs so dependency analyzer can find layoutIds in control values
    if (stepDiffs.length > 0) {
      allDiffs.push(...stepDiffs);
    }

    resultBuilder.addResourceDiff(resourceInfo, null, allDiffs);
  }

  private createWorkflowResourceDiffs(
    sourceResource: NotificationTemplateEntity,
    targetResource: NotificationTemplateEntity,
    resourceChanges: {
      previous: Record<string, any> | null;
      new: Record<string, any> | null;
    } | null,
    otherDiffs: IResourceDiff[]
  ): IResourceDiff[] {
    const allDiffs: IResourceDiff[] = [];

    if (resourceChanges) {
      allDiffs.push({
        sourceResource: {
          id: this.repositoryService.getResourceIdentifier(sourceResource),
          name: this.getResourceName(sourceResource),
          updatedBy: this.extractUpdatedByInfo(sourceResource),
          updatedAt: this.extractUpdatedAtInfo(sourceResource),
        },
        targetResource: {
          id: this.repositoryService.getResourceIdentifier(targetResource),
          name: this.getResourceName(targetResource),
          updatedBy: this.extractUpdatedByInfo(targetResource),
          updatedAt: this.extractUpdatedAtInfo(targetResource),
        },
        resourceType: this.getResourceType(),
        action: DiffActionEnum.MODIFIED,
        diffs: resourceChanges,
      });
    }

    const enrichedOtherDiffs = otherDiffs.map((otherDiff) => ({
      ...otherDiff,
      sourceResource: otherDiff.sourceResource
        ? {
            ...otherDiff.sourceResource,
            updatedBy: this.extractUpdatedByInfo(sourceResource),
            updatedAt: this.extractUpdatedAtInfo(sourceResource),
          }
        : null,
      targetResource: otherDiff.targetResource
        ? {
            ...otherDiff.targetResource,
            updatedBy: this.extractUpdatedByInfo(targetResource),
            updatedAt: this.extractUpdatedAtInfo(targetResource),
          }
        : null,
    }));

    allDiffs.push(...enrichedOtherDiffs);

    return allDiffs;
  }

  private async processDeletedWorkflowResources(
    sourceResources: NotificationTemplateEntity[],
    targetResources: NotificationTemplateEntity[],
    resultBuilder: DiffResultBuilder
  ): Promise<void> {
    const sourceResourceMap = this.repositoryService.createResourceMap(sourceResources);

    for (const targetResource of targetResources) {
      const targetIdentifier = this.repositoryService.getResourceIdentifier(targetResource);
      if (!sourceResourceMap.has(targetIdentifier)) {
        resultBuilder.addResourceDeleted({
          id: this.repositoryService.getResourceIdentifier(targetResource),
          name: this.getResourceName(targetResource),
          updatedBy: this.extractUpdatedByInfo(targetResource),
          updatedAt: this.extractUpdatedAtInfo(targetResource),
        });
      }
    }
  }

  protected getResourceName(resource: NotificationTemplateEntity): string {
    return resource.name;
  }

  protected extractUpdatedByInfo(resource: NotificationTemplateEntity): IUserInfo | null {
    if (!resource.updatedBy) {
      return null;
    }

    return {
      _id: resource.updatedBy._id,
      firstName: resource.updatedBy.firstName,
      lastName: resource.updatedBy.lastName,
      externalId: resource.updatedBy.externalId,
    };
  }

  protected extractUpdatedAtInfo(resource: NotificationTemplateEntity): string | null {
    if (!resource.updatedAt) {
      return null;
    }

    return resource.updatedAt;
  }

  private async extractStepsFromNewWorkflow(
    workflow: NotificationTemplateEntity,
    userContext: UserSessionData,
    workflowDataContainer: WorkflowDataContainer
  ): Promise<IResourceDiff[]> {
    try {
      const workflowIdentifier = workflow.triggers?.[0]?.identifier;

      if (!workflowIdentifier) {
        this.logger.warn(`Workflow ${workflow._id} has no trigger identifier, skipping step extraction`);

        return [];
      }

      this.logger.debug(`Generating workflow DTO for step extraction: ${workflowIdentifier}`);

      const workflowDto = await this.getWorkflowUseCase.execute(
        GetWorkflowCommand.create({
          workflowIdOrInternalId: workflowIdentifier,
          user: {
            ...userContext,
            environmentId: workflow._environmentId,
          },
        }),
        workflowDataContainer
      );

      const normalizedWorkflow = this.workflowNormalizer.normalizeWorkflow(workflowDto);

      // Create step diffs for each step as "added"
      return normalizedWorkflow.steps.map((step, index) => ({
        sourceResource: {
          id: step.stepId,
          name: step.name,
          updatedBy: null,
          updatedAt: null,
        },
        targetResource: null,
        resourceType: ResourceTypeEnum.STEP,
        stepType: step.type,
        action: DiffActionEnum.ADDED,
        newIndex: index,
        diffs: {
          previous: null,
          new: step,
        },
      }));
    } catch (error) {
      this.logger.error({ error }, `Failed to extract steps from new workflow: ${error.message}`);

      return [];
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - batchPromises(sourceResources.map(async (sourceResource))
 - enrichedOtherDiffs(otherDiffs.map((otherDiff))
 - normalizedWorkflow(this.workflowNormalizer.normalizeWorkflow(workflowDto);

      // Create step diffs for each step as...)
Declaraciones 'export' encontradas:
- export class WorkflowDiffOperation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/operations/workflow-repository.service.ts
TamaÃ±o: 847 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { NotificationTemplateEntity, NotificationTemplateRepository } from '@novu/dal';

@Injectable()
export class WorkflowRepositoryService {
  constructor(private notificationTemplateRepository: NotificationTemplateRepository) {}

  async fetchSyncableWorkflows(environmentId: string, organizationId: string): Promise<NotificationTemplateEntity[]> {
    return await this.notificationTemplateRepository.findPublishable(environmentId, organizationId);
  }

  getWorkflowIdentifier(workflow: NotificationTemplateEntity): string {
    return workflow.triggers?.[0]?.identifier as string;
  }

  createWorkflowMap(workflows: NotificationTemplateEntity[]): Map<string, NotificationTemplateEntity> {
    return new Map(workflows.map((workflow) => [this.getWorkflowIdentifier(workflow), workflow]));
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class WorkflowRepositoryService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/operations/workflow-sync.operation.ts
TamaÃ±o: 1103 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { PinoLogger } from '@novu/application-generic';
import { NotificationTemplateEntity } from '@novu/dal';
import { ResourceTypeEnum } from '../../../types/sync.types';
import {
  WorkflowComparatorAdapter,
  WorkflowDeleteAdapter,
  WorkflowRepositoryAdapter,
  WorkflowSyncAdapter,
} from '../adapters';
import { BaseSyncOperation } from '../base/operations/base-sync.operation';

@Injectable()
export class WorkflowSyncOperation extends BaseSyncOperation<NotificationTemplateEntity> {
  constructor(
    protected logger: PinoLogger,
    protected repositoryAdapter: WorkflowRepositoryAdapter,
    protected syncAdapter: WorkflowSyncAdapter,
    protected deleteAdapter: WorkflowDeleteAdapter,
    protected comparatorAdapter: WorkflowComparatorAdapter
  ) {
    super(logger, repositoryAdapter, syncAdapter, deleteAdapter, comparatorAdapter);
  }

  protected getResourceType(): ResourceTypeEnum {
    return ResourceTypeEnum.WORKFLOW;
  }

  protected getResourceName(resource: NotificationTemplateEntity): string {
    return resource.name;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class WorkflowSyncOperation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/types/layout-sync.types.ts
TamaÃ±o: 623 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { LayoutResponseDto } from '../../../../layouts-v2/dtos';

export type INormalizedLayout = Omit<
  LayoutResponseDto,
  | '_id' // Auto-generated database ID
  | 'updatedAt' // System timestamp
  | 'createdAt' // System timestamp
  | 'slug' // Auto-generated from name
  | 'isDefault' // Not relevant for comparison
  | 'origin' // Not relevant for comparison
  | 'type' // Not relevant for comparison
  | 'variables' // Not relevant for comparison
>;

export interface ILayoutComparison {
  layoutChanges: {
    previous: Partial<INormalizedLayout> | null;
    new: Partial<INormalizedLayout> | null;
  } | null;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  type
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v2/usecases/sync-strategies/types/workflow-sync.types.ts
TamaÃ±o: 1368 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { StepResponseDto } from '../../../../workflows-v2/dtos/step.response.dto';
import { WorkflowResponseDto } from '../../../../workflows-v2/dtos/workflow-response.dto';
import { IResourceDiff } from '../../../types/sync.types';

export type INormalizedWorkflow = Omit<
  WorkflowResponseDto,
  | '_id' // Auto-generated database ID
  | 'slug' // Auto-generated from name
  | 'updatedAt' // System timestamp
  | 'createdAt' // System timestamp
  | 'origin' // Not relevant for comparison
  | 'status' // Runtime status, not part of definition
  | 'issues' // Runtime issues, not part of definition
  | 'lastTriggeredAt' // Runtime data
  | 'payloadExample' // Auto-generated from schema
  | 'steps' // Override with normalized steps
> & {
  steps: INormalizedStep[];
};

export type INormalizedStep = Omit<
  StepResponseDto,
  | '_id' // Auto-generated database ID
  | 'slug' // Auto-generated from name
  | 'origin' // Not relevant for comparison
  | 'workflowId' // Parent reference
  | 'workflowDatabaseId' // Parent reference
  | 'issues' // Runtime issues
  | 'controls' // We use controlValues instead
  | 'variables' // Schema definition, not values
>;

export interface IWorkflowComparison {
  workflowChanges: {
    previous: Partial<INormalizedWorkflow> | null;
    new: Partial<INormalizedWorkflow> | null;
  } | null;
  otherDiffs: IResourceDiff[];
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/events.controller.ts
TamaÃ±o: 9517 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Body, Controller, Delete, Param, Post, Req, Scope } from '@nestjs/common';
import { ApiExcludeEndpoint, ApiOperation, ApiTags } from '@nestjs/swagger';
import { RequirePermissions, ResourceCategory } from '@novu/application-generic';
import {
  AddressingTypeEnum,
  ApiRateLimitCategoryEnum,
  ApiRateLimitCostEnum,
  PermissionsEnum,
  ResourceEnum,
  TriggerRequestCategoryEnum,
  UserSessionData,
} from '@novu/shared';
import { v4 as uuidv4 } from 'uuid';
import { PayloadValidationExceptionDto } from '../../error-dto';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { ThrottlerCategory, ThrottlerCost } from '../rate-limiting/guards';
import { AnalyticsStrategyEnum, LogAnalytics } from '../shared/framework/analytics-logs.interceptor';
import {
  ApiCommonResponses,
  ApiCreatedResponse,
  ApiOkResponse,
  ApiResponse,
} from '../shared/framework/response.decorator';
import { KeylessAccessible } from '../shared/framework/swagger/keyless.security';
import { SdkGroupName, SdkMethodName, SdkUsageExample } from '../shared/framework/swagger/sdk.decorators';
import { UserSession } from '../shared/framework/user.decorator';
import { RequestWithReqId } from '../shared/middleware/request-id.middleware';
import {
  BulkTriggerEventDto,
  TestSendEmailRequestDto,
  TriggerEventRequestDto,
  TriggerEventResponseDto,
  TriggerEventToAllRequestDto,
} from './dtos';
import { CancelDelayed, CancelDelayedCommand } from './usecases/cancel-delayed';
import { ParseEventRequest, ParseEventRequestMulticastCommand } from './usecases/parse-event-request';
import { ProcessBulkTrigger, ProcessBulkTriggerCommand } from './usecases/process-bulk-trigger';
import { SendTestEmail, SendTestEmailCommand } from './usecases/send-test-email';
import { TriggerEventToAll, TriggerEventToAllCommand } from './usecases/trigger-event-to-all';

function RequestAnalytics(strategy: AnalyticsStrategyEnum = AnalyticsStrategyEnum.BASIC) {
  return (_target: any, _propertyKey: string, descriptor: PropertyDescriptor) => {
    // Set analytics strategy as a property on the method
    const originalMethod = descriptor.value;
    originalMethod._analyticsStrategy = strategy;

    return descriptor;
  };
}

@ThrottlerCategory(ApiRateLimitCategoryEnum.TRIGGER)
@ResourceCategory(ResourceEnum.EVENTS)
@RequireAuthentication()
@ApiCommonResponses()
@Controller({
  path: 'events',
  scope: Scope.REQUEST,
})
@ApiTags('Events')
export class EventsController {
  constructor(
    private cancelDelayedUsecase: CancelDelayed,
    private triggerEventToAll: TriggerEventToAll,
    private sendTestEmail: SendTestEmail,
    private parseEventRequest: ParseEventRequest,
    private processBulkTriggerUsecase: ProcessBulkTrigger
  ) {}

  @KeylessAccessible()
  @ExternalApiAccessible()
  @Post('/trigger')
  @RequestAnalytics(AnalyticsStrategyEnum.EVENTS)
  @LogAnalytics(AnalyticsStrategyEnum.EVENTS)
  @ApiResponse(TriggerEventResponseDto, 201)
  @ApiResponse(PayloadValidationExceptionDto, 400, false, false, {
    description: 'Payload validation failed - returned when payload does not match the workflow schema',
  })
  @ApiOperation({
    summary: 'Trigger event',
    description: `
    Trigger event is the main (and only) way to send notifications to subscribers. The trigger identifier is used to match the particular workflow associated with it. Additional information can be passed according the body interface below.
    To prevent duplicate triggers, you can optionally pass a **transactionId** in the request body. If the same **transactionId** is used again, the trigger will be ignored. The retention period depends on your billing tier.`,
  })
  @SdkMethodName('trigger')
  @SdkUsageExample('Trigger Notification Event')
  @SdkGroupName('')
  @RequirePermissions(PermissionsEnum.EVENT_WRITE)
  async trigger(
    @UserSession() user: UserSessionData,
    @Req() req: RequestWithReqId,
    @Body() body: TriggerEventRequestDto
  ): Promise<TriggerEventResponseDto> {
    const result = await this.parseEventRequest.execute(
      ParseEventRequestMulticastCommand.create({
        userId: user._id,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        identifier: body.name,
        payload: body.payload || {},
        overrides: body.overrides || {},
        to: body.to,
        actor: body.actor,
        tenant: body.tenant,
        context: body.context,
        transactionId: body.transactionId,
        addressingType: AddressingTypeEnum.MULTICAST,
        requestCategory: TriggerRequestCategoryEnum.SINGLE,
        bridgeUrl: body.bridgeUrl,
        controls: body.controls,
        requestId: req._nvRequestId,
      })
    );

    return result as unknown as TriggerEventResponseDto;
  }

  @ExternalApiAccessible()
  @ThrottlerCost(ApiRateLimitCostEnum.BULK)
  @RequestAnalytics(AnalyticsStrategyEnum.EVENTS_BULK)
  @LogAnalytics(AnalyticsStrategyEnum.EVENTS_BULK)
  @Post('/trigger/bulk')
  @SdkMethodName('triggerBulk')
  @SdkUsageExample('Trigger Notification Events in Bulk')
  @SdkGroupName('')
  @ApiResponse(TriggerEventResponseDto, 201, true)
  @ApiResponse(PayloadValidationExceptionDto, 400, false, false, {
    description: 'Payload validation failed - returned when any event payload does not match the workflow schema',
  })
  @ApiOperation({
    summary: 'Bulk trigger event',
    description: `
      Using this endpoint you can trigger multiple events at once, to avoid multiple calls to the API.
      The bulk API is limited to 100 events per request.
    `,
  })
  @RequirePermissions(PermissionsEnum.EVENT_WRITE)
  async triggerBulk(
    @UserSession() user: UserSessionData,
    @Body() body: BulkTriggerEventDto,
    @Req() req: RequestWithReqId
  ): Promise<TriggerEventResponseDto[]> {
    return this.processBulkTriggerUsecase.execute(
      ProcessBulkTriggerCommand.create({
        userId: user._id,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        events: body.events,
        requestId: req._nvRequestId,
      })
    );
  }

  @ExternalApiAccessible()
  @ThrottlerCost(ApiRateLimitCostEnum.BULK)
  @RequestAnalytics(AnalyticsStrategyEnum.EVENTS)
  @LogAnalytics(AnalyticsStrategyEnum.EVENTS)
  @Post('/trigger/broadcast')
  @ApiResponse(TriggerEventResponseDto)
  @ApiResponse(PayloadValidationExceptionDto, 400, false, false, {
    description: 'Payload validation failed - returned when payload does not match the workflow schema',
  })
  @SdkMethodName('triggerBroadcast')
  @SdkUsageExample('Broadcast Event to All')
  @SdkGroupName('')
  @ApiOperation({
    summary: 'Broadcast event to all',
    description: `Trigger a broadcast event to all existing subscribers, could be used to send announcements, etc.
      In the future could be used to trigger events to a subset of subscribers based on defined filters.`,
  })
  @ApiCreatedResponse({
    description: 'Broadcast request has been registered successfully ',
    type: TriggerEventResponseDto,
  })
  @RequirePermissions(PermissionsEnum.EVENT_WRITE)
  async broadcastEventToAll(
    @UserSession() user: UserSessionData,
    @Body() body: TriggerEventToAllRequestDto,
    @Req() req: RequestWithReqId
  ): Promise<TriggerEventResponseDto> {
    const transactionId = body.transactionId || uuidv4();

    return this.triggerEventToAll.execute(
      TriggerEventToAllCommand.create({
        userId: user._id,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        identifier: body.name,
        payload: body.payload,
        tenant: body.tenant,
        transactionId,
        overrides: body.overrides || {},
        actor: body.actor,
        requestId: req._nvRequestId,
      })
    );
  }

  @Post('/test/email')
  @ApiExcludeEndpoint()
  @RequirePermissions(PermissionsEnum.EVENT_WRITE)
  async testEmailMessage(@UserSession() user: UserSessionData, @Body() body: TestSendEmailRequestDto): Promise<void> {
    return await this.sendTestEmail.execute(
      SendTestEmailCommand.create({
        subject: body.subject,
        payload: body.payload,
        contentType: body.contentType,
        content: body.content,
        preheader: body.preheader,
        layoutId: body.layoutId,
        to: body.to,
        userId: user._id,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        workflowId: body.workflowId,
        stepId: body.stepId,
        bridge: body.bridge,
        controls: body.controls,
      })
    );
  }

  @ExternalApiAccessible()
  @Delete('/trigger/:transactionId')
  @ApiOkResponse({
    type: Boolean,
  })
  @ApiOperation({
    summary: 'Cancel triggered event',
    description: `
    Using a previously generated transactionId during the event trigger,
     will cancel any active or pending workflows. This is useful to cancel active digests, delays etc...
    `,
  })
  @SdkMethodName('cancel')
  @SdkUsageExample('Cancel Triggered Event')
  @SdkGroupName('')
  @RequirePermissions(PermissionsEnum.EVENT_WRITE)
  async cancel(@UserSession() user: UserSessionData, @Param('transactionId') transactionId: string): Promise<boolean> {
    return await this.cancelDelayedUsecase.execute(
      CancelDelayedCommand.create({
        userId: user._id,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        transactionId,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - RequestAnalytics(strategy: AnalyticsStrategyEnum = AnalyticsStrategyEnum.BASIC)
Asignaciones con arrow functions encontradas (posibles funciones):
 - AnalyticsStrategyEnum(AnalyticsStrategyEnum.BASIC) {
  return (_target: any, _propertyKey: string, descriptor: PropertyDes...)
Declaraciones 'export' encontradas:
- export class EventsController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/events.module.ts
TamaÃ±o: 1526 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { TerminusModule } from '@nestjs/terminus';

import { GetNovuProviderCredentials, StorageHelperService } from '@novu/application-generic';

import { CommunityOrganizationRepository, CommunityUserRepository } from '@novu/dal';
import { AuthModule } from '../auth/auth.module';
import { BridgeModule } from '../bridge';
import { ContentTemplatesModule } from '../content-templates/content-templates.module';
import { ExecutionDetailsModule } from '../execution-details/execution-details.module';
import { IntegrationModule } from '../integrations/integrations.module';
import { LayoutsV1Module } from '../layouts-v1/layouts-v1.module';
import { SharedModule } from '../shared/shared.module';
import { SubscribersV1Module } from '../subscribers/subscribersV1.module';
import { TenantModule } from '../tenant/tenant.module';
import { WidgetsModule } from '../widgets/widgets.module';
import { EventsController } from './events.controller';
import { USE_CASES } from './usecases';

const PROVIDERS = [GetNovuProviderCredentials, StorageHelperService, CommunityOrganizationRepository];

@Module({
  imports: [
    SharedModule,
    TerminusModule,
    WidgetsModule,
    AuthModule,
    SubscribersV1Module,
    ContentTemplatesModule,
    IntegrationModule,
    ExecutionDetailsModule,
    LayoutsV1Module,
    TenantModule,
    BridgeModule,
  ],
  controllers: [EventsController],
  providers: [...PROVIDERS, ...USE_CASES, CommunityUserRepository],
})
export class EventsModule {}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class EventsModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/dtos/index.ts
TamaÃ±o: 185 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './test-email-request.dto';
export * from './trigger-event-request.dto';
export * from './trigger-event-response.dto';
export * from './trigger-event-to-all-request.dto';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/dtos/test-email-request.dto.ts
TamaÃ±o: 761 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IEmailBlock, MessageTemplateContentType } from '@novu/shared';
import { IsBoolean, IsDefined, IsOptional, IsString } from 'class-validator';

export class TestSendEmailRequestDto {
  @IsDefined()
  @IsString()
  contentType: MessageTemplateContentType;

  @IsDefined()
  payload: any;

  @IsDefined()
  @IsString()
  subject: string;

  @IsOptional()
  @IsString()
  preheader?: string;

  @IsDefined()
  content: string | IEmailBlock[];

  @IsDefined()
  to: string | string[];

  @IsOptional()
  @IsString()
  layoutId?: string | null;

  @IsOptional()
  @IsBoolean()
  bridge?: boolean = false;

  @IsOptional()
  @IsString()
  stepId?: string | null;

  @IsOptional()
  @IsString()
  workflowId?: string | null;

  @IsOptional()
  controls: any;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class TestSendEmailRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/dtos/trigger-event-request.dto.ts
TamaÃ±o: 9803 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiExtraModels, ApiHideProperty, ApiProperty, ApiPropertyOptional, getSchemaPath } from '@nestjs/swagger';
import { IsValidContextPayload } from '@novu/application-generic';
import {
  ContextPayload,
  ProvidersIdEnum,
  SeverityLevelEnum,
  TriggerRecipientSubscriber,
  TriggerRecipientsPayload,
  TriggerRecipientsTypeEnum,
  TriggerTenantContext,
} from '@novu/shared';
import { Type } from 'class-transformer';
import {
  ArrayMaxSize,
  IsArray,
  IsDefined,
  IsObject,
  IsOptional,
  IsString,
  ValidateIf,
  ValidateNested,
} from 'class-validator';
import { ApiContextPayload } from '../../shared/framework/swagger';
import { SdkApiProperty } from '../../shared/framework/swagger/sdk.decorators';
import { CreateSubscriberRequestDto } from '../../subscribers/dtos';
import { UpdateTenantRequestDto } from '../../tenant/dtos';

export class WorkflowToStepControlValuesDto {
  /**
   * A mapping of step IDs to their corresponding data.
   * Built for stateless triggering by the local studio, those values will not be persisted outside of the job scope
   * First key is step id, second is controlId, value is the control value
   * @type {Record<stepId, Data>}
   * @optional
   */
  @ApiProperty({
    description: 'A mapping of step IDs to their corresponding data.',
    type: 'object',
    additionalProperties: {
      type: 'object',
      additionalProperties: true,
    },
    required: false,
  })
  steps?: Record<string, Record<string, unknown>>;
}

export class SubscriberPayloadDto extends CreateSubscriberRequestDto {}
export class TenantPayloadDto extends UpdateTenantRequestDto {}

export class TopicPayloadDto {
  @ApiProperty()
  topicKey: string;

  @ApiProperty({
    enum: [...Object.values(TriggerRecipientsTypeEnum)],
    enumName: 'TriggerRecipientsTypeEnum',
  })
  type: TriggerRecipientsTypeEnum;

  @ApiPropertyOptional({
    description: 'Optional array of subscriber IDs to exclude from the topic trigger',
    type: [String],
  })
  @IsArray()
  @ArrayMaxSize(100)
  @IsString({ each: true })
  @IsOptional()
  exclude?: string[];
}

export class StepsOverrides {
  @ApiPropertyOptional({
    description: 'Passing the provider id and the provider specific configurations',
    example: {
      sendgrid: {
        templateId: '1234567890',
      },
    },
    type: 'object',
    additionalProperties: {
      type: 'object',
      additionalProperties: true,
    },
  })
  providers?: Record<ProvidersIdEnum, Record<string, unknown>>;

  @ApiPropertyOptional({
    description: 'Override the or remove the layout for this specific step',
    example: 'welcome-email-layout',
    nullable: true,
    type: 'string',
  })
  @IsOptional()
  @IsString()
  layoutId?: string | null;
}

export class EmailChannelOverrides {
  @ApiPropertyOptional({
    description: 'Override or remove the layout for all email steps in the workflow',
    example: 'promotional-layout-2024',
    nullable: true,
    type: 'string',
  })
  @IsOptional()
  @IsString()
  layoutId?: string | null;
}

export class ChannelOverrides {
  @ApiPropertyOptional({
    description: 'Email channel specific overrides',
    type: () => EmailChannelOverrides,
  })
  email?: EmailChannelOverrides;
}

export class TriggerOverrides {
  @ApiPropertyOptional({
    description: 'This could be used to override provider specific configurations or layout at the step level',
    example: {
      'email-step': {
        providers: {
          sendgrid: {
            templateId: '1234567890',
          },
        },
        layoutId: 'step-specific-layout',
      },
    },
    type: 'object',
    additionalProperties: {
      $ref: getSchemaPath(StepsOverrides),
    },
  })
  steps?: Record<string, StepsOverrides>;

  @ApiPropertyOptional({
    description:
      'Channel-specific overrides that apply to all steps of a particular channel type. Step-level overrides take precedence over channel-level overrides.',
    example: {
      email: {
        layoutId: 'promotional-layout-2024',
      },
    },
    type: () => ChannelOverrides,
  })
  channels?: ChannelOverrides;

  @ApiPropertyOptional({
    description: 'Overrides the provider configuration for the entire workflow and all steps',
    example: {
      sendgrid: {
        templateId: '1234567890',
      },
    },
    type: 'object',
    additionalProperties: {
      type: 'object',
      additionalProperties: true,
    },
  })
  providers?: Record<ProvidersIdEnum, Record<string, unknown>>;

  @ApiPropertyOptional({
    description: 'Override the email provider specific configurations for the entire workflow',
    deprecated: true,
    type: 'object',
    additionalProperties: true,
  })
  email?: Record<string, any>;

  @ApiPropertyOptional({
    description: 'Override the push provider specific configurations for the entire workflow',
    deprecated: true,
    type: 'object',
    additionalProperties: true,
  })
  push?: Record<string, any>;

  @ApiPropertyOptional({
    description: 'Override the sms provider specific configurations for the entire workflow',
    deprecated: true,
    type: 'object',
    additionalProperties: true,
  })
  sms?: Record<string, any>;

  @ApiPropertyOptional({
    description: 'Override the chat provider specific configurations for the entire workflow',
    deprecated: true,
    type: 'object',
    additionalProperties: true,
  })
  chat?: Record<string, any>;

  @ApiPropertyOptional({
    description: 'Override the layout identifier for the entire workflow',
    deprecated: true,
  })
  layoutIdentifier?: string;

  @ApiPropertyOptional({
    description: 'Override the severity of the workflow',
    enum: [...Object.values(SeverityLevelEnum)],
    enumName: 'SeverityLevelEnum',
  })
  severity?: SeverityLevelEnum;
}

@ApiExtraModels(
  SubscriberPayloadDto,
  TenantPayloadDto,
  TopicPayloadDto,
  StepsOverrides,
  EmailChannelOverrides,
  ChannelOverrides
)
export class TriggerEventRequestDto {
  @SdkApiProperty(
    {
      description:
        'The trigger identifier of the workflow you wish to send. This identifier can be found on the workflow page.',
      example: 'workflow_identifier',
    },
    { nameOverride: 'workflowId' }
  )
  @IsString()
  @IsDefined()
  name: string;

  @ApiProperty({
    description: `The payload object is used to pass additional custom information that could be 
    used to render the workflow, or perform routing rules based on it. 
      This data will also be available when fetching the notifications feed from the API to display certain parts of the UI.`,
    type: 'object',
    required: false,
    additionalProperties: true,
    example: {
      comment_id: 'string',
      post: {
        text: 'string',
      },
    },
  })
  @IsObject()
  @IsOptional()
  payload?: Record<string, unknown>;

  @ApiHideProperty()
  @IsString()
  @IsOptional()
  bridgeUrl?: string;

  @ApiPropertyOptional({
    description: 'This could be used to override provider specific configurations',
    example: {
      fcm: {
        data: {
          key: 'value',
        },
      },
    },
    type: TriggerOverrides,
    required: false,
  })
  @IsObject()
  @IsOptional()
  overrides?: TriggerOverrides;

  @ApiProperty({
    description: 'The recipients list of people who will receive the notification.',
    oneOf: [
      {
        type: 'array',
        items: {
          oneOf: [
            {
              $ref: getSchemaPath(SubscriberPayloadDto),
            },
            {
              $ref: getSchemaPath(TopicPayloadDto),
            },
            {
              type: 'string',
              description: 'Unique identifier of a subscriber in your systems',
              example: 'SUBSCRIBER_ID',
            },
          ],
        },
      },
      {
        type: 'string',
        description: 'Unique identifier of a subscriber in your systems',
        example: 'SUBSCRIBER_ID',
      },
      {
        $ref: getSchemaPath(SubscriberPayloadDto),
      },
      {
        $ref: getSchemaPath(TopicPayloadDto),
      },
    ],
  })
  @IsDefined()
  to: TriggerRecipientsPayload;

  @ApiPropertyOptional({
    description: `A unique identifier for deduplication. If the same **transactionId** is sent again, 
      the trigger is ignored. Useful to prevent duplicate notifications. The retention period depends on your billing tier.`,
  })
  @IsString()
  @IsOptional()
  transactionId?: string;

  @ApiProperty({
    description: `It is used to display the Avatar of the provided actor's subscriber id or actor object.
    If a new actor object is provided, we will create a new subscriber in our system`,
    oneOf: [
      { type: 'string', description: 'Unique identifier of a subscriber in your systems' },
      { $ref: getSchemaPath(SubscriberPayloadDto) },
    ],
    required: false,
  })
  @IsOptional()
  @ValidateIf((_, value) => typeof value !== 'string')
  @ValidateNested()
  @Type(() => SubscriberPayloadDto)
  actor?: TriggerRecipientSubscriber;

  @ApiProperty({
    description: `It is used to specify a tenant context during trigger event.
    Existing tenants will be updated with the provided details.`,
    oneOf: [
      { type: 'string', description: 'Unique identifier of a tenant in your system' },
      { $ref: getSchemaPath(TenantPayloadDto) },
    ],
    required: false,
  })
  @IsOptional()
  @ValidateIf((_, value) => typeof value !== 'string')
  @ValidateNested()
  @Type(() => TenantPayloadDto)
  tenant?: TriggerTenantContext;

  @ApiHideProperty()
  controls?: WorkflowToStepControlValuesDto;

  @ApiContextPayload()
  @IsOptional()
  @IsValidContextPayload({ maxCount: 5 })
  context?: ContextPayload;
}

export class BulkTriggerEventDto {
  @ApiProperty({
    isArray: true,
    type: TriggerEventRequestDto,
  })
  events: TriggerEventRequestDto[];
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class WorkflowToStepControlValuesDto
- export class SubscriberPayloadDto
- export class TenantPayloadDto
- export class TopicPayloadDto
- export class StepsOverrides
- export class EmailChannelOverrides
- export class ChannelOverrides
- export class TriggerOverrides
- export class TriggerEventRequestDto
- export class BulkTriggerEventDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/dtos/trigger-event-response.dto.ts
TamaÃ±o: 1098 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { TriggerEventStatusEnum } from '@novu/shared';
import { IsBoolean, IsDefined, IsEnum, IsOptional, IsString } from 'class-validator';

export class TriggerEventResponseDto {
  @ApiProperty({
    description: 'Indicates whether the trigger was acknowledged or not',
    type: Boolean,
  })
  @IsBoolean()
  @IsDefined()
  acknowledged: boolean;

  @ApiProperty({
    description: 'Status of the trigger',
    enum: TriggerEventStatusEnum,
  })
  @IsDefined()
  @IsEnum(TriggerEventStatusEnum)
  status: TriggerEventStatusEnum;

  @ApiProperty({
    description: 'In case of an error, this field will contain the error message(s)',
    type: [String], // Specify that this is an array of strings
    required: false, // Not required since it's optional
  })
  @IsOptional()
  error?: string[];

  @ApiProperty({
    description: 'The returned transaction ID of the trigger',
    type: String, // Specify that this is a string
    required: false, // Not required since it's optional
  })
  @IsOptional()
  @IsString()
  transactionId?: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class TriggerEventResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/dtos/trigger-event-to-all-request.dto.ts
TamaÃ±o: 2789 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional, getSchemaPath } from '@nestjs/swagger';
import { TriggerRecipientSubscriber, TriggerTenantContext } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsDefined, IsObject, IsOptional, IsString, ValidateIf, ValidateNested } from 'class-validator';

import { SubscriberPayloadDto, TenantPayloadDto, TriggerOverrides } from './trigger-event-request.dto';

export class TriggerEventToAllRequestDto {
  @ApiProperty({
    description:
      'The trigger identifier associated for the template you wish to send. This identifier can be found on the template page.',
  })
  @IsString()
  @IsDefined()
  name: string;

  @ApiProperty({
    example: {
      comment_id: 'string',
      post: {
        text: 'string',
      },
    },
    type: 'object',
    description: `The payload object is used to pass additional information that 
    could be used to render the template, or perform routing rules based on it. 
      For In-App channel, payload data are also available in <Inbox />`,
    required: true,
    additionalProperties: true,
  })
  @IsObject()
  payload: Record<string, unknown>;

  @ApiPropertyOptional({
    description: 'This could be used to override provider specific configurations',
    example: {
      fcm: {
        data: {
          key: 'value',
        },
      },
    },
    type: TriggerOverrides,
    additionalProperties: {
      type: 'object',
      additionalProperties: true,
    },
    required: false,
  })
  @IsObject()
  @IsOptional()
  overrides?: TriggerOverrides;

  @ApiProperty({
    description: 'A unique identifier for this transaction, we will generated a UUID if not provided.',
  })
  @IsString()
  @IsOptional()
  transactionId?: string;

  @ApiProperty({
    description: `It is used to display the Avatar of the provided actor's subscriber id or actor object.
    If a new actor object is provided, we will create a new subscriber in our system
    `,
    oneOf: [
      { type: 'string', description: 'Unique identifier of a subscriber in your systems' },
      { $ref: getSchemaPath(SubscriberPayloadDto) },
    ],
  })
  @IsOptional()
  @ValidateIf((_, value) => typeof value !== 'string')
  @ValidateNested()
  @Type(() => SubscriberPayloadDto)
  actor?: TriggerRecipientSubscriber;

  @ApiProperty({
    description: `It is used to specify a tenant context during trigger event.
    If a new tenant object is provided, we will create a new tenant.
    `,
    oneOf: [
      { type: 'string', description: 'Unique identifier of a tenant in your system' },
      { $ref: getSchemaPath(TenantPayloadDto) },
    ],
  })
  @IsOptional()
  @ValidateIf((_, value) => typeof value !== 'string')
  @ValidateNested()
  @Type(() => TenantPayloadDto)
  tenant?: TriggerTenantContext;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class TriggerEventToAllRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/bridge-trigger.e2e.ts
TamaÃ±o: 72271 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { DetailEnum } from '@novu/application-generic';
import {
  ExecutionDetailsRepository,
  JobRepository,
  MessageRepository,
  NotificationTemplateRepository,
  SubscriberEntity,
} from '@novu/dal';
import { workflow } from '@novu/framework';
import {
  ChannelTypeEnum,
  CreateWorkflowDto,
  ExecutionDetailsStatusEnum,
  JobStatusEnum,
  MessagesStatusEnum,
  StepTypeEnum,
  WorkflowCreationSourceEnum,
  WorkflowResponseDto,
} from '@novu/shared';

import { JobsService, SubscribersService, UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import getPort from 'get-port';
import sinon from 'sinon';
import { TestBridgeServer } from '../../../../e2e/test-bridge-server';

const eventTriggerPath = '/v1/events/trigger';

type Context = { name: string; isStateful: boolean };
const contexts: Context[] = [{ name: 'stateful', isStateful: true }];

contexts.forEach((context: Context) => {
  /**
   * For some reason, the bridge trigger is very flaky in setting up the test server,
   * It's not clear why, but it's causing the tests to fail.
   */
  describe.skip('Self-Hosted Bridge Trigger #novu-v2', async () => {
    let session: UserSession;
    let bridgeServer: TestBridgeServer;
    const messageRepository = new MessageRepository();
    const workflowsRepository = new NotificationTemplateRepository();
    const jobRepository = new JobRepository();
    let subscriber: SubscriberEntity;
    let subscriberService: SubscribersService;
    const executionDetailsRepository = new ExecutionDetailsRepository();
    let bridge;

    beforeEach(async () => {
      const port = await getPort();
      bridgeServer = new TestBridgeServer(port);
      bridge = context.isStateful ? undefined : { url: `${bridgeServer.serverPath}/novu` };
      session = new UserSession();
      await session.initialize();
      subscriberService = new SubscribersService(session.organization._id, session.environment._id);
      subscriber = await subscriberService.createSubscriber({ _id: session.subscriberId });
    });

    afterEach(async () => {
      await bridgeServer.stop();
    });

    it(`should trigger the bridge workflow with sync [${context.name}]`, async () => {
      const workflowId = `hello-world-${`${context.name}`}`;
      const newWorkflow = workflow(
        workflowId,
        async ({ step, payload }) => {
          await step.email(
            'send-email',
            async (controls) => {
              return {
                subject: `This is an email subject ${controls.name}`,
                body: `Body result ${payload.name}`,
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {
                  name: { type: 'string', default: 'TEST' },
                },
              } as const,
            }
          );

          await step.inApp(
            'send-in-app',
            async (controls) => {
              return {
                body: `in-app result ${payload.name}`,
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {
                  name: { type: 'string', default: 'TEST' },
                },
              } as const,
            }
          );

          await step.sms(
            'send-sms',
            async (controls) => {
              return {
                body: `sms result ${payload.name}`,
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {
                  name: { type: 'string', default: 'TEST' },
                },
              } as const,
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              name: { type: 'string', default: 'default_name' },
            },
            required: [],
            additionalProperties: false,
          } as const,
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);

        const foundWorkflow = await workflowsRepository.findByTriggerIdentifier(session.environment._id, workflowId);
        expect(foundWorkflow).to.be.ok;

        if (!foundWorkflow) {
          throw new Error('Workflow not found');
        }
      }

      await bridgeServer.start({ workflows: [newWorkflow] });
      await triggerEvent(session, workflowId, subscriber.subscriberId, { name: 'test_name' }, bridge);
      await session.waitForJobCompletion();

      const messages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: { $in: [StepTypeEnum.EMAIL, StepTypeEnum.IN_APP, StepTypeEnum.SMS] },
      });

      expect(messages.length).to.be.eq(3);
      const emailMessage = messages.find((message) => message.channel === ChannelTypeEnum.EMAIL);
      expect(emailMessage?.subject).to.include('This is an email subject TEST');
      const inAppMessage = messages.find((message) => message.channel === ChannelTypeEnum.IN_APP);
      expect(inAppMessage?.content).to.include('in-app result test_name');
      const smsMessage = messages.find((message) => message.channel === ChannelTypeEnum.SMS);
      expect(smsMessage?.content).to.include('sms result test_name');
    });

    it(`should skip by static value [${context.name}]`, async () => {
      const workflowIdSkipByStatic = `skip-by-static-value-workflow-${`${context.name}`}`;
      const newWorkflow = workflow(
        workflowIdSkipByStatic,
        async ({ step, payload }) => {
          await step.email(
            'send-email',
            async (controls) => {
              return {
                subject: `This is an email subject ${controls.name}`,
                body: `Body result ${payload.name}`,
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {
                  name: { type: 'string', default: 'TEST' },
                },
              } as const,
              skip: () => true,
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              name: { type: 'string', default: 'default_name' },
            },
            required: [],
            additionalProperties: false,
          } as const,
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await syncWorkflow(session, workflowsRepository, workflowIdSkipByStatic, bridgeServer);
      }

      await triggerEvent(session, workflowIdSkipByStatic, subscriber.subscriberId, {}, bridge);
      await session.waitForJobCompletion();

      const executedMessageByStatic = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.EMAIL,
      });

      expect(executedMessageByStatic.length).to.be.eq(0);

      const cancelledJobByStatic = await jobRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        type: StepTypeEnum.EMAIL,
      });

      expect(cancelledJobByStatic.length).to.be.eq(1);
      expect(cancelledJobByStatic[0].status).to.be.eq(JobStatusEnum.CANCELED);
    });

    it(`should skip by variable default value [${context.name}]`, async () => {
      const workflowIdSkipByVariable = `skip-by-variable-default-value-${`${context.name}`}`;
      const newWorkflow = workflow(
        workflowIdSkipByVariable,
        async ({ step, payload }) => {
          await step.email(
            'send-email',
            async (controls) => {
              return {
                subject: `This is an email subject ${controls.name}`,
                body: `Body result ${payload.name}`,
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {
                  name: { type: 'string', default: 'TEST' },
                  shouldSkipVar: { type: 'boolean', default: true },
                },
              } as const,
              skip: (controls) => controls.shouldSkipVar,
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              name: { type: 'string', default: 'default_name' },
            },
            required: [],
            additionalProperties: false,
          } as const,
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await syncWorkflow(session, workflowsRepository, workflowIdSkipByVariable, bridgeServer);
      }

      await triggerEvent(session, workflowIdSkipByVariable, subscriber.subscriberId, {}, bridge);
      await session.waitForJobCompletion();

      const executedMessage = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.EMAIL,
      });

      expect(executedMessage.length).to.be.eq(0);

      const cancelledJobByVariable = await jobRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        type: StepTypeEnum.EMAIL,
      });

      expect(cancelledJobByVariable.length).to.be.eq(1);
      expect(cancelledJobByVariable[0].status).to.be.eq(JobStatusEnum.CANCELED);
    });

    it(`should have execution detail errors for invalid trigger payload [${context.name}]`, async () => {
      const workflowId = `missing-payload-name-${`${context.name}`}`;
      const newWorkflow = workflow(
        workflowId,
        async ({ step, payload }) => {
          await step.email('send-email', async () => {
            return {
              subject: 'This is an email subject',
              body: 'Body result',
            };
          });
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              name: { type: 'string' },
            },
            required: ['name'],
            additionalProperties: false,
          } as const,
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      await triggerEvent(session, workflowId, subscriber.subscriberId, {}, bridge);

      await session.waitForJobCompletion();

      const messagesAfter = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.EMAIL,
      });

      expect(messagesAfter.length).to.be.eq(0);
      const executionDetailsRequired = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        status: ExecutionDetailsStatusEnum.FAILED,
      });

      let raw = JSON.parse(executionDetailsRequired[0]?.raw ?? '');
      let error = raw.data[0].message;

      expect(error).to.include("must have required property 'name'");

      await executionDetailsRepository.delete({ _environmentId: session.environment._id });

      await triggerEvent(session, workflowId, subscriber.subscriberId, { name: 4 }, bridge);
      await session.waitForJobCompletion();

      const executionDetailsInvalidType = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        status: ExecutionDetailsStatusEnum.FAILED,
      });
      raw = JSON.parse(executionDetailsInvalidType[0]?.raw ?? '');
      error = raw.data[0].message;

      expect(error).to.include('must be string');
    });

    it(`should use custom step [${context.name}]`, async () => {
      const workflowId = `with-custom-step-${`${context.name}`}`;
      const newWorkflow = workflow(workflowId, async ({ step }) => {
        const resInApp = await step.inApp('send-in-app', async () => {
          return {
            body: `Hello There`,
          };
        });

        const resCustom = await step.custom(
          'custom',
          async () => {
            await markAllSubscriberMessagesAs(session, subscriber.subscriberId, MessagesStatusEnum.READ);

            return { readString: 'Read', unReadString: 'Unread' };
          },
          {
            outputSchema: {
              type: 'object',
              properties: {
                readString: { type: 'string' },
                unReadString: { type: 'string' },
              },
              required: [],
              additionalProperties: false,
            } as const,
          }
        );

        await step.email('send-email', async () => {
          const emailSubject = resInApp.read ? resCustom?.readString : resCustom?.unReadString;

          return {
            subject: `${emailSubject}`,
            body: 'Email Body',
          };
        });
      });

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      await triggerEvent(session, workflowId, subscriber.subscriberId, {}, bridge);

      await session.waitForJobCompletion();

      const messagesAfterInApp = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.IN_APP,
      });

      expect(messagesAfterInApp.length).to.be.eq(1);

      const messagesAfterEmail = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.EMAIL,
      });
      expect(messagesAfterEmail.length).to.be.eq(1);
      expect(messagesAfterEmail[0].subject).to.include('Read');
    });

    it(`should trigger the bridge workflow with digest [${context.name}]`, async () => {
      const workflowId = `digest-workflow-${`${context.name}`}`;
      const newWorkflow = workflow(
        workflowId,
        async ({ step }) => {
          const digestResponse = await step.digest(
            'digest',
            async (controls) => {
              return {
                amount: controls.amount,
                unit: controls.unit,
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {
                  amount: {
                    type: 'number',
                    default: 2,
                  },
                  unit: {
                    type: 'string',
                    enum: ['seconds', 'minutes', 'hours', 'days', 'weeks', 'months'],
                    default: 'seconds',
                  },
                },
              } as const,
            }
          );

          await step.sms('send-sms', async () => {
            const events = digestResponse.events.length;

            return {
              body: `${events} people liked your post`,
            };
          });
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              name: { type: 'string', default: 'default_name' },
            },
            required: [],
            additionalProperties: false,
          } as const,
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      await triggerEvent(session, workflowId, subscriber.subscriberId, { name: 'John' }, bridge);
      await triggerEvent(session, workflowId, subscriber.subscriberId, { name: 'Bela' }, bridge);

      await session.waitForJobCompletion();

      const messages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.SMS,
      });

      expect(messages.length).to.be.eq(1);
      expect(messages[0].content).to.include('2 people liked your post');
    });

    it(`should trigger the bridge workflow with delay [${context.name}]`, async () => {
      const workflowId = `delay-workflow-${`${context.name}`}`;
      const newWorkflow = workflow(
        workflowId,
        async ({ step }) => {
          const delayResponse = await step.delay(
            'delay-id',
            async (controls) => {
              return {
                type: 'regular',
                amount: controls.amount,
                unit: controls.unit,
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {
                  amount: {
                    type: 'number',
                    default: 1,
                  },
                  unit: {
                    type: 'string',
                    enum: ['seconds', 'minutes', 'hours', 'days', 'weeks', 'months'],
                    default: 'seconds',
                  },
                },
              } as const,
            }
          );

          await step.sms(
            'send-sms',
            async () => {
              const { duration } = delayResponse;

              return {
                body: `people waited for ${duration} seconds`,
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {},
              },
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              name: { type: 'string', default: 'default_name' },
            },
            required: [],
            additionalProperties: false,
          } as const,
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      await triggerEvent(session, workflowId, subscriber.subscriberId, {}, bridge);

      await session.waitForJobCompletion();

      const messagesAfter = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.SMS,
      });

      expect(messagesAfter.length).to.be.eq(1);
      expect(messagesAfter[0].content).to.match(/people waited for \d+ seconds/);

      const exceedMaxTierDurationWorkflowId = `exceed-max-tier-duration-workflow-${`${context.name}`}`;
      const exceedMaxTierDurationWorkflow = workflow(exceedMaxTierDurationWorkflowId, async ({ step }) => {
        await step.delay('delay-id', async (controls) => {
          return {
            type: 'regular',
            amount: 100,
            unit: 'days',
          };
        });

        await step.inApp('send-in-app', async () => {
          return {
            body: `people want to wait for 100 days`,
          };
        });
      });

      await bridgeServer.stop();
      await bridgeServer.start({ workflows: [exceedMaxTierDurationWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, exceedMaxTierDurationWorkflowId, bridgeServer);
      }

      const result = await triggerEvent(session, exceedMaxTierDurationWorkflowId, subscriber.subscriberId, {}, bridge);
      await session.waitForJobCompletion();

      const executionDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        transactionId: result?.data?.data?.transactionId,
      });

      const delayExecutionDetails = executionDetails.filter((executionDetail) => executionDetail.channel === 'delay');
      expect(delayExecutionDetails.some((detail) => detail.detail === 'Defer duration limit exceeded')).to.be.true;
    });

    it(`should trigger the bridge workflow with control default and payload data [${context.name}]`, async () => {
      const workflowId = `default-payload-params-workflow-${`${context.name}`}`;
      const newWorkflow = workflow(
        workflowId,
        async ({ step, payload }) => {
          await step.email(
            'send-email',
            async (controls) => {
              return {
                subject: `prefix ${controls.name}`,
                body: 'Body result',
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {
                  name: { type: 'string', default: 'Hello {{payload.name}}' },
                },
              } as const,
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              name: { type: 'string', default: 'default_name' },
            },
            required: [],
            additionalProperties: false,
          } as const,
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      await triggerEvent(session, workflowId, subscriber.subscriberId, {}, bridge);

      await triggerEvent(session, workflowId, subscriber.subscriberId, { name: 'payload_name' }, bridge);

      await session.waitForJobCompletion();

      const sentMessage = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.EMAIL,
      });

      expect(sentMessage.length).to.be.eq(2);
      const expectedSubjects = ['prefix Hello default_name', 'prefix Hello payload_name'];

      expectedSubjects.forEach((expectedSubject) => {
        const found = sentMessage.some((message) => message.subject?.includes(expectedSubject));
        expect(found).to.be.true;
      });
    });

    it(`should trigger the bridge workflow with control variables [${context.name}]`, async () => {
      const workflowId = `control-variables-workflow-${`${context.name}`}`;
      const stepId = 'send-email';
      const newWorkflow = workflow(
        workflowId,
        async ({ step, payload }) => {
          await step.email(
            stepId,
            async (controls) => {
              return {
                subject: `email subject ${controls.name}`,
                body: 'Body result',
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {
                  name: { type: 'string', default: 'control default' },
                },
              } as const,
            }
          );
        },
        {
          // todo delete
          payloadSchema: {
            type: 'object',
            properties: {
              name: { type: 'string', default: 'default_name' },
            },
            required: [],
            additionalProperties: false,
          } as const,
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
        await saveControlValues(session, workflowId, stepId, { variables: { name: 'stored_control_name' } });
      }

      const controls = { steps: { [stepId]: { name: 'stored_control_name' } } };
      await triggerEvent(session, workflowId, subscriber.subscriberId, {}, bridge, controls);
      await session.waitForJobCompletion();

      const sentMessage = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.EMAIL,
      });

      expect(sentMessage.length).to.be.eq(1);
      expect(sentMessage[0].subject).to.equal('email subject stored_control_name');
    });

    it(`should store 2 in-app messages for a single notification event [${context.name}]`, async () => {
      const workflowId = `double-in-app-workflow-${`${context.name}`}`;
      const newWorkflow = workflow(workflowId, async ({ step }) => {
        await step.inApp('send-in-app1', () => ({ body: 'Hello there 1' }));
        await step.inApp('send-in-app2', () => ({ body: 'Hello there 2' }));
      });

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      await triggerEvent(session, workflowId, subscriber.subscriberId, {}, bridge);
      await session.waitForJobCompletion();

      const sentMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        templateIdentifier: workflowId,
        channel: StepTypeEnum.IN_APP,
      });

      expect(sentMessages.length).to.be.eq(2);
      const messageBodies = sentMessages.map((message) => message.content);
      expect(messageBodies).to.include('Hello there 1');
      expect(messageBodies).to.include('Hello there 2');
    });

    it(`should deliver message if the Workflow Definition doesn't contain preferences [${context.name}]`, async () => {
      const workflowId = `without-preferences-workflow-${`${context.name}`}`;
      const newWorkflow = workflow(workflowId, async ({ step }) => {
        await step.inApp('send-in-app', () => ({ body: 'Hello there 1' }));
      });

      /*
       * Delete `preferences` from the Workflow Definition to simulate an old
       * Workflow Definition (i.e. from old Framework version) that doesn't have the `preferences` property.
       */
      const { preferences, ...rest } = await newWorkflow.discover();
      // @ts-expect-error - preferences is not part of the resolved object
      sinon.stub(newWorkflow, 'discover').resolves(rest);

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      await triggerEvent(session, workflowId, subscriber.subscriberId, {}, bridge);
      await session.waitForJobCompletion();

      const sentMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        templateIdentifier: workflowId,
        channel: StepTypeEnum.IN_APP,
      });

      expect(sentMessages.length).to.be.eq(1);
    });

    it(`should deliver message if inApp is enabled via workflow preferences [${context.name}]`, async () => {
      const workflowId = `enabled-inapp-workflow-${`${context.name}`}`;
      const newWorkflow = workflow(
        workflowId,
        async ({ step }) => {
          await step.inApp('send-in-app', () => ({ body: 'Hello there 1' }));
        },
        {
          preferences: {
            channels: {
              inApp: {
                enabled: true,
              },
            },
          },
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      await triggerEvent(session, workflowId, subscriber.subscriberId, {}, bridge);
      await session.waitForJobCompletion();

      const sentMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        templateIdentifier: workflowId,
        channel: StepTypeEnum.IN_APP,
      });

      expect(sentMessages.length).to.be.eq(1);
    });

    it(`should NOT deliver message if inApp is disabled via workflow preferences [${context.name}]`, async () => {
      const workflowId = `disabled-inapp-workflow-${`${context.name}`}`;
      const newWorkflow = workflow(
        workflowId,
        async ({ step }) => {
          await step.inApp('send-in-app', () => ({ body: 'Hello there 1' }));
        },
        {
          preferences: {
            channels: {
              inApp: {
                enabled: false,
              },
            },
          },
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      await triggerEvent(session, workflowId, subscriber.subscriberId, {}, bridge);
      await session.waitForJobCompletion();

      const sentMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        templateIdentifier: workflowId,
        channel: StepTypeEnum.IN_APP,
      });

      expect(sentMessages.length).to.be.eq(0);

      const executionDetailsFiltered = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        status: ExecutionDetailsStatusEnum.SUCCESS,
      });

      const executionDetailsWorkflowFiltered = executionDetailsFiltered.filter(
        (executionDetail) => executionDetail.detail === DetailEnum.STEP_FILTERED_BY_WORKFLOW_RESOURCE_PREFERENCES
      );

      expect(executionDetailsWorkflowFiltered.length).to.be.eq(1);
    });

    it(`should deliver inApp message if workflow is disabled via workflow preferences and inApp is enabled [${context.name}]`, async () => {
      const workflowId = `disabled-workflow-inapp-enabled-${`${context.name}`}`;
      const newWorkflow = workflow(
        workflowId,
        async ({ step }) => {
          await step.inApp('send-in-app', () => ({ body: 'Hello there 1' }));
        },
        {
          preferences: {
            all: {
              enabled: false,
            },
            channels: {
              inApp: {
                enabled: true,
              },
            },
          },
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      await triggerEvent(session, workflowId, subscriber.subscriberId, {}, bridge);
      await session.waitForJobCompletion();

      const sentMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        templateIdentifier: workflowId,
        channel: StepTypeEnum.IN_APP,
      });

      expect(sentMessages.length).to.be.eq(1);
    });

    it(`should NOT deliver inApp message if workflow is disabled via workflow preferences [${context.name}]`, async () => {
      const workflowId = `disabled-workflow-${`${context.name}`}`;
      const newWorkflow = workflow(
        workflowId,
        async ({ step }) => {
          await step.inApp('send-in-app', () => ({ body: 'Hello there 1' }));
        },
        {
          preferences: {
            all: {
              enabled: false,
            },
          },
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      await triggerEvent(session, workflowId, subscriber.subscriberId, {}, bridge);
      await session.waitForJobCompletion();

      const sentMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        templateIdentifier: workflowId,
        channel: StepTypeEnum.IN_APP,
      });

      expect(sentMessages.length).to.be.eq(0);

      const executionDetailsFiltered = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        status: ExecutionDetailsStatusEnum.SUCCESS,
      });

      const executionDetailsWorkflowFiltered = executionDetailsFiltered.filter(
        (executionDetail) => executionDetail.detail === DetailEnum.STEP_FILTERED_BY_WORKFLOW_RESOURCE_PREFERENCES
      );

      expect(executionDetailsWorkflowFiltered.length).to.be.eq(1);
    });

    it(`should deliver inApp message if subscriber disabled inApp channel for readOnly workflow with inApp enabled [${context.name}]`, async () => {
      const workflowId = `enabled-readonly-workflow-level-${`${context.name}`}`;
      const newWorkflow = workflow(
        workflowId,
        async ({ step }) => {
          await step.inApp('send-in-app', () => ({ body: 'Hello there 1' }));
        },
        {
          preferences: {
            all: {
              readOnly: true,
            },
            channels: {
              inApp: {
                enabled: true,
              },
            },
          },
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      const createdWorkflow = await workflowsRepository.findByTriggerIdentifier(session.environment._id, workflowId);

      if (context.isStateful) {
        // Set subscriber preference to disable inApp for the workflow
        await session.testAgent
          .patch(`/v1/inbox/preferences/${createdWorkflow?._id}`)
          .set('Authorization', `Bearer ${session.subscriberToken}`)
          .send({
            in_app: false,
          });
      }

      await triggerEvent(session, workflowId, subscriber._id, {}, bridge);
      await session.waitForJobCompletion();

      const sentMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: session.subscriberProfile?._id,
        templateIdentifier: workflowId,
        channel: StepTypeEnum.IN_APP,
      });

      expect(sentMessages.length).to.be.eq(1);
    });

    it(`should NOT deliver inApp message if subscriber enables inApp channel for readOnly workflow with inApp disabled [${context.name}]`, async () => {
      const workflowId = `disabled-readonly-workflow-level-${`${context.name}`}`;
      const newWorkflow = workflow(
        workflowId,
        async ({ step }) => {
          await step.inApp('send-in-app', () => ({ body: 'Hello there 1' }));
        },
        {
          preferences: {
            all: {
              readOnly: true,
            },
            channels: {
              inApp: {
                enabled: false,
              },
            },
          },
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      const createdWorkflow = await workflowsRepository.findByTriggerIdentifier(session.environment._id, workflowId);

      if (context.isStateful) {
        // Set subscriber preference to enable inApp for the workflow
        await session.testAgent
          .patch(`/v1/inbox/preferences/${createdWorkflow?._id}`)
          .set('Authorization', `Bearer ${session.subscriberToken}`)
          .send({
            in_app: true,
          });
      }

      await triggerEvent(session, workflowId, subscriber._id, {}, bridge);
      await session.waitForJobCompletion();

      const sentMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: session.subscriberProfile?._id,
        templateIdentifier: workflowId,
        channel: StepTypeEnum.IN_APP,
      });

      expect(sentMessages.length).to.be.eq(0);

      const executionDetailsFiltered = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        status: ExecutionDetailsStatusEnum.SUCCESS,
      });

      const executionDetailsWorkflowFiltered = executionDetailsFiltered.filter(
        (executionDetail) => executionDetail.detail === DetailEnum.STEP_FILTERED_BY_WORKFLOW_RESOURCE_PREFERENCES
      );

      expect(executionDetailsWorkflowFiltered.length).to.be.eq(1);
    });

    it(`should deliver inApp message if subscriber disabled inApp channel globally for readOnly workflow with inApp enabled [${context.name}]`, async () => {
      const workflowId = `enabled-readonly-global-level-${`${context.name}`}`;
      const newWorkflow = workflow(
        workflowId,
        async ({ step }) => {
          await step.inApp('send-in-app', () => ({ body: 'Hello there 1' }));
        },
        {
          preferences: {
            all: {
              readOnly: true,
            },
            channels: {
              inApp: {
                enabled: true,
              },
            },
          },
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      if (context.isStateful) {
        // Set subscriber preference to disable inApp globally
        await session.testAgent
          .patch(`/v1/inbox/preferences`)
          .set('Authorization', `Bearer ${session.subscriberToken}`)
          .send({
            in_app: false,
          });
      }

      await triggerEvent(session, workflowId, subscriber._id, {}, bridge);
      await session.waitForJobCompletion();

      const sentMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: session.subscriberProfile?._id,
        templateIdentifier: workflowId,
        channel: StepTypeEnum.IN_APP,
      });

      expect(sentMessages.length).to.be.eq(1);
    });

    it(`should NOT deliver inApp message if subscriber enabled inApp channel globally for readOnly workflow with inApp disabled [${context.name}]`, async () => {
      const workflowId = `disabled-readonly-global-level-${`${context.name}`}`;
      const newWorkflow = workflow(
        workflowId,
        async ({ step }) => {
          await step.inApp('send-in-app', () => ({ body: 'Hello there 1' }));
        },
        {
          preferences: {
            all: {
              readOnly: true,
            },
            channels: {
              inApp: {
                enabled: false,
              },
            },
          },
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      if (context.isStateful) {
        // Set subscriber preference to enable inApp globally
        await session.testAgent
          .patch(`/v1/inbox/preferences`)
          .set('Authorization', `Bearer ${session.subscriberToken}`)
          .send({
            in_app: true,
          });
      }

      await triggerEvent(session, workflowId, subscriber._id, {}, bridge);
      await session.waitForJobCompletion();

      const sentMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: session.subscriberProfile?._id,
        templateIdentifier: workflowId,
        channel: StepTypeEnum.IN_APP,
      });

      expect(sentMessages.length).to.be.eq(0);

      const executionDetailsFiltered = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        status: ExecutionDetailsStatusEnum.SUCCESS,
      });

      const executionDetailsWorkflowFiltered = executionDetailsFiltered.filter(
        (executionDetail) => executionDetail.detail === DetailEnum.STEP_FILTERED_BY_WORKFLOW_RESOURCE_PREFERENCES
      );

      expect(executionDetailsWorkflowFiltered.length).to.be.eq(1);
    });

    it(`should deliver inApp message if subscriber enabled inApp channel globally for workflow with inApp disabled [${context.name}]`, async () => {
      if (!context.isStateful) {
        /*
         * Stateless executions don't respect subscriber preferences,
         * so we skip the test.
         */
        expect(true).to.equal(true);
      } else {
        const workflowId = `disabled-editable-global-level-${`${context.name}`}`;
        const newWorkflow = workflow(
          workflowId,
          async ({ step }) => {
            await step.inApp('send-in-app', () => ({ body: 'Hello there 1' }));
          },
          {
            preferences: {
              all: {
                readOnly: false,
              },
              channels: {
                inApp: {
                  enabled: false,
                },
              },
            },
          }
        );

        await bridgeServer.start({ workflows: [newWorkflow] });

        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);

        // Set subscriber preference to disable inApp globally
        await session.testAgent
          .patch(`/v1/inbox/preferences`)
          .set('Authorization', `Bearer ${session.subscriberToken}`)
          .send({
            in_app: true,
          });

        await triggerEvent(session, workflowId, subscriber._id, {}, bridge);
        await session.waitForJobCompletion();

        const sentMessages = await messageRepository.find({
          _environmentId: session.environment._id,
          _subscriberId: session.subscriberProfile?._id,
          templateIdentifier: workflowId,
          channel: StepTypeEnum.IN_APP,
        });

        expect(sentMessages.length).to.be.eq(1);
      }
    });

    it(`should NOT deliver inApp message if subscriber disabled inApp channel globally for workflow with inApp enabled [${context.name}]`, async () => {
      if (!context.isStateful) {
        /*
         * Stateless executions don't respect subscriber preferences,
         * so we skip the test.
         */
        expect(true).to.equal(true);
      } else {
        const workflowId = `enabled-editable-global-level-${`${context.name}`}`;
        const newWorkflow = workflow(
          workflowId,
          async ({ step }) => {
            await step.inApp('send-in-app', () => ({ body: 'Hello there 1' }));
          },
          {
            preferences: {
              all: {
                readOnly: false,
              },
              channels: {
                inApp: {
                  enabled: true,
                },
              },
            },
          }
        );

        await bridgeServer.start({ workflows: [newWorkflow] });

        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);

        // Set subscriber preference to disable inApp globally
        await session.testAgent
          .patch(`/v1/inbox/preferences`)
          .set('Authorization', `Bearer ${session.subscriberToken}`)
          .send({
            in_app: false,
          });

        await triggerEvent(session, workflowId, subscriber._id, {}, bridge);
        await session.waitForJobCompletion();

        const sentMessages = await messageRepository.find({
          _environmentId: session.environment._id,
          _subscriberId: session.subscriberProfile?._id,
          templateIdentifier: workflowId,
          channel: StepTypeEnum.IN_APP,
        });

        expect(sentMessages.length).to.be.eq(0);

        const executionDetailsFiltered = await executionDetailsRepository.find({
          _environmentId: session.environment._id,
          status: ExecutionDetailsStatusEnum.SUCCESS,
        });

        const executionDetailsSubscriberGlobalFiltered = executionDetailsFiltered.filter(
          (executionDetail) => executionDetail.detail === DetailEnum.STEP_FILTERED_BY_SUBSCRIBER_GLOBAL_PREFERENCES
        );

        expect(executionDetailsSubscriberGlobalFiltered.length).to.be.eq(1);
      }
    });

    it(`should deliver inApp message if subscriber disabled inApp channel globally but enabled inApp for workflow with inApp disabled [${context.name}]`, async () => {
      if (!context.isStateful) {
        /*
         * Stateless executions don't respect subscriber preferences,
         * so we skip the test.
         */
        expect(true).to.equal(true);
      } else {
        const workflowId = `disabled-editable-global-workflow-level-${`${context.name}`}`;
        const newWorkflow = workflow(
          workflowId,
          async ({ step }) => {
            await step.inApp('send-in-app', () => ({ body: 'Hello there 1' }));
          },
          {
            preferences: {
              all: {
                readOnly: false,
              },
              channels: {
                inApp: {
                  enabled: false,
                },
              },
            },
          }
        );

        await bridgeServer.start({ workflows: [newWorkflow] });

        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);

        const createdWorkflow = await workflowsRepository.findByTriggerIdentifier(session.environment._id, workflowId);

        // Set subscriber preference to disable inApp globally
        await session.testAgent
          .patch(`/v1/inbox/preferences`)
          .set('Authorization', `Bearer ${session.subscriberToken}`)
          .send({
            in_app: false,
          });

        // Set subscriber preference to enable inApp for the workflow
        await session.testAgent
          .patch(`/v1/inbox/preferences/${createdWorkflow?._id}`)
          .set('Authorization', `Bearer ${session.subscriberToken}`)
          .send({
            in_app: true,
          });
        await triggerEvent(session, workflowId, subscriber._id, {}, bridge);
        await session.waitForJobCompletion();

        const sentMessages = await messageRepository.find({
          _environmentId: session.environment._id,
          _subscriberId: session.subscriberProfile?._id,
          templateIdentifier: workflowId,
          channel: StepTypeEnum.IN_APP,
        });

        expect(sentMessages.length).to.be.eq(1);
      }
    });

    it(`should NOT deliver inApp message if subscriber enabled inApp channel globally but disabled inApp for workflow with inApp enabled [${context.name}]`, async () => {
      if (!context.isStateful) {
        /*
         * Stateless executions don't respect subscriber preferences,
         * so we skip the test.
         */
        expect(true).to.equal(true);
      } else {
        const workflowId = `enabled-editable-global-workflow-level-${`${context.name}`}`;
        const newWorkflow = workflow(
          workflowId,
          async ({ step }) => {
            await step.inApp('send-in-app', () => ({ body: 'Hello there 1' }));
          },
          {
            preferences: {
              all: {
                readOnly: false,
              },
              channels: {
                inApp: {
                  enabled: true,
                },
              },
            },
          }
        );

        await bridgeServer.start({ workflows: [newWorkflow] });

        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);

        const createdWorkflow = await workflowsRepository.findByTriggerIdentifier(session.environment._id, workflowId);

        // Set subscriber preference to enable inApp globally
        await session.testAgent
          .patch(`/v1/inbox/preferences`)
          .set('Authorization', `Bearer ${session.subscriberToken}`)
          .send({
            in_app: true,
          });

        // Set subscriber preference to disable inApp for the workflow
        await session.testAgent
          .patch(`/v1/inbox/preferences/${createdWorkflow?._id}`)
          .set('Authorization', `Bearer ${session.subscriberToken}`)
          .send({
            in_app: false,
          });

        await triggerEvent(session, workflowId, subscriber._id, {}, bridge);
        await session.waitForJobCompletion();

        const sentMessages = await messageRepository.find({
          _environmentId: session.environment._id,
          _subscriberId: session.subscriberProfile?._id,
          templateIdentifier: workflowId,
          channel: StepTypeEnum.IN_APP,
        });

        expect(sentMessages.length).to.be.eq(0);

        const executionDetailsFiltered = await executionDetailsRepository.find({
          _environmentId: session.environment._id,
          status: ExecutionDetailsStatusEnum.SUCCESS,
        });

        const executionDetailsSubscriberWorkflowFiltered = executionDetailsFiltered.filter(
          (executionDetail) => executionDetail.detail === DetailEnum.STEP_FILTERED_BY_SUBSCRIBER_WORKFLOW_PREFERENCES
        );

        expect(executionDetailsSubscriberWorkflowFiltered.length).to.be.eq(1);
      }
    });

    it(`should skip inApp step and execute email step when userName is John Doe [${context.name}]`, async () => {
      const workflowId = `bug-5120-${context.name}`;
      const newWorkflow = workflow(
        workflowId,
        async ({ step, payload }) => {
          await step.inApp(
            'inapp',
            async () => {
              return {
                body: 'This is a log message',
              };
            },
            {
              skip: () => payload.userName === 'John Doe',
            }
          );

          await step.email(
            'send-email',
            async (controls) => {
              return {
                subject: controls.subject,
                body: `This is your first Novu Email ${payload.userName}`,
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {
                  subject: {
                    type: 'string',
                    default: `A Successful Test on Novu from default_name`,
                  },
                },
              } as const,
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              userName: {
                type: 'string',
                default: 'John Doe',
              },
            },
            required: [],
            additionalProperties: false,
          } as const,
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      await triggerEvent(session, workflowId, subscriber.subscriberId, { userName: 'John Doe' }, bridge);
      await session.waitForJobCompletion();

      // Verify inApp message was skipped
      const inAppMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.IN_APP,
      });
      expect(inAppMessages.length).to.eq(0);

      // Verify email was sent
      const emailMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.EMAIL,
      });
      expect(emailMessages.length).to.eq(1);
      expect(emailMessages[0].subject).to.include('A Successful Test on Novu from default_name');
    });

    it(`should execute both inApp and email steps when userName is not John Doe [${context.name}]`, async () => {
      const workflowId = `bug-5120-not-skipped-${context.name}`;
      const newWorkflow = workflow(
        workflowId,
        async ({ step, payload }) => {
          await step.inApp(
            'inapp',
            async () => {
              return {
                body: 'This is a log message',
              };
            },
            {
              skip: () => payload.userName === 'John Doe',
            }
          );

          await step.email(
            'send-email',
            async () => {
              return {
                subject: `Welcome to Novu ${payload.userName}`,
                body: `This is your first Novu Email ${payload.userName}`,
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {
                  subject: {
                    type: 'string',
                  },
                },
              } as const,
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              userName: {
                type: 'string',
                default: 'John Doe',
              },
            },
            required: [],
            additionalProperties: false,
          } as const,
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
      }

      await triggerEvent(session, workflowId, subscriber.subscriberId, { userName: 'Jane Doe' }, bridge);
      await session.waitForJobCompletion();

      // Verify inApp message was not skipped
      const inAppMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.IN_APP,
      });
      expect(inAppMessages.length).to.eq(1);
      expect(inAppMessages[0].content).to.include('This is a log message');

      // Verify email was sent
      const emailMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.EMAIL,
      });
      expect(emailMessages.length).to.eq(1);
      expect(emailMessages[0].subject).to.include('Welcome to Novu Jane Doe');
    });

    it(`should succeed workflow if delay step is skipped via payload [${context.name}]`, async () => {
      const workflowId = `delay-skip-causes-failure-${context.name}`;
      const delayStepId = 'delay-step-under-test'; // Used for clarity, not directly in queries
      const inAppStep1Name = 'in-app-before-delay';
      const inAppStep2Name = 'in-app-after-delay';

      const newWorkflow = workflow(
        workflowId,
        async ({ step, payload }) => {
          await step.inApp(inAppStep1Name, async () => ({ body: 'Message from before delay' }));

          await step.delay(
            delayStepId,
            async () => ({ type: 'regular', amount: 1, unit: 'seconds' }), // Short delay for test speed
            {
              skip: () => payload.skipTheDelay === true,
            }
          );

          await step.inApp(inAppStep2Name, async () => ({ body: 'Message from after delay' }));
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              skipTheDelay: { type: 'boolean' },
            },
            required: ['skipTheDelay'],
            additionalProperties: false,
          } as const,
        }
      );

      await bridgeServer.start({ workflows: [newWorkflow] });

      if (context.isStateful) {
        await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);
        const foundWorkflow = await workflowsRepository.findByTriggerIdentifier(session.environment._id, workflowId);
        expect(foundWorkflow, 'Stateful: Workflow should be found after sync').to.be.ok;
      }

      // Delay is skipped (workflow should succeed) ---
      const triggerResultNoSkip = await triggerEvent(
        session,
        workflowId,
        subscriber.subscriberId,
        { skipTheDelay: true },
        bridge
      );
      const transactionIdNoSkip = triggerResultNoSkip?.data?.data?.transactionId;
      expect(transactionIdNoSkip, 'Scenario 1: TransactionId should exist for successful trigger').to.be.ok;

      if (transactionIdNoSkip) {
        await session.waitForJobCompletion(transactionIdNoSkip);

        const messagesNoSkip = await messageRepository.find({
          _environmentId: session.environment._id,
          _subscriberId: subscriber._id,
          transactionId: transactionIdNoSkip,
          channel: StepTypeEnum.IN_APP,
        });
        expect(messagesNoSkip.length).to.equal(
          2,
          'Scenario 1: Should have 2 in-app messages when delay is not skipped'
        );
        expect(messagesNoSkip.some((message) => message.content === 'Message from before delay')).to.be.true;
        expect(messagesNoSkip.some((message) => message.content === 'Message from after delay')).to.be.true;

        const delayJobNoSkip = await jobRepository.findOne({
          _environmentId: session.environment._id,
          transactionId: transactionIdNoSkip,
          type: StepTypeEnum.DELAY,
        });
        expect(delayJobNoSkip?.status).to.equal(JobStatusEnum.COMPLETED, 'Scenario 1: Delay job should be COMPLETED');

        const failedExecDetailsNoSkip = await executionDetailsRepository.find({
          _environmentId: session.environment._id,
          transactionId: transactionIdNoSkip,
          status: ExecutionDetailsStatusEnum.FAILED,
        });
        expect(failedExecDetailsNoSkip.length).to.equal(0, 'Scenario 1: Should have no failed execution details');
      }
    });

    describe('External workflow control values validation', () => {
      it(`should accept flexible JSON objects in control values for external workflows [${context.name}]`, async () => {
        const workflowId = `external-flexible-controls-${context.name}`;
        const stepId = 'send-email';

        const newWorkflow = workflow(workflowId, async ({ step }) => {
          await step.email(
            stepId,
            async (controls) => {
              return {
                subject: `${controls.customSubject || 'Default Subject'}`,
                body: `${controls.customBody || 'Default Body'}`,
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {
                  customSubject: { type: 'string', default: 'Default Subject' },
                  customBody: { type: 'string', default: 'Default Body' },
                },
              } as const,
            }
          );
        });

        await bridgeServer.start({ workflows: [newWorkflow] });

        if (context.isStateful) {
          await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);

          // Update with flexible control values that wouldn't be allowed in NOVU_CLOUD workflows
          const flexibleControlValues = {
            variables: {
              // Standard fields
              customSubject: 'External workflow subject',
              customBody: 'External workflow body',
              // Custom fields that wouldn't be in EmailControlDto
              customField: 'This is allowed in external workflows',
              nestedObject: {
                key1: 'value1',
                key2: 42,
                key3: true,
              },
              arrayField: ['item1', 'item2', 'item3'],
              metadata: {
                source: 'external-system',
                timestamp: new Date().toISOString(),
                version: '1.0',
              },
            },
          };

          const updateResponse = await saveControlValues(session, workflowId, stepId, flexibleControlValues);
          expect(updateResponse.status).to.equal(200);
        }

        await triggerEvent(session, workflowId, subscriber.subscriberId, {}, bridge);
        await session.waitForJobCompletion();

        const sentMessages = await messageRepository.find({
          _environmentId: session.environment._id,
          _subscriberId: subscriber._id,
          templateIdentifier: workflowId,
          channel: StepTypeEnum.EMAIL,
        });

        expect(sentMessages.length).to.be.eq(1);
        if (context.isStateful) {
          expect(sentMessages[0].subject).to.include('External workflow subject');
        } else {
          // Stateless workflows use defaults when no controls are saved
          expect(sentMessages[0].subject).to.include('Default Subject');
        }
      });

      it(`should accept completely arbitrary JSON structure for external workflows [${context.name}]`, async () => {
        const workflowId = `external-arbitrary-controls-${context.name}`;
        const stepId = 'send-email';

        const newWorkflow = workflow(workflowId, async ({ step }) => {
          await step.email(
            stepId,
            async (controls) => {
              return {
                subject: `Framework: ${controls.customFramework?.name || 'Unknown'}`,
                body: `Features: ${Array.isArray(controls.externalConfig?.features) ? controls.externalConfig.features.join(', ') : 'None'}`,
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {
                  customFramework: { type: 'object' },
                  externalConfig: { type: 'object' },
                },
              } as const,
            }
          );
        });

        await bridgeServer.start({ workflows: [newWorkflow] });

        if (context.isStateful) {
          await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);

          // Update with completely arbitrary data structure
          const arbitraryControlValues = {
            variables: {
              customFramework: {
                name: 'CustomNotificationFramework',
                version: '2.0.0',
                plugins: [
                  { name: 'validator', config: { strict: false } },
                  { name: 'renderer', config: { cache: true } },
                ],
              },
              userDefinedFields: {
                field1: 'string value',
                field2: 12345,
                field3: [1, 2, 3, 4, 5],
                field4: {
                  nested: {
                    deeply: {
                      value: 'deep nesting is allowed',
                    },
                  },
                },
              },
              flags: {
                enableFeatureA: true,
                enableFeatureB: false,
                experimentalFeatures: ['feature1', 'feature2'],
              },
              externalConfig: {
                templateEngine: 'handlebars',
                features: ['responsive', 'dark-mode'],
              },
            },
          };

          const updateResponse = await saveControlValues(session, workflowId, stepId, arbitraryControlValues);
          expect(updateResponse.status).to.equal(200);
        }

        await triggerEvent(session, workflowId, subscriber.subscriberId, {}, bridge);
        await session.waitForJobCompletion();

        const sentMessages = await messageRepository.find({
          _environmentId: session.environment._id,
          _subscriberId: subscriber._id,
          templateIdentifier: workflowId,
          channel: StepTypeEnum.EMAIL,
        });

        expect(sentMessages.length).to.be.eq(1);
        if (context.isStateful) {
          expect(sentMessages[0].subject).to.include('CustomNotificationFramework');
          expect(sentMessages[0].content).to.include('responsive, dark-mode');
        } else {
          // Stateless workflows use defaults when no controls are saved
          expect(sentMessages[0].subject).to.include('Unknown');
        }
      });

      it(`should handle mixed standard and custom fields for external workflows [${context.name}]`, async () => {
        const workflowId = `external-mixed-controls-${context.name}`;
        const stepId = 'send-in-app';

        const newWorkflow = workflow(workflowId, async ({ step }) => {
          await step.inApp(
            stepId,
            async (controls) => {
              return {
                subject: `${controls.subject || 'Default Subject'}`,
                body: `${controls.body || 'Default Body'} - Priority: ${controls.customPriority || 'normal'}`,
                avatar: controls.avatar,
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {
                  subject: { type: 'string', default: 'Default Subject' },
                  body: { type: 'string', default: 'Default Body' },
                  avatar: { type: 'string' },
                  customPriority: { type: 'string', default: 'normal' },
                },
              } as const,
            }
          );
        });

        await bridgeServer.start({ workflows: [newWorkflow] });

        if (context.isStateful) {
          await discoverAndSyncBridge(session, workflowsRepository, workflowId, bridgeServer);

          // Update with mixed standard and custom fields
          const mixedControlValues = {
            variables: {
              // Standard in-app fields
              subject: 'Mixed workflow subject',
              body: 'Mixed workflow body',
              avatar: 'https://example.com/avatar.png',
              // Custom fields that wouldn't be in standard InAppControlDto
              customPriority: 'high',
              customNotificationType: 'alert',
              customMetadata: {
                source: 'external-system',
                timestamp: new Date().toISOString(),
                version: '1.0',
              },
              customActions: [
                { id: 'action1', label: 'Custom Action 1', type: 'button' },
                { id: 'action2', label: 'Custom Action 2', type: 'link' },
              ],
            },
          };

          const updateResponse = await saveControlValues(session, workflowId, stepId, mixedControlValues);
          expect(updateResponse.status).to.equal(200);
        }

        await triggerEvent(session, workflowId, subscriber.subscriberId, {}, bridge);
        await session.waitForJobCompletion();

        const sentMessages = await messageRepository.find({
          _environmentId: session.environment._id,
          _subscriberId: subscriber._id,
          templateIdentifier: workflowId,
          channel: StepTypeEnum.IN_APP,
        });

        expect(sentMessages.length).to.be.eq(1);
        if (context.isStateful) {
          expect(sentMessages[0].subject).to.include('Mixed workflow subject');
          expect(sentMessages[0].content).to.include('Priority: high');
        } else {
          // Stateless workflows use defaults when no controls are saved
          expect(sentMessages[0].subject).to.include('Default Subject');
          expect(sentMessages[0].content).to.include('Priority: normal');
        }
      });
    });
  });
});

describe('Novu-Hosted Bridge Trigger #novu-v2', () => {
  let session: UserSession;
  const messageRepository = new MessageRepository();
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber({ _id: session.subscriberId });
  });

  it('should execute a Novu-managed workflow', async () => {
    // Log current Redis jobs count before starting the test
    const jobsService = new JobsService();
    let currentMetrics = await (jobsService as any).getQueueMetrics();
    console.log(
      `[Test] Starting 'should execute a Novu-managed workflow' - Current Redis jobs count: ${currentMetrics.totalCount}`
    );
    console.log(
      `[Test] Queue breakdown - Workflow: ${currentMetrics.activeWorkflowJobsCount + currentMetrics.waitingWorkflowJobsCount}, Subscriber: ${currentMetrics.activeSubscriberJobsCount + currentMetrics.waitingSubscriberJobsCount}, Standard: ${currentMetrics.activeStandardJobsCount + currentMetrics.waitingStandardJobsCount}`
    );

    const createWorkflowDto: CreateWorkflowDto = {
      tags: [],
      active: true,
      name: 'Test Workflow',
      description: 'Test Workflow',
      __source: WorkflowCreationSourceEnum.DASHBOARD,
      workflowId: 'test-workflow',
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          name: 'Test Step 1',
          controlValues: {
            body: 'Test Body',
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          name: 'Test Step 2',
          controlValues: {
            body: 'Test Body',
          },
        },
      ],
    };

    const response = await session.testAgent.post(`/v2/workflows`).send(createWorkflowDto);
    expect(response.status).to.be.eq(201);

    const responseData = response.body.data as WorkflowResponseDto;

    await triggerEvent(session, responseData.workflowId, subscriber._id, {});
    currentMetrics = await (jobsService as any).getQueueMetrics();
    console.log(
      `[Test] Queue breakdown - Workflow: ${currentMetrics.activeWorkflowJobsCount + currentMetrics.waitingWorkflowJobsCount}, Subscriber: ${currentMetrics.activeSubscriberJobsCount + currentMetrics.waitingSubscriberJobsCount}, Standard: ${currentMetrics.activeStandardJobsCount + currentMetrics.waitingStandardJobsCount}`
    );
    await session.waitForJobCompletion();

    const sentMessages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: session.subscriberProfile?._id,
      templateIdentifier: responseData.workflowId,
      channel: StepTypeEnum.IN_APP,
    });

    expect(sentMessages.length).to.be.eq(2);
  });
});

async function syncWorkflow(
  session: UserSession,
  workflowsRepository: NotificationTemplateRepository,
  workflowIdentifier: string,
  bridgeServer: TestBridgeServer
) {
  await session.testAgent.post(`/v1/bridge/sync`).send({
    bridgeUrl: `${bridgeServer.serverPath}/novu`,
  });

  const foundWorkflow = await workflowsRepository.findByTriggerIdentifier(session.environment._id, workflowIdentifier);

  expect(foundWorkflow).to.be.ok;
  if (!foundWorkflow) throw new Error('Workflow not found');
}

async function triggerEvent(
  session: UserSession,
  workflowId: string,
  subscriberId: string,
  payload?: Record<string, unknown>,
  bridge?: { url: string },
  controls?: Record<string, unknown>
) {
  const defaultPayload = {
    name: 'test_name',
  };

  const response = await axios.post(
    `${session.serverUrl}${eventTriggerPath}`,
    {
      name: workflowId,
      to: {
        subscriberId,
        email: 'test@subscriber.com',
      },
      payload: payload ?? defaultPayload,
      controls: controls ?? undefined,
      bridgeUrl: bridge?.url ?? undefined,
    },
    {
      headers: {
        authorization: `ApiKey ${session.apiKey}`,
      },
    }
  );

  return response;
}

async function discoverAndSyncBridge(
  session: UserSession,
  workflowsRepository?: NotificationTemplateRepository,
  workflowIdentifier?: string,
  bridgeServer?: TestBridgeServer
) {
  const discoverResponse = await session.testAgent.post(`/v1/bridge/sync`).send({
    bridgeUrl: `${bridgeServer?.serverPath}/novu`,
  });

  if (!workflowsRepository || !workflowIdentifier) {
    return discoverResponse;
  }

  const foundWorkflow = await workflowsRepository.findByTriggerIdentifier(session.environment._id, workflowIdentifier);
  expect(foundWorkflow).to.be.ok;

  if (!foundWorkflow) {
    throw new Error('Workflow not found');
  }

  return discoverResponse;
}

async function saveControlValues(
  session: UserSession,
  workflowIdentifier?: string,
  stepIdentifier?: string,
  payloadBody?: Record<string, unknown>
) {
  return await session.testAgent.put(`/v1/bridge/controls/${workflowIdentifier}/${stepIdentifier}`).send(payloadBody);
}

async function markAllSubscriberMessagesAs(session: UserSession, subscriberId: string, markAs: MessagesStatusEnum) {
  const response = await axios.post(
    `${session.serverUrl}/v1/subscribers/${subscriberId}/messages/mark-all`,
    {
      markAs,
    },
    {
      headers: {
        authorization: `ApiKey ${session.apiKey}`,
      },
    }
  );

  return response.data;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - syncWorkflow(session: UserSession,
  workflowsRepository: NotificationTemplateRepository,
  workflowIdentifier: string,
  bridgeServer: TestBridgeServer)
 - triggerEvent(session: UserSession,
  workflowId: string,
  subscriberId: string,
  payload?: Record<string, unknown>,
  bridge?: { url: string },
  controls?: Record<string, unknown>)
 - discoverAndSyncBridge(session: UserSession,
  workflowsRepository?: NotificationTemplateRepository,
  workflowIdentifier?: string,
  bridgeServer?: TestBridgeServer)
 - saveControlValues(session: UserSession,
  workflowIdentifier?: string,
  stepIdentifier?: string,
  payloadBody?: Record<string, unknown>)
 - markAllSubscriberMessagesAs(session: UserSession, subscriberId: string, markAs: MessagesStatusEnum)
Asignaciones con arrow functions encontradas (posibles funciones):
 - executionDetailsRepository(new ExecutionDetailsRepository();
    let bridge;

    beforeEach(async ())
 - subscriber(await subscriberService.createSubscriber({ _id: session.subscriberId });
    });

    afterEach(asyn...)
 - newWorkflow(workflow(
        workflowId,
        async ({ step, payload }))
 - emailMessage(messages.find((message))
 - inAppMessage(messages.find((message))
 - smsMessage(messages.find((message))
 - newWorkflow(workflow(
        workflowIdSkipByStatic,
        async ({ step, payload }))
 - cancelledJobByStatic(await jobRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: s...)
 - newWorkflow(workflow(
        workflowIdSkipByVariable,
        async ({ step, payload }))
 - cancelledJobByVariable(await jobRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: s...)
 - newWorkflow(workflow(
        workflowId,
        async ({ step, payload }))
 - error(raw.data[0].message;

      expect(error).to.include('must be string');
    });

    it(`should use ...)
 - newWorkflow(workflow(workflowId, async ({ step }))
 - resInApp(await step.inApp('send-in-app', async ())
 - resCustom(await step.custom(
          'custom',
          async ())
 - messagesAfterEmail(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - newWorkflow(workflow(
        workflowId,
        async ({ step }))
 - digestResponse(await step.digest(
            'digest',
            async (controls))
 - messages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - newWorkflow(workflow(
        workflowId,
        async ({ step }))
 - delayResponse(await step.delay(
            'delay-id',
            async (controls))
 - exceedMaxTierDurationWorkflow(workflow(exceedMaxTierDurationWorkflowId, async ({ step }))
 - delayExecutionDetails(executionDetails.filter((executionDetail))
 - newWorkflow(workflow(
        workflowId,
        async ({ step, payload }))
 - expectedSubjects(['prefix Hello default_name', 'prefix Hello payload_name'];

      expectedSubjects.forEach((expecte...)
 - found(sentMessage.some((message))
 - newWorkflow(workflow(
        workflowId,
        async ({ step, payload }))
 - sentMessage(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - newWorkflow(workflow(workflowId, async ({ step }))
 - messageBodies(sentMessages.map((message))
 - newWorkflow(workflow(workflowId, async ({ step }))
 - sentMessages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - newWorkflow(workflow(
        workflowId,
        async ({ step }))
 - sentMessages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - newWorkflow(workflow(
        workflowId,
        async ({ step }))
 - executionDetailsWorkflowFiltered(executionDetailsFiltered.filter(
        (executionDetail))
 - newWorkflow(workflow(
        workflowId,
        async ({ step }))
 - sentMessages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - newWorkflow(workflow(
        workflowId,
        async ({ step }))
 - executionDetailsWorkflowFiltered(executionDetailsFiltered.filter(
        (executionDetail))
 - newWorkflow(workflow(
        workflowId,
        async ({ step }))
 - sentMessages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - newWorkflow(workflow(
        workflowId,
        async ({ step }))
 - executionDetailsWorkflowFiltered(executionDetailsFiltered.filter(
        (executionDetail))
 - newWorkflow(workflow(
        workflowId,
        async ({ step }))
 - sentMessages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - newWorkflow(workflow(
        workflowId,
        async ({ step }))
 - executionDetailsWorkflowFiltered(executionDetailsFiltered.filter(
        (executionDetail))
 - newWorkflow(workflow(
          workflowId,
          async ({ step }))
 - sentMessages(await messageRepository.find({
          _environmentId: session.environment._id,
          _subscri...)
 - newWorkflow(workflow(
          workflowId,
          async ({ step }))
 - executionDetailsSubscriberGlobalFiltered(executionDetailsFiltered.filter(
          (executionDetail))
 - newWorkflow(workflow(
          workflowId,
          async ({ step }))
 - sentMessages(await messageRepository.find({
          _environmentId: session.environment._id,
          _subscri...)
 - newWorkflow(workflow(
          workflowId,
          async ({ step }))
 - executionDetailsSubscriberWorkflowFiltered(executionDetailsFiltered.filter(
          (executionDetail))
 - newWorkflow(workflow(
        workflowId,
        async ({ step, payload }))
 - emailMessages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - newWorkflow(workflow(
        workflowId,
        async ({ step, payload }))
 - emailMessages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - newWorkflow(workflow(
        workflowId,
        async ({ step, payload }))
 - messagesNoSkip(await messageRepository.find({
          _environmentId: session.environment._id,
          _subscri...)
 - failedExecDetailsNoSkip(await executionDetailsRepository.find({
          _environmentId: session.environment._id,
         ...)
 - newWorkflow(workflow(workflowId, async ({ step }))
 - sentMessages(await messageRepository.find({
          _environmentId: session.environment._id,
          _subscri...)
 - newWorkflow(workflow(workflowId, async ({ step }))
 - sentMessages(await messageRepository.find({
          _environmentId: session.environment._id,
          _subscri...)
 - newWorkflow(workflow(workflowId, async ({ step }))
 - sentMessages(await messageRepository.find({
          _environmentId: session.environment._id,
          _subscri...)
 - messageRepository(new MessageRepository();
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersSer...)
 - subscriber(await subscriberService.createSubscriber({ _id: session.subscriberId });
  });

  it('should execute...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/bulk-trigger.e2e.ts
TamaÃ±o: 9250 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { NovuCore } from '@novu/api/core';
import { triggerBulk } from '@novu/api/funcs/triggerBulk';
import { TriggerEventRequestDto } from '@novu/api/models/components';
import { MessageRepository, NotificationRepository, NotificationTemplateEntity, SubscriberEntity } from '@novu/dal';
import { ChannelTypeEnum, StepTypeEnum } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { z } from 'zod';
import {
  expectSdkValidationExceptionGeneric,
  initNovuClassSdk,
  initNovuFunctionSdk,
} from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Trigger bulk events - /v1/events/trigger/bulk (POST) #novu-v2', () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let secondTemplate: NotificationTemplateEntity;
  let subscriber: SubscriberEntity;
  let secondSubscriber: SubscriberEntity;
  let subscriberService: SubscribersService;
  const notificationRepository = new NotificationRepository();
  const messageRepository = new MessageRepository();
  let novuClient: Novu;
  let novuCore: NovuCore;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    template = await session.createTemplate();
    secondTemplate = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.SMS,
          content: 'Hello {{firstName}}',
        },
      ],
    });
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
    secondSubscriber = await subscriberService.createSubscriber();
    novuClient = initNovuClassSdk(session);
    novuCore = initNovuFunctionSdk(session);
  });

  it('should return the response array in correct order', async () => {
    const bulkTriggerResponse = await triggerBulk(novuCore, {
      events: [
        {
          transactionId: '1111',
          workflowId: template.triggers[0].identifier,
          to: [subscriber.subscriberId],
          payload: {
            firstName: 'Testing of User Name',
            urlVariable: '/test/url/path',
          },
        },
        {
          transactionId: '2222',
          workflowId: template.triggers[0].identifier,
          to: [subscriber.subscriberId],
          payload: {
            firstName: 'Testing of User Name',
            urlVariable: '/test/url/path',
          },
        },
        {
          transactionId: '3333',
          workflowId: template.triggers[0].identifier,
          to: [subscriber.subscriberId],
          payload: {
            firstName: 'Testing of User Name',
            urlVariable: '/test/url/path',
          },
        },
      ],
    });
    if (!bulkTriggerResponse.ok) {
      throw new Error(`Failed to make bulkTriggerResponse\n${JSON.stringify(bulkTriggerResponse.error, null, 2)}`);
    }
    const value = bulkTriggerResponse.value.result;
    expect(bulkTriggerResponse).to.be.ok;
    expect(bulkTriggerResponse.value.result.length).to.equal(3);

    const firstEvent = bulkTriggerResponse.value.result[0];
    expect(firstEvent.status).to.equal('processed');
    expect(firstEvent.acknowledged).to.equal(true);
    expect(firstEvent.transactionId).to.equal('1111');

    const secondEvent = bulkTriggerResponse.value.result[1];
    expect(secondEvent.status).to.equal('processed');
    expect(secondEvent.acknowledged).to.equal(true);
    expect(secondEvent.transactionId).to.equal('2222');

    const thirdEvent = bulkTriggerResponse.value.result[2];
    expect(thirdEvent.status).to.equal('processed');
    expect(thirdEvent.acknowledged).to.equal(true);
    expect(thirdEvent.transactionId).to.equal('3333');
  });

  it('should generate message and notification based on a bulk event', async () => {
    await novuClient.triggerBulk({
      events: [
        {
          workflowId: template.triggers[0].identifier,
          to: [
            {
              subscriberId: subscriber.subscriberId,
            },
          ],
          payload: {
            firstName: 'Testing of User Name',
            urlVar: '/test/url/path',
          },
        },
        {
          workflowId: secondTemplate.triggers[0].identifier,
          to: [
            {
              subscriberId: secondSubscriber.subscriberId,
            },
          ],
          payload: {
            firstName: 'This is a second template',
          },
        },
      ],
    });

    await session.waitForJobCompletion(template._id);
    await session.waitForJobCompletion(secondTemplate._id);

    const notifications = await notificationRepository.findBySubscriberId(session.environment._id, subscriber._id);
    expect(notifications.length).to.equal(1);

    const notification = notifications[0];

    expect(notification._organizationId).to.equal(session.organization._id);
    expect(notification._templateId).to.equal(template._id);

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      subscriber._id,
      ChannelTypeEnum.IN_APP
    );

    expect(messages.length).to.equal(1);
    const message = messages[0];

    expect(message.channel).to.equal(ChannelTypeEnum.IN_APP);
    expect(message.content as string).to.equal('Test content for <b>Testing of User Name</b>');
    expect(message.seen).to.equal(false);
    expect(message.cta.data.url).to.equal('/cypress/test-shell/example/test?test-param=true');
    expect(message.lastSeenDate).to.be.not.ok;
    expect(message.payload.firstName).to.equal('Testing of User Name');
    expect(message.payload.urlVar).to.equal('/test/url/path');
    expect(message.payload.attachments).to.be.not.ok;

    const emails = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      subscriber._id,
      ChannelTypeEnum.EMAIL
    );

    expect(emails.length).to.equal(1);
    const email = emails[0];

    expect(email.channel).to.equal(ChannelTypeEnum.EMAIL);

    // Validate second template execution
    const otherSubscriberSms = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      subscriber._id,
      ChannelTypeEnum.SMS
    );
    expect(otherSubscriberSms.length).to.equal(0);

    const sms = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      secondSubscriber._id,
      ChannelTypeEnum.SMS
    );

    expect(sms.length).to.equal(1);

    const smsMessage = sms[0];
    expect(smsMessage.content).to.equal(`Hello This is a second template`);

    const secondSubscriberNotifications = await notificationRepository.findBySubscriberId(
      session.environment._id,
      secondSubscriber._id
    );
    expect(secondSubscriberNotifications.length).to.equal(1);

    const secondSubscriberNotification = secondSubscriberNotifications[0];

    expect(secondSubscriberNotification._organizationId).to.equal(session.organization._id);
    expect(secondSubscriberNotification._templateId).to.equal(secondTemplate._id);
  });

  it('should throw an error when sending more than 100 events', async () => {
    const event: TriggerEventRequestDto = {
      transactionId: '2222',
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        firstName: 'Testing of User Name',
        urlVariable: '/test/url/path',
      },
    };

    const { error: errorDto } = await expectSdkValidationExceptionGeneric(() =>
      novuClient.triggerBulk({
        events: Array.from({ length: 101 }, () => event),
      })
    );

    expect(errorDto?.statusCode).to.equal(422);
    expect(errorDto?.errors.events.messages[0]).to.equal('events must contain no more than 100 elements');
  });

  it('should handle bulk if one of the events returns errors', async () => {
    const bulkTriggerResponse = await triggerBulk(novuCore, {
      events: [
        {
          transactionId: '1111',
          workflowId: 'non-existing-trigger',
          to: [subscriber.subscriberId],
          payload: {
            firstName: 'Testing of User Name',
            urlVariable: '/test/url/path',
          },
        },
        {
          transactionId: '2222',
          workflowId: template.triggers[0].identifier,
          to: [subscriber.subscriberId],
          payload: {
            firstName: 'Testing of User Name',
            urlVariable: '/test/url/path',
          },
        },
        {
          transactionId: '1111',
          payload: {
            firstName: 'Testing of User Name',
            name: '',
          },
          workflowId: '',
          to: [],
        },
      ],
    });
    if (!bulkTriggerResponse.ok) {
      throw new Error(`failed to bulk trigger:${JSON.stringify(bulkTriggerResponse.error)}`);
    }

    const dtoList = bulkTriggerResponse.value.result;
    expect(dtoList).to.be.ok;
    expect(dtoList.length).to.equal(3);

    const errorEvent = dtoList[0];
    z;
    if (!errorEvent.error) {
      throw new Error('should have been an error');
    }
    expect(errorEvent.error[0]).to.equal('workflow_not_found');
    expect(errorEvent.status).to.equal('error');

    expect(dtoList[1].status).to.equal('processed');
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - messageRepository(new MessageRepository();
  let novuClient: Novu;
  let novuCore: NovuCore;

  beforeEach(async ())
 - novuCore(initNovuFunctionSdk(session);
  });

  it('should return the response array in correct order', async...)
 - thirdEvent(bulkTriggerResponse.value.result[2];
    expect(thirdEvent.status).to.equal('processed');
    expect...)
 - secondSubscriberNotification(secondSubscriberNotifications[0];

    expect(secondSubscriberNotification._organizationId).to.equal...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/cancel-event.e2e.ts
TamaÃ±o: 18852 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { JobRepository, JobStatusEnum, NotificationTemplateEntity, SubscriberEntity } from '@novu/dal';
import { DelayTypeEnum, DigestTypeEnum, DigestUnitEnum, StepTypeEnum } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';
import { pollForJobStatusChange } from './utils/poll-for-job-status-change.util';

const axiosInstance = axios.create();

describe('Cancel event - /v1/events/trigger/:transactionId (DELETE) #novu-v2', () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;
  const jobRepository = new JobRepository();
  let novuClient: Novu;

  async function cancelEvent(transactionId: string) {
    // TODO: Replace with await novuClient.cancel(transactionId) when the response validation error is fixed
    await axiosInstance.delete(`${session.serverUrl}/v1/events/trigger/${transactionId}`, {
      headers: {
        authorization: `ApiKey ${session.apiKey}`,
      },
    });
  }

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    template = await session.createTemplate();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
    novuClient = initNovuClassSdk(session);
  });

  it('should cancel a digest step', async () => {
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 2,
            digestKey: 'id',
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello world {{step.events.length}}' as string,
        },
      ],
    });

    const { result } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
    });

    const { transactionId } = result;

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    await cancelEvent(transactionId!);

    const cancelledDigestJobs = await pollForJobStatusChange({
      jobRepository,
      query: {
        _environmentId: session.environment._id,
        _templateId: template._id,
        status: JobStatusEnum.CANCELED,
        type: StepTypeEnum.DIGEST,
        transactionId,
      },
      findMultiple: true,
    });

    expect(cancelledDigestJobs?.length).to.eql(1);
  });

  it('should cancel a delay step for all subscribers', async () => {
    const secondSubscriber = await subscriberService.createSubscriber();
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DELAY,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 3,
            type: DelayTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello world {{customVar}}' as string,
        },
      ],
    });

    const { result } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId, secondSubscriber.subscriberId],
    });

    const { transactionId } = result;

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    await cancelEvent(transactionId!);

    const delayedJobs = await pollForJobStatusChange({
      jobRepository,
      query: {
        _environmentId: session.environment._id,
        _templateId: template._id,
        type: StepTypeEnum.DELAY,
        transactionId,
        status: JobStatusEnum.CANCELED,
      },
      findMultiple: true,
    });

    await session.waitForJobCompletion();

    expect(delayedJobs?.[0]?.status).to.equal(JobStatusEnum.CANCELED);
    expect(delayedJobs?.[1]?.status).to.equal(JobStatusEnum.CANCELED);
  });

  it.skip('should cancel a digest after it has already digested some triggers', async () => {
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            digestKey: 'id',
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello world {{step.events.length}}' as string,
        },
      ],
    });

    const { result: result1 } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'trigger_1_data',
      },
    });

    const { result: result2 } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'trigger_2_data',
      },
    });

    const { result: result3 } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'trigger_2_data',
      },
    });

    // Wait for trigger2 to be merged to trigger1
    await session.waitForJobCompletion();

    await cancelEvent(result2.transactionId!);

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    const digestJobs = await jobRepository.find(
      {
        _environmentId: session.environment._id,
        _templateId: template._id,
        type: StepTypeEnum.DIGEST,
      },
      undefined,
      { sort: { createdAt: 1 } }
    );

    expect(digestJobs.length).to.eql(3);

    expect(digestJobs[0]!.status).to.eql(JobStatusEnum.COMPLETED);
    expect(digestJobs[1]!.status).to.eql(JobStatusEnum.CANCELED);
    expect(digestJobs[2]!.status).to.eql(JobStatusEnum.MERGED);

    const jobs = await jobRepository.find(
      {
        _environmentId: session.environment._id,
        _templateId: template._id,
        type: StepTypeEnum.IN_APP,
      },
      undefined,
      { sort: { createdAt: 1 } }
    );

    const rootTrigger = jobs[0];
    expect(rootTrigger.status).to.eql(JobStatusEnum.COMPLETED);
    expect(rootTrigger.payload.customVar).to.eql('trigger_1_data');
    expect(rootTrigger.digest?.events?.length).to.eql(2);
    expect(rootTrigger.digest?.events?.[0].customVar).to.eql('trigger_1_data');
    expect(rootTrigger.digest?.events?.[1].customVar).to.eql('trigger_3_data');

    const secondCancelledTrigger = jobs[1];
    expect(secondCancelledTrigger.payload.customVar).to.eql('trigger_2_data');
    expect(secondCancelledTrigger.status).to.eql(JobStatusEnum.CANCELED);

    const thirdMergedTrigger = jobs[2];
    expect(thirdMergedTrigger.payload.customVar).to.eql('trigger_3_data');
    expect(thirdMergedTrigger.status).to.eql(JobStatusEnum.MERGED);
  });

  it.skip('should be able to cancel 1st main digest', async () => {
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            digestKey: 'id',
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello world {{step.events.length}}' as string,
        },
      ],
    });

    const { result: result1 } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'trigger_1_data',
      },
    });
    await new Promise((resolve) => {
      setTimeout(resolve, 100);
    });
    const { result: result2 } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'trigger_2_data',
      },
    });

    // Wait for trigger2 to be merged to trigger1
    await session.waitForJobCompletion(template?._id);
    await cancelEvent(result1.transactionId!);

    const { result: result3 } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'trigger_3_data',
      },
    });

    await session.waitForJobCompletion(template?._id);

    const delayedJobs = await jobRepository.find(
      {
        _environmentId: session.environment._id,
        _templateId: template._id,
        type: StepTypeEnum.DIGEST,
      },
      undefined,
      { sort: { createdAt: 1 } }
    );

    expect(delayedJobs.length).to.eql(3);

    const cancelledDigestJobs = await jobRepository.find(
      {
        _environmentId: session.environment._id,
        _templateId: template._id,
        status: JobStatusEnum.CANCELED,
        type: StepTypeEnum.DIGEST,
        transactionId: result1.transactionId,
      },
      undefined,
      { sort: { createdAt: 1 } }
    );

    expect(cancelledDigestJobs.length).to.eql(1);

    const inpAppJobs = await jobRepository.find(
      {
        _environmentId: session.environment._id,
        _templateId: template._id,
        type: StepTypeEnum.IN_APP,
      },
      undefined,
      { sort: { createdAt: 1 } }
    );

    const firstMainCanceledTrigger = inpAppJobs[0];
    expect(firstMainCanceledTrigger.status).to.eql(JobStatusEnum.CANCELED);
    expect(firstMainCanceledTrigger.payload.customVar).to.eql('trigger_1_data');
    expect(firstMainCanceledTrigger.digest?.events?.length).to.eql(0);

    const secondTrigger = inpAppJobs[1];
    expect(secondTrigger.payload.customVar).to.eql('trigger_2_data');
    expect(secondTrigger.status).to.eql(JobStatusEnum.COMPLETED);
    expect(secondTrigger.digest?.events?.length).to.eql(2);
    expect(secondTrigger.digest?.events?.[0].customVar).to.eql('trigger_2_data');
    expect(secondTrigger.digest?.events?.[1].customVar).to.eql('trigger_3_data');

    const thirdMergedTrigger = inpAppJobs[2];
    expect(thirdMergedTrigger.payload.customVar).to.eql('trigger_3_data');
    expect(thirdMergedTrigger.digest?.events?.length).to.eql(0);
    expect(thirdMergedTrigger.status).to.eql(JobStatusEnum.MERGED);
  });

  it.skip('should be able to cancel 1st main digest and then its follower', async () => {
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            digestKey: 'id',
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello world {{step.events.length}}' as string,
        },
      ],
    });
    const { result: result1 } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'trigger_1_data',
      },
    });
    await new Promise((resolve) => {
      setTimeout(resolve, 100);
    });
    const { result: result2 } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'trigger_2_data',
      },
    });

    // Wait for trigger2 to be merged to trigger1
    const mainDigest = result1.transactionId;
    await session.waitForJobCompletion(template?._id);
    await cancelEvent(mainDigest!);
    const { result: result3 } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'trigger_3_data',
      },
    });

    // Wait for trigger3 to be merged to trigger2
    const followerDigest = result2.transactionId;
    await session.waitForJobCompletion(template?._id);
    await cancelEvent(followerDigest!);
    const { result: result4 } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'trigger_4_data',
      },
    });

    await session.waitForJobCompletion(template?._id);

    const delayedJobs = await jobRepository.find(
      {
        _environmentId: session.environment._id,
        _templateId: template._id,
        type: StepTypeEnum.DIGEST,
      },
      undefined,
      { sort: { createdAt: 1 } }
    );

    expect(delayedJobs.length).to.eql(4);

    const cancelledDigestJobs = await jobRepository.find(
      {
        _environmentId: session.environment._id,
        _templateId: template._id,
        type: StepTypeEnum.DIGEST,
        transactionId: [result1.transactionId, result2.transactionId],
      },
      undefined,
      { sort: { createdAt: 1 } }
    );

    expect(cancelledDigestJobs.length).to.eql(2);

    const inpAppJobs = await jobRepository.find(
      {
        _environmentId: session.environment._id,
        _templateId: template._id,
        type: StepTypeEnum.IN_APP,
      },
      undefined,
      { sort: { createdAt: 1 } }
    );
    const firstMainCanceledTrigger = inpAppJobs[0];
    expect(firstMainCanceledTrigger.status).to.eql(JobStatusEnum.CANCELED);
    expect(firstMainCanceledTrigger.payload.customVar).to.eql('trigger_1_data');
    expect(firstMainCanceledTrigger.digest?.events?.length).to.eql(0);

    const secondFollowerCanceledTrigger = inpAppJobs[1];
    expect(secondFollowerCanceledTrigger.status).to.eql(JobStatusEnum.CANCELED);
    expect(secondFollowerCanceledTrigger.payload.customVar).to.eql('trigger_2_data');
    expect(secondFollowerCanceledTrigger.digest?.events?.length).to.eql(0);

    const thirdTriggerLatestFollower = inpAppJobs[2];
    expect(thirdTriggerLatestFollower.payload.customVar).to.eql('trigger_3_data');
    expect(thirdTriggerLatestFollower.status).to.eql(JobStatusEnum.COMPLETED);
    expect(thirdTriggerLatestFollower.digest?.events?.length).to.eql(2);
    expect(thirdTriggerLatestFollower.digest?.events?.[0].customVar).to.eql('trigger_3_data');
    expect(thirdTriggerLatestFollower.digest?.events?.[1].customVar).to.eql('trigger_4_data');

    const fourthMergedTrigger = inpAppJobs[3];
    expect(fourthMergedTrigger.payload.customVar).to.eql('trigger_4_data');
    expect(fourthMergedTrigger.digest?.events?.length).to.eql(0);
    expect(fourthMergedTrigger.status).to.eql(JobStatusEnum.MERGED);
  });

  it.skip('should be able to cancel 1st main digest and then its follower and last merged notification', async () => {
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            digestKey: 'id',
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello world {{step.events.length}}' as string,
        },
      ],
    });

    const { result: result1 } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'trigger_1_data',
      },
    });
    await new Promise((resolve) => {
      setTimeout(resolve, 100);
    });
    const { result: result2 } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'trigger_2_data',
      },
    });

    const mainDigest = result1.transactionId;
    await session.waitForJobCompletion(template?._id);
    await cancelEvent(mainDigest!);

    const { result: result3 } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'trigger_3_data',
      },
    });

    // Wait for trigger3 to be merged to trigger2
    const followerDigest = result2.transactionId;
    await session.waitForJobCompletion(template?._id);
    await cancelEvent(followerDigest!);

    const { result } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'trigger_4_data',
      },
    });

    const { transactionId } = result;

    // Wait for trigger4 to be merged to trigger3
    await session.waitForJobCompletion(template?._id);
    await cancelEvent(transactionId!);

    const delayedJobs = await jobRepository.find(
      {
        _environmentId: session.environment._id,
        _templateId: template._id,
        type: StepTypeEnum.DIGEST,
      },
      undefined,
      { sort: { createdAt: 1 } }
    );

    expect(delayedJobs.length).to.eql(4);

    const cancelledDigestJobs = await jobRepository.find(
      {
        _environmentId: session.environment._id,
        _templateId: template._id,
        type: StepTypeEnum.DIGEST,
        transactionId: [result1.transactionId, result2.transactionId, result.transactionId],
      },
      undefined,
      { sort: { createdAt: 1 } }
    );

    expect(cancelledDigestJobs.length).to.eql(3);

    const inpAppJobs = await jobRepository.find(
      {
        _environmentId: session.environment._id,
        _templateId: template._id,
        type: StepTypeEnum.IN_APP,
      },
      undefined,
      { sort: { createdAt: 1 } }
    );

    const firstMainCanceledTrigger = inpAppJobs[0];
    expect(firstMainCanceledTrigger.status).to.eql(JobStatusEnum.CANCELED);
    expect(firstMainCanceledTrigger.payload.customVar).to.eql('trigger_1_data');
    expect(firstMainCanceledTrigger.digest?.events?.length).to.eql(0);

    const secondFollowerCanceledTrigger = inpAppJobs[1];
    expect(secondFollowerCanceledTrigger.status).to.eql(JobStatusEnum.CANCELED);
    expect(secondFollowerCanceledTrigger.payload.customVar).to.eql('trigger_2_data');
    expect(secondFollowerCanceledTrigger.digest?.events?.length).to.eql(0);

    const thirdTriggerLatestFollower = inpAppJobs[2];
    expect(thirdTriggerLatestFollower.payload.customVar).to.eql('trigger_3_data');
    expect(thirdTriggerLatestFollower.status).to.eql(JobStatusEnum.COMPLETED);
    expect(thirdTriggerLatestFollower.digest?.events?.length).to.eql(1);
    expect(thirdTriggerLatestFollower.digest?.events?.[0].customVar).to.eql('trigger_3_data');

    const fourthMergedTrigger = inpAppJobs[3];
    expect(fourthMergedTrigger.payload.customVar).to.eql('trigger_4_data');
    expect(fourthMergedTrigger.digest?.events?.length).to.eql(0);
    expect(fourthMergedTrigger.status).to.eql(JobStatusEnum.CANCELED);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - cancelEvent(transactionId: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - axiosInstance(axios.create();

describe('Cancel event - /v1/events/trigger/:transactionId (DELETE) #novu-v2', ())
 - jobRepository(new JobRepository();
  let novuClient: Novu;

  async function cancelEvent(transactionId: string) {
...)
 - novuClient(initNovuClassSdk(session);
  });

  it('should cancel a digest step', async ())
 - cancelledDigestJobs(await pollForJobStatusChange({
      jobRepository,
      query: {
        _environmentId: session.e...)
 - delayedJobs(await pollForJobStatusChange({
      jobRepository,
      query: {
        _environmentId: session.e...)
 - thirdMergedTrigger(jobs[2];
    expect(thirdMergedTrigger.payload.customVar).to.eql('trigger_3_data');
    expect(third...)
 - thirdMergedTrigger(inpAppJobs[2];
    expect(thirdMergedTrigger.payload.customVar).to.eql('trigger_3_data');
    expect...)
 - fourthMergedTrigger(inpAppJobs[3];
    expect(fourthMergedTrigger.payload.customVar).to.eql('trigger_4_data');
    expec...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/context-events.e2e.ts
TamaÃ±o: 12790 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  ContextRepository,
  JobRepository,
  MessageRepository,
  NotificationRepository,
  SubscriberEntity,
} from '@novu/dal';
import {
  ContextPayload,
  CreateWorkflowDto,
  StepTypeEnum,
  TriggerOverrides,
  TriggerRecipientSubscriber,
  TriggerTenantContext,
  WorkflowCreationSourceEnum,
  WorkflowResponseDto,
} from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Context functionality - /v1/events/trigger (POST) #novu-v2', () => {
  let session: UserSession;
  let workflow: WorkflowResponseDto;
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;
  const contextRepository = new ContextRepository();
  const notificationRepository = new NotificationRepository();
  const messageRepository = new MessageRepository();
  const jobRepository = new JobRepository();

  before(() => {
    // Enable the context feature flag
    // @ts-expect-error process.env is not typed
    process.env.IS_CONTEXT_ENABLED = 'true';
  });

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    // Create V2 workflow for context testing
    const workflowBody: CreateWorkflowDto = {
      name: 'Test Context Workflow',
      workflowId: 'test-context-workflow',
      __source: WorkflowCreationSourceEnum.DASHBOARD,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          name: 'Test Step',
          controlValues: {
            subject: 'Test Subject',
            body: 'Test Body {{subscriber.lastName}}',
          },
        },
        {
          type: StepTypeEnum.EMAIL,
          name: 'Email Step',
          controlValues: {
            subject: 'Email Subject {{subscriber.lastName}}',
            body: 'Email Body {{subscriber.lastName}}',
          },
        },
      ],
    };

    const workflowResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
    expect(workflowResponse.status).to.equal(201);
    workflow = workflowResponse.body.data;

    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
  });

  after(() => {
    // Clean up the feature flag
    // @ts-expect-error process.env is not typed
    delete process.env.IS_CONTEXT_ENABLED;
  });

  afterEach(async () => {
    // Clean up contexts after each test
    await contextRepository.delete({
      _environmentId: session.environment._id,
    });
  });

  async function sendTrigger(
    workflowInner: WorkflowResponseDto,
    newSubscriberIdInAppNotification: string,
    payload: Record<string, unknown> = {},
    overrides: TriggerOverrides = {},
    tenant?: TriggerTenantContext,
    actor?: TriggerRecipientSubscriber,
    context?: ContextPayload
  ) {
    const request = {
      name: workflowInner.workflowId,
      to: [{ subscriberId: newSubscriberIdInAppNotification, lastName: 'Smith', email: 'test@email.novu' }],
      payload: {
        organizationName: 'Umbrella Corp',
        compiledVariable: 'test-env',
        ...payload,
      },
      overrides,
      tenant,
      actor,
      context,
    };

    // TODO: Replace with SDK when available
    const response = await session.testAgent
      .post('/v1/events/trigger')
      .send(request)
      .set('Authorization', `ApiKey ${session.apiKey}`)
      .expect(201);

    // Validate standard response structure
    expect(response.body.data.status).to.equal('processed');
    expect(response.body.data.acknowledged).to.equal(true);

    return response;
  }

  it('should trigger event with various context formats', async () => {
    const context: ContextPayload = {
      app: 'jira',
      tenant: {
        id: 'org-acme',
        data: { name: 'Acme Corp', plan: 'enterprise' },
      },
      region: {
        id: 'us-east-1',
      },
    };

    await sendTrigger(workflow, subscriber.subscriberId, {}, {}, undefined, undefined, context);
    await session.waitForJobCompletion(workflow._id);

    // Verify all contexts were stored with correct data
    const contexts = await contextRepository.find({
      _environmentId: session.environment._id,
    });

    expect(contexts).to.have.length(3);

    const tenantContext = contexts.find((c) => c.type === 'tenant');
    const appContext = contexts.find((c) => c.type === 'app');
    const regionContext = contexts.find((c) => c.type === 'region');

    // Rich object with data
    expect(tenantContext?.id).to.equal('org-acme');
    expect(tenantContext?.data).to.deep.equal({ name: 'Acme Corp', plan: 'enterprise' });
    expect(tenantContext?.key).to.equal('tenant:org-acme');

    // String contexts (should have empty data)
    expect(appContext?.id).to.equal('jira');
    expect(appContext?.data).to.deep.equal({});
    expect(appContext?.key).to.equal('app:jira');

    // Rich object with empty data
    expect(regionContext?.id).to.equal('us-east-1');
    expect(regionContext?.data).to.deep.equal({});
    expect(regionContext?.key).to.equal('region:us-east-1');
  });

  it('should handle context find-or-create logic correctly (no updates)', async () => {
    const initialData = { name: 'Acme Corp', plan: 'basic' };
    const context1: ContextPayload = {
      tenant: {
        id: 'org-acme',
        data: initialData,
      },
    };

    await sendTrigger(workflow, subscriber.subscriberId, {}, {}, undefined, undefined, context1);

    await session.waitForJobCompletion(workflow._id);

    // Verify initial context was created
    let storedContext = await contextRepository.findOne({
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'org-acme',
    });

    expect(storedContext).to.be.ok;
    expect(storedContext?.data).to.deep.equal(initialData);

    // Second trigger with same type+id but as string (no data provided)
    const context2: ContextPayload = {
      tenant: 'org-acme',
    };

    await sendTrigger(workflow, subscriber.subscriberId, {}, {}, undefined, undefined, context2);
    await session.waitForJobCompletion(workflow._id);

    // Verify existing context was retrieved without updates
    storedContext = await contextRepository.findOne({
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'org-acme',
    });

    expect(storedContext?.data).to.deep.equal(initialData);

    // Third trigger with different data - should NOT update existing context
    // this is to prevent accidental updates and overwrites
    const attemptedUpdateData = { name: 'Acme Corporation', plan: 'enterprise', region: 'us-west' };
    const context3: ContextPayload = {
      tenant: {
        id: 'org-acme',
        data: attemptedUpdateData,
      },
    };

    await sendTrigger(workflow, subscriber.subscriberId, {}, {}, undefined, undefined, context3);

    await session.waitForJobCompletion(workflow._id);

    // Verify context was NOT updated - original data should remain
    const contexts = await contextRepository.find({
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'org-acme',
    });

    expect(contexts).to.have.length(1); // Still only one context
    expect(contexts[0].data).to.deep.equal(initialData); // Data should NOT be updated - original data preserved
  });

  it('should reject invalid context payload', async () => {
    const response = await session.testAgent
      .post('/v1/events/trigger')
      .send({
        name: workflow.workflowId,
        to: [{ subscriberId: subscriber.subscriberId }],
        payload: {},
        context: { tenant: { invalid: 'value' } },
      })
      .set('Authorization', `ApiKey ${session.apiKey}`)
      .expect(422);

    expect(response.body.message).to.be.a('string');
  });

  it('should not allow more than 5 contexts', async () => {
    const context: ContextPayload = {
      tenant: { id: 'org-acme' },
      app: { id: 'jira' },
      user: { id: 'john-doe' },
      country: { id: 'us' },
      region: { id: 'us-east-1' },
      device: { id: 'device-1' },
    };

    const response = await session.testAgent
      .post('/v1/events/trigger')
      .send({
        name: workflow.workflowId,
        to: [{ subscriberId: subscriber.subscriberId }],
        payload: {},
        context,
      })
      .set('Authorization', `ApiKey ${session.apiKey}`)
      .expect(422);

    expect(response.body.message).to.equal('Validation Error');
  });

  it('should store contextKeys in notification, message, and job entities', async () => {
    const context: ContextPayload = {
      tenant: {
        id: 'org-acme',
        data: { name: 'Acme Corp', plan: 'enterprise' },
      },
      app: 'jira',
      region: {
        id: 'us-east-1',
        data: { zone: 'availability-zone-1a' },
      },
    };

    await sendTrigger(workflow, subscriber.subscriberId, {}, {}, undefined, undefined, context);
    await session.waitForJobCompletion(workflow._id);

    // Verify contexts were created with correct keys
    const contexts = await contextRepository.find({
      _environmentId: session.environment._id,
    });

    expect(contexts).to.have.length(3);

    const expectedContextKeys = contexts.map((c) => c.key).sort();
    expect(expectedContextKeys).to.deep.equal(['app:jira', 'region:us-east-1', 'tenant:org-acme']);

    // Verify notification entity has contextKeys
    const notifications = await notificationRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
    });

    expect(notifications).to.have.length(1);
    const notification = notifications[0];
    expect(notification.contextKeys).to.be.an('array');
    expect(notification.contextKeys).to.have.length(3);
    expect(notification.contextKeys?.sort()).to.deep.equal(expectedContextKeys);

    // Verify message entities have contextKeys
    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
    });

    expect(messages.length).to.be.greaterThan(0);

    // All messages should have the same contextKeys
    for (const message of messages) {
      expect(message.contextKeys).to.be.an('array');
      expect(message.contextKeys).to.have.length(3);
      expect(message.contextKeys?.sort()).to.deep.equal(expectedContextKeys);
    }

    // Verify job entities have contextKeys
    const jobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
    });

    expect(jobs.length).to.be.greaterThan(0);

    // All jobs should have the same contextKeys
    for (const job of jobs) {
      expect(job.contextKeys).to.be.an('array');
      expect(job.contextKeys).to.have.length(3);
      expect(job.contextKeys?.sort()).to.deep.equal(expectedContextKeys);
    }

    // Verify contextKeys match the actual context entities
    for (const contextKey of expectedContextKeys) {
      const [type, id] = contextKey.split(':');
      const contextEntity = contexts.find((c) => c.type === type && c.id === id);
      expect(contextEntity).to.be.ok;
      expect(contextEntity?.key).to.equal(contextKey);
    }
  });

  it('should handle contextKeys correctly when no context is provided', async () => {
    await sendTrigger(workflow, subscriber.subscriberId);
    await session.waitForJobCompletion(workflow._id);

    // Verify no contexts were created
    const contexts = await contextRepository.find({
      _environmentId: session.environment._id,
    });

    expect(contexts).to.have.length(0);

    // Verify notification entity has empty contextKeys array
    const notifications = await notificationRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
    });

    expect(notifications).to.have.length(1);
    const notification = notifications[0];
    expect(notification.contextKeys).to.be.an('array');
    expect(notification.contextKeys).to.have.length(0);

    // Verify message entities have empty contextKeys array
    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
    });

    expect(messages.length).to.be.greaterThan(0);

    for (const message of messages) {
      expect(message.contextKeys).to.be.an('array');
      expect(message.contextKeys).to.have.length(0);
    }

    // Verify job entities have empty contextKeys array
    const jobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
    });

    expect(jobs.length).to.be.greaterThan(0);

    for (const job of jobs) {
      expect(job.contextKeys).to.be.an('array');
      expect(job.contextKeys).to.have.length(0);
    }
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - sendTrigger(workflowInner: WorkflowResponseDto,
    newSubscriberIdInAppNotification: string,
    payload: Record<string, unknown> = {},
    overrides: TriggerOverrides = {},
    tenant?: TriggerTenantContext,
    actor?: TriggerRecipientSubscriber,
    context?: ContextPayload)
Asignaciones con arrow functions encontradas (posibles funciones):
 - jobRepository(new JobRepository();

  before(())
 - IS_CONTEXT_ENABLED('true';
  });

  beforeEach(async ())
 - subscriber(await subscriberService.createSubscriber();
  });

  after(())
 - response(await session.testAgent
      .post('/v1/events/trigger')
      .send(request)
      .set('Authoriza...)
 - tenantContext(contexts.find((c))
 - appContext(contexts.find((c))
 - regionContext(contexts.find((c))
 - contexts(await contextRepository.find({
      _environmentId: session.environment._id,
      type: 'tenant',
...)
 - response(await session.testAgent
      .post('/v1/events/trigger')
      .send({
        name: workflow.workf...)
 - response(await session.testAgent
      .post('/v1/events/trigger')
      .send({
        name: workflow.workf...)
 - expectedContextKeys(contexts.map((c))
 - contextEntity(contexts.find((c))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/delay-events.e2e.ts
TamaÃ±o: 20704 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { CreateWorkflowDto, WorkflowCreationSourceEnum } from '@novu/api/models/components';
import { JobRepository, JobStatusEnum, MessageRepository, SubscriberEntity } from '@novu/dal';
import { DelayTypeEnum, DigestTypeEnum, DigestUnitEnum, JobTopicNameEnum, StepTypeEnum } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { addSeconds } from 'date-fns';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';
import { pollForJobStatusChange } from './utils/poll-for-job-status-change.util';

describe('Trigger event - Delay triggered events - /v1/events/trigger (POST) #novu-v2', () => {
  let session: UserSession;
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;
  let novuClient: Novu;
  const jobRepository = new JobRepository();
  const messageRepository = new MessageRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
    novuClient = initNovuClassSdk(session);
  });

  it('should delay execution for the provided interval', async () => {
    const template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Not Delayed {{customVar}}' as string,
        },
        {
          type: StepTypeEnum.DELAY,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            type: DelayTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello world {{customVar}}' as string,
        },
      ],
    });

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'Testing of User Name',
      },
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    const delayedJob = await pollForJobStatusChange({
      jobRepository,
      query: {
        _environmentId: session.environment._id,
        _templateId: template._id,
        type: StepTypeEnum.DELAY,
      },
      timeout: 5000,
    });

    expect(delayedJob!.status).to.equal(JobStatusEnum.DELAYED);

    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.IN_APP,
    });

    expect(messages.length).to.equal(1);
    expect(messages[0].content).to.include('Not Delayed');

    await session.waitForJobCompletion(template?._id);

    const messagesAfter = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.IN_APP,
    });

    expect(messagesAfter.length).to.equal(2);
  });

  it('should delay execution until the provided datetime', async () => {
    const template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DELAY,
          content: '',
          metadata: {
            type: DelayTypeEnum.SCHEDULED,
            delayPath: 'sendAt',
          },
        },
        {
          type: StepTypeEnum.SMS,
          content: 'Hello world {{customVar}}' as string,
        },
      ],
    });

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'Testing of User Name',
        sendAt: addSeconds(new Date(), 30),
      },
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    const delayedJobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      type: StepTypeEnum.DELAY,
    });

    expect(delayedJobs.length).to.eql(1);
  });

  it('should not include delayed event in digested sent message', async () => {
    const template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DELAY,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 0.1,
            type: DelayTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.SMS,
          content: 'Event {{eventNumber}}. Digested Events {{step.events.length}}' as string,
        },
      ],
    });

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        eventNumber: '1',
      },
    });

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        eventNumber: '2',
      },
    });

    await session.waitForJobCompletion(template?._id);

    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.SMS,
    });

    expect(messages[0].content).to.include('Event ');
    expect(messages[0].content).to.include('Digested Events 2');
  });

  it('should send a single message for same exact scheduled delay', async () => {
    const template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DELAY,
          content: '',
          metadata: {
            type: DelayTypeEnum.SCHEDULED,
            delayPath: 'sendAt',
          },
        },
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.SMS,
          content: 'Digested Events {{step.events.length}}' as string,
        },
      ],
    });

    const dateValue = addSeconds(new Date(), 1);

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        eventNumber: '1',
        sendAt: dateValue,
      },
    });

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        eventNumber: '2',
        sendAt: dateValue,
      },
    });

    await session.waitForJobCompletion(template?._id);

    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.SMS,
    });

    expect(messages.length).to.equal(1);
    expect(messages[0].content).to.include('Digested Events 2');
  });

  // TODO: Restore the test when the internal SDK is updated
  it.skip('should fail for missing or invalid path for scheduled delay', async () => {
    const template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DELAY,
          content: '',
          metadata: {
            type: DelayTypeEnum.SCHEDULED,
            delayPath: 'sendAt',
          },
        },
        {
          type: StepTypeEnum.SMS,
          content: 'Hello world {{customVar}}' as string,
        },
      ],
    });

    const { result: result1 } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'Testing of User Name',
      },
    });

    expect(result1.error?.[0]).to.equal('payload is missing required key(s) and type(s): sendAt (ISO Date)');

    const { result: result2 } = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId],
      payload: {
        customVar: 'Testing of User Name',
        sendAt: '20-09-2025',
      },
    });

    expect(result2.error?.[0]).to.equal('payload is missing required key(s) and type(s): sendAt (ISO Date)');
  });

  describe('Dynamic Delay', () => {
    it('should delay execution based on ISO-8601 timestamp from payload', async () => {
      const workflowBody: CreateWorkflowDto = {
        name: 'Dynamic Delay ISO-8601 Test',
        workflowId: 'dynamic-delay-iso-test',
        source: WorkflowCreationSourceEnum.Dashboard,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            name: 'Before delay',
            controlValues: {
              body: 'Before delay',
            },
          },
          {
            type: StepTypeEnum.DELAY,
            name: 'Dynamic Delay',
            controlValues: {
              type: DelayTypeEnum.DYNAMIC,
              dynamicKey: 'payload.scheduledTime',
            },
          },
          {
            type: StepTypeEnum.IN_APP,
            name: 'After delay',
            controlValues: {
              body: 'After delay',
            },
          },
        ],
      };

      const createResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
      const workflow = createResponse.body.data;

      const futureTime = addSeconds(new Date(), 2);

      await novuClient.trigger({
        workflowId: workflow.workflowId,
        to: [subscriber.subscriberId],
        payload: {
          scheduledTime: futureTime.toISOString(),
        },
      });

      await session.waitForWorkflowQueueCompletion();
      await session.waitForSubscriberQueueCompletion();

      const delayedJob = await pollForJobStatusChange({
        jobRepository,
        query: {
          _environmentId: session.environment._id,
          _templateId: workflow._id,
          type: StepTypeEnum.DELAY,
        },
        timeout: 5000,
      });

      expect(delayedJob!.status).to.equal(JobStatusEnum.DELAYED);
      expect(delayedJob!.step.metadata).to.deep.include({
        type: DelayTypeEnum.DYNAMIC,
        dynamicKey: 'payload.scheduledTime',
      });

      const messagesBefore = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: 'in_app' as any,
      });

      expect(messagesBefore.length).to.equal(1);
      expect(messagesBefore[0].content).to.include('Before delay');
    });

    it('should delay execution based on duration object from payload', async () => {
      const workflowBody: CreateWorkflowDto = {
        name: 'Dynamic Delay Duration Test',
        workflowId: 'dynamic-delay-duration-test',
        source: WorkflowCreationSourceEnum.Dashboard,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            name: 'Before delay',
            controlValues: {
              body: 'Before delay',
            },
          },
          {
            type: StepTypeEnum.DELAY,
            name: 'Dynamic Delay',
            controlValues: {
              type: DelayTypeEnum.DYNAMIC,
              dynamicKey: 'payload.delayWindow',
            },
          },
          {
            type: StepTypeEnum.IN_APP,
            name: 'After delay',
            controlValues: {
              body: 'After delay',
            },
          },
        ],
      };

      const createResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
      const workflow = createResponse.body.data;

      await novuClient.trigger({
        workflowId: workflow.workflowId,
        to: [subscriber.subscriberId],
        payload: {
          delayWindow: {
            amount: 2,
            unit: 'seconds',
          },
        },
      });

      await session.waitForWorkflowQueueCompletion();
      await session.waitForSubscriberQueueCompletion();

      const delayedJob = await pollForJobStatusChange({
        jobRepository,
        query: {
          _environmentId: session.environment._id,
          _templateId: workflow._id,
          type: 'delay' as any,
        },
        timeout: 5000,
      });

      expect(delayedJob!.status).to.equal(JobStatusEnum.DELAYED);
      expect(delayedJob!.step.metadata).to.deep.include({
        type: DelayTypeEnum.DYNAMIC,
        dynamicKey: 'payload.delayWindow',
      });
    });

    it('should fail when dynamic key is missing from payload', async () => {
      const workflowBody: CreateWorkflowDto = {
        name: 'Dynamic Delay Missing Key Test',
        workflowId: 'dynamic-delay-missing-key-test',
        source: WorkflowCreationSourceEnum.Dashboard,
        steps: [
          {
            type: StepTypeEnum.DELAY,
            name: 'Dynamic Delay',
            controlValues: {
              type: DelayTypeEnum.DYNAMIC,
              dynamicKey: 'payload.scheduledTime',
            },
          },
          {
            type: StepTypeEnum.IN_APP,
            name: 'Should not be sent',
            controlValues: {
              body: 'Should not be sent',
            },
          },
        ],
      };

      const createResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
      const workflow = createResponse.body.data;

      await novuClient.trigger({
        workflowId: workflow.workflowId,
        to: [subscriber.subscriberId],
        payload: {
          otherField: 'value',
        },
      });

      await session.waitForWorkflowQueueCompletion();
      await session.waitForSubscriberQueueCompletion();

      const failedJob = await pollForJobStatusChange({
        jobRepository,
        query: {
          _environmentId: session.environment._id,
          _templateId: workflow._id,
          type: 'delay' as any,
        },
        timeout: 5000,
      });

      expect(failedJob!.status).to.equal(JobStatusEnum.FAILED);
      expect(failedJob!.error?.message).to.include('not found in payload');
    });

    it('should fail when dynamic delay timestamp is in the past', async () => {
      const workflowBody: CreateWorkflowDto = {
        name: 'Dynamic Delay Past Time Test',
        workflowId: 'dynamic-delay-past-time-test',
        source: WorkflowCreationSourceEnum.Dashboard,
        steps: [
          {
            type: StepTypeEnum.DELAY,
            name: 'Dynamic Delay',
            controlValues: {
              type: DelayTypeEnum.DYNAMIC,
              dynamicKey: 'payload.scheduledTime',
            },
          },
          {
            type: StepTypeEnum.IN_APP,
            name: 'Should not be sent',
            controlValues: {
              body: 'Should not be sent',
            },
          },
        ],
      };

      const createResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
      const workflow = createResponse.body.data;

      const pastTime = addSeconds(new Date(), -10);

      await novuClient.trigger({
        workflowId: workflow.workflowId,
        to: [subscriber.subscriberId],
        payload: {
          scheduledTime: pastTime.toISOString(),
        },
      });

      await session.waitForWorkflowQueueCompletion();
      await session.waitForSubscriberQueueCompletion();

      const failedJob = await pollForJobStatusChange({
        jobRepository,
        query: {
          _environmentId: session.environment._id,
          _templateId: workflow._id,
          type: 'delay' as any,
        },
        timeout: 5000,
      });

      expect(failedJob!.status).to.equal(JobStatusEnum.FAILED);
      expect(failedJob!.error?.message).to.include('must be a future date');
    });

    it('should fail when dynamic delay value has invalid format', async () => {
      const workflowBody: CreateWorkflowDto = {
        name: 'Dynamic Delay Invalid Format Test',
        workflowId: 'dynamic-delay-invalid-format-test',
        source: WorkflowCreationSourceEnum.Dashboard,
        steps: [
          {
            type: StepTypeEnum.DELAY,
            name: 'Dynamic Delay',
            controlValues: {
              type: DelayTypeEnum.DYNAMIC,
              dynamicKey: 'payload.delayValue',
            },
          },
          {
            type: StepTypeEnum.IN_APP,
            name: 'Should not be sent',
            controlValues: {
              body: 'Should not be sent',
            },
          },
        ],
      };

      const createResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
      const workflow = createResponse.body.data;

      await novuClient.trigger({
        workflowId: workflow.workflowId,
        to: [subscriber.subscriberId],
        payload: {
          delayValue: 'invalid-format',
        },
      });

      await session.waitForWorkflowQueueCompletion();
      await session.waitForSubscriberQueueCompletion();

      const failedJob = await pollForJobStatusChange({
        jobRepository,
        query: {
          _environmentId: session.environment._id,
          _templateId: workflow._id,
          type: 'delay' as any,
        },
        timeout: 5000,
      });

      expect(failedJob!.status).to.equal(JobStatusEnum.FAILED);
      expect(failedJob!.error?.message).to.include('not a valid format');
    });

    it('should support different time units in duration objects', async () => {
      const workflowBody: CreateWorkflowDto = {
        name: 'Dynamic Delay Time Units Test',
        workflowId: 'dynamic-delay-time-units-test',
        source: WorkflowCreationSourceEnum.Dashboard,
        steps: [
          {
            type: StepTypeEnum.DELAY,
            name: 'Dynamic Delay',
            controlValues: {
              type: DelayTypeEnum.DYNAMIC,
              dynamicKey: 'payload.delayConfig',
            },
          },
          {
            type: StepTypeEnum.IN_APP,
            name: 'Delayed message',
            controlValues: {
              body: 'Delayed message',
            },
          },
        ],
      };

      const createResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
      const workflow = createResponse.body.data;

      const units = ['seconds', 'minutes', 'hours'];

      for (const unit of units) {
        await novuClient.trigger({
          workflowId: workflow.workflowId,
          to: [subscriber.subscriberId],
          payload: {
            delayConfig: {
              amount: 1,
              unit,
            },
          },
        });
      }

      await session.waitForWorkflowQueueCompletion();
      await session.waitForSubscriberQueueCompletion();

      const delayedJobs = await jobRepository.find({
        _environmentId: session.environment._id,
        _templateId: workflow._id,
        type: 'delay' as any,
      });

      expect(delayedJobs.length).to.equal(3);
      delayedJobs.forEach((job) => {
        expect(job.status).to.equal(JobStatusEnum.DELAYED);
      });
    });

    it('should fail when duration object has invalid unit', async () => {
      const workflowBody: CreateWorkflowDto = {
        name: 'Dynamic Delay Invalid Unit Test',
        workflowId: 'dynamic-delay-invalid-unit-test',
        source: WorkflowCreationSourceEnum.Dashboard,
        steps: [
          {
            type: StepTypeEnum.DELAY,
            name: 'Dynamic Delay',
            controlValues: {
              type: DelayTypeEnum.DYNAMIC,
              dynamicKey: 'payload.delayConfig',
            },
          },
          {
            type: StepTypeEnum.IN_APP,
            name: 'Should not be sent',
            controlValues: {
              body: 'Should not be sent',
            },
          },
        ],
      };

      const createResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
      const workflow = createResponse.body.data;

      await novuClient.trigger({
        workflowId: workflow.workflowId,
        to: [subscriber.subscriberId],
        payload: {
          delayConfig: {
            amount: 5,
            unit: 'invalid-unit',
          },
        },
      });

      await session.waitForWorkflowQueueCompletion();
      await session.waitForSubscriberQueueCompletion();

      const failedJob = await pollForJobStatusChange({
        jobRepository,
        query: {
          _environmentId: session.environment._id,
          _templateId: workflow._id,
          type: 'delay' as any,
        },
        timeout: 5000,
      });

      expect(failedJob!.status).to.equal(JobStatusEnum.FAILED);
      expect(failedJob!.error?.message).to.include('Invalid time unit');
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - messageRepository(new MessageRepository();

  beforeEach(async ())
 - novuClient(initNovuClassSdk(session);
  });

  it('should delay execution for the provided interval', async ())
 - messagesAfter(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - delayedJobs(await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: templat...)
 - messages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - messages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - messagesBefore(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - delayedJob(await pollForJobStatusChange({
        jobRepository,
        query: {
          _environmentId: ses...)
 - failedJob(await pollForJobStatusChange({
        jobRepository,
        query: {
          _environmentId: ses...)
 - failedJob(await pollForJobStatusChange({
        jobRepository,
        query: {
          _environmentId: ses...)
 - failedJob(await pollForJobStatusChange({
        jobRepository,
        query: {
          _environmentId: ses...)
 - delayedJobs(await jobRepository.find({
        _environmentId: session.environment._id,
        _templateId: wor...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/digest-events.e2e.ts
TamaÃ±o: 32258 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import {
  JobRepository,
  JobStatusEnum,
  MessageRepository,
  NotificationTemplateEntity,
  SubscriberEntity,
} from '@novu/dal';
import { DigestTypeEnum, DigestUnitEnum, IDigestRegularMetadata, StepTypeEnum } from '@novu/shared';
import { JobsService, SubscribersService, UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';
import { pollForJobStatusChange } from './utils/poll-for-job-status-change.util';

const axiosInstance = axios.create();

describe('Trigger event - Digest triggered events - /v1/events/trigger (POST) #novu-v2', () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;
  const jobRepository = new JobRepository();
  const messageRepository = new MessageRepository();
  const jobsService = new JobsService();
  let novuClient: Novu;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    template = await session.createTemplate();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
    novuClient = initNovuClassSdk(session);
  });
  const triggerEvent = async (payload: { [k: string]: any } | undefined, transactionId?: string): Promise<void> => {
    await novuClient.trigger(
      {
        transactionId,
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload,
      },
      transactionId
    );
  };

  it('should digest events within time interval', async () => {
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.SMS,
          content: 'Hello world {{customVar}}' as string,
        },
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.SMS,
          content: 'Hello world {{customVar}}' as string,
        },
      ],
    });

    await triggerEvent({
      customVar: 'Testing of User Name',
    });

    await triggerEvent({
      customVar: 'digest',
    });

    await session.waitForJobCompletion(template?._id);

    const initialJobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      type: StepTypeEnum.DIGEST,
    });

    expect(initialJobs && initialJobs.length).to.eql(2);

    const delayedJobs = initialJobs.filter((elem) => elem.status === JobStatusEnum.COMPLETED);
    expect(delayedJobs && delayedJobs.length).to.eql(1);
    const mergedJobs = initialJobs.filter((elem) => elem.status === JobStatusEnum.MERGED);
    expect(mergedJobs && mergedJobs.length).to.eql(1);

    const delayedJob = delayedJobs[0];

    expect(delayedJob).to.be.ok;

    await session.waitForJobCompletion(template?._id);

    const jobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      status: {
        $nin: [JobStatusEnum.CANCELED],
      },
    });

    const digestJob = jobs.find((job) => job.step?.template?.type === StepTypeEnum.DIGEST);
    expect((digestJob && (digestJob?.digest as IDigestRegularMetadata))?.amount).to.equal(1);
    expect((digestJob && (digestJob?.digest as IDigestRegularMetadata))?.unit).to.equal(DigestUnitEnum.SECONDS);
    const job = jobs.find((item) => item.digest?.events?.length && item.digest.events.length > 0);
    expect(job && job?.digest?.events?.length).to.equal(2);
  });

  it('should not have digest prop when not running a digest', async () => {
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.SMS,
          content: 'Hello world {{#if step.digest}} HAS_DIGEST_PROP {{else}} NO_DIGEST_PROP {{/if}}' as string,
        },
      ],
    });

    await triggerEvent({
      customVar: 'Testing of User Name',
    });

    await session.waitForJobCompletion(template?._id);

    const message = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.SMS,
    });

    expect(message && message[0].content).to.include('NO_DIGEST_PROP');
    expect(message && message[0].content).to.not.include('HAS_DIGEST_PROP');
  });

  it('should add a digest prop to template compilation', async () => {
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.SMS,
          content: 'Hello world {{#if step.digest}} HAS_DIGEST_PROP {{/if}}' as string,
        },
      ],
    });

    await triggerEvent({
      customVar: 'Testing of User Name',
    });

    await triggerEvent({
      customVar: 'digest',
    });

    await session.waitForJobCompletion(template?._id);

    const jobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      _subscriberId: subscriber._id,
      type: StepTypeEnum.DIGEST,
    });

    expect(jobs && jobs.length).to.eql(2);

    const completedJob = jobs.find((elem) => elem.status === JobStatusEnum.COMPLETED);
    expect(completedJob).to.ok;
    const mergedJob = jobs.find((elem) => elem.status === JobStatusEnum.MERGED);
    expect(mergedJob).to.ok;

    const message = await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.SMS,
      _notificationId: completedJob?._notificationId,
      _templateId: template._id,
    });

    expect(message && message?.content).to.include('HAS_DIGEST_PROP');
  });

  it('should digest based on digestKey within time interval', async () => {
    const id = MessageRepository.createObjectId();
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.SMS,
          content: 'Hello world {{customVar}}' as string,
        },
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            digestKey: 'id',
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.SMS,
          content: 'Hello world {{customVar}}' as string,
        },
      ],
    });

    await triggerEvent({
      customVar: 'Testing of User Name',
      id,
    });

    await triggerEvent({
      customVar: 'digest',
    });

    await triggerEvent({
      customVar: 'haj',
      id,
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();
    await session.waitForStandardQueueCompletion();

    const jobs = await pollForJobStatusChange({
      jobRepository,
      query: {
        _environmentId: session.environment._id,
        _templateId: template._id,
        type: StepTypeEnum.DIGEST,
      },
      findMultiple: true,
    });

    expect(jobs && jobs.length).to.eql(3);

    const delayedJobs = jobs.filter((elem) => elem.status === JobStatusEnum.DELAYED);
    expect(delayedJobs && delayedJobs.length).to.eql(2);
    const mergedJobs = jobs.filter((elem) => elem.status !== JobStatusEnum.DELAYED);
    expect(mergedJobs && mergedJobs.length).to.eql(1);

    await session.waitForDbJobCompletion({ templateId: template?._id });

    const finalJobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
    });

    const digestedJobs = finalJobs.filter((job) => (job?.digest as IDigestRegularMetadata)?.digestKey === 'id');
    expect(digestedJobs && digestedJobs.length).to.eql(3);

    const jobsWithEvents = finalJobs.filter(
      (item) => item.type === StepTypeEnum.SMS && item?.digest?.events && item.digest.events.length > 0
    );
    expect(jobsWithEvents && jobsWithEvents.length).to.equal(2);
  });

  it('should digest based on same digestKey within time interval', async () => {
    const firstDigestKey = 'digest-key-one';
    const secondDigestKey = 'digest-key-two';
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            digestKey: 'id',
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.SMS,
          content: 'Hello world {{step.events.length}}' as string,
        },
      ],
    });

    await triggerEvent({
      customVar: 'Testing of User Name',
      id: firstDigestKey,
    });

    await triggerEvent({
      customVar: 'Testing of User Name',
      id: firstDigestKey,
    });

    await triggerEvent({
      customVar: 'digest',
      id: secondDigestKey,
    });

    await session.waitForJobCompletion(template?._id);

    const jobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      type: StepTypeEnum.DIGEST,
    });

    expect(jobs && jobs.length).to.equal(3);

    const completedJobs = jobs.filter((elem) => elem.status === JobStatusEnum.COMPLETED);
    expect(completedJobs && completedJobs.length).to.eql(2);
    const mergedJobs = jobs.filter((elem) => elem.status === JobStatusEnum.MERGED);
    expect(mergedJobs && mergedJobs.length).to.eql(1);

    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.SMS,
      _templateId: template._id,
      _notificationId: {
        $in: completedJobs.map((job) => job._notificationId),
      },
    });

    const firstDigestKeyBatch = messages.filter((message) => (message.content as string).includes('Hello world 2'));
    const secondDigestKeyBatch = messages.filter((message) => (message.content as string).includes('Hello world 1'));

    expect(firstDigestKeyBatch && firstDigestKeyBatch.length).to.eql(1);
    expect(secondDigestKeyBatch && secondDigestKeyBatch.length).to.eql(1);

    expect(messages && messages.length).to.equal(2);
  });

  it('should digest delayed events', async () => {
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello world {{customVar}}' as string,
        },
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello world {{step.events.length}}' as string,
        },
      ],
    });

    await triggerEvent({
      customVar: 'Testing of User Name',
    });

    await session.waitForJobCompletion(template?._id);

    const jobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      status: {
        $ne: JobStatusEnum.COMPLETED,
      },
    });

    expect(jobs && jobs.length).to.equal(0);
  });

  it.skip('should digest with backoff strategy', async () => {
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            type: DigestTypeEnum.BACKOFF,
            backoffUnit: DigestUnitEnum.SECONDS,
            backoffAmount: 10,
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello world {{step.events.length}}' as string,
        },
      ],
    });

    const events = [
      { customVar: 'Testing of User Name' },
      { customVar: 'digest' },
      { customVar: 'merged' },
      { customVar: 'digest' },
      { customVar: 'merged' },
      { customVar: 'digest' },
      { customVar: 'merged' },
    ];

    await Promise.all(events.map((event) => triggerEvent(event)));

    await session.waitForJobCompletion(template?._id);

    const jobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      _subscriberId: subscriber._id,
      type: StepTypeEnum.DIGEST,
    });

    expect(jobs && jobs.length).to.eql(7);

    const completedJob = jobs.find((elem) => elem.status === JobStatusEnum.COMPLETED);
    expect(completedJob).to.ok;
    const skippedJob = jobs.find((elem) => elem.status === JobStatusEnum.SKIPPED);
    expect(skippedJob).to.ok;
    const mergedJob = jobs.find((elem) => elem.status === JobStatusEnum.MERGED);
    expect(mergedJob).to.ok;

    const generatedMessageJob = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      _subscriberId: subscriber._id,
      type: StepTypeEnum.IN_APP,
    });

    expect(generatedMessageJob && generatedMessageJob.length).to.equal(7);

    const mergedInApp = generatedMessageJob.filter((elem) => elem.status === JobStatusEnum.MERGED);
    expect(mergedInApp && mergedInApp.length).to.equal(5);

    const completedInApp = generatedMessageJob.filter((elem) => elem.status === JobStatusEnum.COMPLETED);
    expect(completedInApp && completedInApp.length).to.equal(2);

    const digestEventLength6 = completedInApp.find((i) => i.digest?.events?.length === 6);
    expect(digestEventLength6).to.be.ok;

    const digestEventLength0 = completedInApp.find((i) => i.digest?.events?.length === 0);
    expect(digestEventLength0).to.be.ok;
  });

  it('should create multiple digest based on different digestKeys', async () => {
    const postId = MessageRepository.createObjectId();
    const postId2 = MessageRepository.createObjectId();

    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            digestKey: 'postId',
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello world {{postId}}' as string,
        },
      ],
    });

    await triggerEvent({
      customVar: 'No digest key',
    });
    await triggerEvent({
      customVar: 'digest key1',
      postId,
    });
    await triggerEvent({
      customVar: 'digest key2',
      postId: postId2,
    });
    await triggerEvent({
      customVar: 'No digest key repeat',
    });
    await triggerEvent({
      customVar: 'digest key1 repeat',
      postId,
    });

    await session.waitForJobCompletion(template?._id);

    const digests = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      type: StepTypeEnum.DIGEST,
    });

    expect(digests && digests.length).to.equal(5);
    const noPostIdJobs = digests.filter((job) => !job.payload.postId);
    expect(noPostIdJobs && noPostIdJobs.length).to.equal(2);

    const postId1Jobs = digests.filter((job) => job.payload.postId === postId);
    const postId2Jobs = digests.filter((job) => job.payload.postId === postId2);
    const postId1MergedJobs = postId1Jobs.filter((job) => job.status === JobStatusEnum.MERGED);

    expect(postId1MergedJobs && postId1MergedJobs.length).to.equal(1);
    expect(postId1Jobs && postId1Jobs.length).to.equal(2);
    expect(postId2Jobs && postId2Jobs.length).to.equal(1);

    await session.waitForJobCompletion(template?._id);

    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      _subscriberId: subscriber._id,
    });
    expect(messages && messages.length).to.eql(3);
    const postId1Content = messages.find((message) => (message.content as string).includes(postId));
    const postId2Content = messages.find((message) => (message.content as string).includes(postId2));
    const noDigestKeyContent = messages.find((message) => message.content === 'Hello world ');
    expect(postId1Content).to.be.ok;
    expect(postId2Content).to.be.ok;
    expect(noDigestKeyContent).to.be.ok;

    const jobCount = await jobRepository.count({
      _environmentId: session.environment._id,
      _templateId: template._id,
    });
    expect(jobCount).to.equal(15);
  });

  it('should create multiple digests based on different nested digestKeys', async () => {
    const postId = MessageRepository.createObjectId();
    const postId2 = MessageRepository.createObjectId();

    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            digestKey: 'nested.postId',
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello world {{nested.postId}}' as string,
        },
      ],
    });

    await triggerEvent({
      customVar: 'No digest key',
    });

    await triggerEvent({
      customVar: 'digest key1',
      nested: { postId },
    });

    await triggerEvent({
      customVar: 'digest key2',
      nested: { postId: postId2 },
    });
    await triggerEvent({
      customVar: 'No digest key repeat',
    });
    await triggerEvent({
      customVar: 'digest key1 repeat',
      nested: { postId },
    });

    await session.waitForJobCompletion(template?._id);

    const digests = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      type: StepTypeEnum.DIGEST,
    });

    expect(digests && digests.length).to.eql(5);

    const noPostIdJobs = digests.filter((job) => !job.payload.nested);
    expect(noPostIdJobs && noPostIdJobs.length).to.equal(2);

    const postId1Jobs = digests.filter((job) => job.payload.nested?.postId === postId);
    const postId2Jobs = digests.filter((job) => job.payload.nested?.postId === postId2);
    const postId1MergedJobs = postId1Jobs.filter((job) => job.status === JobStatusEnum.MERGED);

    expect(postId1MergedJobs && postId1MergedJobs.length).to.equal(1);
    expect(postId1Jobs && postId1Jobs.length).to.equal(2);
    expect(postId2Jobs && postId2Jobs.length).to.equal(1);

    await session.waitForJobCompletion(template?._id);

    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      _subscriberId: subscriber._id,
    });

    expect(messages && messages.length).to.eql(3);
    const postId1Content = messages.find((message) => (message.content as string).includes(postId));
    const postId2Content = messages.find((message) => (message.content as string).includes(postId2));
    const noDigestKeyContent = messages.find((message) => message.content === 'Hello world ');
    expect(postId1Content).to.be.ok;
    expect(postId2Content).to.be.ok;
    expect(noDigestKeyContent).to.be.ok;

    const jobCount = await jobRepository.count({
      _environmentId: session.environment._id,
      _templateId: template._id,
    });
    expect(jobCount).to.equal(15);
  });

  it('should create multiple digest based on different digestKeys with backoff', async () => {
    const postId = MessageRepository.createObjectId();
    const postId2 = MessageRepository.createObjectId();

    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            digestKey: 'postId',
            type: DigestTypeEnum.BACKOFF,
            backoffUnit: DigestUnitEnum.MINUTES,
            backoffAmount: 5,
          },
        },
        {
          type: StepTypeEnum.CHAT,
          content: 'Hello world {{postId}}' as string,
        },
      ],
    });

    await Promise.all([
      triggerEvent({ customVar: 'first', postId }),
      triggerEvent({ customVar: 'second' }),
      triggerEvent({ customVar: 'third', postId: postId2 }),
      triggerEvent({ customVar: 'fourth', postId }),
      triggerEvent({ customVar: 'fifth', postId: postId2 }),
      triggerEvent({ customVar: 'sixth' }),
    ]);

    await session.waitForJobCompletion(template?._id);

    const digests = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      type: StepTypeEnum.DIGEST,
    });

    expect(digests && digests.length).to.equal(6);

    const completedJobs = digests.filter((job) => job.status === JobStatusEnum.COMPLETED);
    expect(completedJobs && completedJobs.length).to.equal(3);

    const skippedJobs = digests.filter((job) => job.status === JobStatusEnum.SKIPPED);
    expect(skippedJobs && skippedJobs.length).to.equal(3);

    const postId1Jobs = digests.filter((job) => job.payload.postId === postId);
    expect(postId1Jobs && postId1Jobs.length).to.equal(2);

    const postId2Jobs = digests.filter((job) => job.payload.postId === postId2);
    expect(postId2Jobs && postId2Jobs.length).to.equal(2);

    const noPostIdJobs = digests.filter((job) => !job.payload.postId);
    expect(noPostIdJobs && noPostIdJobs.length).to.equal(2);

    await session.waitForJobCompletion(template?._id);

    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      _subscriberId: subscriber._id,
    });

    expect(messages && messages.length).to.equal(6);

    const contents: string[] = messages
      .map((message) => message.content)
      .reduce((prev, content: string) => {
        if (prev.includes(content)) {
          return prev;
        }
        prev.push(content);

        return prev;
      }, [] as string[]);

    expect(contents).to.include(`Hello world ${postId}`);
    expect(contents).to.include(`Hello world ${postId2}`);

    const jobCount = await jobRepository.count({
      _environmentId: session.environment._id,
      _templateId: template._id,
    });
    expect(jobCount).to.equal(18);
  });

  it('should create multiple digests based on different nested digestKeys with backoff', async () => {
    const postId = MessageRepository.createObjectId();
    const postId2 = MessageRepository.createObjectId();

    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            digestKey: 'nested.postId',
            type: DigestTypeEnum.BACKOFF,
            backoffUnit: DigestUnitEnum.MINUTES,
            backoffAmount: 5,
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello world {{nested.postId}}' as string,
        },
      ],
    });

    await triggerEvent({
      customVar: 'first',
      nested: { postId },
    });

    await triggerEvent({
      customVar: 'second',
      nested: { postId },
    });

    await triggerEvent({
      customVar: 'third',
    });

    await triggerEvent({
      customVar: 'fourth',
      nested: { postId: postId2 },
    });

    await triggerEvent({
      customVar: 'fifth',
      nested: { postId: postId2 },
    });

    await triggerEvent({
      customVar: 'sixth',
    });

    await session.waitForJobCompletion(template?._id);

    const digests = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      type: StepTypeEnum.DIGEST,
    });

    expect(digests && digests.length).to.equal(6);

    const completedJobs = digests.filter((job) => job.status === JobStatusEnum.COMPLETED);
    expect(completedJobs && completedJobs.length).to.equal(3);

    const skippedJobs = digests.filter((job) => job.status === JobStatusEnum.SKIPPED);
    expect(skippedJobs && skippedJobs.length).to.equal(3);

    const postId1Jobs = digests.filter((job) => job.payload?.nested?.postId === postId);
    expect(postId1Jobs && postId1Jobs.length).to.equal(2);

    const postId2Jobs = digests.filter((job) => job.payload?.nested?.postId === postId2);
    expect(postId2Jobs && postId2Jobs.length).to.equal(2);

    const noPostIdJobs = digests.filter((job) => !job.payload?.nested?.postId);
    expect(noPostIdJobs && noPostIdJobs.length).to.equal(2);

    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      _subscriberId: subscriber._id,
    });
    expect(messages && messages.length).to.equal(6);

    const jobCount = await jobRepository.count({
      _environmentId: session.environment._id,
      _templateId: template._id,
    });
    expect(jobCount).to.equal(18);
  });

  it('should add a digest prop to chat template compilation', async () => {
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          content:
            'Total events in digest:{{step.total_count}} Hello world {{#if step.digest}} HAS_DIGEST_PROP {{/if}}' as string,
        },
      ],
    });

    await triggerEvent({
      customVar: 'Testing of User Name',
    });

    await triggerEvent({
      customVar: 'digest',
    });

    await session.waitForJobCompletion(template?._id);

    const jobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      _subscriberId: subscriber._id,
      type: StepTypeEnum.DIGEST,
    });

    expect(jobs && jobs.length).to.eql(2);

    const completedJob = jobs.find((elem) => elem.status === JobStatusEnum.COMPLETED);
    expect(completedJob).to.ok;
    const mergedJob = jobs.find((elem) => elem.status === JobStatusEnum.MERGED);
    expect(mergedJob).to.ok;

    await session.waitForJobCompletion(template?._id);

    const message = await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.IN_APP,
      _templateId: template._id,
      _notificationId: completedJob?._notificationId,
    });
    expect(message && message?.content).to.include('HAS_DIGEST_PROP');
    expect(message && message?.content).to.include('Total events in digest:2');
  });

  it('should add a digest prop to push template compilation', async () => {
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.PUSH,
          title: 'Hello world {{#if step.digest}} HAS_DIGEST_PROP {{/if}}',
          content: 'Hello world {{#if step.digest}} HAS_DIGEST_PROP {{/if}}' as string,
        },
      ],
    });

    await triggerEvent({
      customVar: 'Testing of User Name',
    });

    await triggerEvent({
      customVar: 'digest',
    });

    await session.waitForJobCompletion(template?._id);

    const jobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      _subscriberId: subscriber._id,
      type: StepTypeEnum.DIGEST,
    });

    expect(jobs && jobs.length).to.eql(2);

    const completedJob = jobs.find((elem) => elem.status === JobStatusEnum.COMPLETED);
    expect(completedJob).to.ok;
    const mergedJob = jobs.find((elem) => elem.status === JobStatusEnum.MERGED);
    expect(mergedJob).to.ok;

    const message = await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.PUSH,
      _templateId: template._id,
      _notificationId: completedJob?._notificationId,
    });

    expect(message && message?.content).to.include('HAS_DIGEST_PROP');
  });

  it('should merge digest events accordingly when concurrent calls', async () => {
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 2,
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello world {{step.events.length}}' as string,
        },
      ],
    });

    await Promise.all([
      triggerEvent({
        customVar: 'concurrent-call-1',
      }),
      triggerEvent({
        customVar: 'concurrent-call-2',
      }),
      triggerEvent({
        customVar: 'concurrent-call-3',
      }),
      triggerEvent({
        customVar: 'concurrent-call-4',
      }),
      triggerEvent({
        customVar: 'concurrent-call-5',
      }),
      triggerEvent({
        customVar: 'concurrent-call-6',
      }),
      triggerEvent({
        customVar: 'concurrent-call-7',
      }),
      triggerEvent({
        customVar: 'concurrent-call-8',
      }),
      triggerEvent({
        customVar: 'concurrent-call-9',
      }),
      triggerEvent({
        customVar: 'concurrent-call-10',
      }),
    ]);

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();
    await session.waitForStandardQueueCompletion();

    const jobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      type: StepTypeEnum.DIGEST,
    });

    expect(jobs && jobs.length).to.eql(10);

    const delayedJobs = jobs.filter((elem) => elem.status === JobStatusEnum.DELAYED);
    expect(delayedJobs && delayedJobs.length).to.eql(1);
    const mergedJobs = jobs.filter((elem) => elem.status !== JobStatusEnum.DELAYED);
    expect(mergedJobs && mergedJobs.length).to.eql(9);
  });

  it('should merge digest events when sequential calls', async () => {
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            type: DigestTypeEnum.REGULAR,
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello world {{step.events.length}}' as string,
        },
      ],
    });

    await triggerEvent({ customVar: 'sequential-calls-1' });
    await triggerEvent({ customVar: 'sequential-calls-2' });
    await triggerEvent({ customVar: 'sequential-calls-3' });
    await triggerEvent({ customVar: 'sequential-calls-4' });
    await triggerEvent({ customVar: 'sequential-calls-5' });
    await triggerEvent({ customVar: 'sequential-calls-6' });
    await triggerEvent({ customVar: 'sequential-calls-7' });
    await triggerEvent({ customVar: 'sequential-calls-8' });
    await triggerEvent({ customVar: 'sequential-calls-9' });
    await triggerEvent({ customVar: 'sequential-calls-10' });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();
    await session.waitForStandardQueueCompletion();

    const jobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      type: StepTypeEnum.DIGEST,
    });

    expect(jobs && jobs.length).to.eql(10);

    const delayedJobs = jobs.filter((elem) => elem.status === JobStatusEnum.DELAYED);
    expect(delayedJobs && delayedJobs.length).to.eql(1);
    const mergedJobs = jobs.filter((elem) => elem.status !== JobStatusEnum.DELAYED);
    expect(mergedJobs && mergedJobs.length).to.eql(9);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - axiosInstance(axios.create();

describe('Trigger event - Digest triggered events - /v1/events/trigger (POST) #novu...)
 - jobsService(new JobsService();
  let novuClient: Novu;
  beforeEach(async ())
 - triggerEvent(async (payload: { [k: string]: any } | undefined, transactionId?: string): Promise<void>)
 - delayedJobs(initialJobs.filter((elem))
 - mergedJobs(initialJobs.filter((elem))
 - digestJob(jobs.find((job))
 - job(jobs.find((item))
 - message(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - completedJob(jobs.find((elem))
 - mergedJob(jobs.find((elem))
 - message(await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId...)
 - delayedJobs(jobs.filter((elem))
 - mergedJobs(jobs.filter((elem))
 - digestedJobs(finalJobs.filter((job))
 - jobsWithEvents(finalJobs.filter(
      (item))
 - completedJobs(jobs.filter((elem))
 - mergedJobs(jobs.filter((elem))
 - messages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - firstDigestKeyBatch(messages.filter((message))
 - secondDigestKeyBatch(messages.filter((message))
 - jobs(await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: templat...)
 - events([
      { customVar: 'Testing of User Name' },
      { customVar: 'digest' },
      { customVar: 'me...)
 - completedJob(jobs.find((elem))
 - skippedJob(jobs.find((elem))
 - mergedJob(jobs.find((elem))
 - mergedInApp(generatedMessageJob.filter((elem))
 - completedInApp(generatedMessageJob.filter((elem))
 - digestEventLength6(completedInApp.find((i))
 - digestEventLength0(completedInApp.find((i))
 - noPostIdJobs(digests.filter((job))
 - postId1Jobs(digests.filter((job))
 - postId2Jobs(digests.filter((job))
 - postId1MergedJobs(postId1Jobs.filter((job))
 - postId1Content(messages.find((message))
 - postId2Content(messages.find((message))
 - noDigestKeyContent(messages.find((message))
 - jobCount(await jobRepository.count({
      _environmentId: session.environment._id,
      _templateId: templa...)
 - noPostIdJobs(digests.filter((job))
 - postId1Jobs(digests.filter((job))
 - postId2Jobs(digests.filter((job))
 - postId1MergedJobs(postId1Jobs.filter((job))
 - postId1Content(messages.find((message))
 - postId2Content(messages.find((message))
 - noDigestKeyContent(messages.find((message))
 - jobCount(await jobRepository.count({
      _environmentId: session.environment._id,
      _templateId: templa...)
 - completedJobs(digests.filter((job))
 - skippedJobs(digests.filter((job))
 - postId1Jobs(digests.filter((job))
 - postId2Jobs(digests.filter((job))
 - noPostIdJobs(digests.filter((job))
 - jobCount(await jobRepository.count({
      _environmentId: session.environment._id,
      _templateId: templa...)
 - completedJobs(digests.filter((job))
 - skippedJobs(digests.filter((job))
 - postId1Jobs(digests.filter((job))
 - postId2Jobs(digests.filter((job))
 - noPostIdJobs(digests.filter((job))
 - jobCount(await jobRepository.count({
      _environmentId: session.environment._id,
      _templateId: templa...)
 - completedJob(jobs.find((elem))
 - mergedJob(jobs.find((elem))
 - message(await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId...)
 - completedJob(jobs.find((elem))
 - mergedJob(jobs.find((elem))
 - message(await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId...)
 - delayedJobs(jobs.filter((elem))
 - mergedJobs(jobs.filter((elem))
 - delayedJobs(jobs.filter((elem))
 - mergedJobs(jobs.filter((elem))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/process-subscriber.e2e.ts
TamaÃ±o: 7374 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CacheInMemoryProviderService, CacheService, InvalidateCacheService } from '@novu/application-generic';
import {
  MessageRepository,
  NotificationTemplateEntity,
  NotificationTemplateRepository,
  SubscriberEntity,
  SubscriberRepository,
} from '@novu/dal';
import { ChannelTypeEnum, ISubscribersDefine, IUpdateNotificationTemplateDto, StepTypeEnum } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';

import { UpdateSubscriberPreferenceRequestDto } from '../../widgets/dtos/update-subscriber-preference-request.dto';

const axiosInstance = axios.create();

describe('Trigger event - process subscriber /v1/events/trigger (POST) #novu-v2', () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;
  let cacheService: CacheService;
  let invalidateCache: InvalidateCacheService;
  let cacheInMemoryProviderService: CacheInMemoryProviderService;

  const subscriberRepository = new SubscriberRepository();
  const messageRepository = new MessageRepository();
  const notificationTemplateRepository = new NotificationTemplateRepository();

  before(async () => {
    cacheInMemoryProviderService = new CacheInMemoryProviderService();
    cacheService = new CacheService(cacheInMemoryProviderService);
    await cacheService.initialize();
    invalidateCache = new InvalidateCacheService(cacheService);
  });

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    template = await session.createTemplate();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
  });

  it('should trigger only active steps', async () => {
    const newTemplate = await session.createTemplate({
      steps: [
        {
          active: true,
          type: StepTypeEnum.IN_APP,
          content: 'Welcome to {{organizationName}}' as string,
        },
        {
          active: true,
          type: StepTypeEnum.IN_APP,
          content: 'Welcome to {{organizationName}}' as string,
        },
        {
          active: false,
          type: StepTypeEnum.IN_APP,
          content: 'Welcome to {{organizationName}}' as string,
        },
      ],
    });

    await axiosInstance.post(
      `${session.serverUrl}/v1/events/trigger`,
      {
        name: newTemplate.triggers[0].identifier,
        to: [{ subscriberId: subscriber.subscriberId, phone: '+972541111111' }],
        payload: {
          organizationName: 'Testing of Organization Name',
        },
      },
      {
        headers: {
          authorization: `ApiKey ${session.apiKey}`,
        },
      }
    );

    await session.waitForJobCompletion(newTemplate._id);

    const message = await messageRepository.find({
      _environmentId: session.environment._id,
      _templateId: newTemplate._id,
      _subscriberId: subscriber._id,
      channel: ChannelTypeEnum.IN_APP,
    });

    expect(message.length).to.equal(2);
  });

  it('should update a subscriber based on event', async () => {
    const payload: ISubscribersDefine = {
      subscriberId: subscriber.subscriberId,
      firstName: 'New Test Name',
      lastName: 'New Last of name',
      email: 'newtest@email.novu',
      locale: 'en',
    };

    await triggerEvent(session, template, payload);

    await session.waitForJobCompletion(template._id);

    const createdSubscriber = await subscriberRepository.findBySubscriberId(
      session.environment._id,
      subscriber.subscriberId
    );

    expect(createdSubscriber?.firstName).to.equal(payload.firstName);
    expect(createdSubscriber?.lastName).to.equal(payload.lastName);
    expect(createdSubscriber?.email).to.equal(payload.email);
    expect(createdSubscriber?.locale).to.equal(payload.locale);
  });

  it('should send only email trigger second time based on the subscriber preference', async () => {
    const payload: ISubscribersDefine = {
      subscriberId: session.subscriberId,
      firstName: 'New Test Name',
      lastName: 'New Last of name',
      email: 'newtest@email.novu',
    };

    await triggerEvent(session, template, payload);

    await session.waitForJobCompletion(template._id);

    const widgetSubscriber = await subscriberRepository.findBySubscriberId(
      session.environment._id,
      session.subscriberId
    );

    let message = await messageRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      _subscriberId: widgetSubscriber?._id,
    });

    expect(message.length).to.equal(2);

    const updateData = {
      channel: {
        type: ChannelTypeEnum.IN_APP,
        enabled: false,
      },
    };

    await updateSubscriberPreference(updateData, session.subscriberToken, template._id);

    await triggerEvent(session, template, payload);

    await session.waitForJobCompletion(template._id);

    message = await messageRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      _subscriberId: widgetSubscriber?._id,
    });

    expect(message.length).to.equal(3);
  });

  it('should ignore subscriber preference and send all triggers for system critical template', async () => {
    const payload: ISubscribersDefine = {
      subscriberId: session.subscriberId,
      firstName: 'New Test Name',
      lastName: 'New Last of name',
      email: 'newtest@email.novu',
    };

    await triggerEvent(session, template, payload);

    await session.waitForJobCompletion(template._id);

    const widgetSubscriber = await subscriberRepository.findBySubscriberId(
      session.environment._id,
      session.subscriberId
    );

    let message = await messageRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      _subscriberId: widgetSubscriber?._id,
    });

    expect(message.length).to.equal(2);

    const updateData = {
      channel: {
        type: ChannelTypeEnum.IN_APP,
        enabled: false,
      },
    };

    await updateSubscriberPreference(updateData, session.subscriberToken, template._id);

    await session.testAgent.put(`/v1/workflows/${template._id}`).send({ critical: true });

    await triggerEvent(session, template, payload);

    await session.waitForJobCompletion(template._id);

    message = await messageRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      _subscriberId: widgetSubscriber?._id,
    });

    expect(message.length).to.equal(4);
  });
});

async function triggerEvent(session, template, payload) {
  await axiosInstance.post(
    `${session.serverUrl}/v1/events/trigger`,
    {
      name: template.triggers[0].identifier,
      to: {
        ...payload,
      },
      payload: {},
    },
    {
      headers: {
        authorization: `ApiKey ${session.apiKey}`,
      },
    }
  );
}

async function updateSubscriberPreference(
  data: UpdateSubscriberPreferenceRequestDto,
  subscriberToken: string,
  templateId: string
) {
  return await axios.patch(`http://127.0.0.1:${process.env.PORT}/v1/widgets/preferences/${templateId}`, data, {
    headers: {
      Authorization: `Bearer ${subscriberToken}`,
    },
  });
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - triggerEvent(session, template, payload)
 - updateSubscriberPreference(data: UpdateSubscriberPreferenceRequestDto,
  subscriberToken: string,
  templateId: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - axiosInstance(axios.create();

describe('Trigger event - process subscriber /v1/events/trigger (POST) #novu-v2', (...)
 - notificationTemplateRepository(new NotificationTemplateRepository();

  before(async ())
 - invalidateCache(new InvalidateCacheService(cacheService);
  });

  beforeEach(async ())
 - subscriber(await subscriberService.createSubscriber();
  });

  it('should trigger only active steps', async ())
 - message(await messageRepository.find({
      _environmentId: session.environment._id,
      _templateId: new...)
 - createdSubscriber(await subscriberRepository.findBySubscriberId(
      session.environment._id,
      subscriber.subsc...)
 - message(await messageRepository.find({
      _environmentId: session.environment._id,
      _templateId: tem...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/scheduled-digest.e2e.ts
TamaÃ±o: 3564 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  JobEntity,
  JobRepository,
  JobStatusEnum,
  MessageRepository,
  NotificationTemplateEntity,
  SubscriberEntity,
} from '@novu/dal';
import { DigestTypeEnum, DigestUnitEnum, IDigestRegularMetadata, StepTypeEnum } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';

const axiosInstance = axios.create();

describe('Trigger event - Scheduled Digest Mode - /v1/events/trigger (POST) #novu-v2', () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;
  const jobRepository = new JobRepository();

  const triggerEvent = async (payload, transactionId?: string): Promise<void> => {
    await axiosInstance.post(
      `${session.serverUrl}/v1/events/trigger`,
      {
        transactionId,
        name: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload,
      },
      {
        headers: {
          authorization: `ApiKey ${session.apiKey}`,
        },
      }
    );
  };

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    template = await session.createTemplate();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
  });

  it.skip('should digest events using a scheduled digest', async () => {
    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.DIGEST,
          content: '',
          metadata: {
            unit: DigestUnitEnum.SECONDS,
            amount: 1,
            type: DigestTypeEnum.TIMED,
          },
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello world {{step.events.length}}' as string,
        },
      ],
    });

    const events = [{ customVar: 'One' }, { customVar: 'Two' }, { customVar: 'Three' }];

    await Promise.all(events.map((event) => triggerEvent(event)));

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();
    await session.waitForStandardQueueCompletion();

    await session.runStandardQueueDelayedJobsImmediately();

    await session.waitForDbJobCompletion({ templateId: template._id });

    const jobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      _subscriberId: subscriber._id,
      type: StepTypeEnum.DIGEST,
    });

    expect(jobs && jobs.length).to.eql(3);

    const completedJob = jobs.find((elem) => elem.status === JobStatusEnum.COMPLETED);
    expect(completedJob).to.ok;

    const mergedJob = jobs.find((elem) => elem.status === JobStatusEnum.MERGED);
    expect(mergedJob).to.ok;

    const generatedMessageJob = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: template._id,
      _subscriberId: subscriber._id,
      type: StepTypeEnum.IN_APP,
    });

    expect(generatedMessageJob.length).to.equal(3);

    const mergedInApp = generatedMessageJob.filter((elem) => elem.status === JobStatusEnum.MERGED);
    expect(mergedInApp.length).to.equal(2);

    const completedInApp = generatedMessageJob.filter((elem) => elem.status === JobStatusEnum.COMPLETED);
    expect(completedInApp.length).to.equal(1);

    const digestEventLength = completedInApp.find((i) => i.digest?.events?.length === 3);
    expect(digestEventLength).to.be.ok;
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - axiosInstance(axios.create();

describe('Trigger event - Scheduled Digest Mode - /v1/events/trigger (POST) #novu-v...)
 - triggerEvent(async (payload, transactionId?: string): Promise<void>)
 - subscriber(await subscriberService.createSubscriber();
  });

  it.skip('should digest events using a scheduled...)
 - events([{ customVar: 'One' }, { customVar: 'Two' }, { customVar: 'Three' }];

    await Promise.all(events....)
 - completedJob(jobs.find((elem))
 - mergedJob(jobs.find((elem))
 - mergedInApp(generatedMessageJob.filter((elem))
 - completedInApp(generatedMessageJob.filter((elem))
 - digestEventLength(completedInApp.find((i))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/send-message-email.e2e.ts
TamaÃ±o: 14903 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CompileEmailTemplate } from '@novu/application-generic';
import { IEmailOptions } from '@novu/stateless';
import { expect } from 'chai';

export const createMailData = (options: IEmailOptions, overrides: Record<string, any>): IEmailOptions => {
  const filterDuplicate = (prev: string[], current: string) => (prev.includes(current) ? prev : [...prev, current]);

  let to = Array.isArray(options.to) ? options.to : [options.to];
  to = [...to, ...(overrides?.to || [])];
  to = to.reduce(filterDuplicate, []);

  return {
    ...options,
    to,
    from: overrides?.from || options.from,
    text: overrides?.text,
    cc: overrides?.cc || [],
    bcc: overrides?.bcc || [],
  };
};

describe('Trigger event - Send message email - /v1/events/trigger (POST) #novu-v2', () => {
  it('should merge mail data', () => {
    const defaultMailData = {
      to: ['to-reply@novu.co'],
      subject: 'subject',
      html: '<html></html>',
      from: 'no-reply@novu.co',
      attachments: [],
      id: 'id',
    };

    let result = createMailData(defaultMailData, {
      to: ['override-to@novu.co'],
      from: 'override-from@novu.co',
      text: 'text',
      cc: ['cc@novu.co'],
      bcc: ['bcc@novu.co'],
    });

    expect(result.to).to.deep.equal(['to-reply@novu.co', 'override-to@novu.co']);
    expect(result.from).to.equal('override-from@novu.co');
    expect(result.text).to.equal('text');
    expect(result.cc).to.deep.equal(['cc@novu.co']);
    expect(result.bcc).to.deep.equal(['bcc@novu.co']);

    result = createMailData(
      {
        ...defaultMailData,
        to: ['override-to@novu.co'],
      },
      {
        from: 'override-from@novu.co',
        text: 'text',
        to: [],
      }
    );

    expect(result.cc).to.deep.equal([]);
    expect(result.bcc).to.deep.equal([]);
    expect(result.to).to.deep.equal(['override-to@novu.co']);
  });

  it('should add a preheader to html string after <body>', async () => {
    let result = CompileEmailTemplate.addPreheader('');

    expect(result).to.equal('');

    result = CompileEmailTemplate.addPreheader('<html><body><div>Hello World</div></body></html>');

    expect(result).to.equal(`<html><body>{{#if preheader}}
          <div style="display: none; max-height: 0px; overflow: hidden;">
            {{preheader}}
            &nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;
          </div>
        {{/if}}<div>Hello World</div></body></html>`);

    result = CompileEmailTemplate.addPreheader('<html><body attribute="value"><div>Hello World</div></body></html>');

    expect(result).to.equal(`<html><body attribute="value">{{#if preheader}}
          <div style="display: none; max-height: 0px; overflow: hidden;">
            {{preheader}}
            &nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;
          </div>
        {{/if}}<div>Hello World</div></body></html>`);

    result = CompileEmailTemplate.addPreheader(
      '<div> </div> \n <html><body attribute="value"><div>Hello World</div></body></html>'
    );

    expect(result).to.equal(`<div> </div> \n <html><body attribute="value">{{#if preheader}}
          <div style="display: none; max-height: 0px; overflow: hidden;">
            {{preheader}}
            &nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;
          </div>
        {{/if}}<div>Hello World</div></body></html>`);
  });

  it('should only add preheader to first occurrence of body', async () => {
    let result = CompileEmailTemplate.addPreheader('');

    expect(result).to.equal('');

    result = CompileEmailTemplate.addPreheader('<html><body><div>Hello World</div> <body></body></html>');

    expect(result).to.equal(`<html><body>{{#if preheader}}
          <div style="display: none; max-height: 0px; overflow: hidden;">
            {{preheader}}
            &nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;
          </div>
        {{/if}}<div>Hello World</div> <body></body></html>`);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - createMailData(options: IEmailOptions, overrides: Record<string, any>): IEmailOptions)
 - filterDuplicate(prev: string[], current: string))
 - to(to.reduce(filterDuplicate, []);

  return {
    ...options,
    to,
    from: overrides?.from || opt...)
 - result(createMailData(
      {
        ...defaultMailData,
        to: ['override-to@novu.co'],
      },
  ...)
 - style("display: none; max-height: 0px; overflow: hidden;">
            {{preheader}}
            &nbsp;&zw...)
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/send-message-push.e2e.ts
TamaÃ±o: 6698 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { DetailEnum } from '@novu/application-generic';
import {
  ExecutionDetailsRepository,
  IntegrationRepository,
  MessageRepository,
  NotificationTemplateEntity,
} from '@novu/dal';
import { ChannelTypeEnum, PushProviderIdEnum, StepTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Trigger event - Send Push Notification - /v1/events/trigger (POST) #novu-v2', () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;

  const executionDetailsRepository = new ExecutionDetailsRepository();
  const integrationRepository = new IntegrationRepository();
  const messageRepository = new MessageRepository();
  let novuClient: Novu;
  before(async () => {
    session = new UserSession();
    await session.initialize();

    template = await session.createTemplate({
      steps: [
        {
          active: true,
          type: StepTypeEnum.PUSH,
          title: 'Title',
          content: 'Welcome to {{organizationName}}' as string,
        },
      ],
    });
    novuClient = initNovuClassSdk(session);
  });

  describe('Multiple providers active', () => {
    before(async () => {
      await novuClient.integrations.create({
        providerId: PushProviderIdEnum.EXPO,
        channel: ChannelTypeEnum.PUSH,
        credentials: { apiKey: '123' },
        environmentId: session.environment._id,
        active: true,
        check: false,
      });
      const integrations = await integrationRepository.find({
        _environmentId: session.environment._id,
        channel: ChannelTypeEnum.PUSH,
        active: true,
      });

      expect(integrations.length).to.equal(2);
    });

    afterEach(async () => {
      await executionDetailsRepository.delete({ _environmentId: session.environment._id });
    });

    it('should not create any message if subscriber has no configured channel', async () => {
      await triggerEvent(template);

      await session.waitForJobCompletion(template._id);

      const messages = await messageRepository.find({
        _environmentId: session.environment._id,
        _templateId: template._id,
        _subscriberId: session.subscriberId,
      });

      expect(messages.length).to.equal(0);

      const executionDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
      });

      const noActiveChannel = executionDetails.find((ex) => ex.detail === DetailEnum.SUBSCRIBER_NO_ACTIVE_CHANNEL);
      expect(noActiveChannel).to.be.ok;
      expect(noActiveChannel?.providerId).to.equal('fcm');
    });

    it('should not create any message if subscriber has configured two providers without device tokens', async () => {
      await updateCredentials(session.subscriberId, PushProviderIdEnum.FCM, []);
      await updateCredentials(session.subscriberId, PushProviderIdEnum.EXPO, []);

      await triggerEvent(template);

      await session.waitForJobCompletion(template._id);

      const messages = await messageRepository.find({
        _environmentId: session.environment._id,
        _templateId: template._id,
        _subscriberId: session.subscriberId,
      });

      expect(messages.length).to.equal(0);

      const executionDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
      });

      const fcm = executionDetails.find(
        (ex) => ex.detail === DetailEnum.PUSH_MISSING_DEVICE_TOKENS && ex.providerId === PushProviderIdEnum.FCM
      );
      expect(fcm).to.be.ok;
      const expo = executionDetails.find(
        (ex) => ex.detail === DetailEnum.PUSH_MISSING_DEVICE_TOKENS && ex.providerId === PushProviderIdEnum.EXPO
      );
      expect(expo).to.be.ok;
      const pushMissingDeviceTokens = executionDetails.filter(
        (ex) => ex.detail === DetailEnum.PUSH_MISSING_DEVICE_TOKENS
      );
      expect(pushMissingDeviceTokens.length).to.equal(2);
      const pushChannelsSkipped = executionDetails.filter((ex) => ex.detail === DetailEnum.PUSH_SOME_CHANNELS_SKIPPED);
      expect(pushChannelsSkipped).to.be.ok;
    });

    it('should not create any message if subscriber has configured one provider without device tokens and the other has invalid device token', async () => {
      await updateCredentials(session.subscriberId, PushProviderIdEnum.FCM, ['invalidDeviceToken']);
      await updateCredentials(session.subscriberId, PushProviderIdEnum.EXPO, []);

      await triggerEvent(template);

      await session.waitForJobCompletion(template._id);

      const messages = await messageRepository.find({
        _environmentId: session.environment._id,
        _templateId: template._id,
        _subscriberId: session.subscriberId,
      });

      expect(messages.length, 'expected messages to be 0').to.equal(0);

      const executionDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
      });

      const fcmMessageCreated = executionDetails.find(
        (ex) => ex.detail === DetailEnum.MESSAGE_CREATED && ex.providerId === PushProviderIdEnum.FCM
      );
      expect(fcmMessageCreated, 'expected fcm message created to be ok').to.be.ok;

      const fcmProviderError = executionDetails.find(
        (ex) => ex.detail === DetailEnum.PROVIDER_ERROR && ex.providerId === PushProviderIdEnum.FCM
      );
      expect(fcmProviderError, 'expected fcm provider error to be ok').to.be.ok;

      const expo = executionDetails.find(
        (ex) => ex.detail === DetailEnum.PUSH_MISSING_DEVICE_TOKENS && ex.providerId === PushProviderIdEnum.EXPO
      );
      expect(expo, 'expected expo to be ok').to.be.ok;
      const pushMissingDeviceTokens = executionDetails.filter(
        (ex) => ex.detail === DetailEnum.PUSH_MISSING_DEVICE_TOKENS
      );
      expect(pushMissingDeviceTokens.length).to.equal(1);
      const pushChannelsSkipped = executionDetails.filter((ex) => ex.detail === DetailEnum.PUSH_SOME_CHANNELS_SKIPPED);
      expect(pushChannelsSkipped).to.be.ok;
    });
  });
  async function triggerEvent(template2) {
    await novuClient.trigger({
      workflowId: template2.triggers[0].identifier,
      to: [{ subscriberId: session.subscriberId }],
      payload: {},
    });
  }
  async function updateCredentials(subscriberId: string, providerId: PushProviderIdEnum, deviceTokens: string[]) {
    await novuClient.subscribers.credentials.update(
      {
        providerId,
        credentials: {
          deviceTokens,
          webhookUrl: 'https:www.someurl.com',
        },
      },
      subscriberId
    );
  }
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - triggerEvent(template2)
 - updateCredentials(subscriberId: string, providerId: PushProviderIdEnum, deviceTokens: string[])
Asignaciones con arrow functions encontradas (posibles funciones):
 - messageRepository(new MessageRepository();
  let novuClient: Novu;
  before(async ())
 - novuClient(initNovuClassSdk(session);
  });

  describe('Multiple providers active', ())
 - integrations(await integrationRepository.find({
        _environmentId: session.environment._id,
        channel:...)
 - noActiveChannel(executionDetails.find((ex))
 - fcm(executionDetails.find(
        (ex))
 - expo(executionDetails.find(
        (ex))
 - pushMissingDeviceTokens(executionDetails.filter(
        (ex))
 - pushChannelsSkipped(executionDetails.filter((ex))
 - fcmMessageCreated(executionDetails.find(
        (ex))
 - fcmProviderError(executionDetails.find(
        (ex))
 - expo(executionDetails.find(
        (ex))
 - pushMissingDeviceTokens(executionDetails.filter(
        (ex))
 - pushChannelsSkipped(executionDetails.filter((ex))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/test-email.e2e.ts
TamaÃ±o: 3225 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IntegrationRepository, MessageRepository } from '@novu/dal';
import { ChannelTypeEnum, EmailProviderIdEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

import { TestSendEmailRequestDto } from '../dtos';

// TODO: Fix these tests
describe.skip('Events - Test email - /v1/events/test/email (POST) #novu-v2', () => {
  const requestDto: TestSendEmailRequestDto = {
    contentType: 'customHtml',
    payload: {},
    controls: {},
    subject: 'subject',
    preheader: 'preheader',
    content: '<html><head></head><body>Hello world!</body></html>',
    to: 'to-reply@novu.co',
  };

  let session: UserSession;
  let integrationRepository: IntegrationRepository;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    integrationRepository = new IntegrationRepository();
  });

  const sendTestEmail = (body: TestSendEmailRequestDto) => {
    return session.testAgent.post('/v1/events/test/email').send(body);
  };

  const deleteEmailIntegration = async () => {
    const emailIntegration = await integrationRepository.findOne({
      channel: ChannelTypeEnum.EMAIL,
      _organizationId: session.organization._id,
    });
    await integrationRepository.delete({ _id: emailIntegration?._id, _organizationId: session.organization._id });
  };

  const deactivateEmailIntegration = async () => {
    const emailIntegration = await integrationRepository.findOne({
      channel: ChannelTypeEnum.EMAIL,
      _environmentId: session.environment._id,
    });
    await integrationRepository.update(
      {
        _id: emailIntegration?._id,
        _environmentId: session.environment._id,
      },
      { active: false }
    );
  };

  const reachNovuProviderLimit = async () => {
    const MAX_NOVU_INTEGRATION_MAIL_REQUESTS = parseInt(process.env.MAX_NOVU_INTEGRATION_MAIL_REQUESTS || '300', 10);
    const messageRepository = new MessageRepository();
    for (let i = 0; i < MAX_NOVU_INTEGRATION_MAIL_REQUESTS; i += 1) {
      await messageRepository.create({
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        providerId: EmailProviderIdEnum.Novu,
        channel: ChannelTypeEnum.EMAIL,
      });
    }
  };

  it('should allow sending test email with email provider', async () => {
    const response = await sendTestEmail(requestDto);

    expect(response.status).to.equal(201);
  });

  it('should allow sending test email with Novu provider', async () => {
    await deleteEmailIntegration();

    const response = await sendTestEmail(requestDto);

    expect(response.status).to.equal(201);
  });

  it('should send test email fallbacking to Novu provider when there is no active integration', async () => {
    await deactivateEmailIntegration();

    const response = await sendTestEmail(requestDto);

    expect(response.status).to.equal(201);
  });

  it('should not allow sending test email when Novu provider limit is reached', async () => {
    await deleteEmailIntegration();
    await reachNovuProviderLimit();

    try {
      await sendTestEmail(requestDto);
    } catch (e) {
      expect(e.response.status).to.equal(409);
    }
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - TestSendEmailRequestDto({
    contentType: 'customHtml',
    payload: {},
    controls: {},
    subject: 'subject',
    preh...)
 - sendTestEmail(body: TestSendEmailRequestDto))
 - deleteEmailIntegration(async ())
 - deactivateEmailIntegration(async ())
 - reachNovuProviderLimit(async ())
 - response(await sendTestEmail(requestDto);

    expect(response.status).to.equal(201);
  });

  it('should all...)
 - response(await sendTestEmail(requestDto);

    expect(response.status).to.equal(201);
  });

  it('should sen...)
 - response(await sendTestEmail(requestDto);

    expect(response.status).to.equal(201);
  });

  it('should not...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/throttle-events.e2e.ts
TamaÃ±o: 20680 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import {
  CreateWorkflowDto,
  StepTypeEnum,
  WorkflowCreationSourceEnum,
  WorkflowResponseDto,
} from '@novu/api/models/components';
import {
  JobRepository,
  JobStatusEnum,
  MessageRepository,
  NotificationTemplateRepository,
  SubscriberEntity,
} from '@novu/dal';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';
import { pollForJobStatusChange } from './utils/poll-for-job-status-change.util';

describe('Trigger event - Throttle triggered events - /v1/events/trigger (POST) #novu-v2', () => {
  let session: UserSession;
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;
  const jobRepository = new JobRepository();
  const messageRepository = new MessageRepository();
  const templateRepository = new NotificationTemplateRepository();
  let novuClient: Novu;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
    novuClient = initNovuClassSdk(session);
  });

  afterEach(async () => {
    await messageRepository.delete({
      _environmentId: session.environment._id,
    });
  });

  const triggerEvent = async (
    workflowId: string,
    payload: { [k: string]: any } | undefined,
    transactionId?: string
  ): Promise<void> => {
    await novuClient.trigger(
      {
        transactionId,
        workflowId,
        to: [subscriber.subscriberId],
        payload,
      },
      transactionId
    );
  };

  it('should not throttle when threshold is not met', async () => {
    const workflowBody: CreateWorkflowDto = {
      name: 'Test Throttle Not Met Workflow',
      workflowId: 'test-throttle-not-met-workflow',
      active: true,
      source: WorkflowCreationSourceEnum.Dashboard,
      steps: [
        {
          type: StepTypeEnum.Throttle,
          name: 'Throttle Step',
          controlValues: {
            type: 'fixed',
            amount: 1,
            unit: 'minutes',
            threshold: 3,
          },
        },
        {
          type: StepTypeEnum.InApp,
          name: 'In-App Message',
          controlValues: {
            body: 'Hello world {{payload.customVar}}',
          },
        },
      ],
    };

    const { result: workflow } = await novuClient.workflows.create(workflowBody);

    // Trigger 2 events (below threshold of 3)
    await triggerEvent(workflow.workflowId, {
      customVar: 'First event',
    });

    await triggerEvent(workflow.workflowId, {
      customVar: 'Second event',
    });

    await session.waitForJobCompletion(workflow.id);

    const throttleJobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: workflow.id,
      type: StepTypeEnum.Throttle,
    });

    expect(throttleJobs?.length).to.equal(2);

    // Both throttle jobs should be completed (not skipped)
    const completedThrottleJobs = throttleJobs.filter((job) => job.status === JobStatusEnum.COMPLETED);
    expect(completedThrottleJobs?.length).to.equal(2);

    // Both in-app messages should be created
    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.InApp,
    });

    expect(messages?.length).to.equal(2);

    // Check that payload variables are properly interpolated (order-independent)
    const messageContents = messages.map((msg) => JSON.stringify(msg.content));
    expect(messageContents.some((content) => content.includes('First event'))).to.be.true;
    expect(messageContents.some((content) => content.includes('Second event'))).to.be.true;
  });

  it('should throttle when threshold is exceeded', async () => {
    const workflowBody: CreateWorkflowDto = {
      name: 'Test Throttle Exceeded Workflow',
      workflowId: 'test-throttle-exceeded-workflow',
      active: true,
      source: WorkflowCreationSourceEnum.Dashboard,
      steps: [
        {
          type: StepTypeEnum.Throttle,
          name: 'Throttle Step',
          controlValues: {
            type: 'fixed',
            amount: 1,
            unit: 'minutes',
            threshold: 2,
          },
        },
        {
          type: StepTypeEnum.InApp,
          name: 'In-App Message',
          controlValues: {
            body: 'Hello world {{payload.customVar}}',
          },
        },
      ],
    };

    const { result: workflow } = await novuClient.workflows.create(workflowBody);

    // Trigger 3 events (exceeds threshold of 2)
    await triggerEvent(workflow.workflowId, {
      customVar: 'First event',
    });

    await triggerEvent(workflow.workflowId, {
      customVar: 'Second event',
    });

    await triggerEvent(workflow.workflowId, {
      customVar: 'Third event - should be throttled',
    });

    await session.waitForJobCompletion(workflow.id);

    const throttleJobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: workflow.id,
      type: StepTypeEnum.Throttle,
    });

    expect(throttleJobs?.length).to.equal(3);

    // First two should be completed, third should be skipped
    const completedThrottleJobs = throttleJobs.filter((job) => job.status === JobStatusEnum.COMPLETED);
    const skippedThrottleJobs = throttleJobs.filter((job) => job.status === JobStatusEnum.SKIPPED);

    expect(completedThrottleJobs?.length).to.equal(2);
    expect(skippedThrottleJobs?.length).to.equal(1);

    // Check throttle result in skipped job
    const skippedJob = skippedThrottleJobs[0];
    expect(skippedJob.stepOutput).to.be.ok;
    expect(skippedJob.stepOutput?.throttled).to.equal(true);
    expect(skippedJob.stepOutput?.threshold).to.equal(2);
    // The execution count should be at least the threshold (2) when throttled
    expect(skippedJob.stepOutput?.executionCount).to.be.at.least(2);

    // Only 2 in-app messages should be created
    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.InApp,
    });

    expect(messages?.length).to.equal(2);
  });

  it('should handle 20 concurrent triggers and only generate single message when threshold is 1', async () => {
    const workflowBody: CreateWorkflowDto = {
      name: 'Test Throttle Concurrent Workflow',
      workflowId: 'test-throttle-concurrent-workflow',
      active: true,
      source: WorkflowCreationSourceEnum.Dashboard,
      steps: [
        {
          type: StepTypeEnum.Throttle,
          name: 'Throttle Step',
          controlValues: {
            type: 'fixed',
            amount: 1,
            unit: 'minutes',
            threshold: 1,
          },
        },
        {
          type: StepTypeEnum.InApp,
          name: 'In-App Message',
          controlValues: {
            body: 'Throttled message {{payload.customVar}}',
          },
        },
      ],
    };

    const { result: workflow } = await novuClient.workflows.create(workflowBody);

    // Trigger 20 concurrent events
    const promises: Promise<void>[] = [];
    for (let i = 1; i <= 20; i++) {
      promises.push(
        triggerEvent(workflow.workflowId, {
          customVar: `Event ${i}`,
        })
      );
    }

    await Promise.all(promises);

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();
    await session.waitForStandardQueueCompletion();

    const throttleJobs = await pollForJobStatusChange({
      jobRepository,
      query: {
        _environmentId: session.environment._id,
        _templateId: workflow.id,
        type: 'throttle' as any,
      },
      findMultiple: true,
    });

    expect(throttleJobs?.length).to.equal(20);

    // Only 1 should be completed, 19 should be skipped
    const completedThrottleJobs = throttleJobs?.filter((job) => job.status === JobStatusEnum.COMPLETED) || [];
    const skippedThrottleJobs = throttleJobs?.filter((job) => job.status === JobStatusEnum.SKIPPED) || [];

    expect(completedThrottleJobs?.length).to.equal(1);
    expect(skippedThrottleJobs?.length).to.equal(19);

    // Verify throttle results in skipped jobs
    for (const job of skippedThrottleJobs) {
      expect(job.stepOutput).to.be.ok;
      expect(job.stepOutput?.throttled).to.equal(true);
      expect(job.stepOutput?.threshold).to.equal(1);
    }

    // Only 1 in-app message should be created
    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.InApp,
    });

    expect(messages?.length).to.equal(1);
  });

  it('should throttle based on throttleKey', async () => {
    const workflowBody: CreateWorkflowDto = {
      name: 'Test Throttle Key Workflow',
      workflowId: 'test-throttle-key-workflow',
      active: true,
      source: WorkflowCreationSourceEnum.Dashboard,
      steps: [
        {
          type: StepTypeEnum.Throttle,
          name: 'Throttle Step',
          controlValues: {
            type: 'fixed',
            amount: 1,
            unit: 'minutes',
            threshold: 1,
            throttleKey: 'userId',
          },
        },
        {
          type: StepTypeEnum.InApp,
          name: 'In-App Message',
          controlValues: {
            body: 'Hello user {{payload.userId}}',
          },
        },
      ],
    };

    const { result: workflow } = await novuClient.workflows.create(workflowBody);

    // Trigger events with different throttle keys
    await triggerEvent(workflow.workflowId, {
      userId: 'user1',
    });

    await triggerEvent(workflow.workflowId, {
      userId: 'user2',
    });

    await triggerEvent(workflow.workflowId, {
      userId: 'user1', // Should be throttled
    });

    await session.waitForJobCompletion(workflow.id);

    const throttleJobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: workflow.id,
      type: StepTypeEnum.Throttle,
    });

    expect(throttleJobs?.length).to.equal(3);

    // 2 should be completed (user1 first, user2), 1 should be skipped (user1 second)
    const completedThrottleJobs = throttleJobs.filter((job) => job.status === JobStatusEnum.COMPLETED);
    const skippedThrottleJobs = throttleJobs.filter((job) => job.status === JobStatusEnum.SKIPPED);

    expect(completedThrottleJobs?.length).to.equal(2);
    expect(skippedThrottleJobs?.length).to.equal(1);

    // Check messages created
    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.InApp,
    });

    expect(messages?.length).to.equal(2);

    const user1Messages = messages.filter((message) => message.payload.userId === 'user1');
    const user2Messages = messages.filter((message) => message.payload.userId === 'user2');

    expect(user1Messages?.length).to.equal(1);
    expect(user2Messages?.length).to.equal(1);
  });

  it('should throttle with dynamic ISO timestamp', async () => {
    const futureTime = new Date(Date.now() + 2 * 60 * 1000).toISOString(); // 2 minutes in future

    const workflowBody: CreateWorkflowDto = {
      name: 'Test Dynamic Throttle ISO Workflow',
      workflowId: 'test-dynamic-throttle-iso-workflow',
      source: WorkflowCreationSourceEnum.Dashboard,
      active: true,
      steps: [
        {
          type: StepTypeEnum.Throttle,
          name: 'Throttle Step',
          controlValues: {
            type: 'dynamic',
            dynamicKey: 'payload.releaseTime',
            threshold: 1,
          },
        },
        {
          type: StepTypeEnum.InApp,
          name: 'In-App Message',
          controlValues: {
            body: 'Dynamic throttled by timestamp {{payload.customVar}}',
          },
        },
      ],
    };

    const { result: workflow } = await novuClient.workflows.create(workflowBody);

    // Trigger first event with dynamic timestamp
    await triggerEvent(workflow.workflowId, {
      customVar: 'test1',
      releaseTime: futureTime,
    });

    // Trigger second event with same timestamp (should be throttled)
    await triggerEvent(workflow.workflowId, {
      customVar: 'test2',
      releaseTime: futureTime,
    });

    await session.waitForJobCompletion(workflow.id);

    const throttleJobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: workflow.id,
      type: StepTypeEnum.Throttle,
    });

    const completedThrottleJobs = throttleJobs.filter((job) => job.status === JobStatusEnum.COMPLETED);
    const skippedThrottleJobs = throttleJobs.filter((job) => job.status === JobStatusEnum.SKIPPED);

    expect(completedThrottleJobs?.length).to.equal(1);
    expect(skippedThrottleJobs?.length).to.equal(1);

    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.InApp,
    });

    expect(messages?.length).to.equal(1);
  });

  it('should throttle with dynamic duration object', async () => {
    const workflowBody: CreateWorkflowDto = {
      name: 'Test Dynamic Throttle Duration Workflow',
      workflowId: 'test-dynamic-throttle-duration-workflow',
      source: WorkflowCreationSourceEnum.Dashboard,
      active: true,
      steps: [
        {
          type: StepTypeEnum.Throttle,
          name: 'Throttle Step',
          controlValues: {
            type: 'dynamic',
            dynamicKey: 'payload.throttleWindow',
            threshold: 1,
          },
        },
        {
          type: StepTypeEnum.InApp,
          name: 'In-App Message',
          controlValues: {
            body: 'Dynamic throttled by duration {{payload.customVar}}',
          },
        },
      ],
    };

    const { result: workflow } = await novuClient.workflows.create(workflowBody);

    // Trigger first event with duration object
    await triggerEvent(workflow.workflowId, {
      customVar: 'test1',
      throttleWindow: { amount: 1, unit: 'minutes' },
    });

    // Trigger second event with same duration (should be throttled)
    await triggerEvent(workflow.workflowId, {
      customVar: 'test2',
      throttleWindow: { amount: 1, unit: 'minutes' },
    });

    await session.waitForJobCompletion(workflow.id);

    const throttleJobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: workflow.id,
      type: StepTypeEnum.Throttle,
    });

    const completedThrottleJobs = throttleJobs.filter((job) => job.status === JobStatusEnum.COMPLETED);
    const skippedThrottleJobs = throttleJobs.filter((job) => job.status === JobStatusEnum.SKIPPED);

    expect(completedThrottleJobs?.length).to.equal(1);
    expect(skippedThrottleJobs?.length).to.equal(1);

    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.InApp,
    });

    expect(messages?.length).to.equal(1);
  });

  it('should throttle with minute time units', async () => {
    const workflowBody: CreateWorkflowDto = {
      name: 'Test Throttle Minutes Workflow',
      workflowId: 'test-throttle-minutes-workflow',
      active: true,
      source: WorkflowCreationSourceEnum.Dashboard,
      steps: [
        {
          type: StepTypeEnum.Throttle,
          name: 'Throttle Step',
          controlValues: {
            type: 'fixed',
            amount: 1,
            unit: 'minutes',
            threshold: 2,
          },
        },
        {
          type: StepTypeEnum.InApp,
          name: 'In-App Message',
          controlValues: {
            body: 'Throttled by minutes {{payload.customVar}}',
          },
        },
      ],
    };

    const { result: workflow } = await novuClient.workflows.create(workflowBody);

    // Trigger 3 events quickly (should exceed threshold of 2 within 1 minute)
    await triggerEvent(workflow.workflowId, {
      customVar: 'First event',
    });

    await triggerEvent(workflow.workflowId, {
      customVar: 'Second event',
    });

    await triggerEvent(workflow.workflowId, {
      customVar: 'Third event - should be throttled',
    });

    await session.waitForJobCompletion(workflow.id);

    const throttleJobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: workflow.id,
      type: StepTypeEnum.Throttle,
    });

    expect(throttleJobs?.length).to.equal(3);

    const completedThrottleJobs = throttleJobs.filter((job) => job.status === JobStatusEnum.COMPLETED);
    const skippedThrottleJobs = throttleJobs.filter((job) => job.status === JobStatusEnum.SKIPPED);

    expect(completedThrottleJobs?.length).to.equal(2);
    expect(skippedThrottleJobs?.length).to.equal(1);

    // Check that the throttle window is correctly calculated for minutes
    const skippedJob = skippedThrottleJobs[0];
    expect(skippedJob.stepOutput?.threshold).to.equal(2);

    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.InApp,
    });

    expect(messages?.length).to.equal(2);
  });

  it('should skip child jobs when throttle step is skipped', async () => {
    const workflowBody: CreateWorkflowDto = {
      name: 'Test Throttle Child Jobs Workflow',
      workflowId: 'test-throttle-child-jobs-workflow',
      active: true,
      source: WorkflowCreationSourceEnum.Dashboard,
      steps: [
        {
          type: StepTypeEnum.Throttle,
          name: 'Throttle Step',
          controlValues: {
            type: 'fixed',
            amount: 1,
            unit: 'minutes',
            threshold: 1,
          },
        },
        {
          type: StepTypeEnum.InApp,
          name: 'In-App Message',
          controlValues: {
            body: 'First message {{payload.customVar}}',
          },
        },
        {
          type: StepTypeEnum.Email,
          name: 'Email Message',
          controlValues: {
            subject: 'Follow-up email',
            body: 'Follow-up email {{payload.customVar}}',
          },
        },
      ],
    };

    const { result: workflow } = await novuClient.workflows.create(workflowBody);

    // Trigger 2 events (second should be throttled)
    await triggerEvent(workflow.workflowId, {
      customVar: 'First event',
    });

    await triggerEvent(workflow.workflowId, {
      customVar: 'Second event - should be throttled',
    });

    await session.waitForJobCompletion(workflow.id);

    // Check all jobs
    const allJobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: workflow.id,
    });

    // V2 workflows create additional jobs (trigger jobs)
    // First workflow: trigger + throttle (completed) + in-app (completed) + email (completed) = 4
    // Second workflow: trigger + throttle (skipped) + in-app (skipped) + email (skipped) = 4
    // Total expected: 8 jobs
    expect(allJobs?.length).to.equal(8);

    const completedJobs = allJobs.filter((job) => job.status === JobStatusEnum.COMPLETED);
    const skippedJobs = allJobs.filter((job) => job.status === JobStatusEnum.SKIPPED);

    // Based on the actual test run behavior:
    // We're getting 4 completed jobs and 3 skipped jobs
    // This suggests the throttle is working correctly
    expect(completedJobs?.length).to.equal(4);
    expect(skippedJobs?.length).to.equal(3);

    // Verify throttle jobs behavior
    const throttleJobs = allJobs.filter((job) => job.type === StepTypeEnum.Throttle);
    expect(throttleJobs?.length).to.equal(2);

    // First throttle should be completed, second should be skipped (threshold=1)
    const completedThrottleJobs = throttleJobs.filter((job) => job.status === JobStatusEnum.COMPLETED);
    const skippedThrottleJobs = throttleJobs.filter((job) => job.status === JobStatusEnum.SKIPPED);
    expect(completedThrottleJobs?.length).to.equal(1);
    expect(skippedThrottleJobs?.length).to.equal(1);

    // Only 1 in-app message should be created (from the first workflow)
    const inAppMessages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      channel: StepTypeEnum.InApp,
    });

    expect(inAppMessages?.length).to.equal(1);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - templateRepository(new NotificationTemplateRepository();
  let novuClient: Novu;

  beforeEach(async ())
 - novuClient(initNovuClassSdk(session);
  });

  afterEach(async ())
 - triggerEvent(async (
    workflowId: string,
    payload: { [k: string]: any } | undefined,
    transactionId?: s...)
 - completedThrottleJobs(throttleJobs.filter((job))
 - messageContents(messages.map((msg))
 - completedThrottleJobs(throttleJobs.filter((job))
 - skippedThrottleJobs(throttleJobs.filter((job))
 - messages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - completedThrottleJobs(throttleJobs?.filter((job))
 - skippedThrottleJobs(throttleJobs?.filter((job))
 - messages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - completedThrottleJobs(throttleJobs.filter((job))
 - skippedThrottleJobs(throttleJobs.filter((job))
 - user1Messages(messages.filter((message))
 - user2Messages(messages.filter((message))
 - completedThrottleJobs(throttleJobs.filter((job))
 - skippedThrottleJobs(throttleJobs.filter((job))
 - messages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - completedThrottleJobs(throttleJobs.filter((job))
 - skippedThrottleJobs(throttleJobs.filter((job))
 - messages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - completedThrottleJobs(throttleJobs.filter((job))
 - skippedThrottleJobs(throttleJobs.filter((job))
 - messages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - completedJobs(allJobs.filter((job))
 - skippedJobs(allJobs.filter((job))
 - throttleJobs(allJobs.filter((job))
 - completedThrottleJobs(throttleJobs.filter((job))
 - skippedThrottleJobs(throttleJobs.filter((job))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/trigger-event-to-all.e2e.ts
TamaÃ±o: 20558 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import {
  IProcessSubscriberBulkJobDto,
  mapSubscribersToJobs,
  SubscriberProcessQueueService,
  TriggerMulticast,
  TriggerMulticastCommand,
} from '@novu/application-generic';
import { NotificationTemplateEntity, SubscriberEntity } from '@novu/dal';
import {
  ExternalSubscriberId,
  ISubscribersDefine,
  ITopic,
  SubscriberSourceEnum,
  TopicId,
  TopicKey,
  TopicName,
  TriggerRecipients,
  TriggerRecipientsTypeEnum,
} from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import sinon from 'sinon';

import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';
import { SharedModule } from '../../shared/shared.module';
import { EventsModule } from '../events.module';

const axiosInstance = axios.create();

const TOPIC_PATH = '/v1/topics';
const TOPIC_KEY_PREFIX = 'topic-key-trigger-event_';
const TOPIC_NAME_PREFIX = 'topic-name-trigger-event_';

// Helper function to create a topic
const createTopic = async (
  session: UserSession,
  key: TopicKey,
  name: TopicName
): Promise<{ _id: TopicId; key: TopicKey }> => {
  const response = await initNovuClassSdk(session).topics.create({ key, name });

  expect(response.result.id).to.exist;
  expect(response.result.key).to.eql(key);

  return { _id: response.result.id, key: response.result.key };
};

export class MockSubscriberProcessQueueService {
  addBulk(data: IProcessSubscriberBulkJobDto[]) {}
}

function mapSubscriberToSubscriberDefine(firstTopicSubscribers: SubscriberEntity[]) {
  return firstTopicSubscribers.map((subscriber) => ({ subscriberId: subscriber.subscriberId }));
}

function expectBulkTopicStub(secondCallStubArgs: IProcessSubscriberBulkJobDto[], jobs: IProcessSubscriberBulkJobDto[]) {
  for (const stubJobAny of secondCallStubArgs) {
    const stubJob: IProcessSubscriberBulkJobDto = stubJobAny;
    const job = jobs.find((xJob) => xJob.name === stubJob.name);
    if (!job) {
      expect(job).to.be.ok;

      return;
    }
    expect(job.name).to.be.equal(stubJob.name);
    expect(job.groupId).to.be.equal(stubJob.groupId);
    expect(job.options).to.be.equal(stubJob.options);

    const { subscriber, topics, ...jobDataWithoutSubscriber } = job.data;
    const { subscriber: stubSubscriber, topics: stubTopics, ...stubJobDataWithoutSubscriber } = stubJob.data;

    expect(jobDataWithoutSubscriber).to.deep.equal(stubJobDataWithoutSubscriber);
  }
}

function expectBulkSingleSubscriberStub(
  secondCallStubArgs: IProcessSubscriberBulkJobDto[],
  jobs: IProcessSubscriberBulkJobDto[]
) {
  for (const stubJobAny of secondCallStubArgs) {
    const stubJob: IProcessSubscriberBulkJobDto = stubJobAny;
    const job = jobs.find((xJob) => xJob.name === stubJob.name);
    if (!job) {
      expect(job).to.be.ok;

      return;
    }
    expect(job.name).to.be.equal(stubJob.name);
    expect(job.groupId).to.be.equal(stubJob.groupId);
    expect(job.options).to.be.equal(stubJob.options);
    expect(job.data).to.deep.equal(stubJob.data);
  }
}

describe('TriggerMulticast #novu-v2', () => {
  let triggerMulticast: TriggerMulticast;
  let subscriberProcessQueueService: SubscriberProcessQueueService;
  let addBulkStub: sinon.SinonStub;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [SharedModule, EventsModule],
      providers: [
        TriggerMulticast,
        {
          provide: SubscriberProcessQueueService,
          useClass: MockSubscriberProcessQueueService,
        },
      ],
    }).compile();

    triggerMulticast = moduleRef.get<TriggerMulticast>(TriggerMulticast);
    subscriberProcessQueueService = moduleRef.get<SubscriberProcessQueueService>(SubscriberProcessQueueService);
    addBulkStub = sinon.stub(subscriberProcessQueueService, 'addBulk');
  });

  afterEach(() => {
    addBulkStub.restore();
  });

  let session: UserSession;
  let template: NotificationTemplateEntity;
  let firstSubscriber: SubscriberEntity;
  let secondSubscriber: SubscriberEntity;
  let thirdSubscriber: SubscriberEntity;
  let forthSubscriber: SubscriberEntity;
  let subscriberService: SubscribersService;
  let bootstrapFirstTopic: ITopic & { _id: TopicId };
  let bootstrapSecondTopic: ITopic & { _id: TopicId };
  let to: TriggerRecipients;
  let firstTopicSubscribers: SubscriberEntity[];
  let secondTopicSubscribers: SubscriberEntity[];

  async function initializeTopic(subscribersToAdd: SubscriberEntity[], topicIndex: string) {
    const firstTopicKey = TOPIC_KEY_PREFIX + topicIndex;
    const firstTopicName = TOPIC_NAME_PREFIX + topicIndex;
    const createdTopic: { _id: TopicId; key: TopicKey } = await createTopic(session, firstTopicKey, firstTopicName);
    await addSubscribersToTopic(
      session,
      { topicKey: createdTopic.key, type: TriggerRecipientsTypeEnum.TOPIC },
      subscribersToAdd
    );

    const res: ITopic & { _id: TopicId } = {
      _id: createdTopic._id,
      topicKey: createdTopic.key,
      type: TriggerRecipientsTypeEnum.TOPIC,
    };

    return res;
  }

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    template = await session.createTemplate();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);

    firstSubscriber = await subscriberService.createSubscriber();
    secondSubscriber = await subscriberService.createSubscriber();
    firstTopicSubscribers = [firstSubscriber, secondSubscriber];
    bootstrapFirstTopic = await initializeTopic(firstTopicSubscribers, '1');
    to = [bootstrapFirstTopic];

    thirdSubscriber = await subscriberService.createSubscriber();
    forthSubscriber = await subscriberService.createSubscriber();
    secondTopicSubscribers = [thirdSubscriber, forthSubscriber];
    bootstrapSecondTopic = await initializeTopic(secondTopicSubscribers, '2');
  });

  it('should call addBulk with correct parameters', async () => {
    const command: TriggerMulticastCommand = triggerMulticastCommandMock as any;

    const subscribers: ISubscribersDefine[] = [{ subscriberId: command.to[0] }];

    await triggerMulticast.execute(command);

    expect(addBulkStub.callCount).to.be.equal(1);

    const firstCallStubData = addBulkStub.getCall(0).args[0];
    const firstJobs = mapSubscribersToJobs(SubscriberSourceEnum.SINGLE, subscribers, command);

    expectBulkSingleSubscriberStub(firstCallStubData, firstJobs);
  });

  it('should send only single subscribers forward to processing', async () => {
    const singleSubscribers = firstTopicSubscribers;
    const command: TriggerMulticastCommand = buildTriggerMulticastCommandMock({
      to: singleSubscribers,
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      userId: session.user._id,
    }) as any;

    await triggerMulticast.execute(command);

    expect(addBulkStub.callCount).to.be.equal(1);

    const firstCallStubData = addBulkStub.getCall(0).args[0];
    const firstJobs = mapSubscribersToJobs(SubscriberSourceEnum.SINGLE, singleSubscribers, command);

    expectBulkSingleSubscriberStub(firstCallStubData, firstJobs);
  });

  it('should fan-out only subscriber from topic to processing', async () => {
    const firstTopic: TriggerRecipients = [bootstrapFirstTopic];
    const command: TriggerMulticastCommand = buildTriggerMulticastCommandMock({
      to: firstTopic,
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      userId: session.user._id,
    }) as any;

    await triggerMulticast.execute(command);

    expect(addBulkStub.callCount).to.be.equal(1);

    const firstCallStubData = addBulkStub.getCall(0).args[0];
    const firstJobs = mapSubscribersToJobs(SubscriberSourceEnum.TOPIC, firstTopicSubscribers, command);
    expectBulkTopicStub(firstCallStubData, firstJobs);
  });

  it('should send single subscribers and fan-out subscriber from topic forward to to processing', async () => {
    const singleSubscribers = secondTopicSubscribers;
    const firstTopic: TriggerRecipients = [bootstrapFirstTopic];
    const command: TriggerMulticastCommand = buildTriggerMulticastCommandMock({
      to: [...singleSubscribers, ...firstTopic],
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      userId: session.user._id,
    }) as any;

    await triggerMulticast.execute(command);

    expect(addBulkStub.callCount).to.be.equal(2);

    const firstCallStubData = addBulkStub.getCall(0).args[0];
    const firstJobs = mapSubscribersToJobs(SubscriberSourceEnum.SINGLE, singleSubscribers, command);

    expectBulkSingleSubscriberStub(firstCallStubData, firstJobs);

    const secondJobs = mapSubscribersToJobs(SubscriberSourceEnum.TOPIC, firstTopicSubscribers, command);
    const secondCallStubData: IProcessSubscriberBulkJobDto[] = addBulkStub.getCall(1).args[0];

    expectBulkTopicStub(secondCallStubData, secondJobs);
  });

  it('should exclude the actor from the topic fan-out', async () => {
    const actor = firstSubscriber;
    const firstTopic: TriggerRecipients = [bootstrapFirstTopic];
    const subscribersDefine = mapSubscriberToSubscriberDefine(firstTopicSubscribers);
    const command: TriggerMulticastCommand = buildTriggerMulticastCommandMock({
      to: [...firstTopic],
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      userId: session.user._id,
      actor,
    }) as any;

    await triggerMulticast.execute(command);

    expect(addBulkStub.callCount).to.be.equal(1);

    const topicSubscribersWithoutActor = subscribersDefine.filter(
      (subscriber) => subscriber.subscriberId !== actor.subscriberId
    );

    const firstCallStubData = addBulkStub.getCall(0).args[0];
    const firstJobs = mapSubscribersToJobs(SubscriberSourceEnum.TOPIC, topicSubscribersWithoutActor, command);

    expectBulkTopicStub(firstCallStubData, firstJobs);
  });

  it('should deduplicate single subscriber from topic fan-out', async () => {
    const singleSubscribers = firstTopicSubscribers;
    const newSubscriber = await subscriberService.createSubscriber();
    await addSubscribersToTopic(session, bootstrapFirstTopic, [newSubscriber]);

    /*
     * in this case we send the same subscriber twice,
     * but the newSubscriber that is not duplicated and should be sent only once by topic
     * singleSubscribers contains: A, B
     * firstTopic contains: A, B, newSubscriber
     */
    const firstTopic: TriggerRecipients = [bootstrapFirstTopic];
    const command: TriggerMulticastCommand = buildTriggerMulticastCommandMock({
      to: [...singleSubscribers, ...firstTopic],
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      userId: session.user._id,
    }) as any;

    await triggerMulticast.execute(command);

    expect(addBulkStub.callCount).to.be.equal(2);

    const firstCallStubData = addBulkStub.getCall(0).args[0];
    const firstJobs = mapSubscribersToJobs(SubscriberSourceEnum.SINGLE, singleSubscribers, command);
    expectBulkSingleSubscriberStub(firstCallStubData, firstJobs);

    const secondCallStubData = addBulkStub.getCall(1).args[0];
    const secondJobs = mapSubscribersToJobs(SubscriberSourceEnum.TOPIC, [newSubscriber], command);
    expectBulkTopicStub(secondCallStubData, secondJobs);
  });

  it('should deduplicate subscribers across topics', async () => {
    // first topic: subscribers A, B
    const firstTopic: TriggerRecipients = [bootstrapFirstTopic];

    // second topic: subscribers C, D
    const secondTopic: TriggerRecipients = [bootstrapSecondTopic];

    /*
     * add to second topic subscribers from first topic,
     * now second topic(A, B, C, D) contains duplication with first topic(A, B) subscribers
     */
    await addSubscribersToTopic(session, bootstrapSecondTopic, firstTopicSubscribers);

    /*
     * in this case we have the same subscriber twice,
     * firstTopic contains: A, B
     * secondTopic contains: A, B, C, D
     */
    const command: TriggerMulticastCommand = buildTriggerMulticastCommandMock({
      to: [...firstTopic, ...secondTopic],
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      userId: session.user._id,
    }) as any;

    await triggerMulticast.execute(command);

    expect(addBulkStub.callCount).to.be.equal(1);

    const firstCallStubData = addBulkStub.getCall(0).args[0];
    const firstJobs = mapSubscribersToJobs(
      SubscriberSourceEnum.TOPIC,
      [...firstTopicSubscribers, ...secondTopicSubscribers],
      command
    );
    expectBulkTopicStub(firstCallStubData, firstJobs);
  });

  it('should deduplicate subscribers across single subscribers and topics', async () => {
    const newSubscriber = await subscriberService.createSubscriber();
    await addSubscribersToTopic(session, bootstrapFirstTopic, [newSubscriber]);

    // first topic: subscribers A, B, newSubscriber
    const firstTopic: TriggerRecipients = [bootstrapFirstTopic];

    // second topic: subscribers C, D
    const secondTopic: TriggerRecipients = [bootstrapSecondTopic];

    /*
     * add to second topic subscribers from first topic,
     * now second topic(A, B, C, D) contains duplication with first topic(A, B) subscribers
     */
    await addSubscribersToTopic(session, bootstrapSecondTopic, firstTopicSubscribers);

    const singleSubscribers = firstTopicSubscribers;
    /*
     * in this case we have the same subscriber twice,
     * however, the newSubscriber is not duplicated and should be sent only once by topic
     * singleSubscribers contains: A, B
     * firstTopic contains: A, B, newSubscriber
     * secondTopic contains: A, B, C, D
     */
    const command: TriggerMulticastCommand = buildTriggerMulticastCommandMock({
      to: [...singleSubscribers, ...firstTopic, ...secondTopic],
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      userId: session.user._id,
    }) as any;

    await triggerMulticast.execute(command);

    expect(addBulkStub.callCount).to.be.equal(2);

    // we check by single subscribers (A, B)
    const firstCallStubData = addBulkStub.getCall(0).args[0];
    const firstJobs = mapSubscribersToJobs(SubscriberSourceEnum.SINGLE, singleSubscribers, command);
    expectBulkSingleSubscriberStub(firstCallStubData, firstJobs);

    // we check by second topic subscribers with newSubscriber (C, D, newSubscriber)
    const modifiedSecondTopicSubscribersDefine = mapSubscriberToSubscriberDefine([
      ...secondTopicSubscribers,
      newSubscriber,
    ]);
    const secondCallStubData = addBulkStub.getCall(1).args[0];
    const secondJobs = mapSubscribersToJobs(SubscriberSourceEnum.TOPIC, modifiedSecondTopicSubscribersDefine, command);

    expectBulkTopicStub(secondCallStubData, secondJobs);
  });

  it('should batch topic subscribers by 100', async () => {
    for (let i = 0; i < 234; i += 1) {
      const newSubscriber = await subscriberService.createSubscriber();
      await addSubscribersToTopic(session, bootstrapFirstTopic, [newSubscriber]);
    }

    // first topic: subscribers A, B
    const firstTopic: TriggerRecipients = [bootstrapFirstTopic];

    const command: TriggerMulticastCommand = buildTriggerMulticastCommandMock({
      to: [...firstTopic],
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      userId: session.user._id,
    }) as any;

    await triggerMulticast.execute(command);

    expect(addBulkStub.callCount).to.be.equal(3);

    const firstCallStubData: IProcessSubscriberBulkJobDto[] = addBulkStub.getCall(0).args[0];
    expect(firstCallStubData.length).to.equal(100);
    expect(firstCallStubData[0].data._subscriberSource).to.equal(SubscriberSourceEnum.TOPIC);

    const secondCallStubData: IProcessSubscriberBulkJobDto[] = addBulkStub.getCall(1).args[0];
    expect(secondCallStubData.length).to.equal(100);
    expect(secondCallStubData[0].data._subscriberSource).to.equal(SubscriberSourceEnum.TOPIC);

    const thirdCallStubData: IProcessSubscriberBulkJobDto[] = addBulkStub.getCall(2).args[0];
    expect(thirdCallStubData.length).to.equal(36);
    expect(thirdCallStubData[0].data._subscriberSource).to.equal(SubscriberSourceEnum.TOPIC);
  });
});

const getErrorMessage = async (callback) => {
  let res;

  try {
    res = await callback();
  } catch (error) {
    res = error.message;
  }

  return res;
};

type TriggerMulticastCommandOverrides = Partial<TriggerMulticastCommand> & {
  organizationId: string;
  environmentId: string;
};
const buildTriggerMulticastCommandMock = (overrides: TriggerMulticastCommandOverrides): TriggerMulticastCommand => {
  return { ...(triggerMulticastCommandMock as any), ...overrides };
};

const triggerMulticastCommandMock = {
  userId: '65ccfbfb374a4f35856d76ef',
  environmentId: '65ccfbfb374a4f35856d76f7',
  organizationId: '65ccfbfb374a4f35856d76f1',
  identifier: 'test-event-b0a06229-98d2-4a15-b062-10146d10ef53',
  payload: {
    customVar: 'Testing of User Name',
  },
  overrides: {},
  to: ['65ccfbfb374a4f35856d7754'],
  transactionId: '428fa85a-2529-4186-80ad-3bf29d365de2',
  addressingType: 'multicast',
  requestCategory: 'single',
  tenant: null,
  template: {
    preferenceSettings: {
      email: true,
      sms: true,
      in_app: true,
      chat: true,
      push: true,
    },
    _id: '65ccfbfb374a4f35856d775c',
    name: 'Central Assurance Analyst',
    description: 'The Nagasaki Lander is the trademarked name of several series of Nagasaki sport bikes, tha',
    active: true,
    draft: false,
    critical: false,
    isBlueprint: false,
    _notificationGroupId: '65ccfbfb374a4f35856d76fa',
    tags: ['test-tag'],
    triggers: [
      {
        type: 'event',
        identifier: 'test-event-b0a06229-98d2-4a15-b062-10146d10ef53',
        variables: [
          {
            name: 'firstName',
            _id: '65ccfbfb374a4f35856d775e',
            id: '65ccfbfb374a4f35856d775e',
          },
          {
            name: 'lastName',
            _id: '65ccfbfb374a4f35856d775f',
            id: '65ccfbfb374a4f35856d775f',
          },
          {
            name: 'urlVariable',
            _id: '65ccfbfb374a4f35856d7760',
            id: '65ccfbfb374a4f35856d7760',
          },
        ],
        _id: '65ccfbfb374a4f35856d775d',
        reservedVariables: [],
        subscriberVariables: [],
        id: '65ccfbfb374a4f35856d775d',
      },
    ],
    steps: [
      {
        metadata: {
          timed: {
            weekDays: [],
            monthDays: [],
          },
        },
        active: true,
        shouldStopOnFail: false,
        filters: [],
        _templateId: '65ccfbfb374a4f35856d775a',
        variants: [],
        _id: '65ccfbfb374a4f35856d7761',
        id: '65ccfbfb374a4f35856d7761',
        template: {
          _id: '65ccfbfb374a4f35856d775a',
          type: 'sms',
          active: true,
          variables: [],
          content: 'Hello world {{customVar}}',
          _environmentId: '65ccfbfb374a4f35856d76f7',
          _organizationId: '65ccfbfb374a4f35856d76f1',
          _creatorId: '65ccfbfb374a4f35856d76ef',
          _feedId: '65ccfbfb374a4f35856d7726',
          _layoutId: '65ccfbfb374a4f35856d76fc',
          deleted: false,
          createdAt: '2024-02-14T17:44:27.529Z',
          updatedAt: '2024-02-14T17:44:27.529Z',
          __v: 0,
          id: '65ccfbfb374a4f35856d775a',
        },
      },
    ],
    _environmentId: '65ccfbfb374a4f35856d76f7',
    _organizationId: '65ccfbfb374a4f35856d76f1',
    _creatorId: '65ccfbfb374a4f35856d76ef',
    deleted: false,
    createdAt: '2024-02-14T17:44:27.532Z',
    updatedAt: '2024-02-14T17:44:27.532Z',
    __v: 0,
    id: '65ccfbfb374a4f35856d775c',
  },
};

const addSubscribersToTopic = async (
  session: UserSession,
  createdTopicDto: ITopic,
  subscribers: SubscriberEntity[]
) => {
  const subscriberIds: ExternalSubscriberId[] = subscribers.map(
    (subscriber: SubscriberEntity) => subscriber.subscriberId
  );

  const response = await axiosInstance.post(
    `${session.serverUrl}${TOPIC_PATH}/${createdTopicDto.topicKey}/subscribers`,
    {
      subscribers: subscriberIds,
    },
    {
      headers: {
        authorization: `ApiKey ${session.apiKey}`,
      },
    }
  );

  expect(response.status).to.be.eq(200);
  expect(response.data.data.succeeded).to.have.deep.members(subscriberIds);
};


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - mapSubscriberToSubscriberDefine(firstTopicSubscribers: SubscriberEntity[])
 - expectBulkTopicStub(secondCallStubArgs: IProcessSubscriberBulkJobDto[], jobs: IProcessSubscriberBulkJobDto[])
 - expectBulkSingleSubscriberStub(secondCallStubArgs: IProcessSubscriberBulkJobDto[],
  jobs: IProcessSubscriberBulkJobDto[])
 - initializeTopic(subscribersToAdd: SubscriberEntity[], topicIndex: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - createTopic(async (
  session: UserSession,
  key: TopicKey,
  name: TopicName
): Promise<{ _id: TopicId; key: T...)
 - response(await initNovuClassSdk(session).topics.create({ key, name });

  expect(response.result.id).to.exist...)
 - job(jobs.find((xJob))
 - job(jobs.find((xJob))
 - addBulkStub(sinon.stub(subscriberProcessQueueService, 'addBulk');
  });

  afterEach(())
 - bootstrapSecondTopic(await initializeTopic(secondTopicSubscribers, '2');
  });

  it('should call addBulk with correct pa...)
 - firstJobs(mapSubscribersToJobs(SubscriberSourceEnum.SINGLE, subscribers, command);

    expectBulkSingleSubscr...)
 - firstJobs(mapSubscribersToJobs(SubscriberSourceEnum.SINGLE, singleSubscribers, command);

    expectBulkSingle...)
 - firstJobs(mapSubscribersToJobs(SubscriberSourceEnum.TOPIC, firstTopicSubscribers, command);
    expectBulkTopi...)
 - topicSubscribersWithoutActor(subscribersDefine.filter(
      (subscriber))
 - firstJobs(mapSubscribersToJobs(SubscriberSourceEnum.TOPIC, topicSubscribersWithoutActor, command);

    expect...)
 - secondJobs(mapSubscribersToJobs(SubscriberSourceEnum.TOPIC, [newSubscriber], command);
    expectBulkTopicStub(...)
 - firstJobs(mapSubscribersToJobs(
      SubscriberSourceEnum.TOPIC,
      [...firstTopicSubscribers, ...secondTo...)
 - secondJobs(mapSubscribersToJobs(SubscriberSourceEnum.TOPIC, modifiedSecondTopicSubscribersDefine, command);

  ...)
 - getErrorMessage(async (callback))
 - buildTriggerMulticastCommandMock(overrides: TriggerMulticastCommandOverrides): TriggerMulticastCommand)
 - addSubscribersToTopic(async (
  session: UserSession,
  createdTopicDto: ITopic,
  subscribers: SubscriberEntity[]
))
Declaraciones 'export' encontradas:
- export class MockSubscriberProcessQueueService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/trigger-event-topic.e2e.ts
TamaÃ±o: 22793 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import {
  SubscriberPayloadDto,
  TopicPayloadDto,
  TopicResponseDto,
  TriggerEventRequestDto,
  TriggerRecipientsTypeEnum,
} from '@novu/api/models/components';
import { MessageRepository, NotificationRepository, NotificationTemplateEntity, SubscriberEntity } from '@novu/dal';
import {
  ChannelTypeEnum,
  DigestTypeEnum,
  DigestUnitEnum,
  ExternalSubscriberId,
  IEmailBlock,
  StepTypeEnum,
  TopicKey,
  TopicName,
} from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Topic Trigger Event #novu-v2', () => {
  describe('Trigger event for a topic - /v1/events/trigger (POST)', () => {
    let session: UserSession;
    let template: NotificationTemplateEntity;
    let firstSubscriber: SubscriberEntity;
    let secondSubscriber: SubscriberEntity;
    let subscribers: SubscriberEntity[];
    let subscriberService: SubscribersService;
    let createdTopicDto: TopicResponseDto;
    let to: Array<TopicPayloadDto | SubscriberPayloadDto | string>;
    const notificationRepository = new NotificationRepository();
    const messageRepository = new MessageRepository();
    let novuClient: Novu;

    beforeEach(async () => {
      session = new UserSession();
      await session.initialize();

      template = await session.createTemplate();
      subscriberService = new SubscribersService(session.organization._id, session.environment._id);
      firstSubscriber = await subscriberService.createSubscriber();
      secondSubscriber = await subscriberService.createSubscriber();
      subscribers = [firstSubscriber, secondSubscriber];

      const topicKey = 'topic-key-trigger-event';
      const topicName = 'topic-name-trigger-event';
      createdTopicDto = await createTopic(session, topicKey, topicName);
      await addSubscribersToTopic(session, createdTopicDto, subscribers);
      to = [{ type: TriggerRecipientsTypeEnum.Topic, topicKey: createdTopicDto.key }];
      novuClient = initNovuClassSdk(session);
    });

    it('should trigger an event successfully', async () => {
      const response = await novuClient.trigger(buildTriggerRequestPayload(template, to));

      const body = response.result;

      expect(body).to.be.ok;
      expect(body.status).to.equal('processed');
      expect(body.acknowledged).to.equal(true);
      expect(body.transactionId).to.exist;
    });

    it('should generate message and notification based on event', async () => {
      const attachments = [
        {
          name: 'text1.txt',
          file: 'hello world!',
        },
        {
          name: 'text2.txt',
          file: Buffer.from('hello world!', 'utf-8'),
        },
      ];

      await novuClient.trigger(buildTriggerRequestPayload(template, to, attachments));

      await session.waitForJobCompletion(template._id);

      expect(subscribers.length).to.be.greaterThan(0);

      for (const subscriber of subscribers) {
        const notifications = await notificationRepository.findBySubscriberId(session.environment._id, subscriber._id);

        expect(notifications.length).to.equal(1);

        const notification = notifications[0];

        expect(notification._organizationId).to.equal(session.organization._id);
        expect(notification._templateId).to.equal(template._id);

        const messages = await messageRepository.findBySubscriberChannel(
          session.environment._id,
          subscriber._id,
          ChannelTypeEnum.IN_APP
        );

        expect(messages.length).to.equal(1);
        const message = messages[0];

        expect(message.channel).to.equal(ChannelTypeEnum.IN_APP);
        expect(message.content as string).to.equal('Test content for <b>Testing of User Name</b>');
        expect(message.seen).to.equal(false);
        expect(message.cta.data.url).to.equal('/cypress/test-shell/example/test?test-param=true');
        expect(message.lastSeenDate).to.be.not.ok;
        expect(message.payload.firstName).to.equal('Testing of User Name');
        expect(message.payload.urlVariable).to.equal('/test/url/path');
        expect(message.payload.attachments).to.be.not.ok;

        const emails = await messageRepository.findBySubscriberChannel(
          session.environment._id,
          subscriber._id,
          ChannelTypeEnum.EMAIL
        );

        expect(emails.length).to.equal(1);
        const email = emails[0];

        expect(email.channel).to.equal(ChannelTypeEnum.EMAIL);
        expect(Array.isArray(email.content)).to.be.ok;
        expect((email.content[0] as IEmailBlock).type).to.equal('text');
        expect((email.content[0] as IEmailBlock).content).to.equal(
          'This are the text contents of the template for Testing of User Name'
        );
      }
    });

    it('should exclude actor from topic events trigger', async () => {
      const actor = firstSubscriber;
      await novuClient.trigger({
        ...buildTriggerRequestPayload(template, to),
        actor: { subscriberId: actor.subscriberId },
      });

      await session.waitForJobCompletion(template._id);

      const actorNotifications = await notificationRepository.findBySubscriberId(session.environment._id, actor._id);
      expect(actorNotifications.length).to.equal(0);

      const actorMessages = await messageRepository.findBySubscriberChannel(
        session.environment._id,
        actor._id,
        ChannelTypeEnum.IN_APP
      );

      expect(actorMessages.length).to.equal(0);

      const actorEmails = await messageRepository.findBySubscriberChannel(
        session.environment._id,
        actor._id,
        ChannelTypeEnum.EMAIL
      );
      expect(actorEmails.length).to.equal(0);

      const secondSubscriberNotifications = await notificationRepository.findBySubscriberId(
        session.environment._id,
        secondSubscriber._id
      );

      expect(secondSubscriberNotifications.length).to.equal(1);

      const secondSubscriberMessages = await messageRepository.findBySubscriberChannel(
        session.environment._id,
        secondSubscriber._id,
        ChannelTypeEnum.IN_APP
      );

      expect(secondSubscriberMessages.length).to.equal(1);

      const secondSubscriberEmails = await messageRepository.findBySubscriberChannel(
        session.environment._id,
        secondSubscriber._id,
        ChannelTypeEnum.EMAIL
      );

      expect(secondSubscriberEmails.length).to.equal(1);
    });

    it('should exclude specific subscribers from topic using exclude array', async () => {
      const excludedSubscriber = firstSubscriber;
      const toWithExclude = [
        {
          type: TriggerRecipientsTypeEnum.Topic,
          topicKey: createdTopicDto.key,
          exclude: [excludedSubscriber.subscriberId],
        },
      ];

      await novuClient.trigger(buildTriggerRequestPayload(template, toWithExclude));

      await session.waitForJobCompletion(template._id);

      const excludedSubscriberNotifications = await notificationRepository.findBySubscriberId(
        session.environment._id,
        excludedSubscriber._id
      );
      expect(excludedSubscriberNotifications.length).to.equal(0);

      const excludedSubscriberMessages = await messageRepository.findBySubscriberChannel(
        session.environment._id,
        excludedSubscriber._id,
        ChannelTypeEnum.IN_APP
      );
      expect(excludedSubscriberMessages.length).to.equal(0);

      const excludedSubscriberEmails = await messageRepository.findBySubscriberChannel(
        session.environment._id,
        excludedSubscriber._id,
        ChannelTypeEnum.EMAIL
      );
      expect(excludedSubscriberEmails.length).to.equal(0);

      const secondSubscriberNotifications = await notificationRepository.findBySubscriberId(
        session.environment._id,
        secondSubscriber._id
      );
      expect(secondSubscriberNotifications.length).to.equal(1);

      const secondSubscriberMessages = await messageRepository.findBySubscriberChannel(
        session.environment._id,
        secondSubscriber._id,
        ChannelTypeEnum.IN_APP
      );
      expect(secondSubscriberMessages.length).to.equal(1);

      const secondSubscriberEmails = await messageRepository.findBySubscriberChannel(
        session.environment._id,
        secondSubscriber._id,
        ChannelTypeEnum.EMAIL
      );
      expect(secondSubscriberEmails.length).to.equal(1);
    });

    it('should exclude multiple subscribers from topic using exclude array', async () => {
      const toWithExclude = [
        {
          type: TriggerRecipientsTypeEnum.Topic,
          topicKey: createdTopicDto.key,
          exclude: [firstSubscriber.subscriberId, secondSubscriber.subscriberId],
        },
      ];

      await novuClient.trigger(buildTriggerRequestPayload(template, toWithExclude));

      await session.waitForJobCompletion(template._id);

      const firstSubscriberNotifications = await notificationRepository.findBySubscriberId(
        session.environment._id,
        firstSubscriber._id
      );
      expect(firstSubscriberNotifications.length).to.equal(0);

      const secondSubscriberNotifications = await notificationRepository.findBySubscriberId(
        session.environment._id,
        secondSubscriber._id
      );
      expect(secondSubscriberNotifications.length).to.equal(0);
    });

    it('should only exclude actor from topic, should send event if actor explicitly included', async () => {
      const actor = firstSubscriber;
      await novuClient.trigger({
        ...buildTriggerRequestPayload(template, [...to, actor.subscriberId]),
        actor: { subscriberId: actor.subscriberId },
      });

      await session.waitForJobCompletion(template._id);

      for (const subscriber of subscribers) {
        const notifications = await notificationRepository.findBySubscriberId(session.environment._id, subscriber._id);

        expect(notifications.length).to.equal(1);

        const notification = notifications[0];

        expect(notification._organizationId).to.equal(session.organization._id);
        expect(notification._templateId).to.equal(template._id);

        const messages = await messageRepository.findBySubscriberChannel(
          session.environment._id,
          subscriber._id,
          ChannelTypeEnum.IN_APP
        );

        expect(messages.length).to.equal(1);
        const message = messages[0];

        expect(message.channel).to.equal(ChannelTypeEnum.IN_APP);
        expect(message.content as string).to.equal('Test content for <b>Testing of User Name</b>');
        expect(message.seen).to.equal(false);
        expect(message.cta.data.url).to.equal('/cypress/test-shell/example/test?test-param=true');
        expect(message.lastSeenDate).to.be.not.ok;
        expect(message.payload.firstName).to.equal('Testing of User Name');
        expect(message.payload.urlVariable).to.equal('/test/url/path');
        expect(message.payload.attachments).to.be.not.ok;

        const emails = await messageRepository.findBySubscriberChannel(
          session.environment._id,
          subscriber._id,
          ChannelTypeEnum.EMAIL
        );

        expect(emails.length).to.equal(1);
        const email = emails[0];

        expect(email.channel).to.equal(ChannelTypeEnum.EMAIL);
        expect(Array.isArray(email.content)).to.be.ok;
        expect((email.content[0] as IEmailBlock).type).to.equal('text');
        expect((email.content[0] as IEmailBlock).content).to.equal(
          'This are the text contents of the template for Testing of User Name'
        );
      }
    });

    it('should trigger SMS notification', async () => {
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.SMS,
            content: 'Hello world {{customVar}}' as string,
          },
        ],
      });

      await novuClient.trigger(buildTriggerRequestPayload(template, to));

      await session.waitForJobCompletion(template._id);

      expect(subscribers.length).to.be.greaterThan(0);

      for (const subscriber of subscribers) {
        const message = await messageRepository._model.findOne({
          _environmentId: session.environment._id,
          _templateId: template._id,
          _subscriberId: subscriber._id,
          channel: ChannelTypeEnum.SMS,
        });

        expect(message?._subscriberId.toString()).to.be.eql(subscriber._id);
        expect(message?.phone).to.equal(subscriber.phone);
      }
    });
  });

  describe('Trigger event for multiple topics and multiple subscribers - /v1/events/trigger (POST)', () => {
    let session: UserSession;
    let template: NotificationTemplateEntity;
    let firstSubscriber: SubscriberEntity;
    let secondSubscriber: SubscriberEntity;
    let thirdSubscriber: SubscriberEntity;
    let fourthSubscriber: SubscriberEntity;
    let fifthSubscriber: SubscriberEntity;
    let sixthSubscriber: SubscriberEntity;
    let firstTopicSubscribers: SubscriberEntity[];
    let subscribers: SubscriberEntity[];
    let subscriberService: SubscribersService;
    let firstTopicDto: TopicResponseDto;
    let secondTopicDto: TopicResponseDto;
    let to: Array<TopicPayloadDto | SubscriberPayloadDto | string>;
    const notificationRepository = new NotificationRepository();
    const messageRepository = new MessageRepository();
    let novuClient: Novu;

    beforeEach(async () => {
      session = new UserSession();
      await session.initialize();

      template = await session.createTemplate();
      subscriberService = new SubscribersService(session.organization._id, session.environment._id);
      firstSubscriber = await subscriberService.createSubscriber();
      secondSubscriber = await subscriberService.createSubscriber();
      firstTopicSubscribers = [firstSubscriber, secondSubscriber];

      const firstTopicKey = 'topic-key-1-trigger-event';
      const firstTopicName = 'topic-name-1-trigger-event';
      firstTopicDto = await createTopic(session, firstTopicKey, firstTopicName);

      await addSubscribersToTopic(session, firstTopicDto, firstTopicSubscribers);

      thirdSubscriber = await subscriberService.createSubscriber();
      fourthSubscriber = await subscriberService.createSubscriber();
      const secondTopicSubscribers = [thirdSubscriber, fourthSubscriber];

      const secondTopicKey = 'topic-key-2-trigger-event';
      const secondTopicName = 'topic-name-2-trigger-event';
      secondTopicDto = await createTopic(session, secondTopicKey, secondTopicName);

      await addSubscribersToTopic(session, secondTopicDto, secondTopicSubscribers);

      fifthSubscriber = await subscriberService.createSubscriber();
      sixthSubscriber = await subscriberService.createSubscriber();

      subscribers = [
        firstSubscriber,
        secondSubscriber,
        thirdSubscriber,
        fourthSubscriber,
        fifthSubscriber,
        sixthSubscriber,
      ];
      to = [
        { type: TriggerRecipientsTypeEnum.Topic, topicKey: firstTopicDto.key },
        { type: TriggerRecipientsTypeEnum.Topic, topicKey: secondTopicDto.key },
        fifthSubscriber.subscriberId,
        {
          subscriberId: sixthSubscriber.subscriberId,
          firstName: 'Subscribers',
          lastName: 'Define',
          email: 'subscribers-define@email.novu',
        },
      ];
      novuClient = initNovuClassSdk(session);
    });

    it('should trigger an event successfully', async () => {
      const localTo = [...to, { type: TriggerRecipientsTypeEnum.Topic, topicKey: 'non-existing-topic-key' }];
      const response = await novuClient.trigger(buildTriggerRequestPayload(template, localTo));

      await session.waitForJobCompletion(template._id);

      const body = response.result;

      expect(body).to.be.ok;
      expect(body.status).to.equal('processed');
      expect(body.acknowledged).to.equal(true);
      expect(body.transactionId).to.exist;

      const messageCount = await messageRepository.count({
        _environmentId: session.environment._id,
        transactionId: body.transactionId,
      });

      expect(messageCount).to.equal(12);
    });

    it('should generate message and notification based on event', async () => {
      const attachments = [
        {
          name: 'text1.txt',
          file: 'hello world!',
        },
        {
          name: 'text2.txt',
          file: Buffer.from('hello world!', 'utf-8'),
        },
      ];

      await novuClient.trigger(buildTriggerRequestPayload(template, to, attachments));

      await session.waitForJobCompletion(template._id);
      expect(subscribers.length).to.be.greaterThan(0);

      for (const subscriber of subscribers) {
        const notifications = await notificationRepository.findBySubscriberId(session.environment._id, subscriber._id);

        expect(notifications.length).to.equal(1);

        const notification = notifications[0];

        expect(notification._organizationId).to.equal(session.organization._id);
        expect(notification._templateId).to.equal(template._id);

        const messages = await messageRepository.findBySubscriberChannel(
          session.environment._id,
          subscriber._id,
          ChannelTypeEnum.IN_APP
        );

        expect(messages.length).to.equal(1);
        const message = messages[0];

        expect(message.channel).to.equal(ChannelTypeEnum.IN_APP);
        expect(message.content as string).to.equal('Test content for <b>Testing of User Name</b>');
        expect(message.seen).to.equal(false);
        expect(message.cta.data.url).to.equal('/cypress/test-shell/example/test?test-param=true');
        expect(message.lastSeenDate).to.be.not.ok;
        expect(message.payload.firstName).to.equal('Testing of User Name');
        expect(message.payload.urlVariable).to.equal('/test/url/path');
        expect(message.payload.attachments).to.be.not.ok;

        const emails = await messageRepository.findBySubscriberChannel(
          session.environment._id,
          subscriber._id,
          ChannelTypeEnum.EMAIL
        );

        expect(emails.length).to.equal(1);
        const email = emails[0];

        expect(email.channel).to.equal(ChannelTypeEnum.EMAIL);
        expect(Array.isArray(email.content)).to.be.ok;
        expect((email.content[0] as IEmailBlock).type).to.equal('text');
        expect((email.content[0] as IEmailBlock).content).to.equal(
          'This are the text contents of the template for Testing of User Name'
        );
      }
    });

    it('should trigger SMS notification', async () => {
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.SMS,
            content: 'Hello world {{customVar}}' as string,
          },
        ],
      });

      await novuClient.trigger(buildTriggerRequestPayload(template, to));

      await session.waitForJobCompletion(template._id);

      expect(subscribers.length).to.be.greaterThan(0);

      for (const subscriber of subscribers) {
        const message = await messageRepository._model.findOne({
          _environmentId: session.environment._id,
          _templateId: template._id,
          _subscriberId: subscriber._id,
          channel: ChannelTypeEnum.SMS,
        });

        expect(message?._subscriberId.toString()).to.be.eql(subscriber._id);
        expect(message?.phone).to.equal(subscriber.phone);
      }
    });

    it('should not contain events from a different digestKey ', async () => {
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.DIGEST,
            content: '',
            metadata: {
              unit: DigestUnitEnum.SECONDS,
              amount: 1,
              digestKey: 'id',
              type: DigestTypeEnum.REGULAR,
            },
          },
          {
            type: StepTypeEnum.IN_APP,
            content: '{{#each step.events}}{{id}} {{/each}}' as string,
          },
        ],
      });
      const toFirstTopic = [{ type: TriggerRecipientsTypeEnum.Topic, topicKey: firstTopicDto.key }];

      await triggerEvent(session, template, toFirstTopic, {
        id: 'key-1',
      });
      await triggerEvent(session, template, toFirstTopic, {
        id: 'key-1',
      });
      await triggerEvent(session, template, toFirstTopic, {
        id: 'key-1',
      });
      await triggerEvent(session, template, toFirstTopic, {
        id: 'key-2',
      });
      await triggerEvent(session, template, toFirstTopic, {
        id: 'key-2',
      });
      await triggerEvent(session, template, toFirstTopic, {
        id: 'key-2',
      });

      await session.waitForJobCompletion(template._id);

      for (const subscriber of firstTopicSubscribers) {
        const messages = await messageRepository.findBySubscriberChannel(
          session.environment._id,
          subscriber._id,
          ChannelTypeEnum.IN_APP
        );
        expect(messages.length).to.equal(2);
        for (const message of messages) {
          const digestKey = message.payload.id;
          expect(message.content).to.equal(`${digestKey} ${digestKey} ${digestKey} `);
        }
      }
    });
  });
});

const createTopic = async (session: UserSession, key: TopicKey, name: TopicName): Promise<TopicResponseDto> => {
  const response = await initNovuClassSdk(session).topics.create({ key, name });

  expect(response.result.id).to.exist;
  expect(response.result.key).to.eql(key);

  return response.result;
};

const addSubscribersToTopic = async (
  session: UserSession,
  createdTopicDto: TopicResponseDto,
  subscribers: SubscriberEntity[]
) => {
  const subscriberIds: ExternalSubscriberId[] = subscribers.map(
    (subscriber: SubscriberEntity) => subscriber.subscriberId
  );

  const response = await initNovuClassSdk(session).topics.subscriptions.create(
    {
      subscriberIds,
    },
    createdTopicDto.key
  );

  expect(response.result.data).to.be.ok;
};

const buildTriggerRequestPayload = (
  template: NotificationTemplateEntity,
  to: (string | TopicPayloadDto | SubscriberPayloadDto)[],
  attachments?: Record<string, unknown>[]
): TriggerEventRequestDto => {
  return {
    workflowId: template.triggers[0].identifier,
    to,
    payload: {
      firstName: 'Testing of User Name',
      urlVariable: '/test/url/path',
      ...(attachments && { attachments }),
    },
  };
};

const triggerEvent = async (
  session: UserSession,
  template: NotificationTemplateEntity,
  to: (string | TopicPayloadDto | SubscriberPayloadDto)[],
  payload: Record<string, unknown> = {}
): Promise<void> => {
  await initNovuClassSdk(session).trigger({
    workflowId: template.triggers[0].identifier,
    to,
    payload,
  });
};


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - messageRepository(new MessageRepository();
    let novuClient: Novu;

    beforeEach(async ())
 - novuClient(initNovuClassSdk(session);
    });

    it('should trigger an event successfully', async ())
 - body(response.result;

      expect(body).to.be.ok;
      expect(body.status).to.equal('processed');
    ...)
 - email(emails[0];

        expect(email.channel).to.equal(ChannelTypeEnum.EMAIL);
        expect(Array.isAr...)
 - secondSubscriberEmails(await messageRepository.findBySubscriberChannel(
        session.environment._id,
        secondSubs...)
 - secondSubscriberEmails(await messageRepository.findBySubscriberChannel(
        session.environment._id,
        secondSubs...)
 - secondSubscriberNotifications(await notificationRepository.findBySubscriberId(
        session.environment._id,
        secondSubs...)
 - email(emails[0];

        expect(email.channel).to.equal(ChannelTypeEnum.EMAIL);
        expect(Array.isAr...)
 - message(await messageRepository._model.findOne({
          _environmentId: session.environment._id,
        ...)
 - messageRepository(new MessageRepository();
    let novuClient: Novu;

    beforeEach(async ())
 - novuClient(initNovuClassSdk(session);
    });

    it('should trigger an event successfully', async ())
 - messageCount(await messageRepository.count({
        _environmentId: session.environment._id,
        transaction...)
 - email(emails[0];

        expect(email.channel).to.equal(ChannelTypeEnum.EMAIL);
        expect(Array.isAr...)
 - message(await messageRepository._model.findOne({
          _environmentId: session.environment._id,
        ...)
 - createTopic(async (session: UserSession, key: TopicKey, name: TopicName): Promise<TopicResponseDto>)
 - addSubscribersToTopic(async (
  session: UserSession,
  createdTopicDto: TopicResponseDto,
  subscribers: SubscriberEntity...)
 - buildTriggerRequestPayload(template: NotificationTemplateEntity,
  to: (string | TopicPayloadDto | SubscriberPayloadDto)[],
  a...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/trigger-event.e2e.ts
TamaÃ±o: 146462 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { CreateIntegrationRequestDto, TriggerEventResponseDto } from '@novu/api/models/components';
import { SubscriberPayloadDto } from '@novu/api/src/models/components/subscriberpayloaddto';
import { DetailEnum } from '@novu/application-generic';
import {
  CommunityOrganizationRepository,
  EnvironmentRepository,
  ExecutionDetailsRepository,
  IntegrationRepository,
  JobRepository,
  JobStatusEnum,
  MessageRepository,
  NotificationRepository,
  NotificationTemplateEntity,
  NotificationTemplateRepository,
  SubscriberEntity,
  SubscriberRepository,
  TenantRepository,
} from '@novu/dal';
import {
  ActorTypeEnum,
  ApiServiceLevelEnum,
  ChannelTypeEnum,
  ChatProviderIdEnum,
  CreateWorkflowDto,
  DelayTypeEnum,
  DigestUnitEnum,
  EmailBlockTypeEnum,
  EmailProviderIdEnum,
  ExecutionDetailsStatusEnum,
  FieldLogicalOperatorEnum,
  FieldOperatorEnum,
  FilterPartTypeEnum,
  IEmailBlock,
  InAppProviderIdEnum,
  PreviousStepTypeEnum,
  SmsProviderIdEnum,
  StepTypeEnum,
  SystemAvatarIconEnum,
  TemplateVariableTypeEnum,
  WorkflowCreationSourceEnum,
  WorkflowResponseDto,
} from '@novu/shared';
import { EmailEventStatusEnum } from '@novu/stateless';
import { SubscribersService, UserSession, WorkflowOverrideService } from '@novu/testing';
import { expect } from 'chai';
import { v4 as uuid } from 'uuid';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';
import { createTenant } from '../../tenant/e2e/create-tenant.e2e';
import { pollForJobStatusChange } from './utils/poll-for-job-status-change.util';
import { sleep } from './utils/sleep.util';

const promiseTimeout = (ms: number): Promise<void> =>
  new Promise((resolve) => {
    setTimeout(resolve, ms);
  });

describe('Trigger event - /v1/events/trigger (POST) #novu-v2', () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;
  let workflowOverrideService: WorkflowOverrideService;
  const notificationRepository = new NotificationRepository();
  const notificationTemplateRepository = new NotificationTemplateRepository();
  const messageRepository = new MessageRepository();
  const subscriberRepository = new SubscriberRepository();
  const integrationRepository = new IntegrationRepository();
  const jobRepository = new JobRepository();
  const executionDetailsRepository = new ExecutionDetailsRepository();
  const environmentRepository = new EnvironmentRepository();
  const tenantRepository = new TenantRepository();
  let novuClient: Novu;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    template = await session.createTemplate();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
    workflowOverrideService = new WorkflowOverrideService({
      organizationId: session.organization._id,
      environmentId: session.environment._id,
    });
    novuClient = initNovuClassSdk(session);
  });

  describe(`Trigger Event - /v1/events/trigger (POST)`, () => {
    it('should filter delay step', async () => {
      const firstStepUuid = uuid();
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.EMAIL,
            name: 'Message Name',
            subject: 'Test email subject',
            content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
            uuid: firstStepUuid,
          },
          {
            type: StepTypeEnum.DELAY,
            content: '',
            metadata: {
              unit: DigestUnitEnum.SECONDS,
              amount: 2,
              type: DelayTypeEnum.REGULAR,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    on: FilterPartTypeEnum.PAYLOAD,
                    operator: FieldOperatorEnum.IS_DEFINED,
                    field: 'exclude',
                    value: '',
                  },
                ],
              },
            ],
          },
          {
            type: StepTypeEnum.EMAIL,
            name: 'Message Name',
            subject: 'Test email subject',
            content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
          },
        ],
      });

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {
          customVar: 'Testing of User Name',
        },
      });

      await session.waitForJobCompletion(template._id);

      const messagesAfter = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.EMAIL,
      });

      expect(messagesAfter.length).to.equal(2);

      const executionDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _notificationTemplateId: template?._id,
        channel: StepTypeEnum.DELAY,
        detail: DetailEnum.SKIPPED_STEP_BY_CONDITIONS,
      });

      expect(executionDetails.length).to.equal(1);
    });

    it('should filter a delay that is the first step in the workflow', async () => {
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.DELAY,
            content: '',
            metadata: {
              unit: DigestUnitEnum.SECONDS,
              amount: 2,
              type: DelayTypeEnum.REGULAR,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    on: FilterPartTypeEnum.PAYLOAD,
                    operator: FieldOperatorEnum.IS_DEFINED,
                    field: 'exclude',
                    value: '',
                  },
                ],
              },
            ],
          },
          {
            type: StepTypeEnum.EMAIL,
            name: 'Message Name',
            subject: 'Test email subject',
            content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
          },
        ],
      });

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {
          customVar: 'Testing of User Name',
        },
      });

      await session.waitForJobCompletion(template._id);

      const messagesAfter = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.EMAIL,
      });

      expect(messagesAfter.length).to.equal(1);

      const executionDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _notificationTemplateId: template?._id,
        channel: StepTypeEnum.DELAY,
        detail: DetailEnum.SKIPPED_STEP_BY_CONDITIONS,
      });

      expect(executionDetails.length).to.equal(1);
    });

    it('should filter digest step', async () => {
      const firstStepUuid = uuid();
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.EMAIL,
            name: 'Message Name',
            subject: 'Test email subject',
            content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
            uuid: firstStepUuid,
          },
          {
            type: StepTypeEnum.DIGEST,
            content: '',
            metadata: {
              unit: DigestUnitEnum.SECONDS,
              amount: 2,
              type: DelayTypeEnum.REGULAR,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    on: FilterPartTypeEnum.PAYLOAD,
                    operator: FieldOperatorEnum.IS_DEFINED,
                    field: 'exclude',
                    value: '',
                  },
                ],
              },
            ],
          },
          {
            type: StepTypeEnum.EMAIL,
            name: 'Message Name',
            subject: 'Test email subject',
            content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
          },
        ],
      });

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {
          customVar: 'Testing of User Name',
        },
      });

      await session.waitForJobCompletion(template._id);

      const messagesAfter = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.EMAIL,
      });

      expect(messagesAfter.length).to.equal(2);

      const executionDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _notificationTemplateId: template?._id,
        channel: StepTypeEnum.DIGEST,
        detail: DetailEnum.SKIPPED_STEP_BY_CONDITIONS,
      });

      expect(executionDetails.length).to.equal(1);
    });

    it('should filter multiple digest steps', async () => {
      const firstStepUuid = uuid();
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.EMAIL,
            name: 'Message Name',
            subject: 'Test email subject',
            content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
            uuid: firstStepUuid,
          },
          {
            type: StepTypeEnum.DIGEST,
            content: '',
            metadata: {
              unit: DigestUnitEnum.SECONDS,
              amount: 2,
              type: DelayTypeEnum.REGULAR,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    field: 'digest_type',
                    value: '1',
                    operator: FieldOperatorEnum.EQUAL,
                    on: FilterPartTypeEnum.PAYLOAD,
                  },
                ],
              },
            ],
          },
          {
            type: StepTypeEnum.DIGEST,
            content: '',
            metadata: {
              unit: DigestUnitEnum.SECONDS,
              amount: 2,
              type: DelayTypeEnum.REGULAR,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    field: 'digest_type',
                    value: '2',
                    operator: FieldOperatorEnum.EQUAL,
                    on: FilterPartTypeEnum.PAYLOAD,
                  },
                ],
              },
            ],
          },
          {
            type: StepTypeEnum.DIGEST,
            content: '',
            metadata: {
              unit: DigestUnitEnum.SECONDS,
              amount: 2,
              type: DelayTypeEnum.REGULAR,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    field: 'digest_type',
                    value: '3',
                    operator: FieldOperatorEnum.EQUAL,
                    on: FilterPartTypeEnum.PAYLOAD,
                  },
                ],
              },
            ],
          },
          {
            type: StepTypeEnum.EMAIL,
            name: 'Message Name',
            subject: 'Test email subject',
            content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
          },
        ],
      });

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {
          customVar: 'Testing of User Name',
          digest_type: '2',
        },
      });

      await session.waitForJobCompletion(template._id);

      const messagesAfter = await messageRepository.find({
        _environmentId: session.environment._id,
        _templateId: template?._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.EMAIL,
      });

      expect(messagesAfter.length).to.equal(2);

      const executionDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _notificationTemplateId: template?._id,
        channel: StepTypeEnum.DIGEST,
        detail: DetailEnum.SKIPPED_STEP_BY_CONDITIONS,
      });

      expect(executionDetails.length).to.equal(2);
    });

    it('should not filter digest step', async () => {
      const firstStepUuid = uuid();
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.EMAIL,
            name: 'Message Name',
            subject: 'Test email subject',
            content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
            uuid: firstStepUuid,
          },
          {
            type: StepTypeEnum.DIGEST,
            content: '',
            metadata: {
              unit: DigestUnitEnum.SECONDS,
              amount: 2,
              type: DelayTypeEnum.REGULAR,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    on: FilterPartTypeEnum.PAYLOAD,
                    operator: FieldOperatorEnum.IS_DEFINED,
                    field: 'exclude',
                    value: '',
                  },
                ],
              },
            ],
          },
          {
            type: StepTypeEnum.EMAIL,
            name: 'Message Name',
            subject: 'Test email subject',
            content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
          },
        ],
      });

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {
          customVar: 'Testing of User Name',
          exclude: false,
        },
      });

      await session.waitForJobCompletion(template._id);

      const messagesAfter = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.EMAIL,
      });

      expect(messagesAfter.length).to.equal(2);

      const executionDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _notificationTemplateId: template?._id,
        channel: StepTypeEnum.DIGEST,
        detail: DetailEnum.SKIPPED_STEP_BY_CONDITIONS,
      });

      expect(executionDetails.length).to.equal(0);
    });

    it('should digest events with filters', async () => {
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.DIGEST,
            content: '',
            metadata: {
              unit: DigestUnitEnum.SECONDS,
              amount: 2,
              type: DelayTypeEnum.REGULAR,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    on: FilterPartTypeEnum.PAYLOAD,
                    operator: FieldOperatorEnum.IS_DEFINED,
                    field: 'exclude',
                    value: '',
                  },
                ],
              },
            ],
          },
          {
            type: StepTypeEnum.SMS,
            content: 'total digested: {{step.total_count}}',
          },
        ],
      });

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {
          exclude: false,
        },
      });
      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {
          exclude: false,
        },
      });

      await session.waitForJobCompletion(template._id);

      const messagesAfter = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.SMS,
      });

      expect(messagesAfter.length).to.equal(1);
      expect(messagesAfter && messagesAfter[0].content).to.include('total digested: 2');

      const executionDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _notificationTemplateId: template?._id,
        channel: StepTypeEnum.DIGEST,
        detail: DetailEnum.SKIPPED_STEP_BY_CONDITIONS,
      });

      expect(executionDetails.length).to.equal(0);
    });

    // TODO: Fix this test
    it.skip('should not aggregate a filtered digest into a non filtered digest', async () => {
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.DIGEST,
            content: '',
            metadata: {
              unit: DigestUnitEnum.SECONDS,
              amount: 2,
              type: DelayTypeEnum.REGULAR,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    on: FilterPartTypeEnum.PAYLOAD,
                    operator: FieldOperatorEnum.IS_DEFINED,
                    field: 'exclude',
                    value: '',
                  },
                ],
              },
            ],
          },
          {
            type: StepTypeEnum.SMS,
            content: 'total digested: {{step.total_count}}',
          },
        ],
      });

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {
          exclude: false,
        },
      });
      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {},
      });

      await session.waitForJobCompletion(template._id);

      const messagesAfter = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.SMS,
      });

      expect(messagesAfter.length).to.equal(2);
      expect(messagesAfter && messagesAfter[0].content).to.include('total digested: 1');
      expect(messagesAfter && messagesAfter[1].content).to.include('total digested: 0');

      const executionDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _notificationTemplateId: template?._id,
        channel: StepTypeEnum.DIGEST,
        detail: DetailEnum.SKIPPED_STEP_BY_CONDITIONS,
      });

      expect(executionDetails.length).to.equal(1);
    });

    it('should not filter delay step', async () => {
      const firstStepUuid = uuid();
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.EMAIL,
            name: 'Message Name',
            subject: 'Test email subject',
            content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
            uuid: firstStepUuid,
          },
          {
            type: StepTypeEnum.DELAY,
            content: '',
            metadata: {
              unit: DigestUnitEnum.SECONDS,
              amount: 2,
              type: DelayTypeEnum.REGULAR,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    on: FilterPartTypeEnum.PAYLOAD,
                    operator: FieldOperatorEnum.IS_DEFINED,
                    field: 'exclude',
                    value: '',
                  },
                ],
              },
            ],
          },
          {
            type: StepTypeEnum.EMAIL,
            name: 'Message Name',
            subject: 'Test email subject',
            content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
          },
        ],
      });

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {
          customVar: 'Testing of User Name',
          exclude: false,
        },
      });

      await session.waitForJobCompletion(template._id);

      const messagesAfter = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: StepTypeEnum.EMAIL,
      });

      expect(messagesAfter.length).to.equal(2);

      const executionDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _notificationTemplateId: template?._id,
        channel: StepTypeEnum.DELAY,
        detail: DetailEnum.SKIPPED_STEP_BY_CONDITIONS,
      });

      expect(executionDetails.length).to.equal(0);
    });

    it('should use conditions to select integration', async () => {
      const payload = {
        providerId: EmailProviderIdEnum.Mailgun,
        channel: 'email',
        credentials: { apiKey: '123', secretKey: 'abc' },
        _environmentId: session.environment._id,
        conditions: [
          {
            children: [{ field: 'identifier', value: 'test', operator: FieldOperatorEnum.EQUAL, on: 'tenant' }],
          },
        ],
        active: true,
        check: false,
      };

      await session.testAgent.post('/v1/integrations').send(payload);

      template = await createTemplate(session, ChannelTypeEnum.EMAIL);

      await createTenant({ session, identifier: 'test', name: 'test' });

      await sendTrigger(template, subscriber.subscriberId, {}, {}, 'test');

      await session.waitForJobCompletion(template._id);

      const createdSubscriber = await subscriberRepository.findBySubscriberId(
        session.environment._id,
        subscriber.subscriberId
      );

      const message = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: createdSubscriber?._id,
        channel: ChannelTypeEnum.EMAIL,
      });

      expect(message?.providerId).to.equal(payload.providerId);
    });

    it('should use or conditions to select integration', async () => {
      const payload = {
        providerId: EmailProviderIdEnum.Mailgun,
        channel: 'email',
        credentials: { apiKey: '123', secretKey: 'abc' },
        _environmentId: session.environment._id,
        conditions: [
          {
            value: FieldLogicalOperatorEnum.OR,
            children: [
              { field: 'identifier', value: 'test3', operator: FieldOperatorEnum.EQUAL, on: 'tenant' },
              { field: 'identifier', value: 'test2', operator: FieldOperatorEnum.EQUAL, on: 'tenant' },
            ],
          },
        ],
        active: true,
        check: false,
      };

      await session.testAgent.post('/v1/integrations').send(payload);

      template = await createTemplate(session, ChannelTypeEnum.EMAIL);

      await createTenant({ session, identifier: 'test3', name: 'test3' });
      await createTenant({ session, identifier: 'test2', name: 'test2' });

      await sendTrigger(template, subscriber.subscriberId, {}, {}, 'test3');

      await session.waitForJobCompletion(template._id);

      const createdSubscriber = await subscriberRepository.findBySubscriberId(
        session.environment._id,
        subscriber.subscriberId
      );

      const firstMessage = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: createdSubscriber?._id,
        channel: ChannelTypeEnum.EMAIL,
      });

      expect(firstMessage?.providerId).to.equal(payload.providerId);

      await sendTrigger(template, subscriber.subscriberId, {}, {}, 'test2');

      await session.waitForJobCompletion(template._id);

      const secondMessage = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: createdSubscriber?._id,
        channel: ChannelTypeEnum.EMAIL,
        _id: {
          $ne: firstMessage?._id,
        },
      });

      expect(secondMessage?.providerId).to.equal(payload.providerId);
      expect(firstMessage?._id).to.not.equal(secondMessage?._id);
    });

    it('should return correct status when using a non existing tenant', async () => {
      const payload = {
        providerId: EmailProviderIdEnum.Mailgun,
        channel: 'email',
        credentials: { apiKey: '123', secretKey: 'abc' },
        _environmentId: session.environment._id,
        conditions: [
          {
            children: [{ field: 'identifier', value: 'test1', operator: FieldOperatorEnum.EQUAL, on: 'tenant' }],
          },
        ],
        active: true,
        check: false,
      };

      await session.testAgent.post('/v1/integrations').send(payload);

      template = await createTemplate(session, ChannelTypeEnum.EMAIL);

      const result = await sendTrigger(template, subscriber.subscriberId, {}, {}, 'test1');

      expect(result.status).to.equal('no_tenant_found');
    });

    it('should trigger an event successfully', async () => {
      const response = await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {
          firstName: 'Testing of User Name',
          urlVariable: '/test/url/path',
        },
      });

      const body = response.result;

      expect(body).to.be.ok;
      expect(body.status).to.equal('processed');
      expect(body.acknowledged).to.equal(true);
    });

    it('should store jobs & message provider id successfully', async () => {
      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
      });

      await session.waitForJobCompletion(template._id);

      const message = await messageRepository.find({
        _environmentId: session.environment._id,
        _templateId: template._id,
        _subscriberId: subscriber._id,
      });

      const inAppMessage = message.find((msg) => msg.channel === ChannelTypeEnum.IN_APP);
      const emailMessage = message.find((msg) => msg.channel === ChannelTypeEnum.EMAIL);

      expect(inAppMessage?.providerId).to.equal(InAppProviderIdEnum.Novu);
      expect(emailMessage?.providerId).to.equal(EmailProviderIdEnum.SendGrid);

      const inAppJob = await jobRepository.findOne({
        _id: inAppMessage?._jobId,
        _environmentId: session.environment._id,
      });
      const emailJob = await jobRepository.findOne({
        _id: emailMessage?._jobId,
        _environmentId: session.environment._id,
      });

      expect(inAppJob?.providerId).to.equal(InAppProviderIdEnum.Novu);
      expect(emailJob?.providerId).to.equal(EmailProviderIdEnum.SendGrid);
    });

    it('should create a subscriber based on event', async () => {
      const subscriberId = SubscriberRepository.createObjectId();
      const payload: SubscriberPayloadDto = {
        subscriberId,
        firstName: 'Test Name',
        lastName: 'Last of name',
        email: 'test@email.novu',
        locale: 'en',
        data: { custom1: 'custom value1', custom2: 'custom value2' },
      };
      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [payload],
        payload: {
          urlVar: '/test/url/path',
        },
      });

      await session.waitForJobCompletion();
      const envId = session.environment._id;
      const createdSubscriber = await subscriberRepository.findBySubscriberId(envId, subscriberId);

      expect(createdSubscriber?.subscriberId).to.equal(subscriberId);
      expect(createdSubscriber?.firstName).to.equal(payload.firstName);
      expect(createdSubscriber?.lastName).to.equal(payload.lastName);
      expect(createdSubscriber?.email).to.equal(payload.email);
      expect(createdSubscriber?.locale).to.equal(payload.locale);
      expect(createdSubscriber?.data).to.deep.equal(payload.data);
    });

    it('should update a subscribers email if one dont exists', async () => {
      const subscriberId = SubscriberRepository.createObjectId();
      const payload = {
        subscriberId,
        firstName: 'Test Name',
        lastName: 'Last of name',
        email: undefined,
        locale: 'en',
      };

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [
          {
            ...payload,
          },
        ],
        payload: {
          urlVar: '/test/url/path',
        },
      });

      await session.waitForJobCompletion();
      const createdSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);

      expect(createdSubscriber?.subscriberId).to.equal(subscriberId);
      expect(createdSubscriber?.firstName).to.equal(payload.firstName);
      expect(createdSubscriber?.lastName).to.equal(payload.lastName);
      expect(createdSubscriber?.email).to.equal(payload.email);
      expect(createdSubscriber?.locale).to.equal(payload.locale);

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [
          {
            ...payload,
            email: 'hello@world.com',
          },
        ],
        payload: {
          urlVar: '/test/url/path',
        },
      });

      await session.waitForJobCompletion();

      const updatedSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);

      expect(updatedSubscriber?.subscriberId).to.equal(subscriberId);
      expect(updatedSubscriber?.firstName).to.equal(payload.firstName);
      expect(updatedSubscriber?.lastName).to.equal(payload.lastName);
      expect(updatedSubscriber?.email).to.equal('hello@world.com');
      expect(updatedSubscriber?.locale).to.equal(payload.locale);
    });

    describe('Subscriber channels', () => {
      it('should set a new subscriber with channels array', async () => {
        const subscriberId = SubscriberRepository.createObjectId();
        const payload: SubscriberPayloadDto = {
          subscriberId,
          firstName: 'Test Name',
          lastName: 'Last of name',
          locale: 'en',
          channels: [
            {
              providerId: ChatProviderIdEnum.Slack,
              credentials: {
                webhookUrl: 'https://slack.com/webhook/test',
                deviceTokens: ['1', '2'],
              },
            },
          ],
        };

        await novuClient.trigger({
          workflowId: template.triggers[0].identifier,
          to: [payload],
          payload: {
            urlVar: '/test/url/path',
          },
        });

        await session.waitForJobCompletion();

        const createdSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);

        expect(createdSubscriber?.channels?.length).to.equal(1);
        if (createdSubscriber?.channels?.length !== 1) {
          throw new Error('need to have 1 channel');
        }
        expect(createdSubscriber?.channels[0]?.providerId).to.equal(ChatProviderIdEnum.Slack);
        const credentials = createdSubscriber?.channels[0]?.credentials;
        expect(credentials).to.be.ok;
        if (!credentials) {
          throw new Error('must have credentials');
        }
        expect(credentials.webhookUrl).to.equal('https://slack.com/webhook/test');
        const { deviceTokens } = credentials;
        expect(deviceTokens).to.be.ok;
        if (!deviceTokens) {
          throw new Error('');
        }
        expect(deviceTokens?.length).to.equal(2);
      });

      it('should update a subscribers channels array', async () => {
        const subscriberId = SubscriberRepository.createObjectId();
        const payload: SubscriberPayloadDto = {
          subscriberId,
          firstName: 'Test Name',
          lastName: 'Last of name',
          email: undefined,
          locale: 'en',
          channels: [
            {
              providerId: ChatProviderIdEnum.Slack,
              credentials: {
                webhookUrl: 'https://slack.com/webhook/test',
              },
            },
          ],
        };

        await novuClient.trigger({
          workflowId: template.triggers[0].identifier,
          to: [
            {
              ...payload,
            },
          ],
          payload: {
            urlVar: '/test/url/path',
          },
        });

        await session.waitForJobCompletion();
        const createdSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);

        expect(createdSubscriber?.subscriberId).to.equal(subscriberId);
        expect(createdSubscriber?.channels?.length).to.equal(1);

        await novuClient.trigger({
          workflowId: template.triggers[0].identifier,
          to: [
            {
              ...payload,
              channels: [
                {
                  providerId: ChatProviderIdEnum.Slack,
                  credentials: {
                    webhookUrl: 'https://slack.com/webhook/test2',
                  },
                },
              ],
            },
          ],
          payload: {
            urlVar: '/test/url/path',
          },
        });

        await session.waitForJobCompletion();

        const updatedSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);

        expect(updatedSubscriber?.channels?.length).to.equal(1);
        if (!updatedSubscriber?.channels?.length) {
          throw new Error('Channels must be an array');
        }
        expect(updatedSubscriber?.channels[0]?.providerId).to.equal(ChatProviderIdEnum.Slack);
        expect(updatedSubscriber?.channels[0]?.credentials?.webhookUrl).to.equal('https://slack.com/webhook/test2');
      });
    });

    it('should not unset a subscriber email', async () => {
      const subscriberId = SubscriberRepository.createObjectId();
      const payload = {
        subscriberId,
        firstName: 'Test Name',
        lastName: 'Last of name',
        email: 'hello@world.com',
        locale: 'en',
      };

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [
          {
            ...payload,
          },
        ],
        payload: {
          urlVar: '/test/url/path',
        },
      });

      await session.waitForJobCompletion();
      const createdSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);

      expect(createdSubscriber?.subscriberId).to.equal(subscriberId);
      expect(createdSubscriber?.firstName).to.equal(payload.firstName);
      expect(createdSubscriber?.lastName).to.equal(payload.lastName);
      expect(createdSubscriber?.email).to.equal(payload.email);
      expect(createdSubscriber?.locale).to.equal(payload.locale);

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [
          {
            ...payload,
            email: undefined,
          },
        ],
        payload: {
          urlVar: '/test/url/path',
        },
      });

      await session.waitForJobCompletion();

      const updatedSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);

      expect(updatedSubscriber?.subscriberId).to.equal(subscriberId);
      expect(updatedSubscriber?.firstName).to.equal(payload.firstName);
      expect(updatedSubscriber?.lastName).to.equal(payload.lastName);
      expect(updatedSubscriber?.email).to.equal('hello@world.com');
      expect(updatedSubscriber?.locale).to.equal(payload.locale);
    });

    it('should override subscriber email based on event data', async () => {
      const subscriberId = SubscriberRepository.createObjectId();
      const transactionId = SubscriberRepository.createObjectId();

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        transactionId,
        to: [
          { subscriberId: subscriber.subscriberId, email: 'gg@ff.com' },
          { subscriberId, email: 'gg@ff.com' },
        ],
        overrides: {
          email: {
            toRecipient: 'new-test-email@gmail.com',
          },
        },
      });

      await session.waitForJobCompletion();

      const messages = await messageRepository.findBySubscriberChannel(
        session.environment._id,
        subscriber._id,
        ChannelTypeEnum.EMAIL
      );
      const createdSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);

      await messageRepository.findBySubscriberChannel(
        session.environment._id,
        createdSubscriber?._id as string,
        ChannelTypeEnum.EMAIL
      );

      expect(subscriber.email).to.not.equal('new-test-email@gmail.com');
      expect(messages[0].email).to.equal('new-test-email@gmail.com');
    });

    it('should generate message and notification based on event', async () => {
      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [
          {
            subscriberId: subscriber.subscriberId,
          },
        ],
        payload: {
          firstName: 'Testing of User Name',
          urlVar: '/test/url/path',
          attachments: [
            {
              name: 'text1.txt',
              file: 'hello world!',
            },
            {
              name: 'text2.txt',
              file: Buffer.from('hello world!', 'utf-8'),
            },
          ],
        },
      });

      await session.waitForJobCompletion(template._id);

      const notifications = await notificationRepository.findBySubscriberId(session.environment._id, subscriber._id);

      expect(notifications.length).to.equal(1);

      const notification = notifications[0];

      expect(notification._organizationId).to.equal(session.organization._id);
      expect(notification._templateId).to.equal(template._id);

      const messages = await messageRepository.findBySubscriberChannel(
        session.environment._id,
        subscriber._id,
        ChannelTypeEnum.IN_APP
      );

      expect(messages.length).to.equal(1);
      const message = messages[0];

      expect(message.channel).to.equal(ChannelTypeEnum.IN_APP);
      expect(message.content as string).to.equal('Test content for <b>Testing of User Name</b>');
      expect(message.seen).to.equal(false);
      expect(message.cta.data.url).to.equal('/cypress/test-shell/example/test?test-param=true');
      expect(message.lastSeenDate).to.be.not.ok;
      expect(message.payload.firstName).to.equal('Testing of User Name');
      expect(message.payload.urlVar).to.equal('/test/url/path');
      expect(message.payload.attachments).to.be.not.ok;

      const emails = await messageRepository.findBySubscriberChannel(
        session.environment._id,
        subscriber._id,
        ChannelTypeEnum.EMAIL
      );

      expect(emails.length).to.equal(1);
      const email = emails[0];

      expect(email.channel).to.equal(ChannelTypeEnum.EMAIL);
    });

    it('should correctly set expiration date (TTL) for notification and messages', async () => {
      const templateName = template.triggers[0].identifier;

      const response = await novuClient.trigger({
        workflowId: templateName,
        to: [
          {
            subscriberId: subscriber.subscriberId,
          },
        ],
        payload: {
          firstName: 'Testing of User Name',
          urlVar: '/test/url/path',
        },
      });
      const body = response.result;
      expect(body).to.have.all.keys('acknowledged', 'status', 'transactionId');
      expect(body.acknowledged).to.equal(true);
      expect(body.status).to.equal('processed');
      expect(body.transactionId).to.be.a.string;

      await session.waitForJobCompletion(template._id);

      const jobs = await jobRepository.find({
        _templateId: template._id,
        _environmentId: session.environment._id,
      });
      expect(jobs.length).to.equal(3);

      const notifications = await notificationRepository.findBySubscriberId(session.environment._id, subscriber._id);

      expect(notifications.length).to.equal(1);

      const messages = await messageRepository.findBySubscriberChannel(
        session.environment._id,
        subscriber._id,
        ChannelTypeEnum.IN_APP
      );

      expect(messages.length).to.equal(1);
      const message = messages[0];

      let createdAt = new Date(message?.createdAt as string);

      const emails = await messageRepository.findBySubscriberChannel(
        session.environment._id,
        subscriber._id,
        ChannelTypeEnum.EMAIL
      );

      expect(emails.length).to.equal(1);
      const email = emails[0];

      createdAt = new Date(email?.createdAt as string);
    });

    it('should trigger SMS notification', async () => {
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.SMS,
            content: 'Hello world {{customVar}}' as string,
          },
        ],
      });

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {
          customVar: 'Testing of User Name',
        },
      });

      await session.waitForJobCompletion(template._id);

      const message = await messageRepository._model.findOne({
        _environmentId: session.environment._id,
        _templateId: template._id,
        _subscriberId: subscriber._id,
        channel: ChannelTypeEnum.SMS,
      });

      expect(message!.phone).to.equal(subscriber.phone);
    });

    it('should trigger SMS notification for all subscribers', async () => {
      const subscriberId = SubscriberRepository.createObjectId();
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.SMS,
            content: 'Welcome to {{organizationName}}' as string,
          },
        ],
      });

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [{ subscriberId: subscriber.subscriberId }, { subscriberId, phone: '+972541111111' }],
        payload: {
          organizationName: 'Testing of Organization Name',
        },
      });

      await session.waitForJobCompletion(template._id);

      const message = await messageRepository._model.findOne({
        _environmentId: session.environment._id,
        _templateId: template._id,
        _subscriberId: subscriber._id,
        channel: ChannelTypeEnum.SMS,
      });

      const createdSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);

      const message2 = await messageRepository._model.findOne({
        _environmentId: session.environment._id,
        _templateId: template._id,
        _subscriberId: createdSubscriber?._id,
        channel: ChannelTypeEnum.SMS,
      });

      expect(message2!.phone).to.equal('+972541111111');
    });

    it('should trigger an sms error', async () => {
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.SMS,
            content: 'Hello world {{firstName}}' as string,
          },
        ],
      });
      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {
          phone: '+972541111111',
          firstName: 'Testing of User Name',
        },
      });

      await session.waitForJobCompletion(template._id);

      const message = await messageRepository._model.findOne({
        _environmentId: session.environment._id,
        _templateId: template._id,
        _subscriberId: subscriber._id,
      });

      expect(message!.status).to.equal('error');
      expect(message!.errorText).to.contains('Currently 3rd-party packages test are not support on test env');
    });

    it('should trigger in-app notification', async () => {
      const channelType = ChannelTypeEnum.IN_APP;

      template = await createTemplate(session, channelType);

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [
          { subscriberId: 'no_type_123', lastName: 'smith_no_type', email: 'test@email.novu' },
          {
            type: 'Subscriber',
            subscriberId: 'with_type_123',
            lastName: 'smith_with_type',
            email: 'test@email.novu',
          },
        ],
        payload: {
          organizationName: 'Umbrella Corp',
          compiledVariable: 'test-env',
        },
      });

      await session.waitForJobCompletion(template._id);

      let createdSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, 'no_type_123');
      let message = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: createdSubscriber?._id,
        channel: channelType,
      });
      expect(message!.content).to.equal('Hello smith_no_type, Welcome to Umbrella Corp');

      createdSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, 'with_type_123');
      message = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: createdSubscriber?._id,
        channel: channelType,
      });
      expect(message!.content).to.equal('Hello smith_with_type, Welcome to Umbrella Corp');
    });

    it('should trigger SMS notification with subscriber data', async () => {
      const newSubscriberIdInAppNotification = SubscriberRepository.createObjectId();
      const channelType = ChannelTypeEnum.SMS;

      template = await createTemplate(session, channelType);

      await sendTrigger(template, newSubscriberIdInAppNotification);

      await session.waitForJobCompletion(template._id);

      const createdSubscriber = await subscriberRepository.findBySubscriberId(
        session.environment._id,
        newSubscriberIdInAppNotification
      );

      const message = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: createdSubscriber?._id,
        channel: channelType,
      });

      expect(message!.content).to.equal('Hello Smith, Welcome to Umbrella Corp');
    });

    it('should trigger E-Mail notification with subscriber data', async () => {
      const newSubscriberIdInAppNotification = SubscriberRepository.createObjectId();
      const channelType = ChannelTypeEnum.EMAIL;

      template = await createTemplate(session, channelType);

      template = await session.createTemplate({
        steps: [
          {
            name: 'Message Name',
            subject: 'Test email {{nested.subject}}',
            type: StepTypeEnum.EMAIL,
            content: [
              {
                type: EmailBlockTypeEnum.TEXT,
                content: 'Hello {{subscriber.lastName}}, Welcome to {{organizationName}}' as string,
              },
            ],
          },
        ],
      });

      await sendTrigger(template, newSubscriberIdInAppNotification, {
        nested: {
          subject: 'a subject nested',
        },
      });

      await session.waitForJobCompletion(template._id);

      const createdSubscriber = await subscriberRepository.findBySubscriberId(
        session.environment._id,
        newSubscriberIdInAppNotification
      );

      const message = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: createdSubscriber?._id,
        channel: channelType,
      });

      const block = message!.content[0] as IEmailBlock;

      expect(block.content).to.equal('Hello Smith, Welcome to Umbrella Corp');
      expect(message!.subject).to.equal('Test email a subject nested');
    });

    it('should trigger E-Mail notification with actor data', async () => {
      const newSubscriberId = SubscriberRepository.createObjectId();
      const channelType = ChannelTypeEnum.EMAIL;
      const actorSubscriber = await subscriberService.createSubscriber({ firstName: 'Actor' });

      template = await session.createTemplate({
        steps: [
          {
            name: 'Message Name',
            subject: 'Test email',
            type: StepTypeEnum.EMAIL,
            content: [
              {
                type: EmailBlockTypeEnum.TEXT,
                content: 'Hello {{actor.firstName}}, Welcome to {{organizationName}}' as string,
              },
            ],
          },
        ],
      });

      await sendTrigger(template, newSubscriberId, {}, {}, '', actorSubscriber.subscriberId);

      await session.waitForJobCompletion(template._id);

      const createdSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, newSubscriberId);

      const message = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: createdSubscriber?._id,
        channel: channelType,
      });

      const block = message!.content[0] as IEmailBlock;

      expect(block.content).to.equal('Hello Actor, Welcome to Umbrella Corp');
    });

    it('should not trigger notification with subscriber data if integration is inactive', async () => {
      const newSubscriberIdInAppNotification = SubscriberRepository.createObjectId();
      const channelType = ChannelTypeEnum.SMS;

      const integration = await integrationRepository.findOne({
        _environmentId: session.environment._id,
        _organizationId: session.organization._id,
        providerId: SmsProviderIdEnum.Twilio,
      });

      await integrationRepository.update(
        { _environmentId: session.environment._id, _id: integration!._id },
        { active: false }
      );

      template = await createTemplate(session, channelType);

      template = await session.createTemplate({
        steps: [
          {
            name: 'Message Name',
            subject: 'Test sms {{nested.subject}}',
            type: StepTypeEnum.EMAIL,
            content: [
              {
                type: EmailBlockTypeEnum.TEXT,
                content: 'Hello {{subscriber.lastName}}, Welcome to {{organizationName}}' as string,
              },
            ],
          },
        ],
      });

      await sendTrigger(template, newSubscriberIdInAppNotification, {
        nested: {
          subject: 'a subject nested',
        },
      });

      await session.waitForJobCompletion(template._id);

      const createdSubscriber = await subscriberRepository.findBySubscriberId(
        session.environment._id,
        newSubscriberIdInAppNotification
      );

      const message = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: createdSubscriber?._id,
        channel: channelType,
      });

      expect(message).to.be.null;
    });

    it('should use Novu integration for new orgs', async () => {
      process.env.NOVU_EMAIL_INTEGRATION_API_KEY = 'true';

      const existingIntegrations = await integrationRepository.find({
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        active: true,
      });

      const integrationIdsToDelete = existingIntegrations.flatMap((integration) =>
        integration._environmentId === session.environment._id ? [integration._id] : []
      );

      const deletedIntegrations = await integrationRepository.deleteMany({
        _id: { $in: integrationIdsToDelete },
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
      });

      expect(deletedIntegrations.modifiedCount).to.eql(integrationIdsToDelete.length);

      await integrationRepository.update(
        {
          _organizationId: session.organization._id,
          _environmentId: session.environment._id,
          active: false,
        },
        {
          $set: {
            active: true,
            primary: true,
            priority: 1,
          },
        }
      );

      const newSubscriberIdInAppNotification = SubscriberRepository.createObjectId();
      const channelType = ChannelTypeEnum.EMAIL;

      template = await createTemplate(session, channelType);

      template = await session.createTemplate({
        steps: [
          {
            name: 'Message Name',
            subject: 'Test sms {{nested.subject}}',
            type: StepTypeEnum.EMAIL,
            content: [
              {
                type: EmailBlockTypeEnum.TEXT,
                content: 'Hello {{subscriber.lastName}}, Welcome to {{organizationName}}' as string,
              },
            ],
          },
        ],
      });

      await sendTrigger(template, newSubscriberIdInAppNotification, {
        nested: {
          subject: 'a subject nested',
        },
      });

      await session.waitForJobCompletion(template._id);

      const createdSubscriber = await subscriberRepository.findBySubscriberId(
        session.environment._id,
        newSubscriberIdInAppNotification
      );

      const message = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: createdSubscriber?._id,
        channel: channelType,
      });

      expect(message!.providerId).to.equal(EmailProviderIdEnum.Novu);
    });

    it('should trigger message with active integration', async () => {
      const newSubscriberIdInAppNotification = SubscriberRepository.createObjectId();
      const channelType = ChannelTypeEnum.EMAIL;

      template = await session.createTemplate({
        steps: [
          {
            name: 'Message Name',
            subject: 'Test email {{nested.subject}}',
            type: StepTypeEnum.EMAIL,
            content: [],
          },
        ],
      });

      await sendTrigger(template, newSubscriberIdInAppNotification, {
        nested: {
          subject: 'a subject nested',
        },
      });

      await session.waitForJobCompletion(template._id);

      const createdSubscriber = await subscriberRepository.findBySubscriberId(
        session.environment._id,
        newSubscriberIdInAppNotification
      );

      let messages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: createdSubscriber?._id,
        channel: channelType,
      });

      expect(messages.length).to.be.equal(1);
      expect(messages[0].providerId).to.be.equal(EmailProviderIdEnum.SendGrid);

      const payload = {
        providerId: EmailProviderIdEnum.Mailgun,
        channel: 'email',
        credentials: { apiKey: '123', secretKey: 'abc' },
        active: true,
        check: false,
      };

      const {
        body: { data },
      } = await session.testAgent.post('/v1/integrations').send(payload);
      await session.testAgent.post(`/v1/integrations/${data._id}/set-primary`).send({});

      await sendTrigger(template, newSubscriberIdInAppNotification, {
        nested: {
          subject: 'a subject nested',
        },
      });

      await session.waitForJobCompletion(template._id);

      messages = await messageRepository.find(
        {
          _environmentId: session.environment._id,
          _subscriberId: createdSubscriber?._id,
          channel: channelType,
        },
        '',
        { sort: { createdAt: -1 } }
      );

      expect(messages.length).to.be.equal(2);
      expect(messages[0].providerId).to.be.equal(EmailProviderIdEnum.Mailgun);
    });

    it('should fail to trigger with missing variables', async () => {
      template = await session.createTemplate({
        steps: [
          {
            name: 'Message Name',
            subject: 'Test email {{nested.subject}}',
            type: StepTypeEnum.EMAIL,
            variables: [
              { name: 'myUser.lastName', required: true, type: TemplateVariableTypeEnum.STRING },
              { name: 'myUser.array', required: true, type: TemplateVariableTypeEnum.ARRAY },
              { name: 'myUser.bool', required: true, type: TemplateVariableTypeEnum.BOOLEAN },
            ],
            content: [
              {
                type: EmailBlockTypeEnum.TEXT,
                content: 'Hello {{myUser.lastName}}, Welcome to {{organizationName}}' as string,
              },
            ],
          },
        ],
      });

      let response = await session.testAgent
        .post('/v1/events/trigger')
        .send({
          name: template.triggers[0].identifier,
          to: [subscriber.subscriberId],
          payload: {},
        })
        .expect(400);

      expect(JSON.stringify(response.body)).to.include(
        'payload is missing required key(s) and type(s): myUser.lastName (Value), myUser.array (Array), myUser.bool (Boolean)'
      );

      response = await session.testAgent
        .post('/v1/events/trigger')
        .send({
          name: template.triggers[0].identifier,
          to: [subscriber.subscriberId],
          payload: {
            myUser: {
              lastName: true,
              array: 'John Doe',
              bool: 0,
            },
          },
        })
        .expect(400);

      expect(JSON.stringify(response.body)).to.include(
        'payload is missing required key(s) and type(s): myUser.lastName (Value), myUser.array (Array), myUser.bool (Boolean)'
      );

      response = await session.testAgent
        .post('/v1/events/trigger')
        .send({
          name: template.triggers[0].identifier,
          to: [subscriber.subscriberId],
          payload: {
            myUser: {
              lastName: '',
              array: [],
              bool: true,
            },
          },
        })
        .expect(201);
    });

    it('should fill trigger payload with default variables', async () => {
      const newSubscriberIdInAppNotification = SubscriberRepository.createObjectId();
      const channelType = ChannelTypeEnum.EMAIL;

      template = await session.createTemplate({
        steps: [
          {
            name: 'Message Name',
            subject: 'Test email {{nested.subject}}',
            type: StepTypeEnum.EMAIL,
            variables: [
              {
                name: 'myUser.lastName',
                required: false,
                type: TemplateVariableTypeEnum.STRING,
                defaultValue: 'John Doe',
              },
              {
                name: 'organizationName',
                required: false,
                type: TemplateVariableTypeEnum.STRING,
                defaultValue: 'Novu Corp',
              },
            ],
            content: [
              {
                type: EmailBlockTypeEnum.TEXT,
                content: 'Hello {{myUser.lastName}}, Welcome to {{organizationName}}' as string,
              },
            ],
          },
        ],
      });

      await session.testAgent
        .post('/v1/events/trigger')
        .send({
          name: template.triggers[0].identifier,
          to: newSubscriberIdInAppNotification,
          payload: {
            organizationName: 'Umbrella Corp',
          },
        })
        .expect(201);

      await session.waitForJobCompletion(template._id);

      const createdSubscriber = await subscriberRepository.findBySubscriberId(
        session.environment._id,
        newSubscriberIdInAppNotification
      );

      const message = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: createdSubscriber?._id,
        channel: channelType,
      });

      const block = message!.content[0] as IEmailBlock;

      expect(block.content).to.equal('Hello John Doe, Welcome to Umbrella Corp');
    });

    it('should throw an error when workflow identifier provided is not in the database', async () => {
      const response = await session.testAgent
        .post('/v1/events/trigger')
        .send({
          name: 'non-existent-template-identifier',
          to: [subscriber.subscriberId],
          payload: {
            myUser: {
              lastName: 'Test',
            },
          },
        })
        .expect(422);

      const { body } = response;

      expect(body.statusCode).to.equal(422);
      expect(body.message).to.equal('workflow_not_found');
      expect(body.error).to.equal('Unprocessable Entity');
    });

    it('should handle empty workflow scenario', async () => {
      template = await session.createTemplate({
        steps: [],
      });

      const response = await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {
          myUser: {
            lastName: 'Test',
          },
        },
      });

      const { status, acknowledged } = response.result;
      expect(status).to.equal('no_workflow_steps_defined');
      expect(acknowledged).to.equal(true);
    });

    it('should trigger with given required variables', async () => {
      template = await session.createTemplate({
        steps: [
          {
            name: 'Message Name',
            subject: 'Test email {{nested.subject}}',
            type: StepTypeEnum.EMAIL,
            variables: [{ name: 'myUser.lastName', required: true, type: TemplateVariableTypeEnum.STRING }],
            content: [
              {
                type: EmailBlockTypeEnum.TEXT,
                content: 'Hello {{myUser.lastName}}, Welcome to {{organizationName}}' as string,
              },
            ],
          },
        ],
      });

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {
          myUser: {
            lastName: 'Test',
          },
        },
      });
    });

    it('should broadcast trigger to all subscribers', async () => {
      subscriberService = new SubscribersService(session.organization._id, session.environment._id);
      await subscriberService.createSubscriber();
      await subscriberService.createSubscriber();

      const channelType = ChannelTypeEnum.EMAIL;

      template = await createTemplate(session, channelType);

      template = await session.createTemplate({
        steps: [
          {
            name: 'Message Name',
            subject: 'Test email subject',
            type: StepTypeEnum.EMAIL,
            content: [
              {
                type: EmailBlockTypeEnum.TEXT,
                content: 'Hello {{subscriber.lastName}}, Welcome to {{organizationName}}' as string,
              },
            ],
          },
        ],
      });

      await novuClient.triggerBroadcast({
        name: template.triggers[0].identifier,
        payload: {
          organizationName: 'Umbrella Corp',
        },
      });
      await session.waitForJobCompletion(template._id);
      const messages = await messageRepository.find({
        _environmentId: session.environment._id,
        channel: channelType,
      });

      expect(messages.length).to.equal(4);
      const isUnique = (value, index, self) => self.indexOf(value) === index;
      const subscriberIds = messages.map((message) => message._subscriberId).filter(isUnique);
      expect(subscriberIds.length).to.equal(4);
    });

    it('should not filter a message with correct payload', async () => {
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.EMAIL,
            subject: 'Password reset',
            content: [
              {
                type: EmailBlockTypeEnum.TEXT,
                content: 'This are the text contents of the template for {{firstName}}',
              },
              {
                type: EmailBlockTypeEnum.BUTTON,
                content: 'SIGN UP',
                url: 'https://url-of-app.com/{{urlVariable}}',
              },
            ],
            filters: [
              {
                isNegated: false,

                type: 'GROUP',

                value: FieldLogicalOperatorEnum.AND,

                children: [
                  {
                    field: 'run',
                    value: 'true',
                    operator: FieldOperatorEnum.EQUAL,
                    on: FilterPartTypeEnum.PAYLOAD,
                  },
                ],
              },
            ],
          },
          {
            type: StepTypeEnum.EMAIL,
            subject: 'Password reset',
            content: [
              {
                type: EmailBlockTypeEnum.TEXT,
                content: 'This are the text contents of the template for {{firstName}}',
              },
              {
                type: EmailBlockTypeEnum.BUTTON,
                content: 'SIGN UP',
                url: 'https://url-of-app.com/{{urlVariable}}',
              },
            ],
            filters: [
              {
                isNegated: false,

                type: 'GROUP',

                value: FieldLogicalOperatorEnum.AND,

                children: [
                  {
                    field: 'subscriberId',
                    value: subscriber.subscriberId,
                    operator: FieldOperatorEnum.NOT_EQUAL,
                    on: FilterPartTypeEnum.SUBSCRIBER,
                  },
                ],
              },
            ],
          },
        ],
      });

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {
          firstName: 'Testing of User Name',
          urlVariable: '/test/url/path',
          run: true,
        },
      });

      await session.waitForJobCompletion(template._id);

      const messages = await messageRepository.count({
        _environmentId: session.environment._id,
        _templateId: template._id,
      });

      expect(messages).to.equal(1);
    });

    it('should filter a message based on webhook filter', async () => {
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.EMAIL,
            subject: 'Password reset',
            content: [
              {
                type: EmailBlockTypeEnum.TEXT,
                content: 'This are the text contents of the template for {{firstName}}',
              },
              {
                type: EmailBlockTypeEnum.BUTTON,
                content: 'SIGN UP',
                url: 'https://url-of-app.com/{{urlVariable}}',
              },
            ],
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    field: 'isOnline',
                    value: 'true',
                    operator: FieldOperatorEnum.EQUAL,
                    on: FilterPartTypeEnum.WEBHOOK,
                    webhookUrl: 'www.user.com/webhook',
                  },
                ],
              },
            ],
          },
        ],
      });

      /*
       * let axiosPostStub = sinon.stub(axios, 'post').resolves(
       *   Promise.resolve({
       *     data: { isOnline: true },
       *   })
       * );
       */

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {},
      });

      await session.waitForJobCompletion(template._id);

      let messages = await messageRepository.count({
        _environmentId: session.environment._id,
        _templateId: template._id,
      });

      expect(messages).to.equal(1);

      /*
       * axiosPostStub.restore();
       * axiosPostStub = sinon.stub(axios, 'post').resolves(
       *   Promise.resolve({
       *     data: { isOnline: false },
       *   })
       * );
       */

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {},
      });

      await session.waitForJobCompletion(template._id);

      messages = await messageRepository.count({
        _environmentId: session.environment._id,
        _templateId: template._id,
      });

      expect(messages).to.equal(2);
    });

    it('should throw exception on webhook filter - demo unavailable server', async () => {
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.EMAIL,
            subject: 'Password reset',
            content: [
              {
                type: EmailBlockTypeEnum.TEXT,
                content: 'This are the text contents of the template for {{firstName}}',
              },
              {
                type: EmailBlockTypeEnum.BUTTON,
                content: 'SIGN UP',
                url: 'https://url-of-app.com/{{urlVariable}}',
              },
            ],
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    field: 'isOnline',
                    value: 'true',
                    operator: FieldOperatorEnum.EQUAL,
                    on: FilterPartTypeEnum.WEBHOOK,
                    webhookUrl: 'www.user.com/webhook',
                  },
                ],
              },
            ],
          },
        ],
      });

      // const axiosPostStub = sinon.stub(axios, 'post').throws(new Error('Users remote error')));

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {},
      });

      await session.waitForJobCompletion(template._id);

      const messages = await messageRepository.count({
        _environmentId: session.environment._id,
        _templateId: template._id,
      });

      expect(messages).to.equal(1);
    });

    it('should backoff on exception while webhook filter (original request + 2 retries)', async () => {
      template = await session.createTemplate({
        steps: [
          {
            type: StepTypeEnum.EMAIL,
            subject: 'Password reset',
            content: [
              {
                type: EmailBlockTypeEnum.TEXT,
                content: 'This are the text contents of the template for {{firstName}}',
              },
              {
                type: EmailBlockTypeEnum.BUTTON,
                content: 'SIGN UP',
                url: 'https://url-of-app.com/{{urlVariable}}',
              },
            ],
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    field: 'isOnline',
                    value: 'true',
                    operator: FieldOperatorEnum.EQUAL,
                    on: FilterPartTypeEnum.WEBHOOK,
                    webhookUrl: 'www.user.com/webhook',
                  },
                ],
              },
            ],
          },
        ],
      });

      // let axiosPostStub = sinon.stub(axios, 'post');

      /*
       * axiosPostStub
       *   .onCall(0)
       *   .throws(new Error('Users remote error'))
       *   .onCall(1)
       *   .resolves({
       *     data: { isOnline: true },
       *   });
       */

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {},
      });

      await session.waitForJobCompletion(template._id);

      let messages = await messageRepository.count({
        _environmentId: session.environment._id,
        _templateId: template._id,
      });

      expect(messages).to.equal(1);

      /*
       * axiosPostStub.restore();
       * axiosPostStub = sinon
       *   .stub(axios, 'post')
       *   .onCall(0)
       *   .throws(new Error('Users remote error'))
       *   .onCall(1)
       *   .throws(new Error('Users remote error'))
       *   .onCall(2)
       *   .throws(new Error('Users remote error'))
       *   .resolves(
       *     Promise.resolve({
       *       data: { isOnline: true },
       *     })
       *   );
       */

      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {},
      });

      await session.waitForJobCompletion(template._id);

      messages = await messageRepository.count({
        _environmentId: session.environment._id,
        _templateId: template._id,
      });

      expect(messages).to.equal(2);
    });

    it('should choose variant by tenant data', async () => {
      const tenant = await tenantRepository.create({
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        identifier: 'one_123',
        name: 'The one and only tenant',
        data: { value1: 'Best fighter', value2: 'Ever' },
      });

      const templateWithVariants = await session.createTemplate({
        name: 'test email template',
        description: 'This is a test description',
        steps: [
          {
            name: 'Root Message Name',
            subject: 'Root Test email subject',
            preheader: 'Root Test email preheader',
            content: [{ type: EmailBlockTypeEnum.TEXT, content: 'Root This is a sample text block' }],
            type: StepTypeEnum.EMAIL,
            filters: [],
            variants: [
              {
                name: 'Bad Variant Message Template',
                subject: 'Bad Variant subject',
                preheader: 'Bad Variant pre header',
                content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample of Bad Variant text block' }],
                type: StepTypeEnum.EMAIL,
                active: true,
                filters: [
                  {
                    isNegated: false,
                    type: 'GROUP',
                    value: FieldLogicalOperatorEnum.AND,
                    children: [
                      {
                        on: FilterPartTypeEnum.TENANT,
                        field: 'name',
                        value: 'Titans',
                        operator: FieldOperatorEnum.EQUAL,
                      },
                    ],
                  },
                ],
              },
              {
                name: 'Better Variant Message Template',
                subject: 'Better Variant subject',
                preheader: 'Better Variant pre header',
                content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample of Better Variant text block' }],
                type: StepTypeEnum.EMAIL,
                active: true,
                filters: [
                  {
                    isNegated: false,
                    type: 'GROUP',
                    value: FieldLogicalOperatorEnum.AND,
                    children: [
                      {
                        on: FilterPartTypeEnum.TENANT,
                        field: 'name',
                        value: 'The one and only tenant',
                        operator: FieldOperatorEnum.EQUAL,
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      });

      await novuClient.trigger({
        workflowId: templateWithVariants.triggers[0].identifier,
        to: [subscriber.subscriberId],
        payload: {},
        tenant: { identifier: tenant.identifier },
      });

      await session.waitForJobCompletion(templateWithVariants._id);

      const messages = await messageRepository.find({
        _environmentId: session.environment._id,
        _templateId: templateWithVariants._id,
      });

      expect(messages.length).to.equal(1);
      expect(messages[0].subject).to.equal('Better Variant subject');
    });

    describe('Post Mortem', () => {
      // Repeat the test 3 times

      it(`should not create multiple subscribers when multiple triggers are made        
         with the same not created subscribers `, async () => {
        // Access subscriberRepository and print database indexes
        console.log('Accessing subscriberRepository indexes...');
        const subscriberModel = subscriberRepository._model;
        subscriberModel.collection
          .getIndexes()
          .then((indexes) => {
            console.log('Subscriber Collection Indexes:');
            console.log(JSON.stringify(indexes, null, 2));
          })
          .catch((error) => {
            console.error('Error fetching indexes:', error);
          });
        template = await createSimpleWorkflow(session);
        for (let i = 0; i < 3; i += 1) {
          const subscriberId = `not-created-twice-subscriber${i}`;
          await Promise.all([
            simpleTrigger(novuClient, template, subscriberId),
            simpleTrigger(novuClient, template, subscriberId),
          ]);
          await session.waitForJobCompletion(template._id);

          const subscribers = await subscriberRepository.find({
            _environmentId: session.environment._id,
            subscriberId,
          });

          expect(subscribers.length).to.equal(1);
        }
      });
    });
    describe('filters logic', () => {
      beforeEach(async () => {
        subscriberService = new SubscribersService(session.organization._id, session.environment._id);
        subscriber = await subscriberService.createSubscriber();
      });

      it('should filter a message with variables', async () => {
        template = await session.createTemplate({
          steps: [
            {
              type: StepTypeEnum.EMAIL,
              subject: 'Password reset',
              content: [
                {
                  type: EmailBlockTypeEnum.TEXT,
                  content: 'This are the text contents of the template for {{firstName}}',
                },
                {
                  type: EmailBlockTypeEnum.BUTTON,
                  content: 'SIGN UP',
                  url: 'https://url-of-app.com/{{urlVariable}}',
                },
              ],
              filters: [
                {
                  isNegated: false,
                  type: 'GROUP',
                  value: FieldLogicalOperatorEnum.AND,
                  children: [
                    {
                      field: 'run',
                      value: '{{payload.var}}',
                      operator: FieldOperatorEnum.EQUAL,
                      on: FilterPartTypeEnum.PAYLOAD,
                    },
                  ],
                },
              ],
            },
            {
              type: StepTypeEnum.EMAIL,
              subject: 'Password reset',
              content: [
                {
                  type: EmailBlockTypeEnum.TEXT,
                  content: 'This are the text contents of the template for {{firstName}}',
                },
              ],
              filters: [
                {
                  isNegated: false,
                  type: 'GROUP',
                  value: FieldLogicalOperatorEnum.AND,
                  children: [
                    {
                      field: 'subscriberId',
                      value: subscriber.subscriberId,
                      operator: FieldOperatorEnum.NOT_EQUAL,
                      on: FilterPartTypeEnum.SUBSCRIBER,
                    },
                  ],
                },
              ],
            },
          ],
        });

        await novuClient.trigger({
          workflowId: template.triggers[0].identifier,
          to: [subscriber.subscriberId],
          payload: {
            firstName: 'Testing of User Name',
            urlVariable: '/test/url/path',
            run: true,
            var: true,
          },
        });

        await session.waitForJobCompletion(template._id);

        const messages = await messageRepository.count({
          _environmentId: session.environment._id,
          _templateId: template._id,
        });

        expect(messages).to.equal(1);
      });

      it('should filter a message with value that includes variables and strings', async () => {
        const actorSubscriber = await subscriberService.createSubscriber({
          firstName: 'Actor',
        });

        template = await session.createTemplate({
          steps: [
            {
              type: StepTypeEnum.EMAIL,
              subject: 'Password reset',
              content: [
                {
                  type: EmailBlockTypeEnum.TEXT,
                  content: 'This are the text contents of the template for {{firstName}}',
                },
              ],
              filters: [
                {
                  isNegated: false,
                  type: 'GROUP',
                  value: FieldLogicalOperatorEnum.AND,
                  children: [
                    {
                      field: 'name',
                      value: 'Test {{actor.firstName}}',
                      operator: FieldOperatorEnum.EQUAL,
                      on: FilterPartTypeEnum.PAYLOAD,
                    },
                  ],
                },
              ],
            },
          ],
        });

        await novuClient.trigger({
          workflowId: template.triggers[0].identifier,
          to: [subscriber.subscriberId],
          payload: {
            firstName: 'Testing of User Name',
            urlVariable: '/test/url/path',
            name: 'Test Actor',
          },
          actor: actorSubscriber.subscriberId,
        });

        await session.waitForJobCompletion(template._id);

        const messages = await messageRepository.count({
          _environmentId: session.environment._id,
          _templateId: template._id,
        });

        expect(messages).to.equal(1);
      });

      it('should filter by tenant variables data', async () => {
        const tenant = await tenantRepository.create({
          _organizationId: session.organization._id,
          _environmentId: session.environment._id,
          identifier: 'one_123',
          name: 'The one and only tenant',
          data: { value1: 'Best fighter', value2: 'Ever', count: 4 },
        });

        const templateWithVariants = await session.createTemplate({
          name: 'test email template',
          description: 'This is a test description',
          steps: [
            {
              name: 'Message Name',
              subject: 'Test email subject',
              preheader: 'Test email preheader',
              content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
              type: StepTypeEnum.EMAIL,
              filters: [
                {
                  isNegated: false,
                  type: 'GROUP',
                  value: FieldLogicalOperatorEnum.AND,
                  children: [
                    {
                      on: FilterPartTypeEnum.TENANT,
                      field: 'data.count',
                      value: '{{payload.count}}',
                      operator: FieldOperatorEnum.LARGER,
                    },
                  ],
                },
              ],
            },
          ],
        });

        await novuClient.trigger({
          workflowId: templateWithVariants.triggers[0].identifier,
          to: [subscriber.subscriberId],
          payload: { count: 5 },
          tenant: { identifier: tenant.identifier },
        });

        await session.waitForJobCompletion(templateWithVariants._id);

        let messages = await messageRepository.find({
          _environmentId: session.environment._id,
          _templateId: templateWithVariants._id,
        });

        expect(messages.length).to.equal(0);

        await novuClient.trigger({
          workflowId: templateWithVariants.triggers[0].identifier,
          to: [subscriber.subscriberId],
          payload: { count: 1 },
          tenant: { identifier: tenant.identifier },
        });
        await session.waitForJobCompletion(templateWithVariants._id);

        messages = await messageRepository.find({
          _environmentId: session.environment._id,
          _templateId: templateWithVariants._id,
        });

        expect(messages.length).to.equal(1);
      });
      it('should trigger message with override integration identifier', async () => {
        const newSubscriberId = SubscriberRepository.createObjectId();
        const channelType = ChannelTypeEnum.EMAIL;

        template = await createTemplate(session, channelType);

        await sendTrigger(template, newSubscriberId);

        await session.waitForJobCompletion(template._id);

        const createdSubscriber = await subscriberRepository.findBySubscriberId(
          session.environment._id,
          newSubscriberId
        );

        let messages = await messageRepository.find({
          _environmentId: session.environment._id,
          _subscriberId: createdSubscriber?._id,
          channel: channelType,
        });

        expect(messages.length).to.be.equal(1);
        expect(messages[0].providerId).to.be.equal(EmailProviderIdEnum.SendGrid);

        const prodEnv = await environmentRepository.findOne({
          name: 'Production',
          _organizationId: session.organization._id,
        });

        const payload: CreateIntegrationRequestDto = {
          providerId: EmailProviderIdEnum.Mailgun,
          channel: 'email',
          credentials: { apiKey: '123', secretKey: 'abc' },
          environmentId: prodEnv?._id,
          active: true,
          check: false,
        };

        const { result } = await novuClient.integrations.create(payload);
        await sendTrigger(template, newSubscriberId, {}, { email: { integrationIdentifier: result.identifier } });

        await session.waitForJobCompletion(template._id);

        messages = await messageRepository.find(
          {
            _environmentId: session.environment._id,
            _subscriberId: createdSubscriber?._id,
            channel: channelType,
          },
          '',
          { sort: { createdAt: -1 } }
        );

        expect(messages.length).to.be.equal(2);
        expect(messages[0].providerId).to.be.equal(EmailProviderIdEnum.Mailgun);
      });

      describe('in-app avatar', () => {
        it('should send the message with chosen system avatar', async () => {
          const firstStepUuid = uuid();
          template = await session.createTemplate({
            steps: [
              {
                type: StepTypeEnum.IN_APP,
                content: 'Hello world!',
                uuid: firstStepUuid,
                actor: {
                  type: ActorTypeEnum.SYSTEM_ICON,
                  data: SystemAvatarIconEnum.WARNING,
                },
              },
            ],
          });

          await novuClient.trigger({
            workflowId: template.triggers[0].identifier,
            to: [subscriber.subscriberId],
            payload: {},
          });

          await session.waitForJobCompletion(template?._id);

          const messages = await messageRepository.find({
            _environmentId: session.environment._id,
            _subscriberId: subscriber._id,
            channel: StepTypeEnum.IN_APP,
          });

          expect(messages.length).to.equal(1);
          expect(messages[0].actor).to.be.ok;
          expect(messages[0].actor?.type).to.eq(ActorTypeEnum.SYSTEM_ICON);
          expect(messages[0].actor?.data).to.eq(SystemAvatarIconEnum.WARNING);
        });

        it('should send the message with custom system avatar url', async () => {
          const firstStepUuid = uuid();
          const avatarUrl = 'https://gravatar.com/avatar/5246ec47a6a90ef2bcd29f0ef7d2faa6?s=400&d=robohash&r=x';

          template = await session.createTemplate({
            steps: [
              {
                type: StepTypeEnum.IN_APP,
                content: 'Hello world!',
                uuid: firstStepUuid,
                actor: {
                  type: ActorTypeEnum.SYSTEM_CUSTOM,
                  data: avatarUrl,
                },
              },
            ],
          });

          await novuClient.trigger({
            workflowId: template.triggers[0].identifier,
            to: [subscriber.subscriberId],
            payload: {},
          });

          await session.waitForJobCompletion(template?._id);

          const messages = await messageRepository.find({
            _environmentId: session.environment._id,
            _subscriberId: subscriber._id,
            channel: StepTypeEnum.IN_APP,
          });

          expect(messages.length).to.equal(1);
          expect(messages[0].actor).to.be.ok;
          expect(messages[0].actor?.type).to.eq(ActorTypeEnum.SYSTEM_CUSTOM);
          expect(messages[0].actor?.data).to.eq(avatarUrl);
        });

        it('should send the message with the actor avatar', async () => {
          const firstStepUuid = uuid();
          const avatarUrl = 'https://gravatar.com/avatar/5246ec47a6a90ef2bcd29f0ef7d2faa6?s=400&d=robohash&r=x';

          const actor = await subscriberService.createSubscriber({ avatar: avatarUrl });

          template = await session.createTemplate({
            steps: [
              {
                type: StepTypeEnum.IN_APP,
                content: 'Hello world!',
                uuid: firstStepUuid,
                actor: {
                  type: ActorTypeEnum.USER,
                  data: null,
                },
              },
            ],
          });

          await novuClient.trigger({
            workflowId: template.triggers[0].identifier,
            to: [subscriber.subscriberId],
            payload: {},
            actor: actor.subscriberId,
          });

          await session.waitForJobCompletion(template?._id);

          const messages = await messageRepository.find({
            _environmentId: session.environment._id,
            _subscriberId: subscriber._id,
            channel: StepTypeEnum.IN_APP,
          });

          expect(messages.length).to.equal(1);
          expect(messages[0].actor).to.be.ok;
          expect(messages[0].actor?.type).to.eq(ActorTypeEnum.USER);
          expect(messages[0].actor?.data).to.eq(null);
          expect(messages[0]._actorId).to.eq(actor._id);
        });
      });

      describe('seen/read filter', () => {
        it('should filter in app seen/read step', async () => {
          const firstStepUuid = uuid();
          template = await session.createTemplate({
            steps: [
              {
                type: StepTypeEnum.IN_APP,
                content: 'Not Delayed {{customVar}}' as string,
                uuid: firstStepUuid,
              },
              {
                type: StepTypeEnum.DELAY,
                content: '',
                metadata: {
                  unit: DigestUnitEnum.SECONDS,
                  amount: 2,
                  type: DelayTypeEnum.REGULAR,
                },
              },
              {
                type: StepTypeEnum.IN_APP,
                content: 'Hello world {{customVar}}' as string,
                filters: [
                  {
                    isNegated: false,
                    type: 'GROUP',
                    value: FieldLogicalOperatorEnum.AND,
                    children: [
                      {
                        on: FilterPartTypeEnum.PREVIOUS_STEP,
                        stepType: PreviousStepTypeEnum.READ,
                        step: firstStepUuid,
                      },
                    ],
                  },
                ],
              },
            ],
          });

          await novuClient.trigger({
            workflowId: template.triggers[0].identifier,
            to: [subscriber.subscriberId],
            payload: {
              customVar: 'Testing of User Name',
            },
          });

          await session.waitForWorkflowQueueCompletion();
          await session.waitForSubscriberQueueCompletion();

          const delayedJob = await pollForJobStatusChange({
            jobRepository,
            query: {
              _environmentId: session.environment._id,
              _templateId: template._id,
              type: StepTypeEnum.DELAY,
            },
          });

          if (!delayedJob) {
            throw new Error();
          }

          expect(delayedJob.status).to.equal(JobStatusEnum.DELAYED);

          const messages = await messageRepository.find({
            _environmentId: session.environment._id,
            _subscriberId: subscriber._id,
            channel: StepTypeEnum.IN_APP,
          });

          expect(messages.length).to.equal(1);

          await session.waitForStandardQueueCompletion();
          await session.waitForDbJobCompletion({ templateId: template._id });

          const messagesAfter = await messageRepository.find({
            _environmentId: session.environment._id,
            _subscriberId: subscriber._id,
            channel: StepTypeEnum.IN_APP,
          });

          expect(messagesAfter.length).to.equal(1);
        });

        it('should filter email seen/read step', async () => {
          const firstStepUuid = uuid();
          template = await session.createTemplate({
            steps: [
              {
                type: StepTypeEnum.EMAIL,
                name: 'Message Name',
                subject: 'Test email subject',
                content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
                uuid: firstStepUuid,
              },
              {
                type: StepTypeEnum.DELAY,
                content: '',
                metadata: {
                  unit: DigestUnitEnum.SECONDS,
                  amount: 2,
                  type: DelayTypeEnum.REGULAR,
                },
              },
              {
                type: StepTypeEnum.EMAIL,
                name: 'Message Name',
                subject: 'Test email subject',
                content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
                filters: [
                  {
                    isNegated: false,
                    type: 'GROUP',
                    value: FieldLogicalOperatorEnum.AND,
                    children: [
                      {
                        on: FilterPartTypeEnum.PREVIOUS_STEP,
                        stepType: PreviousStepTypeEnum.READ,
                        step: firstStepUuid,
                      },
                    ],
                  },
                ],
              },
            ],
          });

          await novuClient.trigger({
            workflowId: template.triggers[0].identifier,
            to: [subscriber.subscriberId],
            payload: {
              customVar: 'Testing of User Name',
            },
          });

          await session.waitForWorkflowQueueCompletion();
          await session.waitForSubscriberQueueCompletion();

          const delayedJob = await pollForJobStatusChange({
            jobRepository,
            query: {
              _environmentId: session.environment._id,
              _templateId: template._id,
              type: StepTypeEnum.DELAY,
            },
          });
          expect(delayedJob!.status).to.equal(JobStatusEnum.DELAYED);

          const messages = await messageRepository.find({
            _environmentId: session.environment._id,
            _subscriberId: subscriber._id,
            channel: StepTypeEnum.EMAIL,
          });

          expect(messages.length).to.equal(1);

          await executionDetailsRepository.create({
            _jobId: delayedJob!._parentId,
            _messageId: messages[0]._id,
            _environmentId: session.environment._id,
            _organizationId: session.organization._id,
            webhookStatus: EmailEventStatusEnum.OPENED,
          });

          await session.waitForJobCompletion(template._id);

          const messagesAfter = await messageRepository.find({
            _environmentId: session.environment._id,
            _subscriberId: subscriber._id,
            channel: StepTypeEnum.EMAIL,
          });

          expect(messagesAfter.length).to.equal(1);
        });
      });

      describe('workflow override', () => {
        beforeEach(async () => {
          workflowOverrideService = new WorkflowOverrideService({
            organizationId: session.organization._id,
            environmentId: session.environment._id,
          });
        });

        it('should override - active false', async () => {
          const subscriberOverride = SubscriberRepository.createObjectId();

          // Create active workflow
          const workflow = await createTemplate(session, ChannelTypeEnum.IN_APP);

          // Create workflow override with active false
          const { tenant } = await workflowOverrideService.createWorkflowOverride({
            workflowId: workflow._id,
            active: false,
          });

          if (!tenant) {
            throw new Error('Tenant not found');
          }

          const triggerResponse = await novuClient.trigger({
            workflowId: workflow.triggers[0].identifier,
            to: [subscriberOverride],
            tenant: tenant.identifier,
            payload: {
              firstName: 'Testing of User Name',
              urlVariable: '/test/url/path',
            },
          });

          expect(triggerResponse.result.status).to.equal('trigger_not_active');

          await session.waitForJobCompletion();

          const messages = await messageRepository.find({
            _environmentId: session.environment._id,
            _templateId: workflow._id,
          });

          expect(messages.length).to.equal(0);

          // Disable workflow - should not take effect, test for anomalies
          await notificationTemplateRepository.update(
            { _id: workflow._id, _environmentId: session.environment._id },
            { $set: { active: false } }
          );

          const triggerResponse2 = await novuClient.trigger({
            workflowId: workflow.triggers[0].identifier,
            to: [subscriberOverride],
            tenant: tenant.identifier,
            payload: {
              firstName: 'Testing of User Name',
              urlVariable: '/test/url/path',
            },
          });

          expect(triggerResponse2.result.status).to.equal('trigger_not_active');

          await session.waitForJobCompletion();

          const messages2 = await messageRepository.find({
            _environmentId: session.environment._id,
            _templateId: workflow._id,
          });

          expect(messages2.length).to.equal(0);
        });

        /*
         * TODO: we need to add support for Tenants in V2 Preferences
         * This test is skipped for now as the tenant-level active flag is not taken into account for V2 Preferences
         */
        it.skip('should override - active true', async () => {
          const subscriberOverride = SubscriberRepository.createObjectId();

          // Create active workflow
          const workflow = await createTemplate(session, ChannelTypeEnum.IN_APP);

          // Create active workflow override
          const { tenant } = await workflowOverrideService.createWorkflowOverride({
            workflowId: workflow._id,
            active: true,
          });

          if (!tenant) {
            throw new Error('Tenant not found');
          }

          const triggerResponse = await novuClient.trigger({
            workflowId: workflow.triggers[0].identifier,
            to: [subscriberOverride],
            tenant: tenant.identifier,
            payload: {
              firstName: 'Testing of User Name',
              urlVariable: '/test/url/path',
            },
          });

          expect(triggerResponse.result.status).to.equal('processed');

          await session.waitForJobCompletion();

          const messages = await messageRepository.find({
            _environmentId: session.environment._id,
            _templateId: workflow._id,
          });

          expect(messages.length).to.equal(1);

          // Disable workflow - should not take effect as override is active
          await notificationTemplateRepository.update(
            { _id: workflow._id, _environmentId: session.environment._id },
            { $set: { active: false } }
          );

          const triggerResponse2 = await novuClient.trigger({
            workflowId: workflow.triggers[0].identifier,
            to: [subscriberOverride],
            tenant: tenant.identifier,
            payload: {
              firstName: 'Testing of User Name',
              urlVariable: '/test/url/path',
            },
          });

          expect(triggerResponse2.result.status).to.equal('processed');

          await session.waitForJobCompletion();

          const messages2 = await messageRepository.find({
            _environmentId: session.environment._id,
            _templateId: workflow._id,
          });

          expect(messages2.length).to.equal(2);
        });

        /*
         * TODO: we need to add support for Tenants in V2 Preferences
         * This test is skipped for now as the tenant-level active flag is not taken into account for V2 Preferences
         */
        it.skip('should override - preference - should disable in app channel', async () => {
          const subscriberOverride = SubscriberRepository.createObjectId();

          // Create a workflow with in app channel enabled
          const workflow = await createTemplate(session, ChannelTypeEnum.IN_APP);

          // Create a workflow with in app channel disabled
          const { tenant } = await workflowOverrideService.createWorkflowOverride({
            workflowId: workflow._id,
            active: true,
            preferenceSettings: { in_app: false },
          });

          if (!tenant) {
            throw new Error('Tenant not found');
          }
          const triggerResponse = await novuClient.trigger({
            workflowId: workflow.triggers[0].identifier,
            to: [subscriberOverride],
            tenant: tenant.identifier,
            payload: {
              firstName: 'Testing of User Name',
              urlVariable: '/test/url/path',
            },
          });

          expect(triggerResponse.result.status).to.equal('processed');

          await session.waitForJobCompletion();

          const messages = await messageRepository.find({
            _environmentId: session.environment._id,
            _templateId: workflow._id,
          });

          expect(messages.length).to.equal(0);
        });

        /*
         * TODO: we need to add support for Tenants in V2 Preferences
         * This test is skipped for now as the tenant-level active flag is not taken into account for V2 Preferences
         */
        it.skip('should override - preference - should enable in app channel', async () => {
          const subscriberOverride = SubscriberRepository.createObjectId();

          // Create a workflow with in-app channel disabled
          const workflow = await session.createTemplate({
            steps: [
              {
                type: StepTypeEnum.IN_APP,
                content: 'Hello' as string,
              },
            ],
            preferenceSettingsOverride: { in_app: false },
          });

          // Create workflow override with in app channel enabled
          const { tenant } = await workflowOverrideService.createWorkflowOverride({
            workflowId: workflow._id,
            active: true,
            preferenceSettings: { in_app: true },
          });

          if (!tenant) {
            throw new Error('Tenant not found');
          }

          const triggerResponse = await novuClient.trigger({
            workflowId: workflow.triggers[0].identifier,
            to: [subscriberOverride],
            tenant: tenant.identifier,
            payload: {
              firstName: 'Testing of User Name',
              urlVariable: '/test/url/path',
            },
          });

          expect(triggerResponse.result.status).to.equal(201);
          expect(triggerResponse.result.status).to.equal('processed');

          await session.waitForJobCompletion();

          const messages = await messageRepository.find({
            _environmentId: session.environment._id,
            _templateId: workflow._id,
          });

          expect(messages.length).to.equal(1);
        });
      });
    });
  });

  async function sendTrigger(
    templateInner: NotificationTemplateEntity,
    newSubscriberIdInAppNotification: string,
    payload: Record<string, unknown> = {},
    overrides: Record<string, Record<string, unknown>> = {},
    tenant?: string,
    actor?: string
  ): Promise<TriggerEventResponseDto> {
    const request = {
      workflowId: templateInner.triggers[0].identifier,
      to: [{ subscriberId: newSubscriberIdInAppNotification, lastName: 'Smith', email: 'test@email.novu' }],
      payload: {
        organizationName: 'Umbrella Corp',
        compiledVariable: 'test-env',
        ...payload,
      },
      overrides,
      tenant,
      actor,
    };

    return (await novuClient.trigger(request)).result;
  }

  describe('Trigger Event v2 workflow - /v1/events/trigger (POST)', () => {
    let organizationRepository: CommunityOrganizationRepository;

    beforeEach(async () => {
      organizationRepository = new CommunityOrganizationRepository();
      // Set removeNovuBranding to true for these tests to avoid branding watermark in email content
      await organizationRepository.update({ _id: session.organization._id }, { removeNovuBranding: true });
    });

    afterEach(async () => {
      await messageRepository.delete({
        _environmentId: session.environment._id,
      });
    });

    it('should execute email step with custom string', async function test() {
      const workflowBody: CreateWorkflowDto = {
        name: 'Test Email Workflow',
        workflowId: 'test-email-workflow',
        __source: WorkflowCreationSourceEnum.DASHBOARD,
        steps: [
          {
            type: StepTypeEnum.EMAIL,
            name: 'Message Name',
            controlValues: {
              subject: 'Hello {{subscriber.lastName}}, Welcome!',
              editorType: 'html',
              body: 'body {{subscriber.lastName}}!',
            },
          },
        ],
      };

      const response = await session.testAgent.post('/v2/workflows').send(workflowBody);
      expect(response.status).to.equal(201);
      const workflow: WorkflowResponseDto = response.body.data;

      await novuClient.trigger({
        workflowId: workflow.workflowId,
        to: [subscriber.subscriberId],
        payload: {
          shouldExecute: false,
        },
      });
      await session.waitForJobCompletion(workflow._id);

      await session.waitForJobCompletion(workflow._id);
      const message = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
      });

      expect(message.length).to.equal(1);
      expect(message[0].subject).to.equal(`Hello ${subscriber.lastName}, Welcome!`);
      expect(message[0].content).to.equal(`body ${subscriber.lastName}!`);
    });

    it('should execute email step with custom html', async function test() {
      const liquidJsHtml = `
                <html>
                  <head>
                    <meta charset="utf-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Welcome Email</title>
                  </head>
                  <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
                    <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                      <h1 style="color: #2d3748;">Welcome {{subscriber.firstName}}!</h1>
                      <p style="font-size: 16px;">Hello {{subscriber.lastName}},</p>
                      <p style="font-size: 16px;">Thank you for joining us. We're excited to have you on board!</p>
                      <div style="margin: 30px 0;">
                        <a href="https://example.com/get-started" style="background-color: #4299e1; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px;">Get Started</a>
                      </div>
                      <p style="font-size: 14px; color: #718096;">Best regards,<br>The Team</p>
                    </div>
                  </body>
                </html>
              `;
      const workflowBody: CreateWorkflowDto = {
        name: 'Test Email Workflow',
        workflowId: 'test-email-workflow',
        __source: WorkflowCreationSourceEnum.DASHBOARD,
        steps: [
          {
            type: StepTypeEnum.EMAIL,
            name: 'Message Name',
            controlValues: {
              subject: 'Hello {{subscriber.lastName}}, Welcome!',
              editorType: 'html',
              body: liquidJsHtml,
            },
          },
        ],
      };

      const response = await session.testAgent.post('/v2/workflows').send(workflowBody);
      expect(response.status).to.equal(201);
      const workflow: WorkflowResponseDto = response.body.data;

      await novuClient.trigger({
        workflowId: workflow.workflowId,
        to: [subscriber.subscriberId],
        payload: {
          shouldExecute: false,
        },
      });
      await session.waitForJobCompletion(workflow._id);

      await session.waitForJobCompletion(workflow._id);
      const message = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
      });

      expect(message.length).to.equal(1);
      expect(message[0].subject).to.equal(`Hello ${subscriber.lastName}, Welcome!`);
      expect(message[0].content).to.include(`Welcome ${subscriber.firstName}!`);
      expect(message[0].content).to.include(`Hello ${subscriber.lastName},`);
    });

    it('should execute step based on conditions', async () => {
      const workflowBody: CreateWorkflowDto = {
        name: 'Test Step Conditions Workflow',
        workflowId: 'test-step-conditions-workflow',
        __source: WorkflowCreationSourceEnum.DASHBOARD,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            name: 'Message Name',
            controlValues: {
              body: 'Hello {{subscriber.lastName}}, Welcome!',
              skip: {
                '==': [{ var: 'payload.shouldExecute' }, true],
              },
            },
          },
        ],
      };

      const response = await session.testAgent.post('/v2/workflows').send(workflowBody);
      expect(response.status).to.equal(201);
      const workflow: WorkflowResponseDto = response.body.data;

      await novuClient.trigger({
        workflowId: workflow.workflowId,
        to: [subscriber.subscriberId],
        payload: {
          shouldExecute: false,
        },
      });
      await session.waitForJobCompletion(workflow._id);
      const skippedMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
      });
      expect(skippedMessages.length).to.equal(0);

      await novuClient.trigger({
        workflowId: workflow.workflowId,
        to: [subscriber.subscriberId],
        payload: {
          shouldExecute: true,
        },
      });
      await session.waitForJobCompletion(workflow._id);
      const notSkippedMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
      });
      expect(notSkippedMessages.length).to.equal(1);
    });

    it('should successfully trigger a workflow with SMS followed by in-app notification', async () => {
      const workflowBody: CreateWorkflowDto = {
        name: 'Test SMS -> In-App Workflow',
        workflowId: 'test-sms-inapp-workflow',
        __source: WorkflowCreationSourceEnum.DASHBOARD,
        steps: [
          {
            type: StepTypeEnum.SMS,
            name: 'SMS Message',
            controlValues: {
              body: 'Hello {{subscriber.firstName}}, this is a test SMS',
            },
          },
          {
            type: StepTypeEnum.IN_APP,
            name: 'In-App Message',
            controlValues: {
              body: 'Welcome {{subscriber.firstName}}! This is an in-app notification',
            },
          },
        ],
      };

      const response = await session.testAgent.post('/v2/workflows').send(workflowBody);
      expect(response.status).to.equal(201);
      const workflow: WorkflowResponseDto = response.body.data;

      subscriber = await subscriberService.createSubscriber({
        firstName: 'John',
        lastName: 'Doe',
        phone: '+1234567890',
      });

      const triggerResponse = await novuClient.trigger({
        workflowId: workflow.workflowId,
        to: [subscriber.subscriberId],
        payload: {
          firstName: subscriber.firstName,
        },
      });

      expect(triggerResponse.result.status).to.equal('processed');
      expect(triggerResponse.result.acknowledged).to.equal(true);

      await session.waitForJobCompletion(workflow._id);

      const messages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
      });

      expect(messages.length).to.equal(2);

      const smsMessage = messages.find((message) => message.channel === ChannelTypeEnum.SMS);
      const inAppMessage = messages.find((message) => message.channel === ChannelTypeEnum.IN_APP);

      expect(smsMessage).to.exist;
      expect(inAppMessage).to.exist;

      expect(smsMessage?.content).to.equal('Hello John, this is a test SMS');
      expect(inAppMessage?.content).to.equal('Welcome John! This is an in-app notification');
    });

    it('should handle complex conditions logic with subscriber data', async () => {
      const workflowBody: CreateWorkflowDto = {
        name: 'Test Complex Conditions Logic',
        workflowId: 'test-complex-conditions-workflow',
        __source: WorkflowCreationSourceEnum.DASHBOARD,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            name: 'Message Name',
            controlValues: {
              body: 'Hello {{subscriber.lastName}}, Welcome!',
              skip: {
                and: [
                  {
                    or: [
                      { '==': [{ var: 'subscriber.firstName' }, 'John'] },
                      { '==': [{ var: 'subscriber.data.role' }, 'admin'] },
                    ],
                  },
                  {
                    and: [
                      { '>=': [{ var: 'payload.userScore' }, 100] },
                      { '==': [{ var: 'subscriber.lastName' }, 'Doe'] },
                    ],
                  },
                ],
              },
            },
          },
        ],
      };

      const response = await session.testAgent.post('/v2/workflows').send(workflowBody);
      expect(response.status).to.equal(201);
      const workflow: WorkflowResponseDto = response.body.data;

      // Should execute step - matches all conditions
      subscriber = await subscriberService.createSubscriber({
        firstName: 'John',
        lastName: 'Doe',
        data: { role: 'admin' },
      });

      await novuClient.trigger({
        workflowId: workflow.workflowId,
        to: [subscriber.subscriberId],
        payload: {
          userScore: 150,
        },
      });
      await session.waitForJobCompletion(workflow._id);
      const messages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
      });
      expect(messages.length).to.equal(1);

      // Should not execute step - doesn't match lastName condition
      subscriber = await subscriberService.createSubscriber({
        firstName: 'John',
        lastName: 'Smith',
        data: { role: 'admin' },
      });

      await novuClient.trigger({
        workflowId: workflow.workflowId,
        to: [subscriber.subscriberId],
        payload: {
          userScore: 150,
        },
      });

      await session.waitForJobCompletion(workflow._id);
      const skippedMessages1 = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
      });
      expect(skippedMessages1.length).to.equal(0);

      // Should not execute step - doesn't match score condition
      subscriber = await subscriberService.createSubscriber({
        firstName: 'John',
        lastName: 'Doe',
        data: { role: 'admin' },
      });

      await novuClient.trigger({
        workflowId: workflow.workflowId,
        to: [subscriber.subscriberId],
        payload: {
          userScore: 50,
        },
      });

      await session.waitForJobCompletion(workflow._id);
      const skippedMessages2 = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
      });
      expect(skippedMessages2.length).to.equal(0);
    });

    it('should exit execution if skip condition execution throws an error', async () => {
      const workflowBody: CreateWorkflowDto = {
        name: 'Test Complex Skip Logic',
        workflowId: 'test-complex-skip-workflow',
        __source: WorkflowCreationSourceEnum.DASHBOARD,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            name: 'Message Name',
            controlValues: {
              body: 'Hello {{subscriber.lastName}}, Welcome!',
              skip: { invalidOp: [1, 2] }, // INVALID OPERATOR
            },
          },
        ],
      };

      const response = await session.testAgent.post('/v2/workflows').send(workflowBody);
      expect(response.status).to.equal(201);
      const workflow: WorkflowResponseDto = response.body.data;

      subscriber = await subscriberService.createSubscriber({
        firstName: 'John',
        lastName: 'Doe',
        data: { role: 'admin' },
      });

      await novuClient.trigger({
        workflowId: workflow.workflowId,
        to: [subscriber.subscriberId],
        payload: {
          userScore: 150,
        },
      });
      await session.waitForJobCompletion(workflow._id);
      const executionDetails = await executionDetailsRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: subscriber._id,
        channel: ChannelTypeEnum.IN_APP,
        status: ExecutionDetailsStatusEnum.FAILED,
      });

      expect(executionDetails?.raw).to.contain('Failed to evaluate rule');
      expect(executionDetails?.raw).to.contain('Unrecognized operation invalidOp');
    });
  });

  describe('Subscriber Schedule Logic', () => {
    const isSubscribersScheduleEnabled = process.env.IS_SUBSCRIBERS_SCHEDULE_ENABLED;

    beforeEach(async () => {
      // Enable the feature flag for schedule tests
      // @ts-expect-error process.env is not typed
      process.env.IS_SUBSCRIBERS_SCHEDULE_ENABLED = 'true';
    });

    afterEach(() => {
      // Restore the original feature flag state
      // @ts-expect-error process.env is not typed
      process.env.IS_SUBSCRIBERS_SCHEDULE_ENABLED = isSubscribersScheduleEnabled;
    });

    // Helper function to create a schedule that's outside current time
    function createScheduleOutsideCurrentTime(timezone: string = 'America/New_York') {
      const now = new Date();
      const localTime = new Date(now.toLocaleString('en-US', { timeZone: timezone }));
      const currentHour = localTime.getHours();
      const currentDay = localTime.getDay();

      const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
      const currentDayName = dayNames[currentDay];

      // Create a schedule that's outside current time
      const isCurrentlyInBusinessHours = currentHour >= 9 && currentHour < 17;
      const scheduleHours = isCurrentlyInBusinessHours
        ? [{ start: '06:00 PM', end: '10:00 PM' }] // Outside business hours
        : [{ start: '09:00 AM', end: '05:00 PM' }]; // Business hours

      const weeklySchedule = {
        sunday: { isEnabled: false },
        monday: { isEnabled: false },
        tuesday: { isEnabled: false },
        wednesday: { isEnabled: false },
        thursday: { isEnabled: false },
        friday: { isEnabled: false },
        saturday: { isEnabled: false },
      };

      weeklySchedule[currentDayName] = {
        isEnabled: true,
        hours: scheduleHours,
      };

      return { weeklySchedule, currentDayName };
    }

    // Helper function to create a schedule that includes current time
    function createScheduleIncludingCurrentTime(timezone: string = 'America/New_York') {
      const now = new Date();
      const localTime = new Date(now.toLocaleString('en-US', { timeZone: timezone }));
      const currentHour = localTime.getHours();
      const currentDay = localTime.getDay();

      const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
      const currentDayName = dayNames[currentDay];

      // Create a schedule that includes current time
      let scheduleHours;
      if (currentHour >= 9 && currentHour < 17) {
        // Current time is in business hours, use business hours schedule
        scheduleHours = [{ start: '09:00 AM', end: '05:00 PM' }];
      } else {
        // Current time is outside business hours, create a schedule around current time
        const startHour = Math.max(0, currentHour - 1);
        const endHour = Math.min(23, currentHour + 1);
        const startTime = `${startHour.toString().padStart(2, '0')}:00 ${startHour < 12 ? 'AM' : 'PM'}`;
        const endTime = `${endHour.toString().padStart(2, '0')}:00 ${endHour < 12 ? 'AM' : 'PM'}`;
        scheduleHours = [{ start: startTime, end: endTime }];
      }

      const weeklySchedule = {
        sunday: { isEnabled: false },
        monday: { isEnabled: false },
        tuesday: { isEnabled: false },
        wednesday: { isEnabled: false },
        thursday: { isEnabled: false },
        friday: { isEnabled: false },
        saturday: { isEnabled: false },
      };

      weeklySchedule[currentDayName] = {
        isEnabled: true,
        hours: scheduleHours,
      };

      return { weeklySchedule, currentDayName };
    }

    it('should skip email message when outside subscriber schedule', async () => {
      // Create a subscriber with a schedule that only allows messages between 9 AM - 5 PM
      const scheduledSubscriber = await subscriberService.createSubscriber({
        subscriberId: 'scheduled-subscriber',
        timezone: 'America/New_York', // EST timezone
      });

      // Create a schedule that's outside current time
      const { weeklySchedule } = createScheduleOutsideCurrentTime('America/New_York');

      await session.testAgent
        .patch(`/v2/subscribers/${scheduledSubscriber.subscriberId}/preferences`)
        .send({
          schedule: {
            isEnabled: true,
            weeklySchedule,
          },
        })
        .set('Authorization', `ApiKey ${session.apiKey}`);

      const workflowBody: CreateWorkflowDto = {
        name: 'Test Email Workflow',
        workflowId: 'test-email-workflow',
        __source: WorkflowCreationSourceEnum.DASHBOARD,
        steps: [
          {
            type: StepTypeEnum.EMAIL,
            name: 'Message Name',
            controlValues: {
              subject: 'Subject',
              editorType: 'html',
              body: 'Body',
            },
          },
        ],
      };

      const workflowResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
      const workflow: WorkflowResponseDto = workflowResponse.body.data;

      // Trigger the event
      const triggerResponse = await novuClient.trigger({
        workflowId: workflowBody.workflowId,
        to: [scheduledSubscriber.subscriberId],
        payload: {
          firstName: 'Test User',
        },
      });

      expect(triggerResponse.result).to.be.ok;

      // Wait for job processing
      await session.waitForJobCompletion(workflow._id);

      // Check that the email job was canceled due to schedule
      const jobs = await jobRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: scheduledSubscriber._id,
        _templateId: workflow._id,
        type: StepTypeEnum.EMAIL,
      });

      expect(jobs).to.have.length(1);

      // Schedule logic is working - expect CANCELED status
      expect(jobs[0].status).to.equal(JobStatusEnum.CANCELED);

      // Check execution details for schedule skip reason (if schedule logic is working)
      const executionDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: scheduledSubscriber._id,
        _templateId: workflow._id,
        detail: DetailEnum.SKIPPED_STEP_OUTSIDE_OF_THE_SCHEDULE,
      });

      // Check if execution details exist (schedule logic might be inconsistent)
      if (executionDetails.length > 0) {
        expect(executionDetails).to.have.length(1);
        expect(executionDetails[0].status).to.equal(ExecutionDetailsStatusEnum.SUCCESS);
      } else {
        // If no execution details, just verify the job was canceled
        expect(jobs[0].status).to.equal(JobStatusEnum.CANCELED);
      }
    });

    it('should deliver email message when within subscriber schedule', async () => {
      // Create a subscriber with a schedule
      const scheduledSubscriber = await subscriberService.createSubscriber({
        subscriberId: 'scheduled-subscriber-within',
        timezone: 'America/New_York',
      });

      // Create a schedule that includes current time
      const { weeklySchedule } = createScheduleIncludingCurrentTime('America/New_York');

      await session.testAgent
        .patch(`/v2/subscribers/${scheduledSubscriber.subscriberId}/preferences`)
        .send({
          schedule: {
            isEnabled: true,
            weeklySchedule,
          },
        })
        .set('Authorization', `ApiKey ${session.apiKey}`);

      const workflowBody: CreateWorkflowDto = {
        name: 'Test Email Workflow',
        workflowId: 'test-email-workflow',
        __source: WorkflowCreationSourceEnum.DASHBOARD,
        steps: [
          {
            name: 'Email Test Step',
            type: StepTypeEnum.EMAIL,
            controlValues: {
              subject: 'Test Email Subject',
              body: 'Test Email Body',
              disableOutputSanitization: false,
            },
          },
        ],
      };

      const workflowResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
      const workflow: WorkflowResponseDto = workflowResponse.body.data;

      // Trigger the event
      const triggerResponse = await novuClient.trigger({
        workflowId: workflowBody.workflowId,
        to: [scheduledSubscriber.subscriberId],
        payload: {
          firstName: 'Test User',
        },
      });

      expect(triggerResponse.result).to.be.ok;

      // Wait for job processing
      await session.waitForJobCompletion(workflow._id);

      const message = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: scheduledSubscriber._id,
        channel: ChannelTypeEnum.EMAIL,
      });

      expect(message).to.be.ok;
      expect(message?.subject).to.equal('Test Email Subject');
      expect(message?.content).to.contain('Test Email Body');

      // Check that no schedule skip execution details were created
      const scheduleSkipDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: scheduledSubscriber._id,
        _templateId: workflow._id,
        detail: DetailEnum.SKIPPED_STEP_OUTSIDE_OF_THE_SCHEDULE,
      });

      expect(scheduleSkipDetails).to.have.length(0);
    });

    it('should always deliver in-app messages regardless of schedule', async () => {
      // Create a subscriber with a restrictive schedule
      const scheduledSubscriber = await subscriberService.createSubscriber({
        subscriberId: 'scheduled-subscriber-inapp',
        timezone: 'America/New_York',
      });

      // Set up a very restrictive schedule (only 1 hour window)
      await session.testAgent
        .patch(`/v2/subscribers/${scheduledSubscriber.subscriberId}/preferences`)
        .send({
          schedule: {
            isEnabled: true,
            weeklySchedule: {
              monday: {
                isEnabled: true,
                hours: [{ start: '02:00 PM', end: '03:00 PM' }], // Very restrictive 1-hour window
              },
              tuesday: { isEnabled: false },
              wednesday: { isEnabled: false },
              thursday: { isEnabled: false },
              friday: { isEnabled: false },
              saturday: { isEnabled: false },
              sunday: { isEnabled: false },
            },
          },
        })
        .set('Authorization', `ApiKey ${session.apiKey}`);

      const workflowBody: CreateWorkflowDto = {
        name: 'Test In-App Workflow',
        workflowId: 'test-in-app-workflow',
        __source: WorkflowCreationSourceEnum.DASHBOARD,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            name: 'Message Name',
            controlValues: {
              subject: 'Subject',
              body: 'Body',
            },
          },
        ],
      };

      const workflowResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
      const workflow: WorkflowResponseDto = workflowResponse.body.data;

      // Trigger the event (regardless of current time)
      const response = await novuClient.trigger({
        workflowId: workflowBody.workflowId,
        to: [scheduledSubscriber.subscriberId],
        payload: {
          firstName: 'Test User',
        },
      });

      expect(response.result).to.be.ok;

      // Wait for job processing
      await session.waitForJobCompletion(workflow._id);

      // Check that the in-app job was completed successfully (not skipped)
      const jobs = await jobRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: scheduledSubscriber._id,
        _templateId: workflow._id,
        type: StepTypeEnum.IN_APP,
      });

      expect(jobs).to.have.length(1);
      expect(jobs[0].status).to.equal(JobStatusEnum.COMPLETED);

      const message = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: scheduledSubscriber._id,
        channel: ChannelTypeEnum.IN_APP,
      });

      expect(message).to.be.ok;
      expect(message?.subject).to.equal('Subject');
      expect(message?.content).to.equal('Body');

      // Check that no schedule skip execution details were created
      const scheduleSkipDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: scheduledSubscriber._id,
        _templateId: workflow._id,
        detail: DetailEnum.SKIPPED_STEP_OUTSIDE_OF_THE_SCHEDULE,
      });

      expect(scheduleSkipDetails).to.have.length(0);
    });

    it('should always deliver critical messages regardless of schedule', async () => {
      // Create a subscriber with a restrictive schedule
      const scheduledSubscriber = await subscriberService.createSubscriber({
        subscriberId: 'scheduled-subscriber-critical',
        timezone: 'America/New_York',
      });

      // Set up a very restrictive schedule (only 1 hour window)
      await session.testAgent
        .patch(`/v2/subscribers/${scheduledSubscriber.subscriberId}/preferences`)
        .send({
          schedule: {
            isEnabled: true,
            weeklySchedule: {
              monday: {
                isEnabled: true,
                hours: [{ start: '02:00 PM', end: '03:00 PM' }], // Very restrictive 1-hour window
              },
              tuesday: { isEnabled: false },
              wednesday: { isEnabled: false },
              thursday: { isEnabled: false },
              friday: { isEnabled: false },
              saturday: { isEnabled: false },
              sunday: { isEnabled: false },
            },
          },
        })
        .set('Authorization', `ApiKey ${session.apiKey}`);

      const workflowBody: CreateWorkflowDto = {
        name: 'Test Critical Email Workflow',
        workflowId: 'test-critical-email-workflow',
        __source: WorkflowCreationSourceEnum.DASHBOARD,
        steps: [
          {
            name: 'Email Test Step',
            type: StepTypeEnum.EMAIL,
            controlValues: {
              subject: 'Test Email Subject',
              body: 'Test Email Body',
              disableOutputSanitization: false,
            },
          },
        ],
        preferences: {
          user: {
            all: {
              enabled: true,
              readOnly: true,
            },
            channels: {
              email: {
                enabled: true,
              },
              in_app: {
                enabled: true,
              },
              sms: {
                enabled: true,
              },
              chat: {
                enabled: true,
              },
              push: {
                enabled: true,
              },
            },
          },
        },
      };

      const workflowResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
      const workflow: WorkflowResponseDto = workflowResponse.body.data;

      // Trigger the event (critical messages should always deliver)
      const response = await novuClient.trigger({
        workflowId: workflowBody.workflowId,
        to: [scheduledSubscriber.subscriberId],
        payload: {
          firstName: 'Test User',
        },
      });

      expect(response.result).to.be.ok;

      // Wait for job processing
      await session.waitForJobCompletion(workflow._id);

      const message = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: scheduledSubscriber._id,
        channel: ChannelTypeEnum.EMAIL,
      });

      expect(message).to.be.ok;
      expect(message?.subject).to.equal('Test Email Subject');
      expect(message?.content).to.contain('Test Email Body');

      // Check that no schedule skip execution details were created
      const scheduleSkipDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: scheduledSubscriber._id,
        _templateId: workflow._id,
        detail: DetailEnum.SKIPPED_STEP_OUTSIDE_OF_THE_SCHEDULE,
      });

      expect(scheduleSkipDetails).to.have.length(0);
    });

    it('should skip digest messages when outside subscriber schedule', async () => {
      // Create a subscriber with a schedule
      const scheduledSubscriber = await subscriberService.createSubscriber({
        subscriberId: 'scheduled-subscriber-digest-outside',
        timezone: 'America/New_York',
      });

      // Create a schedule that's outside current time
      const { weeklySchedule } = createScheduleOutsideCurrentTime('America/New_York');

      await session.testAgent
        .patch(`/v2/subscribers/${scheduledSubscriber.subscriberId}/preferences`)
        .send({
          schedule: {
            isEnabled: true,
            weeklySchedule,
          },
        })
        .set('Authorization', `ApiKey ${session.apiKey}`);

      const workflowBody: CreateWorkflowDto = {
        name: 'Test Email Workflow',
        workflowId: 'test-email-workflow',
        __source: WorkflowCreationSourceEnum.DASHBOARD,
        steps: [
          {
            name: 'DigestStep',
            type: StepTypeEnum.DIGEST,
            controlValues: {
              amount: 5,
              unit: 'seconds',
            },
          },
          {
            type: StepTypeEnum.EMAIL,
            name: 'Message Name',
            controlValues: {
              subject: 'Subject',
              editorType: 'html',
              body: 'Body',
            },
          },
        ],
      };

      const workflowResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
      const workflow: WorkflowResponseDto = workflowResponse.body.data;

      // Trigger the event
      const response = await novuClient.trigger({
        workflowId: workflowBody.workflowId,
        to: [scheduledSubscriber.subscriberId],
        payload: {
          firstName: 'Test User',
        },
      });

      expect(response.result).to.be.ok;

      // Wait for job processing (digest jobs need more time)
      await session.waitForJobCompletion(workflow._id);

      // Check that the digest job was canceled due to schedule
      const jobs = await jobRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: scheduledSubscriber._id,
        _templateId: workflow._id,
      });

      expect(jobs).to.have.length(3);
      expect(jobs.find((job) => job.type === StepTypeEnum.TRIGGER)?.status).to.equal(JobStatusEnum.COMPLETED);
      expect(jobs.find((job) => job.type === StepTypeEnum.DIGEST)?.status).to.equal(JobStatusEnum.COMPLETED);
      expect(jobs.find((job) => job.type === StepTypeEnum.EMAIL)?.status).to.equal(JobStatusEnum.CANCELED);

      // Check execution details for schedule skip reason (if schedule logic is working)
      const executionDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: scheduledSubscriber._id,
        _templateId: workflow._id,
        detail: DetailEnum.SKIPPED_STEP_OUTSIDE_OF_THE_SCHEDULE,
      });

      // Check if execution details exist (schedule logic might be inconsistent)
      if (executionDetails.length > 0) {
        expect(executionDetails).to.have.length(1);
        expect(executionDetails[0].status).to.equal(ExecutionDetailsStatusEnum.SUCCESS);
      }
    });

    it('should deliver digest messages when within subscriber schedule', async () => {
      // Create a subscriber with a schedule
      const scheduledSubscriber = await subscriberService.createSubscriber({
        subscriberId: 'scheduled-subscriber-digest-within',
        timezone: 'America/New_York',
      });

      // Create a schedule that includes current time
      const { weeklySchedule } = createScheduleIncludingCurrentTime('America/New_York');

      await session.testAgent
        .patch(`/v2/subscribers/${scheduledSubscriber.subscriberId}/preferences`)
        .send({
          schedule: {
            isEnabled: true,
            weeklySchedule,
          },
        })
        .set('Authorization', `ApiKey ${session.apiKey}`);

      const workflowBody: CreateWorkflowDto = {
        name: 'Test Email Workflow',
        workflowId: 'test-email-workflow',
        __source: WorkflowCreationSourceEnum.DASHBOARD,
        steps: [
          {
            name: 'DigestStep',
            type: StepTypeEnum.DIGEST,
            controlValues: {
              amount: 5,
              unit: 'seconds',
            },
          },
          {
            name: 'Email Test Step',
            type: StepTypeEnum.EMAIL,
            controlValues: {
              subject: 'Test Email Subject',
              body: 'Test Email Body',
              disableOutputSanitization: false,
            },
          },
        ],
      };

      const workflowResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
      const workflow: WorkflowResponseDto = workflowResponse.body.data;

      // Trigger the event
      const response = await novuClient.trigger({
        workflowId: workflowBody.workflowId,
        to: [scheduledSubscriber.subscriberId],
        payload: {
          firstName: 'Test User',
        },
      });

      expect(response.result).to.be.ok;

      // Wait for job processing (digest jobs need more time)
      await session.waitForJobCompletion(workflow._id);

      // Check that the digest job was completed successfully
      const jobs = await jobRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: scheduledSubscriber._id,
        _templateId: workflow._id,
      });

      expect(jobs).to.have.length(3);
      expect(jobs.find((job) => job.type === StepTypeEnum.TRIGGER)?.status).to.equal(JobStatusEnum.COMPLETED);
      expect(jobs.find((job) => job.type === StepTypeEnum.DIGEST)?.status).to.equal(JobStatusEnum.COMPLETED);

      const message = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: scheduledSubscriber._id,
        channel: ChannelTypeEnum.EMAIL,
      });

      expect(message).to.be.ok;
      expect(message?.subject).to.equal('Test Email Subject');
      expect(message?.content).to.contain('Test Email Body');

      // Check that no schedule skip execution details were created
      const scheduleSkipDetails = await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: scheduledSubscriber._id,
        _templateId: workflow._id,
        detail: DetailEnum.SKIPPED_STEP_OUTSIDE_OF_THE_SCHEDULE,
      });

      expect(scheduleSkipDetails).to.have.length(0);
    });

    it('should deliver digest messages when subscriber schedule is disabled', async () => {
      // Create a subscriber with a schedule
      const scheduledSubscriber = await subscriberService.createSubscriber({
        subscriberId: 'scheduled-subscriber-digest-within',
        timezone: 'America/New_York',
      });

      await session.testAgent
        .patch(`/v2/subscribers/${scheduledSubscriber.subscriberId}/preferences`)
        .send({
          schedule: {
            isEnabled: false,
          },
        })
        .set('Authorization', `ApiKey ${session.apiKey}`);

      const workflowBody: CreateWorkflowDto = {
        name: 'Test Email Workflow',
        workflowId: 'test-email-workflow',
        __source: WorkflowCreationSourceEnum.DASHBOARD,
        steps: [
          {
            name: 'DigestStep',
            type: StepTypeEnum.DIGEST,
            controlValues: {
              amount: 5,
              unit: 'seconds',
            },
          },
          {
            name: 'Email Test Step',
            type: StepTypeEnum.EMAIL,
            controlValues: {
              subject: 'Test Email Subject',
              body: 'Test Email Body',
              disableOutputSanitization: false,
            },
          },
        ],
      };

      const workflowResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
      const workflow: WorkflowResponseDto = workflowResponse.body.data;

      // Trigger the event
      const response = await novuClient.trigger({
        workflowId: workflowBody.workflowId,
        to: [scheduledSubscriber.subscriberId],
        payload: {
          firstName: 'Test User',
        },
      });

      expect(response.result).to.be.ok;

      // Wait for job processing (digest jobs need more time)
      await session.waitForJobCompletion(workflow._id);

      // Check that the digest job was completed successfully
      const jobs = await jobRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: scheduledSubscriber._id,
        _templateId: workflow._id,
      });

      expect(jobs).to.have.length(3);
      expect(jobs.find((job) => job.type === StepTypeEnum.TRIGGER)?.status).to.equal(JobStatusEnum.COMPLETED);
      expect(jobs.find((job) => job.type === StepTypeEnum.DIGEST)?.status).to.equal(JobStatusEnum.COMPLETED);

      const message = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: scheduledSubscriber._id,
        channel: ChannelTypeEnum.EMAIL,
      });

      expect(message).to.be.ok;
      expect(message?.subject).to.equal('Test Email Subject');
      expect(message?.content).to.contain('Test Email Body');
    });
  });
});

async function createTemplate(session, channelType) {
  return await session.createTemplate({
    steps: [
      {
        type: channelType,
        content: 'Hello {{subscriber.lastName}}, Welcome to {{organizationName}}' as string,
      },
    ],
  });
}
async function createSimpleWorkflow(session) {
  return await session.createTemplate({
    steps: [
      {
        type: StepTypeEnum.EMAIL,
        content: 'Hello world {{firstName}}' as string,
      },
    ],
  });
}

function simpleTrigger(novuClient: Novu, template, subscriberID: string) {
  return novuClient.trigger({
    workflowId: template.triggers[0].identifier,
    to: [subscriberID],
    payload: {
      firstName: 'Testing of User Name',
      phone: '+972541111111',
    },
  });
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - sendTrigger(templateInner: NotificationTemplateEntity,
    newSubscriberIdInAppNotification: string,
    payload: Record<string, unknown> = {},
    overrides: Record<string, Record<string, unknown>> = {},
    tenant?: string,
    actor?: string)
 - test()
 - test()
 - createScheduleOutsideCurrentTime(timezone: string = 'America/New_York')
 - createScheduleIncludingCurrentTime(timezone: string = 'America/New_York')
 - createTemplate(session, channelType)
 - createSimpleWorkflow(session)
 - simpleTrigger(novuClient: Novu, template, subscriberID: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - promiseTimeout(ms: number): Promise<void>)
 - tenantRepository(new TenantRepository();
  let novuClient: Novu;

  beforeEach(async ())
 - novuClient(initNovuClassSdk(session);
  });

  describe(`Trigger Event - /v1/events/trigger (POST)`, ())
 - executionDetails(await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _no...)
 - executionDetails(await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _no...)
 - executionDetails(await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _no...)
 - executionDetails(await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _no...)
 - executionDetails(await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _no...)
 - executionDetails(await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _no...)
 - executionDetails(await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _no...)
 - executionDetails(await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _no...)
 - message(await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscrib...)
 - secondMessage(await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscrib...)
 - result(await sendTrigger(template, subscriber.subscriberId, {}, {}, 'test1');

      expect(result.status)....)
 - body(response.result;

      expect(body).to.be.ok;
      expect(body.status).to.equal('processed');
    ...)
 - inAppMessage(message.find((msg))
 - emailMessage(message.find((msg))
 - emailJob(await jobRepository.findOne({
        _id: emailMessage?._jobId,
        _environmentId: session.env...)
 - createdSubscriber(await subscriberRepository.findBySubscriberId(envId, subscriberId);

      expect(createdSubscriber?...)
 - updatedSubscriber(await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);

      expect(...)
 - updatedSubscriber(await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);

        expec...)
 - updatedSubscriber(await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);

      expect(...)
 - createdSubscriber(await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);

      await m...)
 - email(emails[0];

      expect(email.channel).to.equal(ChannelTypeEnum.EMAIL);
    });

    it('should cor...)
 - createdAt(new Date(email?.createdAt as string);
    });

    it('should trigger SMS notification', async ())
 - message(await messageRepository._model.findOne({
        _environmentId: session.environment._id,
        _t...)
 - message2(await messageRepository._model.findOne({
        _environmentId: session.environment._id,
        _t...)
 - message(await messageRepository._model.findOne({
        _environmentId: session.environment._id,
        _t...)
 - message(await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscrib...)
 - message(await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscrib...)
 - block(message!.content[0] as IEmailBlock;

      expect(block.content).to.equal('Hello Smith, Welcome to U...)
 - block(message!.content[0] as IEmailBlock;

      expect(block.content).to.equal('Hello Actor, Welcome to U...)
 - message(await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscrib...)
 - integrationIdsToDelete(existingIntegrations.flatMap((integration))
 - message(await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscrib...)
 - messages(await messageRepository.find(
        {
          _environmentId: session.environment._id,
         ...)
 - response(await session.testAgent
        .post('/v1/events/trigger')
        .send({
          name: template...)
 - block(message!.content[0] as IEmailBlock;

      expect(block.content).to.equal('Hello John Doe, Welcome t...)
 - template(await session.createTemplate({
        steps: [
          {
            name: 'Message Name',
      ...)
 - isUnique(value, index, self))
 - subscriberIds(messages.map((message))
 - messages(await messageRepository.count({
        _environmentId: session.environment._id,
        _templateId...)
 - messages(await messageRepository.count({
        _environmentId: session.environment._id,
        _templateId...)
 - messages(await messageRepository.count({
        _environmentId: session.environment._id,
        _templateId...)
 - messages(await messageRepository.count({
        _environmentId: session.environment._id,
        _templateId...)
 - messages(await messageRepository.find({
        _environmentId: session.environment._id,
        _templateId:...)
 - subscriberModel(subscriberRepository._model;
        subscriberModel.collection
          .getIndexes()
          .t...)
 - subscribers(await subscriberRepository.find({
            _environmentId: session.environment._id,
            s...)
 - subscriber(await subscriberService.createSubscriber();
      });

      it('should filter a message with variab...)
 - messages(await messageRepository.count({
          _environmentId: session.environment._id,
          _templa...)
 - messages(await messageRepository.count({
          _environmentId: session.environment._id,
          _templa...)
 - messages(await messageRepository.find({
          _environmentId: session.environment._id,
          _templat...)
 - messages(await messageRepository.find(
          {
            _environmentId: session.environment._id,
     ...)
 - messages(await messageRepository.find({
            _environmentId: session.environment._id,
            _sub...)
 - messages(await messageRepository.find({
            _environmentId: session.environment._id,
            _sub...)
 - messages(await messageRepository.find({
            _environmentId: session.environment._id,
            _sub...)
 - messagesAfter(await messageRepository.find({
            _environmentId: session.environment._id,
            _sub...)
 - messagesAfter(await messageRepository.find({
            _environmentId: session.environment._id,
            _sub...)
 - workflowOverrideService(new WorkflowOverrideService({
            organizationId: session.organization._id,
            envi...)
 - messages2(await messageRepository.find({
            _environmentId: session.environment._id,
            _tem...)
 - messages2(await messageRepository.find({
            _environmentId: session.environment._id,
            _tem...)
 - messages(await messageRepository.find({
            _environmentId: session.environment._id,
            _tem...)
 - request({
      workflowId: templateInner.triggers[0].identifier,
      to: [{ subscriberId: newSubscriberId...)
 - organizationRepository(new CommunityOrganizationRepository();
      // Set removeNovuBranding to true for these tests to av...)
 - message(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - notSkippedMessages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - smsMessage(messages.find((message))
 - inAppMessage(messages.find((message))
 - skippedMessages2(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - executionDetails(await executionDetailsRepository.findOne({
        _environmentId: session.environment._id,
        ...)
 - isSubscribersScheduleEnabled(process.env.IS_SUBSCRIBERS_SCHEDULE_ENABLED;

    beforeEach(async ())
 - IS_SUBSCRIBERS_SCHEDULE_ENABLED('true';
    });

    afterEach(())
 - executionDetails(await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _su...)
 - scheduleSkipDetails(await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _su...)
 - scheduleSkipDetails(await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _su...)
 - scheduleSkipDetails(await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _su...)
 - jobs(await jobRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: s...)
 - executionDetails(await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _su...)
 - jobs(await jobRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: s...)
 - scheduleSkipDetails(await executionDetailsRepository.find({
        _environmentId: session.environment._id,
        _su...)
 - jobs(await jobRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: s...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/utils/poll-for-job-status-change.util.ts
TamaÃ±o: 1491 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { JobEntity, JobRepository, JobStatusEnum } from '@novu/dal';
import { sleep } from './sleep.util';

type EnforceEnvOrOrgIds = { _environmentId: string } | { _organizationId: string };

interface IPollForJobOptions {
  jobRepository: JobRepository;
  query: Partial<JobEntity> & EnforceEnvOrOrgIds;
  timeout?: number;
  pollInterval?: number;
}

// Function overloads to make return type conditional based on findMultiple
export async function pollForJobStatusChange(
  options: IPollForJobOptions & { findMultiple: true }
): Promise<JobEntity[] | null>;

export async function pollForJobStatusChange(
  options: IPollForJobOptions & { findMultiple?: false }
): Promise<JobEntity | null>;

export async function pollForJobStatusChange({
  jobRepository,
  query,
  timeout = 5000,
  pollInterval = 100,
  findMultiple = false,
}: IPollForJobOptions & { findMultiple?: boolean }): Promise<JobEntity | JobEntity[] | null> {
  const startTime = Date.now();

  while (true) {
    if (findMultiple) {
      const jobs = await jobRepository.find(query);

      if (jobs.length > 0 && jobs.every((job: JobEntity) => job.status !== JobStatusEnum.PENDING)) {
        return jobs;
      }
    } else {
      const job = await jobRepository.findOne(query);

      if (job && job.status !== JobStatusEnum.PENDING) {
        return job;
      }
    }

    if (Date.now() - startTime > timeout) {
      return findMultiple ? ([] as JobEntity[]) : null;
    }

    await sleep(pollInterval);
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - pollForJobStatusChange(options: IPollForJobOptions & { findMultiple: true })
 - pollForJobStatusChange(options: IPollForJobOptions & { findMultiple?: false })
 - pollForJobStatusChange({
  jobRepository,
  query,
  timeout = 5000,
  pollInterval = 100,
  findMultiple = false,
}: IPollForJobOptions & { findMultiple?: boolean })
Asignaciones con arrow functions encontradas (posibles funciones):
 - jobs(await jobRepository.find(query);

      if (jobs.length > 0 && jobs.every((job: JobEntity))
Declaraciones 'export' encontradas:
- export  async
- export  async
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/e2e/utils/sleep.util.ts
TamaÃ±o: 124 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - sleep(ms: number)
Declaraciones 'export' encontradas:
- export function sleep

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/exceptions/payload-validation-exception.ts
TamaÃ±o: 1687 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException } from '@nestjs/common';
import { ErrorObject } from 'ajv';

export interface IPayloadValidationError {
  field: string;
  message: string;
  value?: any;
  schemaPath?: string;
}

export class PayloadValidationException extends BadRequestException {
  constructor(
    public validationErrors: IPayloadValidationError[],
    public schema?: any
  ) {
    const errorMessage = `Payload validation failed: ${validationErrors.map((err) => `${err.field}: ${err.message}`).join('; ')}`;

    super({
      message: errorMessage,
      errors: validationErrors,
      schema,
      type: 'PAYLOAD_VALIDATION_ERROR',
    });
  }

  static fromAjvErrors(ajvErrors: ErrorObject[], payload: any, schema: any): PayloadValidationException {
    const validationErrors: IPayloadValidationError[] = ajvErrors.map((error: ErrorObject) => {
      const path = error.instancePath ? error.instancePath.replace(/^\//, '').replace(/\//g, '.') : 'root';
      const field = error.params?.missingProperty ? `${path ? `${path}.` : ''}${error.params.missingProperty}` : path;

      // Get the actual value that failed validation
      let value: any;
      try {
        if (error.instancePath) {
          const pathParts = error.instancePath.split('/').filter(Boolean);
          value = pathParts.reduce((obj, key) => obj?.[key], payload);
        } else {
          value = payload;
        }
      } catch {
        value = undefined;
      }

      return {
        field,
        message: error.message || 'Validation failed',
        value,
        schemaPath: error.schemaPath,
      };
    });

    return new PayloadValidationException(validationErrors, schema);
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - errorMessage(`Payload validation failed: ${validationErrors.map((err))
 - value(pathParts.reduce((obj, key))
Declaraciones 'export' encontradas:
- export  interface
- export class PayloadValidationException

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/index.ts
TamaÃ±o: 477 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CancelDelayed } from './cancel-delayed';
import { ParseEventRequest } from './parse-event-request';
import { ProcessBulkTrigger } from './process-bulk-trigger';
import { SendTestEmail } from './send-test-email';
import { TriggerEventToAll } from './trigger-event-to-all';
import { VerifyPayload } from './verify-payload';

export const USE_CASES = [
  CancelDelayed,
  TriggerEventToAll,
  VerifyPayload,
  ParseEventRequest,
  ProcessBulkTrigger,
  SendTestEmail,
];


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/cancel-delayed/cancel-delayed.command.ts
TamaÃ±o: 270 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class CancelDelayedCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  transactionId: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class CancelDelayedCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/cancel-delayed/cancel-delayed.usecase.ts
TamaÃ±o: 5966 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import {
  isActionStepType,
  isMainDigest,
  LogRepository,
  MessageInteractionService,
  MessageInteractionTrace,
  PinoLogger,
  StepRunRepository,
  StepType,
} from '@novu/application-generic';
import { JobEntity, JobRepository, JobStatusEnum } from '@novu/dal';
import { DeliveryLifecycleDetail, DeliveryLifecycleStatusEnum, StepTypeEnum } from '@novu/shared';

import { CancelDelayedCommand } from './cancel-delayed.command';

@Injectable()
export class CancelDelayed {
  constructor(
    private jobRepository: JobRepository,
    private stepRunRepository: StepRunRepository,
    private messageInteractionService: MessageInteractionService,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  public async execute(command: CancelDelayedCommand): Promise<boolean> {
    let jobs: JobEntity[] = await this.jobRepository.find({
      _environmentId: command.environmentId,
      transactionId: command.transactionId,
      status: [JobStatusEnum.DELAYED, JobStatusEnum.MERGED],
    });

    if (!jobs?.length) {
      return false;
    }

    if (jobs.find((job) => job.type && isActionStepType(job.type))) {
      const possiblePendingJobs: JobEntity[] = await this.jobRepository.find({
        _environmentId: command.environmentId,
        transactionId: command.transactionId,
        status: [JobStatusEnum.PENDING],
      });

      jobs = [...jobs, ...possiblePendingJobs];
    }

    await this.jobRepository.update(
      {
        _environmentId: command.environmentId,
        _id: {
          $in: jobs.map((job) => job._id),
        },
      },
      {
        $set: {
          status: JobStatusEnum.CANCELED,
          deliveryLifecycleState: {
            status: DeliveryLifecycleStatusEnum.CANCELED,
            detail: DeliveryLifecycleDetail.EXECUTION_CANCELED_BY_USER,
          },
        },
      }
    );

    await this.recordCancellationTraces(jobs);

    await this.stepRunRepository.createMany(jobs, {
      status: JobStatusEnum.CANCELED,
    });

    const mainDigestJob = jobs.find((job) => isMainDigest(job.type, job.status));

    if (!mainDigestJob) {
      return true;
    }

    return await this.assignNextDigestJob(mainDigestJob);
  }

  private async assignNextDigestJob(job: JobEntity) {
    const mainFollowerDigestJob = await this.jobRepository.findOne(
      {
        _mergedDigestId: job._id,
        status: JobStatusEnum.MERGED,
        type: StepTypeEnum.DIGEST,
        _environmentId: job._environmentId,
        _subscriberId: job._subscriberId,
      },
      '',
      {
        query: { sort: { createdAt: 1 } },
      }
    );

    // meaning that only one trigger was send, and it was cancelled in the CancelDelayed.execute
    if (!mainFollowerDigestJob) {
      return true;
    }

    await this.stepRunRepository.create(mainFollowerDigestJob, {
      status: JobStatusEnum.DELAYED,
    });

    // update new main follower from Merged to Delayed
    await this.jobRepository.update(
      {
        _environmentId: job._environmentId,
        status: JobStatusEnum.MERGED,
        _id: mainFollowerDigestJob._id,
      },
      {
        $set: {
          status: JobStatusEnum.DELAYED,
          _mergedDigestId: null,
        },
      }
    );

    // update all main follower children jobs to pending status
    await this.jobRepository.updateAllChildJobStatus(
      mainFollowerDigestJob,
      JobStatusEnum.PENDING,
      mainFollowerDigestJob._id
    );

    // update all jobs that were merged into the old main digest job to point to the new follower
    await this.jobRepository.update(
      {
        _environmentId: job._environmentId,
        status: JobStatusEnum.MERGED,
        _mergedDigestId: job._id,
      },
      {
        $set: {
          _mergedDigestId: mainFollowerDigestJob._id,
        },
      }
    );

    return true;
  }

  private async recordCancellationTraces(jobs: JobEntity[]): Promise<void> {
    try {
      const interactionTraces: MessageInteractionTrace[] = jobs.map((job) => ({
        created_at: LogRepository.formatDateTime64(new Date()),
        organization_id: job._organizationId,
        environment_id: job._environmentId,
        user_id: job._userId || null,
        subscriber_id: job._subscriberId || null,
        external_subscriber_id: job.subscriberId || null,
        event_type: 'step_canceled' as const,
        title: 'Step canceled',
        message: 'Step execution was canceled by Novu platform user',
        raw_data: JSON.stringify({
          message: 'Step execution was canceled by Novu platform user',
        }),
        status: 'success' as const,
        entity_type: 'step_run' as const,
        entity_id: job._id,
        step_run_type: this.mapStepTypeEnumToStepType(job.type) || undefined,
        workflow_run_identifier: job.identifier || '',
        _notificationId: job._notificationId,
      }));

      await this.messageInteractionService.trace(
        interactionTraces,
        DeliveryLifecycleStatusEnum.CANCELED,
        DeliveryLifecycleDetail.EXECUTION_CANCELED_BY_USER
      );
    } catch (error) {
      this.logger.error({ err: error }, 'Failed to create cancel traces');
    }
  }

  private mapStepTypeEnumToStepType(stepType: StepTypeEnum | undefined): StepType | null {
    switch (stepType) {
      case StepTypeEnum.EMAIL:
        return 'email';
      case StepTypeEnum.SMS:
        return 'sms';
      case StepTypeEnum.IN_APP:
        return 'in_app';
      case StepTypeEnum.PUSH:
        return 'push';
      case StepTypeEnum.CHAT:
        return 'chat';
      case StepTypeEnum.DIGEST:
        return 'digest';
      case StepTypeEnum.THROTTLE:
        return 'throttle';
      case StepTypeEnum.TRIGGER:
        return 'trigger';
      case StepTypeEnum.DELAY:
        return 'delay';
      case StepTypeEnum.CUSTOM:
        return 'custom';
      default:
        return null;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - jobs([...jobs, ...possiblePendingJobs];
    }

    await this.jobRepository.update(
      {
        _envi...)
 - mainDigestJob(jobs.find((job))
Declaraciones 'export' encontradas:
- export class CancelDelayed

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/cancel-delayed/index.ts
TamaÃ±o: 123 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { CancelDelayedCommand } from './cancel-delayed.command';
export { CancelDelayed } from './cancel-delayed.usecase';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/parse-event-request/index.ts
TamaÃ±o: 218 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export {
  ParseEventRequestBroadcastCommand,
  ParseEventRequestCommand,
  ParseEventRequestMulticastCommand,
} from './parse-event-request.command';
export { ParseEventRequest } from './parse-event-request.usecase';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/parse-event-request/parse-event-request.command.ts
TamaÃ±o: 2244 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsValidContextPayload } from '@novu/application-generic';
import { NotificationTemplateEntity } from '@novu/dal';
import {
  AddressingTypeEnum,
  ContextPayload,
  StatelessControls,
  TriggerOverrides,
  TriggerRecipientSubscriber,
  TriggerRecipientsPayload,
  TriggerRequestCategoryEnum,
  TriggerTenantContext,
} from '@novu/shared';
import { IsDefined, IsEnum, IsOptional, IsString, ValidateIf, ValidateNested } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class ParseEventRequestBaseCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  @IsString()
  identifier: string;

  @IsDefined()
  payload: any;

  @IsDefined()
  overrides: TriggerOverrides;

  @IsString()
  @IsOptional()
  transactionId?: string;

  @IsOptional()
  @ValidateIf((_, value) => typeof value !== 'string')
  @ValidateNested()
  actor?: TriggerRecipientSubscriber | null;

  @IsOptional()
  @ValidateNested()
  @ValidateIf((_, value) => typeof value !== 'string')
  tenant?: TriggerTenantContext | null;

  @IsOptional()
  @IsEnum(TriggerRequestCategoryEnum)
  requestCategory?: TriggerRequestCategoryEnum;

  @IsString()
  @IsOptional()
  bridgeUrl?: string;
  /**
   * A mapping of step IDs to their corresponding data.
   * Built for stateless triggering by the local studio, those values will not be persisted outside the job scope
   * First key is step id, second is controlId, value is the control value
   * @type {Record<stepId, Data>}
   * @optional
   */
  controls?: StatelessControls;

  @IsString()
  requestId: string;

  @IsOptional()
  workflow?: NotificationTemplateEntity;

  @IsOptional()
  @IsValidContextPayload({ maxCount: 5 })
  context?: ContextPayload;
}

export class ParseEventRequestMulticastCommand extends ParseEventRequestBaseCommand {
  @IsDefined()
  to: TriggerRecipientsPayload;

  @IsEnum(AddressingTypeEnum)
  addressingType: AddressingTypeEnum.MULTICAST;
}

export class ParseEventRequestBroadcastCommand extends ParseEventRequestBaseCommand {
  @IsEnum(AddressingTypeEnum)
  addressingType: AddressingTypeEnum.BROADCAST;
}

export type ParseEventRequestCommand = ParseEventRequestMulticastCommand | ParseEventRequestBroadcastCommand;


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class ParseEventRequestBaseCommand
- export class ParseEventRequestMulticastCommand
- export class ParseEventRequestBroadcastCommand
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/parse-event-request/parse-event-request.e2e.ts
TamaÃ±o: 8873 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import { NotificationTemplateEntity, SubscriberRepository } from '@novu/dal';
import { AddressingTypeEnum, TriggerRecipients, TriggerRequestCategoryEnum } from '@novu/shared';

import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { v4 as uuid } from 'uuid';
import { SharedModule } from '../../../shared/shared.module';
import { EventsModule } from '../../events.module';
import { ParseEventRequestCommand, ParseEventRequestMulticastCommand } from './parse-event-request.command';
import { ParseEventRequest } from './parse-event-request.usecase';

describe('ParseEventRequest Usecase - #novu-v2', () => {
  let session: UserSession;
  let subscribersService: SubscribersService;
  let parseEventRequestUsecase: ParseEventRequest;
  let template: NotificationTemplateEntity;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [SharedModule, EventsModule],
    }).compile();

    session = new UserSession();
    await session.initialize();

    template = await session.createTemplate();
    parseEventRequestUsecase = moduleRef.get<ParseEventRequest>(ParseEventRequest);
    subscribersService = new SubscribersService(session.organization._id, session.environment._id);
  });

  it('should throw exception when subscriber id sent as array', async () => {
    const transactionId = uuid();
    const subscriberId = [SubscriberRepository.createObjectId()];

    const command = buildCommand(
      session,
      transactionId,
      [{ subscriberId } as unknown as string],
      template.triggers[0].identifier
    );

    try {
      await parseEventRequestUsecase.execute(command);
    } catch (error) {
      expect(error.message).to.be.eql(
        'subscriberId under property to is type array, which is not allowed please make sure all subscribers ids are strings'
      );
    }
  });

  it('should validate payload against schema when validatePayload is enabled', async () => {
    const transactionId = uuid();
    const subscriber = await subscribersService.createSubscriber();

    // Create a template with payload schema validation enabled
    const templateWithSchema = await session.createTemplate({
      validatePayload: true,
      payloadSchema: {
        type: 'object',
        properties: {
          name: { type: 'string' },
          age: { type: 'number' },
        },
        required: ['name'],
      },
    });

    const command = buildCommand(
      session,
      transactionId,
      [{ subscriberId: subscriber.subscriberId }],
      templateWithSchema.triggers[0].identifier
    );

    // Test with invalid payload (missing required field)
    command.payload = { age: 25 };

    try {
      await parseEventRequestUsecase.execute(command);
      expect.fail('Should have thrown validation error');
    } catch (error) {
      expect(error.message).to.include('Payload validation failed');
      expect(error.response).to.exist;
      expect(error.response.type).to.equal('PAYLOAD_VALIDATION_ERROR');
      expect(error.response.errors).to.be.an('array');
      expect(error.response.errors).to.have.length.greaterThan(0);
      expect(error.response.errors[0]).to.have.property('field');
      expect(error.response.errors[0]).to.have.property('message');
      expect(error.response.errors[0].field).to.include('name');
    }
  });

  it('should pass validation when payload matches schema', async () => {
    const transactionId = uuid();
    const subscriber = await subscribersService.createSubscriber();

    // Create a template with payload schema validation enabled
    const templateWithSchema = await session.createTemplate({
      validatePayload: true,
      payloadSchema: {
        type: 'object',
        properties: {
          name: { type: 'string' },
          age: { type: 'number' },
        },
        required: ['name'],
      },
    });

    const command = buildCommand(
      session,
      transactionId,
      [{ subscriberId: subscriber.subscriberId }],
      templateWithSchema.triggers[0].identifier
    );

    // Test with valid payload
    command.payload = { name: 'John Doe', age: 25 };

    const result = await parseEventRequestUsecase.execute(command);
    expect(result.acknowledged).to.be.true;
  });

  it('should skip validation when validatePayload is disabled', async () => {
    const transactionId = uuid();
    const subscriber = await subscribersService.createSubscriber();

    // Create a template with payload schema validation disabled
    const templateWithoutValidation = await session.createTemplate({
      validatePayload: false,
      payloadSchema: {
        type: 'object',
        properties: {
          name: { type: 'string' },
        },
        required: ['name'],
      },
    });

    const command = buildCommand(
      session,
      transactionId,
      [{ subscriberId: subscriber.subscriberId }],
      templateWithoutValidation.triggers[0].identifier
    );

    // Test with invalid payload - should not throw error since validation is disabled
    command.payload = { invalidField: 'value' };

    const result = await parseEventRequestUsecase.execute(command);
    expect(result.acknowledged).to.be.true;
  });

  it('should apply default values from schema when validatePayload is enabled', async () => {
    const transactionId = uuid();
    const subscriber = await subscribersService.createSubscriber();

    // Create a template with payload schema validation enabled and default values
    const templateWithDefaults = await session.createTemplate({
      validatePayload: true,
      payloadSchema: {
        type: 'object',
        properties: {
          name: { type: 'string', default: 'Default Name' },
          age: { type: 'number', default: 30 },
          isActive: { type: 'boolean', default: true },
          settings: {
            type: 'object',
            properties: {
              theme: { type: 'string', default: 'dark' },
              notifications: { type: 'boolean', default: false },
            },
            default: {},
          },
        },
        required: [],
      },
    });

    const command = buildCommand(
      session,
      transactionId,
      [{ subscriberId: subscriber.subscriberId }],
      templateWithDefaults.triggers[0].identifier
    );

    // Test with partial payload - defaults should be applied
    command.payload = { name: 'John Doe' };

    const result = await parseEventRequestUsecase.execute(command);
    expect(result.acknowledged).to.be.true;

    // Verify that defaults were applied to the payload
    expect(command.payload.name).to.equal('John Doe'); // Provided value should remain
    expect(command.payload.age).to.equal(30); // Default value should be applied
    expect(command.payload.isActive).to.equal(true); // Default value should be applied
    expect(command.payload.settings).to.deep.equal({ theme: 'dark', notifications: false }); // Nested defaults should be applied
  });

  it('should not override provided values with defaults', async () => {
    const transactionId = uuid();
    const subscriber = await subscribersService.createSubscriber();

    // Create a template with payload schema validation enabled and default values
    const templateWithDefaults = await session.createTemplate({
      validatePayload: true,
      payloadSchema: {
        type: 'object',
        properties: {
          name: { type: 'string', default: 'Default Name' },
          age: { type: 'number', default: 30 },
          isActive: { type: 'boolean', default: true },
        },
        required: [],
      },
    });

    const command = buildCommand(
      session,
      transactionId,
      [{ subscriberId: subscriber.subscriberId }],
      templateWithDefaults.triggers[0].identifier
    );

    // Test with full payload - no defaults should override provided values
    command.payload = { name: 'Jane Doe', age: 25, isActive: false };

    const result = await parseEventRequestUsecase.execute(command);
    expect(result.acknowledged).to.be.true;

    // Verify that provided values were not overridden by defaults
    expect(command.payload.name).to.equal('Jane Doe');
    expect(command.payload.age).to.equal(25);
    expect(command.payload.isActive).to.equal(false);
  });
});

const buildCommand = (
  session: UserSession,
  transactionId: string,
  to: TriggerRecipients,
  identifier: string
): ParseEventRequestCommand => {
  return ParseEventRequestMulticastCommand.create({
    organizationId: session.organization._id,
    environmentId: session.environment._id,
    to,
    transactionId,
    userId: session.user._id,
    identifier,
    payload: {},
    overrides: {},
    addressingType: AddressingTypeEnum.MULTICAST,
    requestCategory: TriggerRequestCategoryEnum.SINGLE,
    requestId: uuid(),
  });
};


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - subscribersService(new SubscribersService(session.organization._id, session.environment._id);
  });

  it('should throw...)
 - command(buildCommand(
      session,
      transactionId,
      [{ subscriberId } as unknown as string],
   ...)
 - payload({ age: 25 };

    try {
      await parseEventRequestUsecase.execute(command);
      expect.fail('Sh...)
 - result(await parseEventRequestUsecase.execute(command);
    expect(result.acknowledged).to.be.true;
  });

...)
 - result(await parseEventRequestUsecase.execute(command);
    expect(result.acknowledged).to.be.true;
  });

...)
 - result(await parseEventRequestUsecase.execute(command);
    expect(result.acknowledged).to.be.true;

    //...)
 - buildCommand(session: UserSession,
  transactionId: string,
  to: TriggerRecipients,
  identifier: string
): Pars...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/parse-event-request/parse-event-request.usecase.ts
TamaÃ±o: 16934 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { randomBytes } from 'node:crypto';
import { BadRequestException, Injectable, UnprocessableEntityException } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import type { EventType, Trace } from '@novu/application-generic';
import {
  ExecuteBridgeRequest,
  ExecuteBridgeRequestCommand,
  ExecuteBridgeRequestDto,
  FeatureFlagsService,
  Instrument,
  InstrumentUsecase,
  IWorkflowDataDto,
  LogRepository,
  mapEventTypeToTitle,
  PinoLogger,
  StorageHelperService,
  TraceLogRepository,
  WorkflowQueueService,
} from '@novu/application-generic';
import {
  NotificationTemplateEntity,
  NotificationTemplateRepository,
  TenantEntity,
  TenantRepository,
  UserEntity,
  WorkflowOverrideEntity,
  WorkflowOverrideRepository,
} from '@novu/dal';
import { DiscoverWorkflowOutput, GetActionEnum } from '@novu/framework/internal';
import {
  FeatureFlagsKeysEnum,
  ReservedVariablesMap,
  ResourceOriginEnum,
  TriggerContextTypeEnum,
  TriggerEventStatusEnum,
  TriggerRecipientsPayload,
} from '@novu/shared';
import { addBreadcrumb } from '@sentry/node';
import Ajv from 'ajv';
import addFormats from 'ajv-formats';
import { toMerged } from 'es-toolkit';
import { generateTransactionId } from '../../../shared/helpers/generate-transaction-id';
import { PayloadValidationException } from '../../exceptions/payload-validation-exception';
import { RecipientSchema, RecipientsSchema } from '../../utils/trigger-recipient-validation';
import { VerifyPayload, VerifyPayloadCommand } from '../verify-payload';
import {
  ParseEventRequestBroadcastCommand,
  ParseEventRequestCommand,
  ParseEventRequestMulticastCommand,
} from './parse-event-request.command';

@Injectable()
export class ParseEventRequest {
  constructor(
    private notificationTemplateRepository: NotificationTemplateRepository,
    private verifyPayload: VerifyPayload,
    private storageHelperService: StorageHelperService,
    private workflowQueueService: WorkflowQueueService,
    private tenantRepository: TenantRepository,
    private workflowOverrideRepository: WorkflowOverrideRepository,
    private executeBridgeRequest: ExecuteBridgeRequest,
    private logger: PinoLogger,
    private featureFlagService: FeatureFlagsService,
    private traceLogRepository: TraceLogRepository,
    protected moduleRef: ModuleRef
  ) {
    this.logger.setContext(this.constructor.name);
  }

  @InstrumentUsecase()
  public async execute(command: ParseEventRequestCommand) {
    const transactionId = command.transactionId || generateTransactionId();
    const requestId = command.requestId;

    try {
      const statelessWorkflowAllowed = this.isStatelessWorkflowAllowed(command.bridgeUrl);

      if (statelessWorkflowAllowed) {
        const discoveredWorkflow = await this.queryDiscoverWorkflow(command);

        if (!discoveredWorkflow) {
          await this.createRequestTrace(
            requestId,
            command,
            'request_workflow_not_found',
            transactionId,
            'error',
            'Bridge workflow not found'
          );
          throw new UnprocessableEntityException('workflow_not_found');
        }

        return await this.dispatchEventToWorkflowQueue({
          requestId,
          command,
          transactionId,
          discoveredWorkflow,
        });
      }

      const template =
        command.workflow ||
        (await this.getNotificationTemplateByTriggerIdentifier({
          environmentId: command.environmentId,
          triggerIdentifier: command.identifier,
        }));

      if (!template) {
        await this.createRequestTrace(
          requestId,
          command,
          'request_workflow_not_found',
          transactionId,
          'error',
          'Notification template not found'
        );
        throw new UnprocessableEntityException('workflow_not_found');
      }

      const reservedVariablesTypes = this.getReservedVariablesTypes(template);
      this.validateTriggerContext(command, reservedVariablesTypes);

      if (template.validatePayload && template.payloadSchema) {
        try {
          const validatedPayload = this.validateAndApplyPayloadDefaults(command.payload, template.payloadSchema);
          // eslint-disable-next-line no-param-reassign
          command.payload = validatedPayload;
        } catch (error) {
          if (error instanceof PayloadValidationException) {
            await this.createRequestTrace(
              requestId,
              command,
              'request_payload_validation_failed',
              transactionId,
              'error',
              'Payload validation failed',
              { validationErrors: error.message, payload: command.payload }
            );
          }
          throw error;
        }
      }

      let tenant: TenantEntity | null = null;
      if (command.tenant) {
        tenant = await this.tenantRepository.findOne({
          _environmentId: command.environmentId,
          identifier: typeof command.tenant === 'string' ? command.tenant : command.tenant.identifier,
        });

        if (!tenant) {
          return {
            acknowledged: true,
            status: TriggerEventStatusEnum.TENANT_MISSING,
          };
        }
      }

      let workflowOverride: WorkflowOverrideEntity | null = null;
      if (tenant) {
        workflowOverride = await this.workflowOverrideRepository.findOne({
          _environmentId: command.environmentId,
          _organizationId: command.organizationId,
          _workflowId: template._id,
          _tenantId: tenant._id,
        });
      }

      const inactiveWorkflow = !workflowOverride && !template.active;
      const inactiveWorkflowOverride = workflowOverride && !workflowOverride.active;

      if (inactiveWorkflowOverride || inactiveWorkflow) {
        return {
          acknowledged: true,
          status: TriggerEventStatusEnum.NOT_ACTIVE,
        };
      }

      if (!template.steps?.length) {
        return {
          acknowledged: true,
          status: TriggerEventStatusEnum.NO_WORKFLOW_STEPS,
        };
      }

      if (!template.steps?.some((step) => step.active)) {
        return {
          acknowledged: true,
          status: TriggerEventStatusEnum.NO_WORKFLOW_ACTIVE_STEPS,
        };
      }

      addBreadcrumb({
        message: 'Sending trigger',
        data: {
          triggerIdentifier: command.identifier,
        },
      });

      // Modify Attachment Key Name, Upload attachments to Storage Provider and Remove file from payload
      if (command.payload && Array.isArray(command.payload.attachments)) {
        this.modifyAttachments(command);
        await this.storageHelperService.uploadAttachments(command.payload.attachments);
        // eslint-disable-next-line no-param-reassign
        command.payload.attachments = command.payload.attachments.map(({ file, ...attachment }) => attachment);
      }

      const defaultPayload = this.verifyPayload.execute(
        VerifyPayloadCommand.create({
          payload: command.payload,
          template,
        })
      );
      // eslint-disable-next-line no-param-reassign
      command.payload = toMerged(defaultPayload, command.payload);

      const result = await this.dispatchEventToWorkflowQueue({
        requestId,
        command,
        transactionId,
      });

      return result;
    } catch (error) {
      // Trace: Request failed
      await this.createRequestTrace(
        requestId,
        command,
        'request_failed',
        transactionId,
        'error',
        `Request processing failed: ${error.message}`,
        { error: error.message, stack: error.stack }
      );

      throw error;
    }
  }

  private async createRequestTrace(
    requestId: string | undefined,
    command: ParseEventRequestCommand,
    eventType: EventType,
    transactionId: string,
    status: 'success' | 'error' = 'success',
    message?: string,
    rawData?: any
  ): Promise<void> {
    if (!requestId) {
      this.logger.warn(
        { command, eventType, transactionId, status, message, rawData },
        'Request trace skipped, no request ID found'
      );
      return;
    }

    try {
      const traceData: Omit<Trace, 'id' | 'expires_at'> = {
        created_at: LogRepository.formatDateTime64(new Date()),
        organization_id: command.organizationId,
        environment_id: command.environmentId,
        user_id: command.userId,
        subscriber_id: null,
        external_subscriber_id: null,
        event_type: eventType,
        title: mapEventTypeToTitle(eventType),
        message: message || null,
        raw_data: rawData ? JSON.stringify(rawData) : null,
        status,
        entity_type: 'request',
        entity_id: requestId,
        workflow_run_identifier: command.identifier,
      };

      await this.traceLogRepository.createRequest([traceData]);
    } catch (error) {
      this.logger.error(
        {
          error,
          eventType,
          transactionId,
          organizationId: command.organizationId,
          environmentId: command.environmentId,
        },
        'Failed to create request trace'
      );
    }
  }

  private async queryDiscoverWorkflow(command: ParseEventRequestCommand): Promise<DiscoverWorkflowOutput | null> {
    if (!command.bridgeUrl) {
      return null;
    }

    const discover = (await this.executeBridgeRequest.execute(
      ExecuteBridgeRequestCommand.create({
        statelessBridgeUrl: command.bridgeUrl,
        environmentId: command.environmentId,
        action: GetActionEnum.DISCOVER,
        workflowOrigin: ResourceOriginEnum.EXTERNAL,
      })
    )) as ExecuteBridgeRequestDto<GetActionEnum.DISCOVER>;

    return discover?.workflows?.find((findWorkflow) => findWorkflow.workflowId === command.identifier) || null;
  }

  private async dispatchEventToWorkflowQueue({
    requestId,
    command,
    transactionId,
    discoveredWorkflow,
  }: {
    requestId: string;
    command: ParseEventRequestMulticastCommand | ParseEventRequestBroadcastCommand;
    transactionId: string;
    discoveredWorkflow?: DiscoverWorkflowOutput | null;
  }) {
    const commandArgs = {
      ...command,
    };

    const isDryRun = await this.featureFlagService.getFlag({
      environment: { _id: command.environmentId },
      organization: { _id: command.organizationId },
      user: { _id: command.userId } as UserEntity,
      key: FeatureFlagsKeysEnum.IS_SUBSCRIBER_ID_VALIDATION_DRY_RUN_ENABLED,
      defaultValue: true,
    });

    if ('to' in commandArgs) {
      const { validRecipients, invalidRecipients } = this.parseRecipients(commandArgs.to);

      if (invalidRecipients.length > 0 && isDryRun) {
        this.logger.warn(
          `[Dry run] Invalid recipients: ${invalidRecipients.map((recipient) => JSON.stringify(recipient)).join(', ')}`
        );
      }

      /**
       * If all the recipients are invalid, we should return with status INVALID_RECIPIENTS,
       * otherwise we should continue with the valid recipients.
       */
      if (!validRecipients && !isDryRun) {
        await this.createRequestTrace(
          requestId,
          command,
          'request_invalid_recipients',
          transactionId,
          'error',
          'All recipients are invalid',
          { invalidRecipients }
        );

        return {
          acknowledged: true,
          status: TriggerEventStatusEnum.INVALID_RECIPIENTS,
          transactionId,
        };
      }

      if (!isDryRun && validRecipients) {
        commandArgs.to = validRecipients as TriggerRecipientsPayload;
      }
    }

    const jobData: IWorkflowDataDto = {
      ...commandArgs,
      actor: command.actor,
      transactionId,
      bridgeWorkflow: discoveredWorkflow ?? undefined,
      requestId,
    };

    await this.workflowQueueService.add({ name: transactionId, data: jobData, groupId: command.organizationId });
    this.logger.info(
      { ...command, transactionId, discoveredWorkflowId: discoveredWorkflow?.workflowId },
      'Event dispatched to [Workflow] Queue'
    );

    return {
      acknowledged: true,
      status: TriggerEventStatusEnum.PROCESSED,
      transactionId,
    };
  }

  private isStatelessWorkflowAllowed(bridgeUrl: string | undefined) {
    if (!bridgeUrl) {
      return false;
    }

    return true;
  }

  @Instrument()
  private async getNotificationTemplateByTriggerIdentifier(command: {
    triggerIdentifier: string;
    environmentId: string;
  }) {
    return await this.notificationTemplateRepository.findByTriggerIdentifier(
      command.environmentId,
      command.triggerIdentifier
    );
  }

  @Instrument()
  private validateTriggerContext(
    command: ParseEventRequestCommand,
    reservedVariablesTypes: TriggerContextTypeEnum[]
  ): void {
    const invalidKeys: string[] = [];

    for (const reservedVariableType of reservedVariablesTypes) {
      const payload = command[reservedVariableType];
      if (!payload) {
        invalidKeys.push(`${reservedVariableType} object`);
        continue;
      }
      const reservedVariableFields = ReservedVariablesMap[reservedVariableType].map((variable) => variable.name);
      for (const variableName of reservedVariableFields) {
        const variableNameExists = payload[variableName];

        if (!variableNameExists) {
          invalidKeys.push(`${variableName} property of ${reservedVariableType}`);
        }
      }
    }

    if (invalidKeys.length) {
      throw new BadRequestException(`Trigger is missing: ${invalidKeys.join(', ')}`);
    }
  }

  private modifyAttachments(command: ParseEventRequestCommand): void {
    // eslint-disable-next-line no-param-reassign
    command.payload.attachments = command.payload.attachments.map((attachment) => {
      const randomId = randomBytes(16).toString('hex');

      return {
        ...attachment,
        name: attachment.name,
        file: Buffer.from(attachment.file, 'base64'),
        storagePath: `${command.organizationId}/${command.environmentId}/${randomId}/${attachment.name}`,
      };
    });
  }

  private getReservedVariablesTypes(template: NotificationTemplateEntity): TriggerContextTypeEnum[] {
    const { reservedVariables } = template.triggers[0];

    return reservedVariables?.map((reservedVariable) => reservedVariable.type) || [];
  }

  /**
   * Validates a single Parent item.
   * @param item - The item to validate
   * @param invalidValues - Array to collect invalid values
   * @returns The valid item or null if invalid
   */
  private validateItem(item: unknown, invalidValues: unknown[]) {
    const result = RecipientSchema.safeParse(item);
    if (result.success) {
      return result.data;
    } else {
      invalidValues.push(item);

      return null;
    }
  }

  /**
   * Parses and validates the recipients from the given input.
   *
   * The input can be a single recipient or an array of recipients. Each recipient can be:
   * - A string that matches the `SUBSCRIBER_ID_REGEX`
   * - An object with a `subscriberId` property that matches the `SUBSCRIBER_ID_REGEX`
   * - An object with a `topicKey` property that matches the `SUBSCRIBER_ID_REGEX`
   *
   * If the input is valid, it returns the parsed data. If the input is an array, it returns an object
   * containing arrays of valid and invalid values. If the input is a single item, it returns an object
   * containing the valid item and an array of invalid values.
   *
   * @param input - The input to parse and validate. Can be a single recipient or an array of recipients.
   * @returns The object containing valid and invalid values.
   */
  private parseRecipients(input: unknown) {
    const invalidValues: unknown[] = [];

    // Try to validate the whole input first
    const parsed = RecipientsSchema.safeParse(input);
    if (parsed.success) {
      return { validRecipients: parsed.data, invalidRecipients: [] };
    }

    // If input is an array, validate each item
    if (Array.isArray(input)) {
      const validValues = input.map((item) => this.validateItem(item, invalidValues)).filter(Boolean);

      return { validRecipients: validValues, invalidRecipients: invalidValues };
    }

    // If input is a single item
    const validItem = this.validateItem(input, invalidValues);

    return { validRecipients: validItem, invalidRecipients: invalidValues };
  }

  private validateAndApplyPayloadDefaults(payload: any, schema: any): any {
    const ajv = new Ajv({
      allErrors: true,
      useDefaults: true,
    });
    addFormats(ajv);

    const validate = ajv.compile(schema);

    // Create a deep copy of the payload to avoid mutating the original
    const payloadWithDefaults = JSON.parse(JSON.stringify(payload));
    const valid = validate(payloadWithDefaults);

    if (!valid && validate.errors) {
      throw PayloadValidationException.fromAjvErrors(validate.errors, payload, schema);
    }

    return payloadWithDefaults;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - inactiveWorkflowOverride(workflowOverride && !workflowOverride.active;

      if (inactiveWorkflowOverride || inactiveWorkflo...)
 - attachments(command.payload.attachments.map(({ file, ...attachment }))
 - discover(await this.executeBridgeRequest.execute(
      ExecuteBridgeRequestCommand.create({
        stateles...)
 - reservedVariableFields(ReservedVariablesMap[reservedVariableType].map((variable))
 - attachments(command.payload.attachments.map((attachment))
 - validValues(input.map((item))
Declaraciones 'export' encontradas:
- export class ParseEventRequest

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/process-bulk-trigger/index.ts
TamaÃ±o: 145 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { ProcessBulkTriggerCommand } from './process-bulk-trigger.command';
export { ProcessBulkTrigger } from './process-bulk-trigger.usecase';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/process-bulk-trigger/process-bulk-trigger.command.ts
TamaÃ±o: 426 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ArrayMaxSize, ArrayNotEmpty, IsArray, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';
import { TriggerEventRequestDto } from '../../dtos';

export class ProcessBulkTriggerCommand extends EnvironmentWithUserCommand {
  @IsArray()
  @ArrayNotEmpty()
  @ArrayMaxSize(100)
  events: TriggerEventRequestDto[];

  @IsString()
  requestId: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class ProcessBulkTriggerCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/process-bulk-trigger/process-bulk-trigger.usecase.ts
TamaÃ±o: 2882 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { NotificationTemplateRepository } from '@novu/dal';
import { AddressingTypeEnum, TriggerEventStatusEnum, TriggerRequestCategoryEnum } from '@novu/shared';
import { TriggerEventResponseDto } from '../../dtos';
import { ParseEventRequestMulticastCommand } from '../parse-event-request/parse-event-request.command';
import { ParseEventRequest } from '../parse-event-request/parse-event-request.usecase';
import { ProcessBulkTriggerCommand } from './process-bulk-trigger.command';

@Injectable()
export class ProcessBulkTrigger {
  constructor(
    private parseEventRequest: ParseEventRequest,
    private notificationTemplateRepository: NotificationTemplateRepository
  ) {}

  async execute(command: ProcessBulkTriggerCommand) {
    // Extract unique workflow identifiers from all events
    const uniqueWorkflowIdentifiers = [...new Set(command.events.map((event) => event.name))];

    // Fetch all unique workflows in a single batch operation
    const workflows = await this.notificationTemplateRepository.findByTriggerIdentifierBulk(
      command.environmentId,
      uniqueWorkflowIdentifiers
    );

    // Create a map for quick lookup
    const workflowMap = new Map();
    for (const workflow of workflows) {
      const triggerIdentifier = workflow.triggers[0]?.identifier;
      if (triggerIdentifier) {
        workflowMap.set(triggerIdentifier, workflow);
      }
    }

    const eventPromises = command.events.map(async (event) => {
      try {
        const workflow = workflowMap.get(event.name);

        const result = (await this.parseEventRequest.execute(
          ParseEventRequestMulticastCommand.create({
            userId: command.userId,
            environmentId: command.environmentId,
            organizationId: command.organizationId,
            identifier: event.name,
            payload: event.payload,
            overrides: event.overrides || {},
            to: event.to,
            actor: event.actor,
            tenant: event.tenant,
            transactionId: event.transactionId,
            addressingType: AddressingTypeEnum.MULTICAST,
            requestCategory: TriggerRequestCategoryEnum.BULK,
            bridgeUrl: event.bridgeUrl,
            requestId: command.requestId,
            workflow,
          })
        )) as unknown as TriggerEventResponseDto;

        return result;
      } catch (e) {
        let error: string[];
        if (e.response?.message) {
          error = Array.isArray(e.response?.message) ? e.response?.message : [e.response?.message];
        } else {
          error = [e.message];
        }

        return {
          acknowledged: true,
          status: TriggerEventStatusEnum.ERROR,
          error,
        } as TriggerEventResponseDto;
      }
    });

    const results = await Promise.all(eventPromises);

    return results;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - uniqueWorkflowIdentifiers([...new Set(command.events.map((event))
 - eventPromises(command.events.map(async (event))
Declaraciones 'export' encontradas:
- export class ProcessBulkTrigger

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/send-test-email/index.ts
TamaÃ±o: 86 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './send-test-email.command';
export * from './send-test-email.usecase';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/send-test-email/send-test-email.command.ts
TamaÃ±o: 906 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '@novu/application-generic';
import { IEmailBlock } from '@novu/shared';
import { IsBoolean, IsDefined, IsOptional, IsString } from 'class-validator';

export class SendTestEmailCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  contentType: 'customHtml' | 'editor';

  @IsDefined()
  payload: Record<string, unknown>;

  @IsDefined()
  @IsString()
  subject: string;

  @IsOptional()
  @IsString()
  preheader?: string;

  @IsOptional()
  @IsString()
  senderName?: string;

  @IsDefined()
  content: string | IEmailBlock[];

  @IsDefined()
  to: string | string[];

  @IsOptional()
  @IsString()
  layoutId?: string | null;

  @IsOptional()
  @IsBoolean()
  bridge?: boolean;

  @IsOptional()
  @IsString()
  stepId?: string | null;

  @IsOptional()
  controls: Record<string, unknown>;

  @IsOptional()
  @IsString()
  workflowId?: string | null;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class SendTestEmailCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/send-test-email/send-test-email.usecase.ts
TamaÃ±o: 5474 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import {
  AnalyticsService,
  CompileEmailTemplate,
  CompileEmailTemplateCommand,
  GetNovuProviderCredentials,
  InstrumentUsecase,
  MailFactory,
  SelectIntegration,
  SelectIntegrationCommand,
} from '@novu/application-generic';
import { IntegrationEntity, OrganizationRepository } from '@novu/dal';
import { ChannelTypeEnum, EmailProviderIdEnum, IEmailOptions, ResourceOriginEnum } from '@novu/shared';
import { addBreadcrumb } from '@sentry/node';
import { PreviewStep, PreviewStepCommand } from '../../../bridge/usecases/preview-step';
import { SendTestEmailCommand } from './send-test-email.command';

@Injectable()
export class SendTestEmail {
  constructor(
    private compileEmailTemplateUsecase: CompileEmailTemplate,
    private organizationRepository: OrganizationRepository,
    private selectIntegration: SelectIntegration,
    private analyticsService: AnalyticsService,
    protected getNovuProviderCredentials: GetNovuProviderCredentials,
    private previewStep: PreviewStep
  ) {}

  @InstrumentUsecase()
  public async execute(command: SendTestEmailCommand) {
    const mailFactory = new MailFactory();
    const organization = await this.organizationRepository.findById(command.organizationId);
    if (!organization) throw new NotFoundException('Organization not found');

    const email = command.to;

    addBreadcrumb({
      message: 'Sending Email',
    });

    const integration = await this.selectIntegration.execute(
      SelectIntegrationCommand.create({
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        channelType: ChannelTypeEnum.EMAIL,
        userId: command.userId,
        filterData: {},
      })
    );

    if (!integration) {
      throw new BadRequestException(`Missing an active email integration`);
    }

    if (integration.providerId === EmailProviderIdEnum.Novu) {
      integration.credentials = await this.getNovuProviderCredentials.execute({
        channelType: integration.channel,
        providerId: integration.providerId,
        environmentId: integration._environmentId,
        organizationId: integration._organizationId,
        userId: command.userId,
      });
    }

    let html = '';
    let subject = '';
    let bridgeProviderData: Record<string, unknown> = {};

    if (!command.bridge) {
      const template = await this.compileEmailTemplateUsecase.execute(
        CompileEmailTemplateCommand.create({
          ...command,
          payload: {
            ...command.payload,
            step: {
              digest: true,
              events: [],
              total_count: 1,
              ...this.getSystemVariables('step', command),
            },
            subscriber: this.getSystemVariables('subscriber', command),
          },
        })
      );
      html = template.html;
      subject = template.subject;
    }

    if (command.bridge) {
      if (!command.workflowId || !command.stepId) {
        throw new BadRequestException('Workflow ID and step ID are required');
      }

      const data = await this.previewStep.execute(
        PreviewStepCommand.create({
          workflowId: command.workflowId,
          stepId: command.stepId,
          controls: command.controls,
          payload: command.payload,
          environmentId: command.environmentId,
          organizationId: command.organizationId,
          userId: command.userId,
          workflowOrigin: ResourceOriginEnum.EXTERNAL,
        })
      );

      if (!data.outputs) {
        throw new BadRequestException('Could not retrieve content from edge');
      }

      html = data.outputs.body as string;
      subject = data.outputs.subject as string;

      if (data.providers && typeof data.providers === 'object') {
        bridgeProviderData = data.providers[integration.providerId] || {};
      }
    }

    if (email && integration) {
      const mailData: IEmailOptions = {
        to: Array.isArray(email) ? email : [email],
        subject,
        html: html as string,
        from: (command.payload.$sender_email as string) || integration?.credentials.from || 'no-reply@novu.co',
      };

      await this.sendMessage(integration, mailData, mailFactory, command, bridgeProviderData);
    }
  }

  private async sendMessage(
    integration: IntegrationEntity,
    mailData: IEmailOptions,
    mailFactory: MailFactory,
    command: SendTestEmailCommand,
    bridgeProviderData: Record<string, unknown>
  ) {
    const { providerId } = integration;

    try {
      const mailHandler = mailFactory.getHandler(integration, mailData.from);
      await mailHandler.send({ ...mailData, bridgeProviderData });
      this.analyticsService.track('Test Email Sent - [Events]', command.userId, {
        _organization: command.organizationId,
        _environment: command.environmentId,
        channel: ChannelTypeEnum.EMAIL,
        providerId,
      });
    } catch (error) {
      throw new BadRequestException(`Unexpected provider error`);
    }
  }

  private getSystemVariables(variableType: 'subscriber' | 'step' | 'branding', command: SendTestEmailCommand) {
    const variables = {};
    for (const variable in command.payload) {
      const [type, names] = variable.includes('.') ? variable.split('.') : variable;
      if (type === variableType) {
        variables[names] = command.payload[variable];
      }
    }

    return variables;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class SendTestEmail

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/trigger-event-to-all/index.ts
TamaÃ±o: 143 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { TriggerEventToAllCommand } from './trigger-event-to-all.command';
export { TriggerEventToAll } from './trigger-event-to-all.usecase';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/trigger-event-to-all/trigger-event-to-all.command.ts
TamaÃ±o: 779 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { TriggerOverrides, TriggerRecipientSubscriber, TriggerTenantContext } from '@novu/shared';
import { IsDefined, IsNotEmpty, IsObject, IsOptional, IsString } from 'class-validator';

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class TriggerEventToAllCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  @IsString()
  identifier: string;

  @IsDefined()
  payload: any;

  @IsString()
  @IsDefined()
  transactionId: string;

  @IsObject()
  @IsOptional()
  overrides?: TriggerOverrides;

  @IsOptional()
  actor?: TriggerRecipientSubscriber | null;

  @IsOptional()
  tenant?: TriggerTenantContext | null;

  @IsOptional()
  @IsString()
  bridgeUrl?: string;

  @IsString()
  @IsNotEmpty()
  requestId: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class TriggerEventToAllCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/trigger-event-to-all/trigger-event-to-all.spec.ts
TamaÃ±o: 10795 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  buildSubscriberDefine,
  IProcessSubscriberBulkJobDto,
  mapSubscribersToJobs,
  splitByRecipientType,
  validateSubscriberDefine,
} from '@novu/application-generic';

import {
  ISubscribersDefine,
  ITopic,
  SubscriberSourceEnum,
  TriggerRecipientSubscriber,
  TriggerRecipientsTypeEnum,
} from '@novu/shared';
import { expect } from 'chai';

describe('TriggerMulticast Spec', () => {
  describe('splitByRecipientType', () => {
    it('should split recipients into singleSubscribers and topicKeys', async () => {
      const recipients: Array<ISubscribersDefine | ITopic> = [
        { subscriberId: '1', firstName: 'John', lastName: 'Doe' },
        { subscriberId: '2', firstName: 'Jane', lastName: 'Doe' },
        { type: TriggerRecipientsTypeEnum.TOPIC, topicKey: 'topic1' },
        { subscriberId: '3', firstName: 'Bob', lastName: 'Smith' },
      ];

      const result = splitByRecipientType(recipients);

      expect(result.singleSubscribers.size).to.be.equal(3);
      expect(result.topicKeys.size).to.be.equal(1);
      expect(result.topicKeys.has('topic1')).to.be.equal(true);
    });

    it('should handle empty array of recipients', async () => {
      const recipients: Array<ISubscribersDefine | ITopic> = [];

      const result = splitByRecipientType(recipients);

      expect(result.singleSubscribers.size).to.be.equal(0);
      expect(result.topicKeys.size).to.be.equal(0);
    });

    it('should handle null/undefined values in the array', async () => {
      const recipients: Array<ISubscribersDefine | ITopic | null | undefined> = [
        null,
        undefined,
        { subscriberId: '1', firstName: 'John', lastName: 'Doe' },
        null,
        { type: TriggerRecipientsTypeEnum.TOPIC, topicKey: 'topic1' },
        undefined,
      ];

      const result = splitByRecipientType(recipients as any);

      expect(result.singleSubscribers.size).to.be.equal(1);
      expect(result.topicKeys.size).to.be.equal(1);
    });

    it('should handle arrays with only topics', async () => {
      const recipients: Array<ISubscribersDefine | ITopic> = [
        { type: TriggerRecipientsTypeEnum.TOPIC, topicKey: 'topic1' },
        { type: TriggerRecipientsTypeEnum.TOPIC, topicKey: 'topic2' },
      ];

      const result = splitByRecipientType(recipients);

      expect(result.singleSubscribers.size).to.be.equal(0);
      expect(result.topicKeys.size).to.be.equal(2);
    });

    it('should handle arrays with only subscribers', async () => {
      const recipients: Array<ISubscribersDefine | ITopic> = [
        { subscriberId: '1', firstName: 'John', lastName: 'Doe' },
        { subscriberId: '2', firstName: 'Jane', lastName: 'Doe' },
      ];

      const result = splitByRecipientType(recipients);

      expect(result.singleSubscribers.size).to.be.equal(2);
      expect(result.topicKeys.size).to.be.equal(0);
    });

    it('should handle arrays with duplicate subscriber IDs', async () => {
      const recipients: Array<ISubscribersDefine | ITopic> = [
        { subscriberId: '1', firstName: 'John', lastName: 'Doe' },
        { subscriberId: '2', firstName: 'Jane', lastName: 'Doe' },
        { subscriberId: '1', firstName: 'Bob', lastName: 'Smith' },
      ];

      const result = splitByRecipientType(recipients);

      expect(result.singleSubscribers.size).to.be.equal(2);
      expect(result.topicKeys.size).to.be.equal(0);
    });

    it('should handle arrays with duplicate topics', async () => {
      const recipients: Array<ISubscribersDefine | ITopic> = [
        { type: TriggerRecipientsTypeEnum.TOPIC, topicKey: 'topic1' },
        { subscriberId: '1', firstName: 'John', lastName: 'Doe' },
        { type: TriggerRecipientsTypeEnum.TOPIC, topicKey: 'topic2' },
        { type: TriggerRecipientsTypeEnum.TOPIC, topicKey: 'topic1' },
        { subscriberId: '2', firstName: 'Jane', lastName: 'Doe' },
      ];

      const result = splitByRecipientType(recipients);

      expect(result.singleSubscribers.size).to.be.equal(2);
      expect(result.topicKeys.size).to.be.equal(2);
    });
  });

  describe('buildSubscriberDefine', () => {
    it('should build ISubscribersDefine from string subscriber ID', async () => {
      const recipient: TriggerRecipientSubscriber = '123';

      const result = buildSubscriberDefine(recipient);

      expect(result).to.be.ok;
      expect(result.subscriberId).to.be.equal('123'); // Ensure correct subscriber ID
    });

    it('should build ISubscribersDefine from ISubscribersDefine object', async () => {
      const recipient: TriggerRecipientSubscriber = {
        subscriberId: '123',
        firstName: 'John',
        lastName: 'Doe',
        email: 'john@example.com',
      };

      const result = buildSubscriberDefine(recipient);

      expect(result).to.be.ok;
      expect(result).to.be.equal(recipient);
    });

    it('should throw error for invalid ISubscribersDefine object', async () => {
      const recipient = [{ subscriberId: '123' }];

      expect(() => buildSubscriberDefine(recipient as any)).to.throw(
        'subscriberId under property to is type array, which is not allowed please make sure all subscribers ids are strings'
      );
    });
  });

  describe('validateSubscriberDefine', () => {
    it('should throw error if recipient is an array', async () => {
      const recipient: any = ['subscriber123'];

      expect(() => validateSubscriberDefine(recipient)).to.throw(
        'subscriberId under property to is type array, which is not allowed please make sure all subscribers ids are strings'
      );
    });

    it('should throw error if recipient is null or undefined', async () => {
      const recipient: any = null;

      expect(() => validateSubscriberDefine(recipient)).to.throw(
        'subscriberId under property to is not configured, please make sure all subscribers contains subscriberId property'
      );

      const recipient2: any = undefined;

      expect(() => validateSubscriberDefine(recipient2)).to.throw(
        'subscriberId under property to is not configured, please make sure all subscribers contains subscriberId property'
      );
    });

    it('should throw error if recipient does not have subscriberId property', async () => {
      const recipient: any = {};

      expect(() => validateSubscriberDefine(recipient)).to.throw(
        'subscriberId under property to is not configured, please make sure all subscribers contains subscriberId property'
      );
    });

    it('should not throw error if recipient is valid', async () => {
      const recipient: ISubscribersDefine = {
        subscriberId: 'subscriber123',
        firstName: 'John',
        lastName: 'Doe',
      };

      expect(() => validateSubscriberDefine(recipient)).not.to.throw();
    });
  });

  describe('mapSubscribersToJobs', () => {
    const subscriberSource: SubscriberSourceEnum = SubscriberSourceEnum.SINGLE;
    const subscribers: ISubscribersDefine[] = [
      { subscriberId: 'subscriber123', firstName: 'John', lastName: 'Doe' },
      { subscriberId: 'subscriber456', firstName: 'Jane', lastName: 'Doe' },
    ];

    it('should map subscribers to jobs with correct data', async () => {
      const jobs: IProcessSubscriberBulkJobDto[] = mapSubscribersToJobs(
        subscriberSource,
        subscribers,
        triggerMulticastCommandMock as any
      );

      expect(jobs.length).to.be.equal(2);
      expect(jobs[0].name).to.be.equal('428fa85a-2529-4186-80ad-3bf29d365de2subscriber123');
      expect(jobs[0].data.environmentId).to.be.equal('65ccfbfb374a4f35856d76f7');
      expect(jobs[1].name).to.be.equal('428fa85a-2529-4186-80ad-3bf29d365de2subscriber456');
      expect(jobs[1].data.environmentId).to.be.equal('65ccfbfb374a4f35856d76f7');
    });
  });
});

const triggerMulticastCommandMock = {
  userId: '65ccfbfb374a4f35856d76ef',
  environmentId: '65ccfbfb374a4f35856d76f7',
  organizationId: '65ccfbfb374a4f35856d76f1',
  identifier: 'test-event-b0a06229-98d2-4a15-b062-10146d10ef53',
  payload: {
    customVar: 'Testing of User Name',
  },
  overrides: {},
  to: ['65ccfbfb374a4f35856d7754'],
  transactionId: '428fa85a-2529-4186-80ad-3bf29d365de2',
  addressingType: 'multicast',
  requestCategory: 'single',
  tenant: null,
  template: {
    preferenceSettings: {
      email: true,
      sms: true,
      in_app: true,
      chat: true,
      push: true,
    },
    _id: '65ccfbfb374a4f35856d775c',
    name: 'Central Assurance Analyst',
    description: 'The Nagasaki Lander is the trademarked name of several series of Nagasaki sport bikes, tha',
    active: true,
    draft: false,
    critical: false,
    isBlueprint: false,
    _notificationGroupId: '65ccfbfb374a4f35856d76fa',
    tags: ['test-tag'],
    triggers: [
      {
        type: 'event',
        identifier: 'test-event-b0a06229-98d2-4a15-b062-10146d10ef53',
        variables: [
          {
            name: 'firstName',
            _id: '65ccfbfb374a4f35856d775e',
            id: '65ccfbfb374a4f35856d775e',
          },
          {
            name: 'lastName',
            _id: '65ccfbfb374a4f35856d775f',
            id: '65ccfbfb374a4f35856d775f',
          },
          {
            name: 'urlVariable',
            _id: '65ccfbfb374a4f35856d7760',
            id: '65ccfbfb374a4f35856d7760',
          },
        ],
        _id: '65ccfbfb374a4f35856d775d',
        reservedVariables: [],
        subscriberVariables: [],
        id: '65ccfbfb374a4f35856d775d',
      },
    ],
    steps: [
      {
        metadata: {
          timed: {
            weekDays: [],
            monthDays: [],
          },
        },
        active: true,
        shouldStopOnFail: false,
        filters: [],
        _templateId: '65ccfbfb374a4f35856d775a',
        variants: [],
        _id: '65ccfbfb374a4f35856d7761',
        id: '65ccfbfb374a4f35856d7761',
        template: {
          _id: '65ccfbfb374a4f35856d775a',
          type: 'sms',
          active: true,
          variables: [],
          content: 'Hello world {{customVar}}',
          _environmentId: '65ccfbfb374a4f35856d76f7',
          _organizationId: '65ccfbfb374a4f35856d76f1',
          _creatorId: '65ccfbfb374a4f35856d76ef',
          _feedId: '65ccfbfb374a4f35856d7726',
          _layoutId: '65ccfbfb374a4f35856d76fc',
          deleted: false,
          createdAt: '2024-02-14T17:44:27.529Z',
          updatedAt: '2024-02-14T17:44:27.529Z',
          __v: 0,
          id: '65ccfbfb374a4f35856d775a',
        },
      },
    ],
    _environmentId: '65ccfbfb374a4f35856d76f7',
    _organizationId: '65ccfbfb374a4f35856d76f1',
    _creatorId: '65ccfbfb374a4f35856d76ef',
    deleted: false,
    createdAt: '2024-02-14T17:44:27.532Z',
    updatedAt: '2024-02-14T17:44:27.532Z',
    __v: 0,
    id: '65ccfbfb374a4f35856d775c',
  },
};


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - result(splitByRecipientType(recipients);

      expect(result.singleSubscribers.size).to.be.equal(3);
     ...)
 - result(splitByRecipientType(recipients);

      expect(result.singleSubscribers.size).to.be.equal(0);
     ...)
 - result(splitByRecipientType(recipients as any);

      expect(result.singleSubscribers.size).to.be.equal(1)...)
 - result(splitByRecipientType(recipients);

      expect(result.singleSubscribers.size).to.be.equal(0);
     ...)
 - result(splitByRecipientType(recipients);

      expect(result.singleSubscribers.size).to.be.equal(2);
     ...)
 - result(splitByRecipientType(recipients);

      expect(result.singleSubscribers.size).to.be.equal(2);
     ...)
 - result(splitByRecipientType(recipients);

      expect(result.singleSubscribers.size).to.be.equal(2);
     ...)
 - result(buildSubscriberDefine(recipient);

      expect(result).to.be.ok;
      expect(result.subscriberId)....)
 - result(buildSubscriberDefine(recipient);

      expect(result).to.be.ok;
      expect(result).to.be.equal(r...)
 - recipient([{ subscriberId: '123' }];

      expect(())
 - any(['subscriber123'];

      expect(())
 - any(null;

      expect(())
 - any(undefined;

      expect(())
 - any({};

      expect(())
 - ISubscribersDefine({
        subscriberId: 'subscriber123',
        firstName: 'John',
        lastName: 'Doe',
      }...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/trigger-event-to-all/trigger-event-to-all.usecase.ts
TamaÃ±o: 1290 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { AddressingTypeEnum, TriggerEventStatusEnum, TriggerRequestCategoryEnum } from '@novu/shared';
import { ParseEventRequest, ParseEventRequestBroadcastCommand } from '../parse-event-request';
import { TriggerEventToAllCommand } from './trigger-event-to-all.command';

@Injectable()
export class TriggerEventToAll {
  constructor(private parseEventRequest: ParseEventRequest) {}

  public async execute(command: TriggerEventToAllCommand) {
    await this.parseEventRequest.execute(
      ParseEventRequestBroadcastCommand.create({
        userId: command.userId,
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        identifier: command.identifier,
        payload: command.payload || {},
        addressingType: AddressingTypeEnum.BROADCAST,
        transactionId: command.transactionId,
        overrides: command.overrides || {},
        actor: command.actor,
        tenant: command.tenant,
        requestCategory: TriggerRequestCategoryEnum.SINGLE,
        bridgeUrl: command.bridgeUrl,
        requestId: command.requestId,
      })
    );

    return {
      acknowledged: true,
      status: TriggerEventStatusEnum.PROCESSED,
      transactionId: command.transactionId,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class TriggerEventToAll

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/verify-payload/index.ts
TamaÃ±o: 123 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { VerifyPayloadCommand } from './verify-payload.command';
export { VerifyPayload } from './verify-payload.usecase';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/verify-payload/verify-payload.command.ts
TamaÃ±o: 324 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { NotificationTemplateEntity } from '@novu/dal';
import { IsDefined } from 'class-validator';

export class VerifyPayloadCommand extends BaseCommand {
  @IsDefined()
  payload: Record<string, unknown>;

  @IsDefined()
  template: NotificationTemplateEntity;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class VerifyPayloadCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/verify-payload/verify-payload.spec.ts
TamaÃ±o: 3604 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException } from '@nestjs/common';
import { NotificationTemplateEntity } from '@novu/dal';
import { ITemplateVariable, TemplateVariableTypeEnum } from '@novu/shared';
import { expect } from 'chai';
import { merge } from 'lodash';
import { VerifyPayloadCommand } from './verify-payload.command';
import { VerifyPayload } from './verify-payload.usecase';

describe('Verify Payload Usecase', () => {
  const verifyPayload = new VerifyPayload();

  it('should handle empty and undefined strings', () => {
    const template = createTemplate([
      { name: 'user.firstName', type: TemplateVariableTypeEnum.STRING, defaultValue: 'John', required: false },
      { name: 'user.hej', type: TemplateVariableTypeEnum.STRING, required: false, defaultValue: '' },
      { name: 'user.test', type: TemplateVariableTypeEnum.STRING, required: false, defaultValue: undefined },
    ]);

    const payload = {
      user: {
        lastName: 'Doe',
      },
    };

    const result = verifyPayload.execute(
      VerifyPayloadCommand.create({
        payload,
        template: template as NotificationTemplateEntity,
      })
    );

    const final = merge({}, payload, result);

    expect(final.user.lastName).to.eq('Doe');
    expect(final.user.firstName).to.eq('John');
    expect(Object.keys(final.user)).to.not.include('hej');
    expect(Object.keys(final.user)).to.not.include('test');
  });

  it('should fill and merge as expected', () => {
    const template = createTemplate([
      { name: 'user.firstName', type: TemplateVariableTypeEnum.STRING, defaultValue: 'John', required: false },
      { name: 'user.lastName', type: TemplateVariableTypeEnum.STRING, required: true },
    ]);

    const payload = {
      user: {
        lastName: 'Doe',
      },
    };

    const result = verifyPayload.execute(
      VerifyPayloadCommand.create({
        payload,
        template: template as NotificationTemplateEntity,
      })
    );

    const final = merge({}, payload, result);

    expect(final.user.lastName).to.eq('Doe');
    expect(final.user.firstName).to.eq('John');
  });

  it('should respect system variables', () => {
    const template = createTemplate([
      { name: 'subscriber.firstName', type: TemplateVariableTypeEnum.STRING, defaultValue: 'John', required: false },
      { name: 'subscriber.lastName', type: TemplateVariableTypeEnum.STRING, required: true },
    ]);

    const payload = {
      user: {
        lastName: 'Doe',
      },
    };

    const result = verifyPayload.execute(
      VerifyPayloadCommand.create({
        payload,
        template: template as NotificationTemplateEntity,
      })
    );

    expect(Object.keys(result).length).to.eq(0);
  });

  it('should not allow false types', () => {
    const template = createTemplate([
      { name: 'first', type: TemplateVariableTypeEnum.STRING, required: true },
      { name: 'second', type: TemplateVariableTypeEnum.ARRAY, required: true },
      { name: 'third', type: TemplateVariableTypeEnum.BOOLEAN, required: true },
    ]);

    const payload = {
      first: [],
      second: false,
      third: '',
    };

    expect(() => {
      verifyPayload.execute(
        VerifyPayloadCommand.create({
          payload,
          template: template as NotificationTemplateEntity,
        })
      );
    }).to.throw('payload is missing required key(s) and type(s): first (Value), second (Array), third (Boolean)');
  });
});

function createTemplate(variables: ITemplateVariable[]) {
  return {
    steps: [
      {
        template: {
          variables,
        },
      },
    ],
  };
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - createTemplate(variables: ITemplateVariable[])
Asignaciones con arrow functions encontradas (posibles funciones):
 - verifyPayload(new VerifyPayload();

  it('should handle empty and undefined strings', ())
 - final(merge({}, payload, result);

    expect(final.user.lastName).to.eq('Doe');
    expect(final.user.fir...)
 - final(merge({}, payload, result);

    expect(final.user.lastName).to.eq('Doe');
    expect(final.user.fir...)
 - result(verifyPayload.execute(
      VerifyPayloadCommand.create({
        payload,
        template: templa...)
 - payload({
      first: [],
      second: false,
      third: '',
    };

    expect(())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/usecases/verify-payload/verify-payload.usecase.ts
TamaÃ±o: 2104 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException } from '@nestjs/common';
import { InstrumentUsecase, VerifyPayloadService } from '@novu/application-generic';
import { DelayTypeEnum, StepTypeEnum } from '@novu/shared';

import { VerifyPayloadCommand } from './verify-payload.command';

const ISO_DATE_REGEX = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/;

export class VerifyPayload {
  @InstrumentUsecase()
  execute(command: VerifyPayloadCommand): Record<string, unknown> {
    const verifyPayloadService = new VerifyPayloadService();

    const invalidKeys: string[] = [];
    let defaultPayload;

    for (const step of command.template.steps) {
      invalidKeys.push(...verifyPayloadService.checkRequired(step.template?.variables || [], command.payload));
      if (
        step.template?.type === StepTypeEnum.DELAY &&
        step.metadata &&
        'type' in step.metadata &&
        step.metadata.type === DelayTypeEnum.SCHEDULED
      ) {
        if (!('delayPath' in step.metadata) || !step.metadata.delayPath) {
          throw new BadRequestException('Delay path is required for scheduled delay');
        }

        const invalidKey = this.checkRequiredDelayPath(step.metadata.delayPath, command.payload);
        if (invalidKey) {
          invalidKeys.push(invalidKey);
        }
      }
    }

    if (invalidKeys.length) {
      // TODO: create execution detail for missing keys in payload
      throw new BadRequestException(`payload is missing required key(s) and type(s): ${invalidKeys.join(', ')}`);
    }

    for (const step of command.template.steps) {
      defaultPayload = verifyPayloadService.fillDefaults(step.template?.variables || []);
    }

    // TODO: create execution detail for payload created
    return defaultPayload;
  }

  private checkRequiredDelayPath(delayPath: string, payload: Record<string, unknown>): string | undefined {
    if (!delayPath) {
      return 'Missing delay path';
    }

    const delayDate = (payload[delayPath] as string) || '';
    const isoDate = delayDate.match(ISO_DATE_REGEX);
    if (!isoDate) {
      return `${delayPath} (ISO Date)`;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class VerifyPayload

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/events/utils/trigger-recipient-validation.ts
TamaÃ±o: 518 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { VALID_ID_REGEX } from '@novu/shared';
import { z } from 'zod';

export const subscriberIdSchema = z.string().trim().regex(VALID_ID_REGEX);
export const subscriberObjectSchema = z.object({ subscriberId: subscriberIdSchema }).passthrough();
export const topicSchema = z.object({ topicKey: subscriberIdSchema }).passthrough();
export const RecipientSchema = z.union([subscriberIdSchema, subscriberObjectSchema, topicSchema]);
export const RecipientsSchema = z.union([RecipientSchema, z.array(RecipientSchema)]);


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/execution-details/execution-details.controller.ts
TamaÃ±o: 1733 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ClassSerializerInterceptor, Controller, Get, Query, UseInterceptors } from '@nestjs/common';
import { ApiExcludeController, ApiOperation, ApiTags } from '@nestjs/swagger';
import { ExecutionDetailsResponseDto } from '@novu/application-generic';
import { UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { UserSession } from '../shared/framework/user.decorator';
import { ExecutionDetailsRequestDto } from './dtos/execution-details-request.dto';
import { GetExecutionDetails, GetExecutionDetailsCommand } from './usecases/get-execution-details';

@ApiCommonResponses()
@Controller('/execution-details')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiTags('Execution Details')
@ApiExcludeController()
export class ExecutionDetailsController {
  constructor(private getExecutionDetails: GetExecutionDetails) {}

  @Get('/')
  @ApiOperation({
    summary: 'Get execution details',
  })
  @ApiResponse(ExecutionDetailsResponseDto, 200, true)
  @ExternalApiAccessible()
  async getExecutionDetailsForNotification(
    @UserSession() user: UserSessionData,
    @Query() query: ExecutionDetailsRequestDto
  ): Promise<ExecutionDetailsResponseDto[]> {
    return this.getExecutionDetails.execute(
      GetExecutionDetailsCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        userId: user._id,
        notificationId: query.notificationId,
        subscriberId: query.subscriberId,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class ExecutionDetailsController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/execution-details/execution-details.module.ts
TamaÃ±o: 457 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { AuthModule } from '../auth/auth.module';
import { SharedModule } from '../shared/shared.module';
import { ExecutionDetailsController } from './execution-details.controller';
import { USE_CASES } from './usecases';

@Module({
  imports: [SharedModule, AuthModule],
  providers: [...USE_CASES],
  exports: [...USE_CASES],
  controllers: [ExecutionDetailsController],
})
export class ExecutionDetailsModule {}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class ExecutionDetailsModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/execution-details/dtos/execution-details-request.dto.ts
TamaÃ±o: 221 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsMongoId, IsString } from 'class-validator';

export class ExecutionDetailsRequestDto {
  @IsDefined()
  @IsMongoId()
  notificationId: string;

  @IsDefined()
  @IsString()
  subscriberId: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class ExecutionDetailsRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/execution-details/e2e/get-execution-details.e2e.ts
TamaÃ±o: 2238 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ExecutionDetailsRepository, SubscriberEntity } from '@novu/dal';
import { ExecutionDetailsSourceEnum, ExecutionDetailsStatusEnum, StepTypeEnum } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';

const axiosInstance = axios.create();

describe('Execution details - Get execution details by notification id - /v1/execution-details/notification/:notificationId (GET) #novu-v2', () => {
  let session: UserSession;
  const executionDetailsRepository: ExecutionDetailsRepository = new ExecutionDetailsRepository();
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
  });

  it('should get execution details', async () => {
    const notificationId = ExecutionDetailsRepository.createObjectId();
    const detail = await executionDetailsRepository.create({
      _jobId: ExecutionDetailsRepository.createObjectId(),
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _notificationId: notificationId,
      _notificationTemplateId: ExecutionDetailsRepository.createObjectId(),
      _subscriberId: subscriber._id,
      providerId: '',
      transactionId: 'transactionId',
      channel: StepTypeEnum.EMAIL,
      detail: '',
      source: ExecutionDetailsSourceEnum.INTERNAL,
      status: ExecutionDetailsStatusEnum.SUCCESS,
      isTest: false,
      isRetry: false,
    });

    const {
      data: { data },
    } = await axiosInstance.get(
      `${session.serverUrl}/v1/execution-details?notificationId=${notificationId}&subscriberId=${subscriber.subscriberId}`,
      {
        headers: {
          authorization: `ApiKey ${session.apiKey}`,
        },
      }
    );
    const responseDetail = data[0];
    expect(responseDetail._notificationId).to.equal(notificationId);
    expect(responseDetail.channel).to.equal(detail.channel);
    expect(responseDetail._id).to.equal(detail._id);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - axiosInstance(axios.create();

describe('Execution details - Get execution details by notification id - /v1/execut...)
 - ExecutionDetailsRepository(new ExecutionDetailsRepository();
  let subscriber: SubscriberEntity;
  let subscriberService: Subsc...)
 - subscriber(await subscriberService.createSubscriber();
  });

  it('should get execution details', async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/execution-details/usecases/index.ts
TamaÃ±o: 261 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BulkCreateExecutionDetails, CreateExecutionDetails } from '@novu/application-generic';

import { GetExecutionDetails } from './get-execution-details';

export const USE_CASES = [CreateExecutionDetails, BulkCreateExecutionDetails, GetExecutionDetails];


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/execution-details/usecases/get-execution-details/get-execution-details.command.ts
TamaÃ±o: 278 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '@novu/application-generic';
import { IsDefined } from 'class-validator';

export class GetExecutionDetailsCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  notificationId: string;

  @IsDefined()
  subscriberId: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class GetExecutionDetailsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/execution-details/usecases/get-execution-details/get-execution-details.usecase.ts
TamaÃ±o: 1597 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { buildSubscriberKey, CachedResponse } from '@novu/application-generic';
import { ExecutionDetailsEntity, ExecutionDetailsRepository, SubscriberEntity, SubscriberRepository } from '@novu/dal';
import { GetExecutionDetailsCommand } from './get-execution-details.command';

@Injectable()
export class GetExecutionDetails {
  constructor(
    private executionDetailsRepository: ExecutionDetailsRepository,
    private subscriberRepository: SubscriberRepository
  ) {}

  async execute(command: GetExecutionDetailsCommand): Promise<ExecutionDetailsEntity[]> {
    const subscriber = await this.fetchSubscriber({
      _environmentId: command.environmentId,
      subscriberId: command.subscriberId,
    });
    if (!subscriber) {
      throw new NotFoundException(`Subscriber not found for id ${command.subscriberId}`);
    }

    return this.executionDetailsRepository.find({
      _notificationId: command.notificationId,
      _environmentId: command.environmentId,
      _subscriberId: subscriber?._id,
    });
  }

  @CachedResponse({
    builder: (command: { subscriberId: string; _environmentId: string }) =>
      buildSubscriberKey({
        _environmentId: command._environmentId,
        subscriberId: command.subscriberId,
      }),
  })
  private async fetchSubscriber({
    subscriberId,
    _environmentId,
  }: {
    subscriberId: string;
    _environmentId: string;
  }): Promise<SubscriberEntity | null> {
    return await this.subscriberRepository.findBySubscriberId(_environmentId, subscriberId, true);
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriber(await this.fetchSubscriber({
      _environmentId: command.environmentId,
      subscriberId: comman...)
Declaraciones 'export' encontradas:
- export class GetExecutionDetails

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/execution-details/usecases/get-execution-details/index.ts
TamaÃ±o: 149 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { GetExecutionDetailsCommand } from './get-execution-details.command';
export { GetExecutionDetails } from './get-execution-details.usecase';


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/feeds/feeds.controller.ts
TamaÃ±o: 2959 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  ClassSerializerInterceptor,
  Controller,
  Delete,
  Get,
  Param,
  Post,
  UseInterceptors,
} from '@nestjs/common';
import { ApiOperation, ApiTags } from '@nestjs/swagger';
import { ApiExcludeController } from '@nestjs/swagger/dist/decorators/api-exclude-controller.decorator';
import { UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { UserSession } from '../shared/framework/user.decorator';
import { CreateFeedRequestDto } from './dtos/create-feed-request.dto';
import { FeedResponseDto } from './dtos/feed-response.dto';
import { CreateFeedCommand } from './usecases/create-feed/create-feed.command';
import { CreateFeed } from './usecases/create-feed/create-feed.usecase';
import { DeleteFeedCommand } from './usecases/delete-feed/delete-feed.command';
import { DeleteFeed } from './usecases/delete-feed/delete-feed.usecase';
import { GetFeedsCommand } from './usecases/get-feeds/get-feeds.command';
import { GetFeeds } from './usecases/get-feeds/get-feeds.usecase';

@ApiCommonResponses()
@Controller('/feeds')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiTags('Feeds')
@ApiExcludeController()
export class FeedsController {
  constructor(
    private createFeedUsecase: CreateFeed,
    private getFeedsUsecase: GetFeeds,
    private deleteFeedsUsecase: DeleteFeed
  ) {}

  @Post('')
  @ApiResponse(FeedResponseDto, 201)
  @ApiOperation({
    summary: 'Create feed',
  })
  @ExternalApiAccessible()
  createFeed(@UserSession() user: UserSessionData, @Body() body: CreateFeedRequestDto): Promise<FeedResponseDto> {
    return this.createFeedUsecase.execute(
      CreateFeedCommand.create({
        organizationId: user.organizationId,
        userId: user._id,
        environmentId: user.environmentId,
        name: body.name,
      })
    );
  }

  @Get('')
  @ApiResponse(FeedResponseDto, 200, true)
  @ApiOperation({
    summary: 'Get feeds',
  })
  @ExternalApiAccessible()
  getFeeds(@UserSession() user: UserSessionData): Promise<FeedResponseDto[]> {
    return this.getFeedsUsecase.execute(
      GetFeedsCommand.create({
        organizationId: user.organizationId,
        userId: user._id,
        environmentId: user.environmentId,
      })
    );
  }

  @Delete('/:feedId')
  @ApiResponse(FeedResponseDto, 200, true)
  @ApiOperation({
    summary: 'Delete feed',
  })
  @ExternalApiAccessible()
  deleteFeedById(@UserSession() user: UserSessionData, @Param('feedId') feedId: string): Promise<FeedResponseDto[]> {
    return this.deleteFeedsUsecase.execute(
      DeleteFeedCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        feedId,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class FeedsController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/feeds/feeds.module.ts
TamaÃ±o: 590 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { AuthModule } from '../auth/auth.module';
import { ChangeModule } from '../change/change.module';
import { MessageTemplateModule } from '../message-template/message-template.module';
import { SharedModule } from '../shared/shared.module';
import { FeedsController } from './feeds.controller';
import { USE_CASES } from './usecases';

@Module({
  imports: [SharedModule, MessageTemplateModule, ChangeModule, AuthModule],
  providers: [...USE_CASES],
  controllers: [FeedsController],
  exports: [...USE_CASES],
})
export class FeedsModule {}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class FeedsModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/feeds/dtos/create-feed-request.dto.ts
TamaÃ±o: 203 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsDefined, IsString } from 'class-validator';

export class CreateFeedRequestDto {
  @ApiProperty()
  @IsString()
  @IsDefined()
  name: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class CreateFeedRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/feeds/dtos/feed-response.dto.ts
TamaÃ±o: 306 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class FeedResponseDto {
  @ApiPropertyOptional()
  _id?: string;

  @ApiProperty()
  name: string;

  @ApiProperty()
  identifier: string;

  @ApiProperty()
  _environmentId: string;

  @ApiProperty()
  _organizationId: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class FeedResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/feeds/e2e/create-feed.e2e.ts
TamaÃ±o: 4178 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { FeedRepository } from '@novu/dal';
import { StepTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { CreateWorkflowRequestDto, UpdateWorkflowRequestDto } from '../../workflows-v1/dtos';

describe('Create A Feed - /feeds (POST) #novu-v0', async () => {
  let session: UserSession;
  const feedRepository: FeedRepository = new FeedRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should create a new feed', async () => {
    const testFeed = {
      name: 'Test name',
    };

    const { body } = await session.testAgent.post(`/v1/feeds`).send(testFeed);

    expect(body.data).to.be.ok;
    const feed = body.data;

    expect(feed.name).to.equal(`Test name`);
    expect(feed._environmentId).to.equal(session.environment._id);
  });

  it('should promote feed changes with template', async () => {
    const testFeed = {
      name: 'add feed to message',
    };

    const { body } = await session.testAgent.post(`/v1/feeds`).send(testFeed);
    const feed = body.data;

    const testTemplate: Partial<CreateWorkflowRequestDto> = {
      name: 'test email template',
      description: 'This is a test description',
      tags: ['test-tag'],
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [
        {
          template: {
            name: 'Message Name',
            subject: 'Test email subject',
            content: 'This is a sample text block',
            type: StepTypeEnum.IN_APP,
            feedId: feed._id,
          },
        },
      ],
    };

    await session.testAgent.post(`/v1/workflows`).send(testTemplate);

    await session.applyChanges({
      enabled: false,
    });

    const feedsCount = await feedRepository.count({
      name: feed.name,
      _organizationId: session.organization._id,
    });
    expect(feedsCount).to.equal(2);
  });

  it('update existing message with feed', async () => {
    const testTemplate: Partial<CreateWorkflowRequestDto> = {
      name: 'test email template',
      description: 'This is a test description',
      tags: ['test-tag'],
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [
        {
          template: {
            name: 'Message Name',
            content: 'This is a sample text block',
            type: StepTypeEnum.IN_APP,
          },
        },
      ],
    };

    let {
      body: { data },
    } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);

    await session.applyChanges({
      enabled: false,
    });

    const notificationTemplateId = data._id;

    const testFeed = {
      name: 'Test update message with feed',
    };

    const {
      body: { data: feed },
    } = await session.testAgent.post(`/v1/feeds`).send(testFeed);

    const step = data.steps[0];
    const update: UpdateWorkflowRequestDto = {
      name: data.name,
      description: data.description,
      tags: data.tags,
      notificationGroupId: data._notificationGroupId,
      steps: [
        {
          _id: step._templateId,
          _templateId: step._templateId,
          template: {
            feedId: feed._id,
            name: 'test',
            type: step.template.type,
            cta: step.template.cta,
            content: step.template.content,
          },
        },
      ],
    };

    const body: any = await session.testAgent.put(`/v1/workflows/${notificationTemplateId}`).send(update);
    data = body.data;

    await session.applyChanges({
      enabled: false,
    });

    const feedsCount = await feedRepository.count({
      name: feed.name,
      _organizationId: session.organization._id,
    });
    expect(feedsCount).to.equal(2);
  });

  it('should throw error if a feed already exist', async () => {
    await session.testAgent.post(`/v1/feeds`).send({
      name: 'identifier_123',
    });
    const { body } = await session.testAgent.post(`/v1/feeds`).send({
      name: 'identifier_123',
    });
    expect(body.statusCode).to.equal(409);
    expect(body.message).to.equal('Feed with identifier: identifier_123 already exists');
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - FeedRepository(new FeedRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should create a new feed', async ())
 - feed(body.data;

    expect(feed.name).to.equal(`Test name`);
    expect(feed._environmentId).to.equal(se...)
 - feedsCount(await feedRepository.count({
      name: feed.name,
      _organizationId: session.organization._id,...)
 - feedsCount(await feedRepository.count({
      name: feed.name,
      _organizationId: session.organization._id,...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/feeds/e2e/delete-feed.e2e.ts
TamaÃ±o: 5327 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { FeedRepository, MessageTemplateRepository, NotificationTemplateRepository } from '@novu/dal';
import { StepTypeEnum } from '@novu/shared';
import { NotificationTemplateService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { CreateWorkflowRequestDto } from '../../workflows-v1/dtos';

describe('Delete A Feed - /feeds (POST) #novu-v0', async () => {
  let session: UserSession;
  let feedRepository = new FeedRepository();
  let notificationTemplateRepository = new NotificationTemplateRepository();
  let messageTemplateRepository: MessageTemplateRepository = new MessageTemplateRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    feedRepository = new FeedRepository();
    notificationTemplateRepository = new NotificationTemplateRepository();
    messageTemplateRepository = new MessageTemplateRepository();
  });

  it('should not be able to delete feed that has a message', async () => {
    const feeds = await feedRepository.find({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    const notificationTemplateService = new NotificationTemplateService(
      session.user._id,
      session.organization._id,
      session.environment._id
    );
    await notificationTemplateService.createTemplate();

    const { body } = await session.testAgent.delete(`/v1/feeds/${feeds[0]._id}`).send();

    expect(body.message).to.contains('Can not delete feed that has existing');
  });

  it('should delete feed', async () => {
    const newFeed = {
      name: 'Test name',
    };

    const { body } = await session.testAgent.post(`/v1/feeds`).send(newFeed);
    const newFeedId = body.data._id;
    const feed = await feedRepository.findOne({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _id: newFeedId,
    });

    expect(feed).to.be.ok;
    expect(feed?.name).to.equal(`Test name`);
    const { body: deletedBody } = await session.testAgent.delete(`/v1/feeds/${newFeedId}`).send();

    expect(deletedBody.data).to.be.ok;
    expect(deletedBody.data.length).to.equal(2);
    const deletedFeed = (
      await feedRepository.findDeleted({ _environmentId: session.environment._id, _id: newFeedId })
    )[0];

    expect(deletedFeed.deleted).to.equal(true);
  });

  it('update existing message with feed', async () => {
    const testFeed = {
      name: 'Test delete feed in message',
    };

    const {
      body: { data: feed },
    } = await session.testAgent.post(`/v1/feeds`).send(testFeed);

    await session.applyChanges({
      enabled: false,
    });

    await session.testAgent.delete(`/v1/feeds/${feed._id}`).send();

    await session.applyChanges({
      enabled: false,
    });

    const feeds = await feedRepository.find({
      _environmentId: session.environment._id,
      name: feed.name,
    });
    expect(feeds.length).to.equal(0);
  });

  it('should be able to delete feed after template is deleted', async () => {
    const testFeed = {
      name: 'add feed to message',
    };

    const { body } = await session.testAgent.post(`/v1/feeds`).send(testFeed);
    const feed = body.data;

    const testTemplate: Partial<CreateWorkflowRequestDto> = {
      name: 'test email template',
      description: 'This is a test description',
      tags: ['test-tag'],
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [
        {
          template: {
            name: 'Message Name',
            subject: 'Test email subject',
            content: 'This is a sample text block',
            type: StepTypeEnum.IN_APP,
            feedId: feed._id,
          },
        },
      ],
    };

    const { body: notificationTemplateBody } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);

    const template = notificationTemplateBody.data;

    const messageTemplateIds = template.steps.map((step) => step._templateId);

    const messageTemplates = await messageTemplateRepository.find({
      _environmentId: session.environment._id,
      _id: { $in: messageTemplateIds },
    });

    expect(messageTemplates.length).to.equal(1);

    await session.testAgent.delete(`/v1/workflows/${template._id}`).send();

    const deletedNotificationTemplate = await notificationTemplateRepository.findOne({
      _environmentId: session.environment._id,
      _id: template._id,
    });

    expect(deletedNotificationTemplate).to.equal(null);

    const deletedIntegration = (
      await notificationTemplateRepository.findDeleted({
        _environmentId: session.environment._id,
        _id: template._id,
      })
    )[0];

    expect(deletedIntegration.deleted).to.equal(true);

    const deletedMessageTemplates = await messageTemplateRepository.find({
      _environmentId: session.environment._id,
      _id: { $in: messageTemplateIds },
    });

    expect(deletedMessageTemplates.length).to.equal(0);

    const { body: deletedFeedBody } = await session.testAgent.delete(`/v1/feeds/${feed._id}`).send();

    expect(deletedFeedBody.data).to.be.ok;

    const deletedFeed = (
      await feedRepository.findDeleted({ _environmentId: session.environment._id, _id: feed._id })
    )[0];

    expect(deletedFeed.deleted).to.equal(true);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - MessageTemplateRepository(new MessageTemplateRepository();

  beforeEach(async ())
 - messageTemplateRepository(new MessageTemplateRepository();
  });

  it('should not be able to delete feed that has a message',...)
 - deletedFeed(await feedRepository.findDeleted({ _environmentId: session.environment._id, _id: newFeedId })
    )[...)
 - feeds(await feedRepository.find({
      _environmentId: session.environment._id,
      name: feed.name,
  ...)
 - messageTemplateIds(template.steps.map((step))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/feeds/e2e/get-feeds.e2e.ts
TamaÃ±o: 1420 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get Feeds - /feeds (GET) #novu-v0', async () => {
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should get all feeds', async () => {
    await session.testAgent.post(`/v1/feeds`).send({
      name: 'Test name',
    });
    await session.testAgent.post(`/v1/feeds`).send({
      name: 'Test name 2',
    });

    const { body } = await session.testAgent.get(`/v1/feeds`);

    expect(body.data.length).to.equal(4);
    const feed = body.data.find((i) => i.name === 'Test name');

    expect(feed.name).to.equal(`Test name`);
    expect(feed._environmentId).to.equal(session.environment._id);
  });

  it('should create default feed if none exists', async () => {
    const { body } = await session.testAgent.get(`/v1/feeds`);
    expect(body.data.length).to.equal(2);
    const defaultFeed = body.data[0];

    expect(defaultFeed.name).to.equal(`Activities`);

    await session.testAgent.post(`/v1/feeds`).send({
      name: 'Feed 2',
    });
    const { body: newBody } = await session.testAgent.get(`/v1/feeds`);

    expect(newBody.data.length).to.equal(3);
    const feed = newBody.data.find((i) => i.name === 'Feed 2');

    expect(feed.name).to.equal(`Feed 2`);
    expect(feed._environmentId).to.equal(session.environment._id);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should get all feeds', async ())
 - feed(body.data.find((i))
 - feed(newBody.data.find((i))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/feeds/usecases/index.ts
TamaÃ±o: 248 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CreateFeed } from './create-feed/create-feed.usecase';
import { DeleteFeed } from './delete-feed/delete-feed.usecase';
import { GetFeeds } from './get-feeds/get-feeds.usecase';

export const USE_CASES = [CreateFeed, GetFeeds, DeleteFeed];


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/feeds/usecases/create-feed/create-feed.command.ts
TamaÃ±o: 232 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class CreateFeedCommand extends EnvironmentWithUserCommand {
  @IsString()
  name: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class CreateFeedCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/feeds/usecases/create-feed/create-feed.usecase.ts
TamaÃ±o: 1343 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ConflictException, Injectable } from '@nestjs/common';
import { CreateChange, CreateChangeCommand } from '@novu/application-generic';
import { FeedEntity, FeedRepository } from '@novu/dal';
import { ChangeEntityTypeEnum } from '@novu/shared';
import { CreateFeedCommand } from './create-feed.command';

@Injectable()
export class CreateFeed {
  constructor(
    private feedRepository: FeedRepository,
    private createChange: CreateChange
  ) {}

  async execute(command: CreateFeedCommand): Promise<FeedEntity> {
    const feedExist = await this.feedRepository.findOne({
      _environmentId: command.environmentId,
      identifier: command.name,
    });

    if (feedExist) {
      throw new ConflictException(`Feed with identifier: ${command.name} already exists`);
    }

    const item = await this.feedRepository.create({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      name: command.name,
      identifier: command.name,
    });

    await this.createChange.execute(
      CreateChangeCommand.create({
        item,
        type: ChangeEntityTypeEnum.FEED,
        changeId: FeedRepository.createObjectId(),
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        userId: command.userId,
      })
    );

    return item;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class CreateFeed

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/feeds/usecases/delete-feed/delete-feed.command.ts
TamaÃ±o: 234 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class DeleteFeedCommand extends EnvironmentWithUserCommand {
  @IsString()
  feedId: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class DeleteFeedCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/feeds/usecases/delete-feed/delete-feed.usecase.ts
TamaÃ±o: 1723 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { CreateChange, CreateChangeCommand } from '@novu/application-generic';
import { ChangeRepository, DalException, FeedRepository } from '@novu/dal';
import { ChangeEntityTypeEnum } from '@novu/shared';
import { DeleteFeedCommand } from './delete-feed.command';

@Injectable()
export class DeleteFeed {
  constructor(
    private feedRepository: FeedRepository,
    private createChange: CreateChange,
    private changeRepository: ChangeRepository
  ) {}

  async execute(command: DeleteFeedCommand) {
    try {
      await this.feedRepository.delete({
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
        _id: command.feedId,
      });
      const items = await this.feedRepository.findDeleted({
        _environmentId: command.environmentId,
        _id: command.feedId,
      });
      const item = items[0];

      const parentChangeId: string = await this.changeRepository.getChangeId(
        command.environmentId,
        ChangeEntityTypeEnum.FEED,
        command.feedId
      );

      await this.createChange.execute(
        CreateChangeCommand.create({
          organizationId: command.organizationId,
          environmentId: command.environmentId,
          userId: command.userId,
          item,
          type: ChangeEntityTypeEnum.FEED,
          changeId: parentChangeId,
        })
      );
    } catch (e) {
      if (e instanceof DalException) {
        throw new BadRequestException(e.message);
      }
      throw e;
    }

    return await this.feedRepository.find({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class DeleteFeed

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/feeds/usecases/get-feeds/get-feeds.command.ts
TamaÃ±o: 155 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetFeedsCommand extends EnvironmentWithUserCommand {}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class GetFeedsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/feeds/usecases/get-feeds/get-feeds.usecase.ts
TamaÃ±o: 425 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { FeedEntity, FeedRepository } from '@novu/dal';
import { GetFeedsCommand } from './get-feeds.command';

@Injectable()
export class GetFeeds {
  constructor(private feedsRepository: FeedRepository) {}

  async execute(command: GetFeedsCommand): Promise<FeedEntity[]> {
    return await this.feedsRepository.find({
      _environmentId: command.environmentId,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class GetFeeds

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/health/health.controller.ts
TamaÃ±o: 3292 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Controller, Get, NotFoundException } from '@nestjs/common';
import { Body, Post } from '@nestjs/common/decorators';
import { ApiExcludeController } from '@nestjs/swagger';
import { HealthCheck, HealthCheckResult, HealthCheckService, HealthIndicatorFunction } from '@nestjs/terminus';
import {
  CacheServiceHealthIndicator,
  DalServiceHealthIndicator,
  ExternalApiAccessible,
  SkipPermissionsCheck,
  WorkflowQueueServiceHealthIndicator,
} from '@novu/application-generic';
import { version } from '../../../package.json';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ApiCommonResponses, ApiCreatedResponse } from '../shared/framework/response.decorator';
import { DocumentationIgnore, SdkMethodName } from '../shared/framework/swagger/sdk.decorators';
import {
  IdempotenceTestingResponse,
  IdempotencyBehaviorEnum,
  IdempotencyTestingDto,
} from '../testing/dtos/idempotency.dto';

@Controller('health-check')
@ApiExcludeController()
export class HealthController {
  constructor(
    private healthCheckService: HealthCheckService,
    private cacheHealthIndicator: CacheServiceHealthIndicator,
    private dalHealthIndicator: DalServiceHealthIndicator,
    private workflowQueueHealthIndicator: WorkflowQueueServiceHealthIndicator
  ) {}

  @Get()
  @HealthCheck()
  healthCheck(): Promise<HealthCheckResult> {
    const checks: HealthIndicatorFunction[] = [
      async () => this.dalHealthIndicator.isHealthy(),
      async () => this.workflowQueueHealthIndicator.isHealthy(),
      async () => ({
        apiVersion: {
          version,
          status: 'up',
        },
      }),
    ];

    if (process.env.ELASTICACHE_CLUSTER_SERVICE_HOST) {
      checks.push(async () => this.cacheHealthIndicator.isHealthy());
    }

    return this.healthCheckService.check(checks);
  }

  @ExternalApiAccessible()
  @RequireAuthentication()
  @ApiCommonResponses()
  @ApiCreatedResponse({ type: IdempotenceTestingResponse })
  @DocumentationIgnore()
  @SdkMethodName('testIdempotency')
  @Post('/test-idempotency')
  @SkipPermissionsCheck()
  async testIdempotency(@Body() body: IdempotencyTestingDto): Promise<IdempotenceTestingResponse> {
    if (process.env.NODE_ENV !== 'test') throw new NotFoundException();

    const randomNumber = Math.random();
    if (body.expectedBehavior === IdempotencyBehaviorEnum.IMMEDIATE_RESPONSE) {
      return { number: randomNumber };
    }
    if (body.expectedBehavior === IdempotencyBehaviorEnum.IMMEDIATE_EXCEPTION) {
      throw new Error(new Date().toDateString());
    }
    if (body.expectedBehavior === IdempotencyBehaviorEnum.DELAYED_RESPONSE) {
      // for testing conflict
      await new Promise((resolve) => {
        setTimeout(resolve, 500);
      });
    }

    return { number: randomNumber };
  }
  @DocumentationIgnore()
  @ExternalApiAccessible()
  @RequireAuthentication()
  @ApiCommonResponses()
  @ApiCreatedResponse({ type: IdempotenceTestingResponse })
  @SdkMethodName('generateRandomNumber')
  @Get('/test-idempotency')
  @SkipPermissionsCheck()
  async generateRandomNumber(): Promise<IdempotenceTestingResponse> {
    if (process.env.NODE_ENV !== 'test') throw new NotFoundException();

    const randomNumber = Math.random();

    return { number: randomNumber };
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class HealthController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/health/health.module.ts
TamaÃ±o: 342 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { TerminusModule } from '@nestjs/terminus';
import { SharedModule } from '../shared/shared.module';
import { HealthController } from './health.controller';

@Module({
  imports: [SharedModule, TerminusModule],
  controllers: [HealthController],
  providers: [],
})
export class HealthModule {}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class HealthModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/health/e2e/health-check.e2e.ts
TamaÃ±o: 498 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Health-check', () => {
  const session = new UserSession();

  before(async () => {
    await session.initialize();
  });

  describe('/health-check (GET) #novu-v2', () => {
    it('should correctly return a health check', async () => {
      const result = await session.testAgent.get('/v1/health-check');
      const { data } = result.body || {};

      expect(data?.status).to.equal('ok');
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();

  before(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbound-parse/inbound-parse.controller.ts
TamaÃ±o: 1696 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ClassSerializerInterceptor, Controller, Get, UseInterceptors } from '@nestjs/common';
import { ApiExcludeController, ApiOperation, ApiTags } from '@nestjs/swagger';
import { PinoLogger } from '@novu/application-generic';
import { UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { UserSession } from '../shared/framework/user.decorator';
import { GetMxRecordResponseDto } from './dtos/get-mx-record.dto';
import { GetMxRecordCommand } from './usecases/get-mx-record/get-mx-record.command';
import { GetMxRecord } from './usecases/get-mx-record/get-mx-record.usecase';

@ApiCommonResponses()
@Controller('/inbound-parse')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiTags('Inbound Parse')
@ApiExcludeController()
export class InboundParseController {
  constructor(
    private getMxRecordUsecase: GetMxRecord,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  @Get('/mx/status')
  @ApiOperation({
    summary: 'Validate the mx record setup for the inbound parse functionality',
  })
  @ApiResponse(GetMxRecordResponseDto)
  @ExternalApiAccessible()
  async getMxRecordStatus(@UserSession() user: UserSessionData): Promise<GetMxRecordResponseDto> {
    this.logger.info('Getting MX Record Status');

    return await this.getMxRecordUsecase.execute(
      GetMxRecordCommand.create({ environmentId: user.environmentId, organizationId: user.organizationId })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class InboundParseController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbound-parse/inbound-parse.module.ts
TamaÃ±o: 1209 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MiddlewareConsumer, Module, NestModule, OnApplicationShutdown } from '@nestjs/common';
import { CompileTemplate, WorkflowInMemoryProviderService } from '@novu/application-generic';
import { AuthModule } from '../auth/auth.module';
import { SharedModule } from '../shared/shared.module';
import { InboundParseController } from './inbound-parse.controller';
import { USE_CASES } from './usecases';

const PROVIDERS = [CompileTemplate];

const memoryQueueService = {
  provide: WorkflowInMemoryProviderService,
  useFactory: async () => {
    const memoryService = new WorkflowInMemoryProviderService();

    await memoryService.initialize();

    return memoryService;
  },
};
@Module({
  imports: [SharedModule, AuthModule],
  controllers: [InboundParseController],
  providers: [...PROVIDERS, ...USE_CASES, memoryQueueService],
  exports: [...USE_CASES],
})
export class InboundParseModule implements NestModule, OnApplicationShutdown {
  constructor(private workflowInMemoryProviderService: WorkflowInMemoryProviderService) {}
  configure(consumer: MiddlewareConsumer): MiddlewareConsumer | void {}

  async onApplicationShutdown() {
    await this.workflowInMemoryProviderService.shutdown();
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - memoryQueueService({
  provide: WorkflowInMemoryProviderService,
  useFactory: async ())
Declaraciones 'export' encontradas:
- export class InboundParseModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbound-parse/dtos/get-mx-record.dto.ts
TamaÃ±o: 136 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class GetMxRecordResponseDto {
  @ApiProperty()
  mxRecordConfigured: boolean;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class GetMxRecordResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbound-parse/usecases/index.ts
TamaÃ±o: 110 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { GetMxRecord } from './get-mx-record/get-mx-record.usecase';

export const USE_CASES = [GetMxRecord];


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbound-parse/usecases/get-mx-record/get-mx-record.command.ts
TamaÃ±o: 142 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class GetMxRecordCommand extends EnvironmentCommand {}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class GetMxRecordCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbound-parse/usecases/get-mx-record/get-mx-record.usecase.ts
TamaÃ±o: 2233 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { type MxRecord, promises } from 'node:dns';
import { BadRequestException, Injectable, Scope } from '@nestjs/common';
import { EnvironmentEntity, EnvironmentRepository } from '@novu/dal';
import { GetMxRecordResponseDto } from '../../dtos/get-mx-record.dto';
import { GetMxRecordCommand } from './get-mx-record.command';

@Injectable({
  scope: Scope.REQUEST,
})
export class GetMxRecord {
  constructor(private environmentRepository: EnvironmentRepository) {}

  async execute(command: GetMxRecordCommand): Promise<GetMxRecordResponseDto> {
    const env = await this.environmentRepository.findOne({ _id: command.environmentId });
    if (!env) throw new BadRequestException('Environment is not found');

    const inboundParseDomain = env.dns?.inboundParseDomain;

    if (!inboundParseDomain) return { mxRecordConfigured: false };

    const mxRecordExist = await this.checkMxRecordExistence(inboundParseDomain);
    const res: GetMxRecordResponseDto = { mxRecordConfigured: mxRecordExist };
    const updateNotNeeded = mxRecordExist === env.dns?.mxRecordConfigured;

    if (updateNotNeeded) return res;

    await this.updateMxRecord(mxRecordExist, command);

    return res;
  }

  private async updateMxRecord(mxRecordExist: boolean, command: GetMxRecordCommand) {
    const updatePayload: Partial<EnvironmentEntity> = {};

    updatePayload[`dns.mxRecordConfigured`] = mxRecordExist;

    await this.environmentRepository.update(
      {
        _id: command.environmentId,
        _organizationId: command.organizationId,
      },
      { $set: updatePayload }
    );
  }

  private async checkMxRecordExistence(inboundParseDomain: string) {
    const relativeDnsRecords = await this.getMxRecords(inboundParseDomain);
    const INBOUND_DOMAIN = process.env.MAIL_SERVER_DOMAIN?.replace('https://', '').replace('/', '');
    if (!INBOUND_DOMAIN) {
      throw new BadRequestException('MAIL_SERVER_DOMAIN is not defined as an environment variable');
    }

    return relativeDnsRecords.some((record: MxRecord) => record.exchange === INBOUND_DOMAIN);
  }

  async getMxRecords(domain: string): Promise<MxRecord[]> {
    try {
      return await promises.resolveMx(domain);
    } catch (e) {
      return [];
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - INBOUND_DOMAIN(process.env.MAIL_SERVER_DOMAIN?.replace('https://', '').replace('/', '');
    if (!INBOUND_DOMAIN) {...)
Declaraciones 'export' encontradas:
- export class GetMxRecord

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/inbox.controller.ts
TamaÃ±o: 23025 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  Controller,
  Delete,
  Get,
  Headers,
  HttpCode,
  HttpStatus,
  Param,
  Patch,
  Post,
  Query,
  Req,
  UseGuards,
} from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { ApiExcludeController } from '@nestjs/swagger';
import {
  AddressingTypeEnum,
  MessageActionStatusEnum,
  PreferenceLevelEnum,
  TriggerRequestCategoryEnum,
  UserSessionData,
} from '@novu/shared';
import { TriggerEventRequestDto } from '../events/dtos';
import { TriggerEventResponseDto } from '../events/dtos/trigger-event-response.dto';
import { ParseEventRequestMulticastCommand } from '../events/usecases/parse-event-request';
import { ParseEventRequest } from '../events/usecases/parse-event-request/parse-event-request.usecase';
import { ExcludeFromIdempotency } from '../shared/framework/exclude-from-idempotency';
import { ApiCommonResponses } from '../shared/framework/response.decorator';
import { KeylessAccessible } from '../shared/framework/swagger/keyless.security';
import { SubscriberSession, UserSession } from '../shared/framework/user.decorator';
import { RequestWithReqId } from '../shared/middleware/request-id.middleware';
import {
  GetSubscriberGlobalPreference,
  GetSubscriberGlobalPreferenceCommand,
} from '../subscribers/usecases/get-subscriber-global-preference';
import { ActionTypeRequestDto } from './dtos/action-type-request.dto';
import { BulkUpdatePreferencesRequestDto } from './dtos/bulk-update-preferences-request.dto';
import { GetNotificationsCountRequestDto } from './dtos/get-notifications-count-request.dto';
import { GetNotificationsCountResponseDto } from './dtos/get-notifications-count-response.dto';
import { GetNotificationsRequestDto } from './dtos/get-notifications-request.dto';
import { GetNotificationsResponseDto } from './dtos/get-notifications-response.dto';
import { GetPreferencesRequestDto } from './dtos/get-preferences-request.dto';
import { GetPreferencesResponseDto } from './dtos/get-preferences-response.dto';
import { MarkNotificationsAsSeenRequestDto } from './dtos/mark-notifications-as-seen-request.dto';
import { SnoozeNotificationRequestDto } from './dtos/snooze-notification-request.dto';
import { SubscriberSessionRequestDto } from './dtos/subscriber-session-request.dto';
import { SubscriberSessionResponseDto } from './dtos/subscriber-session-response.dto';
import { UpdateAllNotificationsRequestDto } from './dtos/update-all-notifications-request.dto';
import { UpdatePreferencesRequestDto } from './dtos/update-preferences-request.dto';
import { BulkUpdatePreferencesCommand } from './usecases/bulk-update-preferences/bulk-update-preferences.command';
import { BulkUpdatePreferences } from './usecases/bulk-update-preferences/bulk-update-preferences.usecase';
import { DeleteAllNotificationsCommand } from './usecases/delete-all-notifications/delete-all-notifications.command';
import { DeleteAllNotifications } from './usecases/delete-all-notifications/delete-all-notifications.usecase';
import { DeleteNotificationCommand } from './usecases/delete-notification/delete-notification.command';
import { DeleteNotification } from './usecases/delete-notification/delete-notification.usecase';
import { GetInboxPreferencesCommand } from './usecases/get-inbox-preferences/get-inbox-preferences.command';
import { GetInboxPreferences } from './usecases/get-inbox-preferences/get-inbox-preferences.usecase';
import { GetNotificationsCommand } from './usecases/get-notifications/get-notifications.command';
import { GetNotifications } from './usecases/get-notifications/get-notifications.usecase';
import { MarkNotificationAsCommand } from './usecases/mark-notification-as/mark-notification-as.command';
import { MarkNotificationAs } from './usecases/mark-notification-as/mark-notification-as.usecase';
import { MarkNotificationsAsSeenCommand } from './usecases/mark-notifications-as-seen/mark-notifications-as-seen.command';
import { MarkNotificationsAsSeen } from './usecases/mark-notifications-as-seen/mark-notifications-as-seen.usecase';
import { NotificationsCountCommand } from './usecases/notifications-count/notifications-count.command';
import { NotificationsCount } from './usecases/notifications-count/notifications-count.usecase';
import { SessionCommand } from './usecases/session/session.command';
import { Session } from './usecases/session/session.usecase';
import { SnoozeNotificationCommand } from './usecases/snooze-notification/snooze-notification.command';
import { SnoozeNotification } from './usecases/snooze-notification/snooze-notification.usecase';
import { UnsnoozeNotificationCommand } from './usecases/unsnooze-notification/unsnooze-notification.command';
import { UnsnoozeNotification } from './usecases/unsnooze-notification/unsnooze-notification.usecase';
import { UpdateAllNotificationsCommand } from './usecases/update-all-notifications/update-all-notifications.command';
import { UpdateAllNotifications } from './usecases/update-all-notifications/update-all-notifications.usecase';
import { UpdateNotificationActionCommand } from './usecases/update-notification-action/update-notification-action.command';
import { UpdateNotificationAction } from './usecases/update-notification-action/update-notification-action.usecase';
import { UpdatePreferencesCommand } from './usecases/update-preferences/update-preferences.command';
import { UpdatePreferences } from './usecases/update-preferences/update-preferences.usecase';
import type { InboxNotification, InboxPreference } from './utils/types';

@ApiCommonResponses()
@Controller('/inbox')
@ApiExcludeController()
@ExcludeFromIdempotency()
export class InboxController {
  constructor(
    private initializeSessionUsecase: Session,
    private getNotificationsUsecase: GetNotifications,
    private notificationsCountUsecase: NotificationsCount,
    private markNotificationAsUsecase: MarkNotificationAs,
    private updateNotificationActionUsecase: UpdateNotificationAction,
    private updateAllNotifications: UpdateAllNotifications,
    private getInboxPreferencesUsecase: GetInboxPreferences,
    private updatePreferencesUsecase: UpdatePreferences,
    private bulkUpdatePreferencesUsecase: BulkUpdatePreferences,
    private snoozeNotificationUsecase: SnoozeNotification,
    private unsnoozeNotificationUsecase: UnsnoozeNotification,
    private markNotificationsAsSeenUsecase: MarkNotificationsAsSeen,
    private parseEventRequest: ParseEventRequest,
    private getSubscriberGlobalPreference: GetSubscriberGlobalPreference,
    private deleteNotificationUsecase: DeleteNotification,
    private deleteAllNotificationsUsecase: DeleteAllNotifications
  ) {}

  @KeylessAccessible()
  @Post('/session')
  async sessionInitialize(
    @Body() body: SubscriberSessionRequestDto,
    @Headers('origin') origin: string
  ): Promise<SubscriberSessionResponseDto> {
    return await this.initializeSessionUsecase.execute(
      SessionCommand.create({
        requestData: body,
        origin,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Get('/notifications')
  async getNotifications(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Query() query: GetNotificationsRequestDto
  ): Promise<GetNotificationsResponseDto> {
    return await this.getNotificationsUsecase.execute(
      GetNotificationsCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        contextKeys: subscriberSession.contextKeys,
        limit: query.limit,
        offset: query.offset,
        after: query.after,
        tags: query.tags,
        read: query.read,
        archived: query.archived,
        snoozed: query.snoozed,
        seen: query.seen,
        data: query.data,
        severity: query.severity,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Get('/notifications/count')
  async getNotificationsCount(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Query() query: GetNotificationsCountRequestDto
  ): Promise<GetNotificationsCountResponseDto> {
    const res = await this.notificationsCountUsecase.execute(
      NotificationsCountCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        contextKeys: subscriberSession.contextKeys,
        filters: query.filters,
      })
    );

    return res;
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Get('/preferences')
  async getAllPreferences(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Query() query: GetPreferencesRequestDto
  ): Promise<GetPreferencesResponseDto[]> {
    return await this.getInboxPreferencesUsecase.execute(
      GetInboxPreferencesCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        tags: query.tags,
        severity: query.severity,
        criticality: query.criticality,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Get('/preferences/global')
  async getSchedule(@SubscriberSession() subscriberSession: SubscriberSession): Promise<InboxPreference> {
    const globalPreference = await this.getSubscriberGlobalPreference.execute(
      GetSubscriberGlobalPreferenceCommand.create({
        organizationId: subscriberSession._organizationId,
        environmentId: subscriberSession._environmentId,
        subscriberId: subscriberSession.subscriberId,
        includeInactiveChannels: false,
        subscriber: subscriberSession,
      })
    );

    return {
      level: PreferenceLevelEnum.GLOBAL,
      ...globalPreference.preference,
    };
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Patch('/notifications/:id/read')
  async markNotificationAsRead(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Param('id') notificationId: string
  ): Promise<InboxNotification> {
    return await this.markNotificationAsUsecase.execute(
      MarkNotificationAsCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        contextKeys: subscriberSession.contextKeys,
        notificationId,
        read: true,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Patch('/notifications/:id/unread')
  async markNotificationAsUnread(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Param('id') notificationId: string
  ): Promise<InboxNotification> {
    return await this.markNotificationAsUsecase.execute(
      MarkNotificationAsCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        contextKeys: subscriberSession.contextKeys,
        notificationId,
        read: false,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Patch('/notifications/:id/archive')
  async markNotificationAsArchived(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Param('id') notificationId: string
  ): Promise<InboxNotification> {
    return await this.markNotificationAsUsecase.execute(
      MarkNotificationAsCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        contextKeys: subscriberSession.contextKeys,
        notificationId,
        archived: true,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Patch('/notifications/:id/unarchive')
  async markNotificationAsUnarchived(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Param('id') notificationId: string
  ): Promise<InboxNotification> {
    return await this.markNotificationAsUsecase.execute(
      MarkNotificationAsCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        contextKeys: subscriberSession.contextKeys,
        notificationId,
        archived: false,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Patch('/notifications/:id/snooze')
  async snoozeNotification(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Param('id') notificationId: string,
    @Body() body: SnoozeNotificationRequestDto
  ): Promise<InboxNotification> {
    return await this.snoozeNotificationUsecase.execute(
      SnoozeNotificationCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        contextKeys: subscriberSession.contextKeys,
        notificationId,
        snoozeUntil: body.snoozeUntil,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Patch('/notifications/:id/unsnooze')
  async unsnoozeNotification(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Param('id') notificationId: string
  ): Promise<InboxNotification> {
    return await this.unsnoozeNotificationUsecase.execute(
      UnsnoozeNotificationCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        contextKeys: subscriberSession.contextKeys,
        notificationId,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Delete('/notifications/:id/delete')
  @HttpCode(HttpStatus.NO_CONTENT)
  async deleteNotification(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Param('id') notificationId: string
  ): Promise<void> {
    await this.deleteNotificationUsecase.execute(
      DeleteNotificationCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        contextKeys: subscriberSession.contextKeys,
        notificationId,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Patch('/notifications/:id/complete')
  async completeAction(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Param('id') notificationId: string,
    @Body() body: ActionTypeRequestDto
  ): Promise<InboxNotification> {
    return await this.updateNotificationActionUsecase.execute(
      UpdateNotificationActionCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        contextKeys: subscriberSession.contextKeys,
        notificationId,
        actionType: body.actionType,
        actionStatus: MessageActionStatusEnum.DONE,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Patch('/notifications/:id/revert')
  async revertAction(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Param('id') notificationId: string,
    @Body() body: ActionTypeRequestDto
  ): Promise<InboxNotification> {
    return await this.updateNotificationActionUsecase.execute(
      UpdateNotificationActionCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        contextKeys: subscriberSession.contextKeys,
        notificationId,
        actionType: body.actionType,
        actionStatus: MessageActionStatusEnum.PENDING,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Patch('/preferences')
  async updateGlobalPreference(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Body() body: UpdatePreferencesRequestDto
  ): Promise<InboxPreference> {
    return await this.updatePreferencesUsecase.execute(
      UpdatePreferencesCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        level: PreferenceLevelEnum.GLOBAL,
        chat: body.chat,
        email: body.email,
        in_app: body.in_app,
        push: body.push,
        sms: body.sms,
        schedule: body.schedule,
        includeInactiveChannels: false,
      })
    );
  }

  /**
   * IMPORTANT: Make sure this endpoint route is defined before the single workflow preference update endpoint
   * "PATCH /preferences/:workflowIdOrIdentifier", otherwise, the single workflow preference update endpoint will be triggered instead
   */
  @UseGuards(AuthGuard('subscriberJwt'))
  @Patch('/preferences/bulk')
  async bulkUpdateWorkflowPreferences(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Body() body: BulkUpdatePreferencesRequestDto
  ): Promise<GetPreferencesResponseDto[]> {
    return await this.bulkUpdatePreferencesUsecase.execute(
      BulkUpdatePreferencesCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        preferences: body.preferences,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Patch('/preferences/:workflowIdOrIdentifier')
  async updateWorkflowPreference(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Param('workflowIdOrIdentifier') workflowIdOrIdentifier: string,
    @Body() body: UpdatePreferencesRequestDto
  ): Promise<InboxPreference> {
    return await this.updatePreferencesUsecase.execute(
      UpdatePreferencesCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        level: PreferenceLevelEnum.TEMPLATE,
        chat: body.chat,
        email: body.email,
        in_app: body.in_app,
        push: body.push,
        sms: body.sms,
        workflowIdOrIdentifier,
        includeInactiveChannels: false,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Post('/notifications/seen')
  @HttpCode(HttpStatus.NO_CONTENT)
  async markNotificationsAsSeen(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Body() body: MarkNotificationsAsSeenRequestDto
  ): Promise<void> {
    await this.markNotificationsAsSeenUsecase.execute(
      MarkNotificationsAsSeenCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        contextKeys: subscriberSession.contextKeys,
        notificationIds: body.notificationIds,
        tags: body.tags,
        data: body.data,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Post('/notifications/read')
  @HttpCode(HttpStatus.NO_CONTENT)
  async markAllAsRead(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Body() body: UpdateAllNotificationsRequestDto
  ): Promise<void> {
    await this.updateAllNotifications.execute(
      UpdateAllNotificationsCommand.create({
        environmentId: subscriberSession._environmentId,
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        contextKeys: subscriberSession.contextKeys,
        from: {
          tags: body.tags,
          data: body.data,
        },
        to: {
          read: true,
        },
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Post('/notifications/archive')
  @HttpCode(HttpStatus.NO_CONTENT)
  async markAllAsArchived(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Body() body: UpdateAllNotificationsRequestDto
  ): Promise<void> {
    await this.updateAllNotifications.execute(
      UpdateAllNotificationsCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        contextKeys: subscriberSession.contextKeys,
        from: {
          tags: body.tags,
          data: body.data,
        },
        to: {
          archived: true,
        },
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Post('/notifications/read-archive')
  @HttpCode(HttpStatus.NO_CONTENT)
  async markAllAsReadArchived(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Body() body: UpdateAllNotificationsRequestDto
  ): Promise<void> {
    await this.updateAllNotifications.execute(
      UpdateAllNotificationsCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        contextKeys: subscriberSession.contextKeys,
        from: {
          tags: body.tags,
          read: true,
          data: body.data,
        },
        to: {
          archived: true,
        },
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Post('/notifications/delete')
  @HttpCode(HttpStatus.NO_CONTENT)
  async deleteAllNotifications(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Body() body: UpdateAllNotificationsRequestDto
  ): Promise<void> {
    await this.deleteAllNotificationsUsecase.execute(
      DeleteAllNotificationsCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        contextKeys: subscriberSession.contextKeys,
        filters: {
          tags: body.tags,
          data: body.data,
        },
      })
    );
  }

  @KeylessAccessible()
  @UseGuards(AuthGuard('subscriberJwt'))
  @Post('/events')
  async keylessEvents(
    @UserSession() user: UserSessionData,
    @Body() body: TriggerEventRequestDto,
    @Req() req: RequestWithReqId
  ): Promise<TriggerEventResponseDto> {
    const result = await this.parseEventRequest.execute(
      ParseEventRequestMulticastCommand.create({
        userId: user._id,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        identifier: body.name,
        payload: body.payload || {},
        overrides: body.overrides || {},
        to: body.to,
        actor: body.actor,
        tenant: body.tenant,
        context: body.context,
        transactionId: body.transactionId,
        addressingType: AddressingTypeEnum.MULTICAST,
        requestCategory: TriggerRequestCategoryEnum.SINGLE,
        bridgeUrl: body.bridgeUrl,
        controls: body.controls,
        requestId: req._nvRequestId,
      })
    );

    return result as unknown as TriggerEventResponseDto;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class InboxController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/inbox.module.ts
TamaÃ±o: 1052 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { CommunityOrganizationRepository, ContextRepository } from '@novu/dal';
import { AuthModule } from '../auth/auth.module';
import { IntegrationModule } from '../integrations/integrations.module';
import { OrganizationModule } from '../organization/organization.module';
import { OutboundWebhooksModule } from '../outbound-webhooks/outbound-webhooks.module';
import { PreferencesModule } from '../preferences';
import { SharedModule } from '../shared/shared.module';
import { SubscribersV1Module } from '../subscribers/subscribersV1.module';
import { InboxController } from './inbox.controller';
import { USE_CASES } from './usecases';

@Module({
  imports: [
    SharedModule,
    SubscribersV1Module,
    AuthModule,
    IntegrationModule,
    PreferencesModule,
    OrganizationModule,
    OutboundWebhooksModule.forRoot(),
  ],
  providers: [...USE_CASES, CommunityOrganizationRepository, ContextRepository],
  exports: [...USE_CASES],
  controllers: [InboxController],
})
export class InboxModule {}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class InboxModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/dtos/action-type-request.dto.ts
TamaÃ±o: 219 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ButtonTypeEnum } from '@novu/shared';
import { IsDefined, IsEnum } from 'class-validator';

export class ActionTypeRequestDto {
  @IsEnum(ButtonTypeEnum)
  @IsDefined()
  readonly actionType: ButtonTypeEnum;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class ActionTypeRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/dtos/bulk-update-preferences-request.dto.ts
TamaÃ±o: 555 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Type } from 'class-transformer';
import { IsArray, IsDefined, IsString, ValidateNested } from 'class-validator';

import { UpdatePreferencesRequestDto } from './update-preferences-request.dto';

export class BulkUpdatePreferenceItemDto extends UpdatePreferencesRequestDto {
  @IsDefined()
  @IsString()
  readonly workflowId: string;
}

export class BulkUpdatePreferencesRequestDto {
  @IsDefined()
  @IsArray()
  @Type(() => BulkUpdatePreferenceItemDto)
  @ValidateNested({ each: true })
  readonly preferences: BulkUpdatePreferenceItemDto[];
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class BulkUpdatePreferenceItemDto
- export class BulkUpdatePreferencesRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/dtos/get-notifications-count-request.dto.ts
TamaÃ±o: 1444 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException } from '@nestjs/common';
import { SeverityLevelEnum } from '@novu/shared';
import { plainToClass, Transform, Type } from 'class-transformer';
import {
  ArrayMaxSize,
  IsArray,
  IsBoolean,
  IsDefined,
  IsEnum,
  IsOptional,
  IsString,
  ValidateNested,
} from 'class-validator';
import { IsEnumOrArray } from '../../shared/validators/is-enum-or-array';
import { NotificationFilter } from '../utils/types';

export class NotificationsFilter implements NotificationFilter {
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @IsOptional()
  @IsBoolean()
  read?: boolean;

  @IsOptional()
  @IsBoolean()
  archived?: boolean;

  @IsOptional()
  @IsBoolean()
  snoozed?: boolean;

  @IsOptional()
  @IsBoolean()
  seen?: boolean;

  @IsOptional()
  @IsEnumOrArray(SeverityLevelEnum)
  severity?: SeverityLevelEnum | SeverityLevelEnum[];
}

export class GetNotificationsCountRequestDto {
  @IsDefined()
  @Transform(({ value }) => {
    try {
      const filters = JSON.parse(value);
      if (Array.isArray(filters)) {
        return filters.map((el) => plainToClass(NotificationsFilter, el));
      }

      return filters;
    } catch (e) {
      throw new BadRequestException('Invalid filters, the JSON object should be provided.');
    }
  })
  @IsArray()
  @ArrayMaxSize(30)
  @ValidateNested({ each: true })
  @Type(() => NotificationsFilter)
  filters: NotificationsFilter[];
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - filters(JSON.parse(value);
      if (Array.isArray(filters)) {
        return filters.map((el))
Declaraciones 'export' encontradas:
- export class NotificationsFilter
- export class GetNotificationsCountRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/dtos/get-notifications-count-response.dto.ts
TamaÃ±o: 182 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { NotificationFilter } from '../utils/types';

export class GetNotificationsCountResponseDto {
  data: Array<{
    count: number;
    filter: NotificationFilter;
  }>;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class GetNotificationsCountResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/dtos/get-notifications-request.dto.ts
TamaÃ±o: 1470 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { SeverityLevelEnum } from '@novu/shared';
import { Transform } from 'class-transformer';
import { IsArray, IsBoolean, IsOptional, IsString } from 'class-validator';

import { CursorPaginationRequestDto } from '../../shared/dtos/cursor-pagination-request';
import { IsEnumOrArray } from '../../shared/validators/is-enum-or-array';
import { NotificationFilter } from '../utils/types';

const LIMIT = {
  DEFAULT: 10,
  MAX: 100,
};

export class GetNotificationsRequestDto
  extends CursorPaginationRequestDto(LIMIT.DEFAULT, LIMIT.MAX)
  implements NotificationFilter
{
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => value === 'true')
  read?: boolean;

  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => value === 'true')
  archived?: boolean;

  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => value === 'true')
  snoozed?: boolean;

  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => value === 'true')
  seen?: boolean;

  @IsOptional()
  @IsString()
  @ApiPropertyOptional({
    description: 'Filter by data attributes (JSON string)',
  })
  data?: string;

  @IsOptional()
  @IsEnumOrArray(SeverityLevelEnum)
  @ApiPropertyOptional({
    description: 'Filter by severity levels',
    type: [String],
    enum: SeverityLevelEnum,
  })
  severity?: SeverityLevelEnum | SeverityLevelEnum[];
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - LIMIT({
  DEFAULT: 10,
  MAX: 100,
};

export class GetNotificationsRequestDto
  extends CursorPaginationR...)
Declaraciones 'export' encontradas:
- export class GetNotificationsRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/dtos/get-notifications-response.dto.ts
TamaÃ±o: 202 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { InboxNotification, NotificationFilter } from '../utils/types';

export class GetNotificationsResponseDto {
  data: InboxNotification[];
  hasMore: boolean;
  filter: NotificationFilter;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class GetNotificationsResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/dtos/get-preferences-request.dto.ts
TamaÃ±o: 579 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SeverityLevelEnum, WorkflowCriticalityEnum } from '@novu/shared';
import { IsArray, IsEnum, IsOptional, IsString } from 'class-validator';
import { IsEnumOrArray } from '../../shared/validators/is-enum-or-array';

export class GetPreferencesRequestDto {
  @IsEnum(WorkflowCriticalityEnum)
  @IsOptional()
  criticality: WorkflowCriticalityEnum = WorkflowCriticalityEnum.NON_CRITICAL;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @IsOptional()
  @IsEnumOrArray(SeverityLevelEnum)
  severity?: SeverityLevelEnum | SeverityLevelEnum[];
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class GetPreferencesRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/dtos/get-preferences-response.dto.ts
TamaÃ±o: 1353 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { PreferenceLevelEnum } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsDefined, IsEnum, IsOptional, ValidateNested } from 'class-validator';
import { SubscriberPreferenceChannels } from '../../shared/dtos/preference-channels';
import { WorkflowDto } from './workflow.dto';

export class GetPreferencesResponseDto {
  @ApiProperty({
    enum: PreferenceLevelEnum,
    enumName: 'PreferenceLevelEnum',
    description: 'The level of the preference (global or template)',
  })
  @IsDefined()
  @IsEnum(PreferenceLevelEnum, {
    message: 'level must be a valid PreferenceLevelEnum',
  })
  level: PreferenceLevelEnum;

  @ApiPropertyOptional({
    type: WorkflowDto,
    description: 'Workflow information if this is a template-level preference',
    nullable: true,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => WorkflowDto)
  workflow?: WorkflowDto;

  @ApiProperty({
    type: Boolean,
    description: 'Whether the preference is enabled',
    example: true,
  })
  @IsDefined()
  enabled: boolean;

  @ApiProperty({
    type: SubscriberPreferenceChannels,
    description: 'Channel-specific preference settings',
  })
  @IsDefined()
  @ValidateNested()
  @Type(() => SubscriberPreferenceChannels)
  channels: SubscriberPreferenceChannels;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class GetPreferencesResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/dtos/mark-notifications-as-seen-request.dto.ts
TamaÃ±o: 341 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsArray, IsMongoId, IsOptional, IsString } from 'class-validator';

export class MarkNotificationsAsSeenRequestDto {
  @IsOptional()
  @IsArray()
  @IsMongoId({ each: true })
  notificationIds?: string[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @IsOptional()
  @IsString()
  data?: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class MarkNotificationsAsSeenRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/dtos/snooze-notification-request.dto.ts
TamaÃ±o: 1120 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Type } from 'class-transformer';
import { IsDate, IsDefined, registerDecorator, ValidationArguments, ValidationOptions } from 'class-validator';

function IsFutureDate(
  options?: {
    leewayMs?: number;
  },
  validationOptions?: ValidationOptions
) {
  const leewayMs = options?.leewayMs ?? 1000 * 60; // default 1 minute

  return (object: Object, propertyName: string) => {
    registerDecorator({
      name: 'isFutureDate',
      target: object.constructor,
      propertyName,
      options: {
        message: `Snooze time must be at least ${leewayMs / 1000} seconds in the future`,
        ...validationOptions,
      },
      validator: {
        validate(value: Date, args: ValidationArguments) {
          if (!(value instanceof Date)) {
            return false;
          }

          const now = new Date();
          const delay = value.getTime() - now.getTime();

          return delay >= leewayMs;
        },
      },
    });
  };
}

export class SnoozeNotificationRequestDto {
  @Type(() => Date)
  @IsDate()
  @IsFutureDate({
    leewayMs: 1000 * 60,
  })
  readonly snoozeUntil: Date;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - IsFutureDate(options?: {
    leewayMs?: number;
  },
  validationOptions?: ValidationOptions)
Asignaciones con arrow functions encontradas (posibles funciones):
 - leewayMs(options?.leewayMs ?? 1000 * 60; // default 1 minute

  return (object: Object, propertyName: string))
Declaraciones 'export' encontradas:
- export class SnoozeNotificationRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/dtos/subscriber-session-request.dto.ts
TamaÃ±o: 1774 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsValidContextPayload } from '@novu/application-generic';
import { ContextPayload } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsDefined, IsOptional, IsString, ValidateNested } from 'class-validator';
import { ScheduleDto } from '../../shared/dtos/schedule';
import { ApiContextPayload } from '../../shared/framework/swagger';

export class SubscriberSessionRequestDto {
  @IsString()
  @IsOptional()
  readonly applicationIdentifier?: string;

  @IsString()
  @IsOptional()
  // TODO: Backward compatibility support - remove in future versions (see NV-5801)
  /** @deprecated Use subscriber instead */
  readonly subscriberId?: string;

  @IsString()
  @IsOptional()
  readonly subscriberHash?: string;

  @IsOptional()
  @ValidateNested()
  @Type(() => SubscriberDto)
  readonly subscriber?: SubscriberDto | string;

  @IsOptional()
  @ValidateNested()
  @Type(() => ScheduleDto)
  readonly defaultSchedule?: ScheduleDto;

  @ApiContextPayload()
  @IsOptional()
  @IsValidContextPayload({ maxCount: 5 })
  readonly context?: ContextPayload;

  @IsString()
  @IsOptional()
  readonly contextHash?: string;
}

export class SubscriberDto {
  @IsOptional()
  @IsString()
  readonly id?: string;

  @IsDefined()
  @IsString()
  readonly subscriberId: string;

  @IsOptional()
  @IsString()
  readonly firstName?: string;

  @IsOptional()
  @IsString()
  readonly lastName?: string;

  @IsOptional()
  @IsString()
  readonly email?: string;

  @IsOptional()
  @IsString()
  readonly phone?: string;

  @IsOptional()
  @IsString()
  readonly avatar?: string;

  @IsOptional()
  readonly data?: Record<string, unknown>;

  @IsOptional()
  @IsString()
  readonly timezone?: string;

  @IsOptional()
  @IsString()
  readonly locale?: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class SubscriberSessionRequestDto
- export class SubscriberDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/dtos/subscriber-session-response.dto.ts
TamaÃ±o: 727 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Schedule, SeverityLevelEnum } from '@novu/shared';

type SeverityCounts = {
  [SeverityLevelEnum.HIGH]: number;
  [SeverityLevelEnum.MEDIUM]: number;
  [SeverityLevelEnum.LOW]: number;
  [SeverityLevelEnum.NONE]: number;
};

type UnreadCount = {
  total: number;
  severity: SeverityCounts;
};

export class SubscriberSessionResponseDto {
  readonly token: string;
  /** @deprecated Use unreadCount instead */
  readonly totalUnreadCount: number;
  readonly unreadCount: UnreadCount;
  readonly removeNovuBranding: boolean;
  readonly maxSnoozeDurationHours: number;
  readonly isDevelopmentMode: boolean;
  readonly applicationIdentifier?: string;
  readonly schedule?: Schedule;
  readonly contextKeys?: string[];
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class SubscriberSessionResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/dtos/update-all-notifications-request.dto.ts
TamaÃ±o: 240 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsArray, IsOptional, IsString } from 'class-validator';

export class UpdateAllNotificationsRequestDto {
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @IsOptional()
  @IsString()
  data?: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class UpdateAllNotificationsRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/dtos/update-preferences-request.dto.ts
TamaÃ±o: 614 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Type } from 'class-transformer';
import { IsBoolean, IsOptional, ValidateNested } from 'class-validator';
import { ScheduleDto } from '../../shared/dtos/schedule';

export class UpdatePreferencesRequestDto {
  @IsOptional()
  @IsBoolean()
  readonly email?: boolean;

  @IsOptional()
  @IsBoolean()
  readonly sms?: boolean;

  @IsOptional()
  @IsBoolean()
  readonly in_app?: boolean;

  @IsOptional()
  @IsBoolean()
  readonly chat?: boolean;

  @IsOptional()
  @IsBoolean()
  readonly push?: boolean;

  @IsOptional()
  @ValidateNested()
  @Type(() => ScheduleDto)
  readonly schedule?: ScheduleDto;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class UpdatePreferencesRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/dtos/workflow.dto.ts
TamaÃ±o: 1648 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { CustomDataType, SeverityLevelEnum } from '@novu/shared';
import { IsArray, IsBoolean, IsDefined, IsEnum, IsObject, IsOptional, IsString } from 'class-validator';

export class WorkflowDto {
  @ApiProperty({
    type: String,
    description: 'Unique identifier of the workflow',
    example: '64a1b2c3d4e5f6g7h8i9j0k1',
  })
  @IsDefined()
  @IsString()
  id: string;

  @ApiProperty({
    type: String,
    description: 'Workflow identifier used for triggering',
    example: 'welcome-email',
  })
  @IsDefined()
  @IsString()
  identifier: string;

  @ApiProperty({
    type: String,
    description: 'Human-readable name of the workflow',
    example: 'Welcome Email Workflow',
  })
  @IsDefined()
  @IsString()
  name: string;

  @ApiProperty({
    type: Boolean,
    description: 'Whether this workflow is marked as critical',
    example: false,
  })
  @IsDefined()
  @IsBoolean()
  critical: boolean;

  @ApiPropertyOptional({
    type: [String],
    description: 'Tags associated with the workflow',
    example: ['user-onboarding', 'email'],
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @ApiPropertyOptional({
    type: Object,
    description: 'Custom data associated with the workflow',
    example: { category: 'onboarding', priority: 'high' },
  })
  @IsOptional()
  @IsObject()
  data?: CustomDataType;

  @ApiProperty({
    enum: SeverityLevelEnum,
    enumName: 'SeverityLevelEnum',
    description: 'Severity level of the workflow',
  })
  @IsDefined()
  @IsEnum(SeverityLevelEnum)
  severity: SeverityLevelEnum;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class WorkflowDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/e2e/delete-notifications.e2e.ts
TamaÃ±o: 7713 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import {
  MessageEntity,
  MessageRepository,
  NotificationTemplateEntity,
  SubscriberEntity,
  SubscriberRepository,
} from '@novu/dal';
import { ChannelCTATypeEnum, StepTypeEnum, TemplateVariableTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { randomBytes } from 'crypto';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Delete Notifications - /inbox/notifications (DELETE/POST) #novu-v2', async () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity | null;
  let messages: MessageEntity[];
  const messageRepository = new MessageRepository();
  const subscriberRepository = new SubscriberRepository();
  let novuClient: Novu;

  const getSubscriber = (): SubscriberEntity => {
    if (!subscriber) {
      throw new Error('Subscriber not initialized');
    }
    return subscriber;
  };

  const deleteNotification = async (id: string) => {
    return await session.testAgent
      .delete(`/v1/inbox/notifications/${id}/delete`)
      .set('Authorization', `Bearer ${session.subscriberToken}`);
  };

  const deleteAllNotifications = async (body?: any) => {
    return await session.testAgent
      .post(`/v1/inbox/notifications/delete`)
      .set('Authorization', `Bearer ${session.subscriberToken}`)
      .send(body || {});
  };

  const triggerEvent = async (templateToTrigger: NotificationTemplateEntity, times = 1) => {
    const currentSubscriber = getSubscriber();

    const promises: Array<Promise<unknown>> = [];
    for (let i = 0; i < times; i += 1) {
      promises.push(
        novuClient.trigger({
          workflowId: templateToTrigger.triggers[0].identifier,
          to: currentSubscriber.subscriberId,
          payload: {
            subject: 'this is a test',
            message: 'Hello, World!',
            isUrgent: true,
            nested: {
              value: `Nested property ${i}`,
            },
          },
        })
      );
    }
    await Promise.all(promises);

    await session.waitForJobCompletion(templateToTrigger._id);
  };

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    template = await session.createTemplate({
      noFeedId: true,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello World {{#if isUrgent}}URGENT: {{/if}}{{#each nested}}{{value}}{{/each}}' as string,
          cta: {
            type: ChannelCTATypeEnum.REDIRECT,
            data: {
              url: '/cypress/test-shell/example/test?test-param=true',
            },
          },
          variables: [
            {
              name: 'isUrgent',
              type: TemplateVariableTypeEnum.BOOLEAN,
            },
          ],
        },
      ],
    });

    subscriber = await subscriberRepository.findBySubscriberId(session.environment._id, session.subscriberId);

    if (!subscriber) {
      throw new Error('Subscriber not found after session initialization');
    }

    novuClient = initNovuClassSdk(session);

    // Create multiple messages for testing
    await triggerEvent(template, 3);

    messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: getSubscriber()._id,
      _templateId: template._id,
    });
  });

  describe('Single notification deletion', () => {
    it('should delete a single notification', async () => {
      const message = messages[0];

      const response = await deleteNotification(message._id);
      expect(response.status).to.equal(204);

      // Verify the message is actually deleted from the database
      const deletedMessage = await messageRepository.findOne({
        _id: message._id,
        _environmentId: session.environment._id,
      });
      expect(deletedMessage).to.be.null;
    });

    it('should return 404 for non-existent notification', async () => {
      const response = await deleteNotification('507f1f77bcf86cd799439011');
      expect(response.status).to.equal(404);
    });
  });

  describe('Bulk notification deletion', () => {
    it('should delete all notifications without filters', async () => {
      const response = await deleteAllNotifications();
      expect(response.status).to.equal(204);

      // Verify all messages are deleted
      const remainingMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: getSubscriber()._id,
        _templateId: template._id,
      });
      expect(remainingMessages).to.have.length(0);
    });

    it('should delete notifications with tag filter', async () => {
      // First, add tags to some messages
      await messageRepository.update(
        { _id: messages[0]._id, _environmentId: session.environment._id },
        { $set: { tags: ['urgent'] } }
      );
      await messageRepository.update(
        { _id: messages[1]._id, _environmentId: session.environment._id },
        { $set: { tags: ['urgent'] } }
      );

      const response = await deleteAllNotifications({ tags: ['urgent'] });
      expect(response.status).to.equal(204);

      // Verify only tagged messages are deleted
      const remainingMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: getSubscriber()._id,
        _templateId: template._id,
      });
      expect(remainingMessages).to.have.length(1);
      expect(remainingMessages[0]._id).to.equal(messages[2]._id);
    });

    it('should delete notifications with data filter', async () => {
      // First, add data to some messages
      await messageRepository.update(
        { _id: messages[0]._id, _environmentId: session.environment._id },
        { $set: { data: { category: 'test' } } }
      );

      const response = await deleteAllNotifications({
        data: JSON.stringify({ category: 'test' }),
      });
      expect(response.status).to.equal(204);

      // Verify only messages with matching data are deleted
      const remainingMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: getSubscriber()._id,
        _templateId: template._id,
      });
      expect(remainingMessages).to.have.length(2);
    });
  });

  describe('Authorization', () => {
    it('should require authentication', async () => {
      const response = await session.testAgent.delete(`/v1/inbox/notifications/${messages[0]._id}/delete`);
      expect(response.status).to.equal(401);
    });

    it('should not allow deleting notifications from other subscribers', async () => {
      const uniqueSubscriberId = `other-subscriber-${randomBytes(4).toString('hex')}`;
      const otherSubscriber = await subscriberRepository.create({
        subscriberId: uniqueSubscriberId,
        _environmentId: session.environment._id,
        _organizationId: session.organization._id,
      });

      // Trigger event for the other subscriber
      await novuClient.trigger({
        workflowId: template.triggers[0].identifier,
        to: uniqueSubscriberId,
        payload: {
          subject: 'this is a test',
          message: 'Hello, World!',
          isUrgent: true,
        },
      });

      await session.waitForJobCompletion(template._id);

      const otherMessage = await messageRepository.findOne({
        _environmentId: session.environment._id,
        _subscriberId: otherSubscriber._id,
        _templateId: template._id,
      });

      const response = await deleteNotification(otherMessage?._id || '');
      expect(response.status).to.equal(404);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - getSubscriber(): SubscriberEntity)
 - deleteNotification(async (id: string))
 - deleteAllNotifications(async (body?: any))
 - times(1))
 - messages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: g...)
 - deletedMessage(await messageRepository.findOne({
        _id: message._id,
        _environmentId: session.environm...)
 - response(await deleteNotification('507f1f77bcf86cd799439011');
      expect(response.status).to.equal(404);
 ...)
 - remainingMessages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - remainingMessages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - remainingMessages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - response(await session.testAgent.delete(`/v1/inbox/notifications/${messages[0]._id}/delete`);
      expect(re...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/e2e/get-notifications-count.e2e.ts
TamaÃ±o: 19225 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { MessageRepository, NotificationTemplateEntity, SubscriberEntity, SubscriberRepository } from '@novu/dal';
import {
  ActorTypeEnum,
  ChannelCTATypeEnum,
  ChannelTypeEnum,
  SeverityLevelEnum,
  StepTypeEnum,
  SystemAvatarIconEnum,
  TemplateVariableTypeEnum,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Get Notifications Count - /inbox/notifications/count (GET) #novu-v2', async () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity | null;
  const messageRepository = new MessageRepository();
  const subscriberRepository = new SubscriberRepository();

  let novuClient: Novu;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);
    subscriber = await subscriberRepository.findBySubscriberId(session.environment._id, session.subscriberId);
    template = await session.createTemplate({
      noFeedId: true,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test content for <b>{{firstName}}</b>',
          cta: {
            type: ChannelCTATypeEnum.REDIRECT,
            data: {
              url: '/cypress/test-shell/example/test?test-param=true',
            },
          },
          variables: [
            {
              defaultValue: '',
              name: 'firstName',
              required: false,
              type: TemplateVariableTypeEnum.STRING,
            },
          ],
          actor: {
            type: ActorTypeEnum.SYSTEM_ICON,
            data: SystemAvatarIconEnum.WARNING,
          },
        },
      ],
    });
  });

  const getNotificationsCount = async (
    filters: Array<{
      tags?: string[];
      read?: boolean;
      archived?: boolean;
      snoozed?: boolean;
      seen?: boolean;
      severity?: SeverityLevelEnum[];
    }>
  ) => {
    return await session.testAgent
      .get(`/v1/inbox/notifications/count?filters=${JSON.stringify(filters)}`)
      .set('Authorization', `Bearer ${session.subscriberToken}`);
  };

  const triggerEvent = async (templateToTrigger: NotificationTemplateEntity, times = 1) => {
    const promises: Array<Promise<unknown>> = [];
    for (let i = 0; i < times; i += 1) {
      promises.push(
        novuClient.trigger({
          workflowId: templateToTrigger.triggers[0].identifier,
          to: { subscriberId: session.subscriberId },
        })
      );
    }

    await Promise.all(promises);
    await session.waitForJobCompletion(templateToTrigger._id);
  };

  it('should throw exception when filtering for unread and archived notifications', async () => {
    await triggerEvent(template);

    const { body, status } = await getNotificationsCount([{ read: false, archived: true }]);

    expect(status).to.equal(400);
    expect(body.message).to.equal('Filtering for unread and archived notifications is not supported.');
  });

  it('should return all notifications count', async () => {
    const count = 4;
    await triggerEvent(template, count);
    const { body, status } = await getNotificationsCount([{}]);

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(1);
    expect(body.data[0].count).to.eq(count);
    expect(body.data[0].filter).to.deep.equal({});
  });

  it('should return notifications count for specified tags', async () => {
    const count = 4;
    const tags = ['hello'];
    const templateWithTags = await session.createTemplate({
      noFeedId: true,
      tags,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test content for newsletter',
          actor: {
            type: ActorTypeEnum.SYSTEM_ICON,
            data: SystemAvatarIconEnum.WARNING,
          },
        },
      ],
    });
    await triggerEvent(template, 2);
    await triggerEvent(templateWithTags, count);

    const { body, status } = await getNotificationsCount([{ tags }]);

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(1);
    expect(body.data[0].count).to.eq(count);
    expect(body.data[0].filter).to.deep.equal({
      tags,
    });
  });

  it('should return notifications count for read notifications', async () => {
    const count = 4;
    await triggerEvent(template, count);
    await messageRepository.update(
      {
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id ?? '',
        channel: ChannelTypeEnum.IN_APP,
      },
      { $set: { read: true } }
    );

    const { body, status } = await getNotificationsCount([{ read: true }]);

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(1);
    expect(body.data[0].count).to.eq(count);
    expect(body.data[0].filter).to.deep.equal({
      read: true,
    });
  });

  it('should return notifications count for archived notifications', async () => {
    const count = 4;
    await triggerEvent(template, count);
    await messageRepository.update(
      {
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id ?? '',
        channel: ChannelTypeEnum.IN_APP,
      },
      { $set: { archived: true } }
    );

    const { body, status } = await getNotificationsCount([{ archived: true }]);

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(1);
    expect(body.data[0].count).to.eq(count);
    expect(body.data[0].filter).to.deep.equal({
      archived: true,
    });
  });

  it('should return notifications count for read and archived notifications', async () => {
    const count = 2;
    await triggerEvent(template, count);
    await messageRepository.update(
      {
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id ?? '',
        channel: ChannelTypeEnum.IN_APP,
      },
      { $set: { read: true, archived: true } }
    );

    const { body, status } = await getNotificationsCount([{ read: true, archived: true }]);

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(1);
    expect(body.data[0].count).to.eq(count);
    expect(body.data[0].filter).to.deep.equal({
      read: true,
      archived: true,
    });
  });

  it('should return notifications count for snoozed notifications', async () => {
    const count = 4;
    await triggerEvent(template, count);
    await messageRepository.update(
      {
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id ?? '',
        channel: ChannelTypeEnum.IN_APP,
      },
      { $set: { snoozedUntil: new Date() } }
    );

    const { body, status } = await getNotificationsCount([{ snoozed: true }]);

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(1);
    expect(body.data[0].count).to.eq(count);
    expect(body.data[0].filter).to.deep.equal({
      snoozed: true,
    });
  });

  it('should return read notifications count for specified tags', async () => {
    const count = 4;
    const tags = ['hello'];
    const templateWithTags = await session.createTemplate({
      noFeedId: true,
      tags,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test content for newsletter',
          actor: {
            type: ActorTypeEnum.SYSTEM_ICON,
            data: SystemAvatarIconEnum.WARNING,
          },
        },
      ],
    });
    await triggerEvent(template, 2);
    await triggerEvent(templateWithTags, count);

    await messageRepository.update(
      {
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id ?? '',
        channel: ChannelTypeEnum.IN_APP,
        tags: { $in: tags },
      },
      { $set: { read: true } }
    );

    const { body, status } = await getNotificationsCount([{ tags, read: true }]);

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(1);
    expect(body.data[0].count).to.eq(count);
    expect(body.data[0].filter).to.deep.equal({
      tags,
      read: true,
    });
  });

  it('should return notification counts for multiple filters', async () => {
    const count = 4;
    const tags = ['hello'];
    const templateWithTags = await session.createTemplate({
      noFeedId: true,
      tags,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test content for newsletter',
          actor: {
            type: ActorTypeEnum.SYSTEM_ICON,
            data: SystemAvatarIconEnum.WARNING,
          },
        },
      ],
    });
    await triggerEvent(template, 2);
    await triggerEvent(templateWithTags, count);

    const { body, status } = await getNotificationsCount([{ tags }, { read: false }]);

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(2);
    expect(body.data[0].count).to.eq(count);
    expect(body.data[0].filter).to.deep.equal({
      tags,
    });
    expect(body.data[1].count).to.eq(6);
    expect(body.data[1].filter).to.deep.equal({ read: false });
  });

  it('should return notifications count for seen notifications', async () => {
    const count = 4;
    await triggerEvent(template, count);
    await messageRepository.update(
      {
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id ?? '',
        channel: ChannelTypeEnum.IN_APP,
      },
      { $set: { seen: true } }
    );

    const { body, status } = await getNotificationsCount([{ seen: true }]);

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(1);
    expect(body.data[0].count).to.eq(count);
    expect(body.data[0].filter).to.deep.equal({
      seen: true,
    });
  });

  it('should return notifications count for unseen notifications', async () => {
    const count = 4;
    await triggerEvent(template, count);

    const { body, status } = await getNotificationsCount([{ seen: false }]);

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(1);
    expect(body.data[0].count).to.eq(count);
    expect(body.data[0].filter).to.deep.equal({
      seen: false,
    });
  });

  it('should return seen notifications count for specified tags', async () => {
    const count = 4;
    const tags = ['hello'];
    const templateWithTags = await session.createTemplate({
      noFeedId: true,
      tags,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test content for newsletter',
          actor: {
            type: ActorTypeEnum.SYSTEM_ICON,
            data: SystemAvatarIconEnum.WARNING,
          },
        },
      ],
    });
    await triggerEvent(template, 2);
    await triggerEvent(templateWithTags, count);

    await messageRepository.update(
      {
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id ?? '',
        channel: ChannelTypeEnum.IN_APP,
        tags: { $in: tags },
      },
      { $set: { seen: true } }
    );

    const { body, status } = await getNotificationsCount([{ tags, seen: true }]);

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(1);
    expect(body.data[0].count).to.eq(count);
    expect(body.data[0].filter).to.deep.equal({
      tags,
      seen: true,
    });
  });

  describe('Severity filtering', () => {
    it('should return notifications count for high severity', async () => {
      const highSeverityTemplate = await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.HIGH,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'High severity notification',
            actor: {
              type: ActorTypeEnum.SYSTEM_ICON,
              data: SystemAvatarIconEnum.WARNING,
            },
          },
        ],
      });

      const mediumSeverityTemplate = await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.MEDIUM,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'Medium severity notification',
            actor: {
              type: ActorTypeEnum.SYSTEM_ICON,
              data: SystemAvatarIconEnum.WARNING,
            },
          },
        ],
      });

      // Trigger notifications with different severities
      await triggerEvent(highSeverityTemplate, 3);
      await triggerEvent(mediumSeverityTemplate, 2);
      await triggerEvent(template, 1); // Default template (no severity - none)

      const { body, status } = await getNotificationsCount([{ severity: [SeverityLevelEnum.HIGH] }]);

      expect(status).to.equal(200);
      expect(body.data).to.be.ok;
      expect(body.data.length).to.eq(1);
      expect(body.data[0].count).to.eq(3);
      expect(body.data[0].filter).to.deep.equal({
        severity: [SeverityLevelEnum.HIGH],
      });
    });

    it('should return notifications count for multiple severities', async () => {
      const highSeverityTemplate = await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.HIGH,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'High severity notification',
            actor: {
              type: ActorTypeEnum.SYSTEM_ICON,
              data: SystemAvatarIconEnum.WARNING,
            },
          },
        ],
      });

      const lowSeverityTemplate = await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.LOW,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'Low severity notification',
            actor: {
              type: ActorTypeEnum.SYSTEM_ICON,
              data: SystemAvatarIconEnum.WARNING,
            },
          },
        ],
      });

      // Trigger notifications with different severities
      await triggerEvent(highSeverityTemplate, 2);
      await triggerEvent(lowSeverityTemplate, 3);
      await triggerEvent(template, 1); // Default template (no severity - none)

      const { body, status } = await getNotificationsCount([
        { severity: [SeverityLevelEnum.HIGH, SeverityLevelEnum.LOW] },
      ]);

      expect(status).to.equal(200);
      expect(body.data).to.be.ok;
      expect(body.data.length).to.eq(1);
      expect(body.data[0].count).to.eq(5); // 2 high + 3 low
      expect(body.data[0].filter).to.deep.equal({
        severity: [SeverityLevelEnum.HIGH, SeverityLevelEnum.LOW],
      });
    });

    it('should return notifications count for none severity', async () => {
      const highSeverityTemplate = await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.HIGH,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'High severity notification',
            actor: {
              type: ActorTypeEnum.SYSTEM_ICON,
              data: SystemAvatarIconEnum.WARNING,
            },
          },
        ],
      });

      // Trigger notifications with different severities
      await triggerEvent(highSeverityTemplate, 2);
      await triggerEvent(template, 3); // Default template (no severity - none)

      const { body, status } = await getNotificationsCount([{ severity: [SeverityLevelEnum.NONE] }]);

      expect(status).to.equal(200);
      expect(body.data).to.be.ok;
      expect(body.data.length).to.eq(1);
      expect(body.data[0].count).to.eq(3);
      expect(body.data[0].filter).to.deep.equal({
        severity: [SeverityLevelEnum.NONE],
      });
    });

    it('should return notifications count combining severity with other filters', async () => {
      const tags = ['urgent'];
      const highSeverityTemplate = await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.HIGH,
        tags,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'High severity urgent notification',
            actor: {
              type: ActorTypeEnum.SYSTEM_ICON,
              data: SystemAvatarIconEnum.WARNING,
            },
          },
        ],
      });

      const highSeverityTemplateNoTags = await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.HIGH,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'High severity notification without tags',
            actor: {
              type: ActorTypeEnum.SYSTEM_ICON,
              data: SystemAvatarIconEnum.WARNING,
            },
          },
        ],
      });

      // Trigger notifications
      await triggerEvent(highSeverityTemplate, 2); // High severity with urgent tags
      await triggerEvent(highSeverityTemplateNoTags, 3); // High severity without tags

      // Test combining severity and tags filters
      const { body, status } = await getNotificationsCount([{ severity: [SeverityLevelEnum.HIGH], tags, read: false }]);

      expect(status).to.equal(200);
      expect(body.data).to.be.ok;
      expect(body.data.length).to.eq(1);
      expect(body.data[0].count).to.eq(2); // Only the high severity with urgent tags
      expect(body.data[0].filter).to.deep.equal({
        severity: [SeverityLevelEnum.HIGH],
        tags,
        read: false,
      });
    });

    it('should return multiple filters with different severities', async () => {
      const highSeverityTemplate = await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.HIGH,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'High severity notification',
            actor: {
              type: ActorTypeEnum.SYSTEM_ICON,
              data: SystemAvatarIconEnum.WARNING,
            },
          },
        ],
      });

      const mediumSeverityTemplate = await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.MEDIUM,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'Medium severity notification',
            actor: {
              type: ActorTypeEnum.SYSTEM_ICON,
              data: SystemAvatarIconEnum.WARNING,
            },
          },
        ],
      });

      // Trigger notifications
      await triggerEvent(highSeverityTemplate, 2);
      await triggerEvent(mediumSeverityTemplate, 3);

      const { body, status } = await getNotificationsCount([
        { severity: [SeverityLevelEnum.HIGH] },
        { severity: [SeverityLevelEnum.MEDIUM] },
      ]);

      expect(status).to.equal(200);
      expect(body.data).to.be.ok;
      expect(body.data.length).to.eq(2);
      expect(body.data[0].count).to.eq(2);
      expect(body.data[0].filter).to.deep.equal({
        severity: [SeverityLevelEnum.HIGH],
      });
      expect(body.data[1].count).to.eq(3);
      expect(body.data[1].filter).to.deep.equal({
        severity: [SeverityLevelEnum.MEDIUM],
      });
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberRepository(new SubscriberRepository();

  let novuClient: Novu;
  beforeEach(async ())
 - getNotificationsCount(async (
    filters: Array<{
      tags?: string[];
      read?: boolean;
      archived?: boolean;
...)
 - times(1))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/e2e/get-notifications.e2e.ts
TamaÃ±o: 16519 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { MessageRepository, NotificationTemplateEntity, SubscriberEntity, SubscriberRepository } from '@novu/dal';
import {
  ActorTypeEnum,
  ChannelCTATypeEnum,
  ChannelTypeEnum,
  SeverityLevelEnum,
  StepTypeEnum,
  SystemAvatarIconEnum,
  TemplateVariableTypeEnum,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';
import { mapToDto } from '../utils/notification-mapper';

describe('Get Notifications - /inbox/notifications (GET) #novu-v2', async () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity | null;
  const messageRepository = new MessageRepository();
  const subscriberRepository = new SubscriberRepository();
  let novuClient: Novu;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);
    subscriber = await subscriberRepository.findBySubscriberId(session.environment._id, session.subscriberId);
    template = await session.createTemplate({
      noFeedId: true,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test content for <b>{{firstName}}</b>',
          cta: {
            type: ChannelCTATypeEnum.REDIRECT,
            data: {
              url: '/cypress/test-shell/example/test?test-param=true',
            },
          },
          variables: [
            {
              defaultValue: '',
              name: 'firstName',
              required: false,
              type: TemplateVariableTypeEnum.STRING,
            },
          ],
          actor: {
            type: ActorTypeEnum.SYSTEM_ICON,
            data: SystemAvatarIconEnum.WARNING,
          },
        },
      ],
    });
  });

  const getNotifications = async ({
    limit = 10,
    offset = 0,
    after,
    tags,
    read,
    archived,
    snoozed,
    severity,
  }: {
    limit?: number;
    after?: string;
    offset?: number;
    tags?: string[];
    read?: boolean;
    archived?: boolean;
    snoozed?: boolean;
    severity?: SeverityLevelEnum[];
  } = {}) => {
    let query = `limit=${limit}`;
    if (after) {
      query += `&after=${after}`;
    }
    if (offset) {
      query += `&offset=${offset}`;
    }
    if (tags) {
      query += tags.map((tag) => `&tags[]=${tag}`).join('');
    }
    if (typeof read !== 'undefined') {
      query += `&read=${read}`;
    }
    if (typeof archived !== 'undefined') {
      query += `&archived=${archived}`;
    }
    if (typeof snoozed !== 'undefined') {
      query += `&snoozed=${snoozed}`;
    }
    if (severity) {
      query += severity.map((el) => `&severity[]=${el}`).join('');
    }

    return await session.testAgent
      .get(`/v1/inbox/notifications?${query}`)
      .set('Authorization', `Bearer ${session.subscriberToken}`);
  };

  const triggerEvent = async (templateToTrigger: NotificationTemplateEntity, times = 1) => {
    const promises: Array<Promise<unknown>> = [];
    for (let i = 0; i < times; i += 1) {
      promises.push(
        novuClient.trigger({
          workflowId: templateToTrigger.triggers[0].identifier,
          to: { subscriberId: session.subscriberId },
        })
      );
    }

    await Promise.all(promises);
    await session.waitForJobCompletion(templateToTrigger._id);
  };

  const removeUndefinedDeep = (obj) => {
    if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) return obj;

    const newObj = {};
    for (const key in obj) {
      if (obj[key] !== undefined) {
        newObj[key] = removeUndefinedDeep(obj[key]);
      }
    }

    return newObj;
  };

  it('should validate that the offset is greater or equals to zero', async () => {
    const { body, status } = await getNotifications({ limit: 1, offset: -1 });

    expect(status).to.equal(422);
    expect(body.errors.general.messages[0]).to.equal('offset must not be less than 0');
  });

  it('should validate the after to mongo id', async () => {
    const { body, status } = await getNotifications({ limit: 1, after: 'after' });

    expect(status).to.equal(422);
    expect(body.errors.general.messages[0]).to.equal('The after cursor must be a valid MongoDB ObjectId');
  });

  it('should throw exception when filtering for unread and archived notifications', async () => {
    await triggerEvent(template);

    const { body, status } = await getNotifications({ limit: 1, read: false, archived: true });

    expect(status).to.equal(400);
    expect(body.message).to.equal('Filtering for unread and archived notifications is not supported.');
  });

  it('should include fields from message entity', async () => {
    await triggerEvent(template);

    const { data: messages } = await messageRepository.paginate(
      {
        environmentId: session.environment._id,
        subscriberId: subscriber?._id ?? '',
        channel: ChannelTypeEnum.IN_APP,
      },
      { limit: 1, offset: 0 }
    );
    const [messageEntity] = messages;
    if (!messageEntity) {
      throw new Error('Message entity not found');
    }

    const { body, status } = await getNotifications({ limit: 1 });

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(1);
    expect(body.hasMore).to.be.false;
    expect(body.data[0]).to.deep.equal(removeUndefinedDeep(mapToDto(messageEntity)));
  });

  it('should paginate notifications by offset', async () => {
    const limit = 2;
    await triggerEvent(template, 4);

    const { body, status } = await getNotifications({ limit });

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(limit);
    expect(new Date(body.data[0].createdAt).getTime()).to.be.greaterThanOrEqual(
      new Date(body.data[1].createdAt).getTime()
    );
    expect(body.hasMore).to.be.true;

    const { body: nextPageBody, status: nextPageStatus } = await getNotifications({ limit, offset: 2 });

    expect(nextPageStatus).to.equal(200);
    expect(nextPageBody.data).to.be.ok;
    expect(nextPageBody.data.length).to.eq(limit);
    expect(new Date(nextPageBody.data[0].createdAt).getTime()).to.be.greaterThanOrEqual(
      new Date(nextPageBody.data[1].createdAt).getTime()
    );
    expect(nextPageBody.hasMore).to.be.false;
  });

  it('should paginate notifications with after as id', async () => {
    const limit = 2;
    await triggerEvent(template, 4);

    const { body, status } = await getNotifications({ limit });

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(limit);
    expect(new Date(body.data[0].createdAt).getTime()).to.be.greaterThanOrEqual(
      new Date(body.data[1].createdAt).getTime()
    );
    expect(body.hasMore).to.be.true;

    const { body: nextPageBody, status: nextPageStatus } = await getNotifications({ limit, after: body.data[1].id });

    expect(nextPageStatus).to.equal(200);
    expect(nextPageBody.data).to.be.ok;
    expect(nextPageBody.data.length).to.eq(limit);
    expect(new Date(nextPageBody.data[0].createdAt).getTime()).to.be.greaterThanOrEqual(
      new Date(nextPageBody.data[1].createdAt).getTime()
    );
    expect(nextPageBody.hasMore).to.be.false;
  });

  it('should filter notifications by tags', async () => {
    const tags = ['newsletter'];
    const templateWithTags = await session.createTemplate({
      noFeedId: true,
      tags,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test content for newsletter',
          actor: {
            type: ActorTypeEnum.SYSTEM_ICON,
            data: SystemAvatarIconEnum.WARNING,
          },
        },
      ],
    });
    await triggerEvent(template, 2);
    await triggerEvent(templateWithTags, 4);

    const limit = 4;
    const { body, status } = await getNotifications({ limit, tags });

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(limit);
    expect(new Date(body.data[0].createdAt).getTime()).to.be.greaterThanOrEqual(
      new Date(body.data[1].createdAt).getTime()
    );
    expect(body.hasMore).to.be.false;
  });

  it('should filter by read', async () => {
    await triggerEvent(template, 4);
    await messageRepository.update(
      {
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id ?? '',
        channel: ChannelTypeEnum.IN_APP,
      },
      { $set: { read: true } }
    );

    const limit = 4;
    const { body, status } = await getNotifications({ limit, read: true });

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(limit);
    expect(new Date(body.data[0].createdAt).getTime()).to.be.greaterThanOrEqual(
      new Date(body.data[1].createdAt).getTime()
    );
    expect(body.hasMore).to.be.false;
    expect(body.data.every((message) => message.isRead)).to.be.true;
  });

  it('should filter by archived', async () => {
    await triggerEvent(template, 4);
    await messageRepository.update(
      {
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id ?? '',
        channel: ChannelTypeEnum.IN_APP,
      },
      { $set: { archived: true } }
    );

    const limit = 4;
    const { body, status } = await getNotifications({ limit, archived: true });

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(limit);
    expect(new Date(body.data[0].createdAt).getTime()).to.be.greaterThanOrEqual(
      new Date(body.data[1].createdAt).getTime()
    );
    expect(body.hasMore).to.be.false;
    expect(body.data.every((message) => message.isArchived)).to.be.true;
  });

  it('should filter by archived with pagination', async () => {
    await triggerEvent(template, 4);
    await messageRepository.update(
      {
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id ?? '',
        channel: ChannelTypeEnum.IN_APP,
      },
      { $set: { archived: true } }
    );

    const limit = 2;
    const { body: firstPageBody, status: firstPageStatus } = await getNotifications({ limit, archived: true });

    expect(firstPageStatus).to.equal(200);
    expect(firstPageBody.data).to.be.ok;
    expect(firstPageBody.data.length).to.eq(limit);
    expect(new Date(firstPageBody.data[0].createdAt).getTime()).to.be.greaterThanOrEqual(
      new Date(firstPageBody.data[1].createdAt).getTime()
    );
    expect(firstPageBody.hasMore).to.be.true;
    expect(firstPageBody.data.every((message) => message.isArchived)).to.be.true;

    const { body: secondPageBody, status: secondPageStatus } = await getNotifications({
      limit,
      after: firstPageBody.data[1].id,
      archived: true,
    });

    expect(secondPageStatus).to.equal(200);
    expect(secondPageBody.data).to.be.ok;
    expect(secondPageBody.data.length).to.eq(limit);
    expect(new Date(secondPageBody.data[0].createdAt).getTime()).to.be.greaterThanOrEqual(
      new Date(secondPageBody.data[1].createdAt).getTime()
    );
    expect(secondPageBody.hasMore).to.be.false;
    expect(secondPageBody.data.every((message) => message.isArchived)).to.be.true;
  });

  it('should filter by snoozed', async () => {
    await triggerEvent(template, 4);
    await messageRepository.update(
      {
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id ?? '',
        channel: ChannelTypeEnum.IN_APP,
      },
      { $set: { snoozedUntil: new Date() } }
    );

    const limit = 4;
    const { body, status } = await getNotifications({ limit, snoozed: true });

    expect(status).to.equal(200);
    expect(body.data).to.be.ok;
    expect(body.data.length).to.eq(limit);
    expect(new Date(body.data[0].createdAt).getTime()).to.be.greaterThanOrEqual(
      new Date(body.data[1].createdAt).getTime()
    );
    expect(body.hasMore).to.be.false;
    expect(body.data.every((message) => message.isSnoozed)).to.be.true;
  });

  it('should filter notifications by severity', async () => {
    // Create templates with different severities
    const highSeverityTemplate = await session.createTemplate({
      noFeedId: true,
      severity: SeverityLevelEnum.HIGH,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'High severity notification',
        },
      ],
    });

    const mediumSeverityTemplate = await session.createTemplate({
      noFeedId: true,
      severity: SeverityLevelEnum.MEDIUM,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Medium severity notification',
        },
      ],
    });

    const lowSeverityTemplate = await session.createTemplate({
      noFeedId: true,
      severity: SeverityLevelEnum.LOW,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Low severity notification',
        },
      ],
    });

    // Trigger notifications with different severities
    await novuClient.trigger({
      workflowId: highSeverityTemplate.triggers[0].identifier,
      to: { subscriberId: session.subscriberId },
    });

    await novuClient.trigger({
      workflowId: mediumSeverityTemplate.triggers[0].identifier,
      to: { subscriberId: session.subscriberId },
    });

    await novuClient.trigger({
      workflowId: lowSeverityTemplate.triggers[0].identifier,
      to: { subscriberId: session.subscriberId },
    });

    // Wait for jobs to complete
    await session.waitForJobCompletion(highSeverityTemplate._id);
    await session.waitForJobCompletion(mediumSeverityTemplate._id);
    await session.waitForJobCompletion(lowSeverityTemplate._id);

    // Test filtering by high severity only
    const { body: highSeverityBody, status: highSeverityStatus } = await getNotifications({
      severity: [SeverityLevelEnum.HIGH],
    });

    expect(highSeverityStatus).to.equal(200);
    expect(highSeverityBody.data).to.be.ok;
    expect(highSeverityBody.data.length).to.equal(1);
    expect(highSeverityBody.data[0].severity).to.equal(SeverityLevelEnum.HIGH);
    expect(highSeverityBody.filter.severity).to.deep.equal([SeverityLevelEnum.HIGH]);

    // Test filtering by multiple severities
    const { body: multipleSeverityBody, status: multipleSeverityStatus } = await getNotifications({
      severity: [SeverityLevelEnum.HIGH, SeverityLevelEnum.MEDIUM],
    });

    expect(multipleSeverityStatus).to.equal(200);
    expect(multipleSeverityBody.data).to.be.ok;
    expect(multipleSeverityBody.data.length).to.equal(2);
    expect(
      multipleSeverityBody.data.every((notification) =>
        [SeverityLevelEnum.HIGH, SeverityLevelEnum.MEDIUM].includes(notification.severity)
      )
    ).to.be.true;
    expect(multipleSeverityBody.filter.severity).to.deep.equal([SeverityLevelEnum.HIGH, SeverityLevelEnum.MEDIUM]);

    // Test getting all notifications without filter
    const { body: allNotificationsBody, status: allNotificationsStatus } = await getNotifications({});

    expect(allNotificationsStatus).to.equal(200);
    expect(allNotificationsBody.data).to.be.ok;
    expect(allNotificationsBody.data.length).to.be.greaterThanOrEqual(3);
  });

  it('should include severity field in notification response', async () => {
    const highSeverityTemplate = await session.createTemplate({
      noFeedId: true,
      severity: SeverityLevelEnum.HIGH,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'High severity notification',
        },
      ],
    });

    await triggerEvent(highSeverityTemplate);

    const { body } = await getNotifications();

    expect(body.data).to.be.ok;
    expect(body.data.length).to.equal(1);
    expect(body.data[0]).to.have.property('severity');
    expect(body.data[0].severity).to.equal(SeverityLevelEnum.HIGH);
  });

  it('should default to none severity for templates without explicit severity', async () => {
    const noSeverityTemplate = await session.createTemplate({
      noFeedId: true,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Notification without explicit severity',
        },
      ],
    });

    await triggerEvent(noSeverityTemplate);

    const { body } = await getNotifications();

    expect(body.data).to.be.ok;
    expect(body.data.length).to.equal(1);
    expect(body.data[0]).to.have.property('severity');
    expect(body.data[0].severity).to.equal(SeverityLevelEnum.NONE);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberRepository(new SubscriberRepository();
  let novuClient: Novu;
  beforeEach(async ())
 - times(1))
 - removeUndefinedDeep(obj))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/e2e/get-preferences.e2e.ts
TamaÃ±o: 13216 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SeverityLevelEnum, StepTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get all preferences - /inbox/preferences (GET) #novu-v2', () => {
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should return no global preferences if workflow preferences are not present', async () => {
    const response = await session.testAgent
      .get('/v1/inbox/preferences')
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    const globalPreference = response.body.data[0];

    expect(globalPreference.channels.email).to.equal(undefined);
    expect(globalPreference.channels.in_app).to.equal(undefined);
    expect(globalPreference.level).to.equal('global');
    expect(response.body.data.length).to.equal(1);
  });

  it('should get both global preferences for active channels and workflow preferences if workflow is present', async () => {
    await session.createTemplate({
      noFeedId: true,
      steps: [
        {
          type: StepTypeEnum.EMAIL,
          content: 'Test notification content',
        },
      ],
    });

    const response = await session.testAgent
      .get('/v1/inbox/preferences')
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    const globalPreference = response.body.data[0];

    expect(globalPreference.channels.email).to.equal(true);
    expect(globalPreference.channels.in_app).to.equal(undefined);
    expect(globalPreference.level).to.equal('global');

    const workflowPreference = response.body.data[1];

    expect(workflowPreference.channels.email).to.equal(true);
    expect(workflowPreference.channels.in_app).to.equal(undefined);
    expect(workflowPreference.level).to.equal('template');
  });

  it('should throw error when made unauthorized call', async () => {
    const response = await session.testAgent.get(`/v1/inbox/preferences`).set('Authorization', `Bearer InvalidToken`);

    expect(response.status).to.equal(401);
  });

  it('should allow filtering preferences by tags', async () => {
    const newsletterTag = 'newsletter';
    const securityTag = 'security';
    const marketingTag = 'marketing';
    await session.createTemplate({
      noFeedId: true,
      tags: [newsletterTag],
    });
    await session.createTemplate({
      noFeedId: true,
      tags: [securityTag],
    });
    await session.createTemplate({
      noFeedId: true,
      tags: [marketingTag],
    });
    await session.createTemplate({
      noFeedId: true,
      tags: [],
    });

    const response = await session.testAgent
      .get(`/v1/inbox/preferences?tags[]=${newsletterTag}&tags[]=${securityTag}`)
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    expect(response.body.data.length).to.equal(3);

    const globalPreference = response.body.data[0];
    expect(globalPreference.channels.email).to.equal(true);
    expect(globalPreference.channels.in_app).to.equal(true);
    expect(globalPreference.level).to.equal('global');

    const workflowPreferences = response.body.data.slice(1);
    workflowPreferences.forEach((workflowPreference) => {
      expect(workflowPreference.workflow.tags[0]).to.be.oneOf([newsletterTag, securityTag]);
    });
  });

  it('should fetch only non-critical/readOnly=false workflows', async () => {
    await session.createTemplate({
      noFeedId: true,
      critical: true,
    });

    await session.createTemplate({
      noFeedId: true,
      critical: false,
    });

    const response = await session.testAgent
      .get('/v1/inbox/preferences')
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    expect(response.body.data.length).to.equal(2);

    const globalPreference = response.body.data[0];

    expect(globalPreference.channels.email).to.equal(true);
    expect(globalPreference.channels.in_app).to.equal(true);
    expect(globalPreference.level).to.equal('global');

    const workflowPreference = response.body.data[1];

    expect(workflowPreference.channels.email).to.equal(true);
    expect(workflowPreference.channels.in_app).to.equal(true);
    expect(workflowPreference.level).to.equal('template');
    expect(workflowPreference.workflow.critical).to.equal(false);
  });

  describe('Severity filtering', () => {
    it('should return preferences filtered by single severity level', async () => {
      // Create templates with different severities
      await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.HIGH,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'High severity notification',
          },
        ],
      });

      await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.MEDIUM,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'Medium severity notification',
          },
        ],
      });

      await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.LOW,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'Low severity notification',
          },
        ],
      });

      const response = await session.testAgent
        .get(`/v1/inbox/preferences?severity[]=${SeverityLevelEnum.HIGH}`)
        .set('Authorization', `Bearer ${session.subscriberToken}`);

      expect(response.status).to.equal(200);
      expect(response.body.data).to.be.an('array');

      // Should include global preference and only high severity workflow
      const workflowPreferences = response.body.data.filter((pref: any) => pref.level === 'template');
      expect(workflowPreferences).to.have.length(1);
      expect(workflowPreferences[0].workflow.severity).to.equal(SeverityLevelEnum.HIGH);
    });

    it('should return preferences filtered by multiple severity levels', async () => {
      // Create templates with different severities
      await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.HIGH,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'High severity notification',
          },
        ],
      });

      await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.MEDIUM,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'Medium severity notification',
          },
        ],
      });

      await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.LOW,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'Low severity notification',
          },
        ],
      });

      const response = await session.testAgent
        .get(`/v1/inbox/preferences?severity[]=${SeverityLevelEnum.HIGH}&severity[]=${SeverityLevelEnum.LOW}`)
        .set('Authorization', `Bearer ${session.subscriberToken}`);

      expect(response.status).to.equal(200);
      expect(response.body.data).to.be.an('array');

      // Should include global preference and high + low severity workflows
      const workflowPreferences = response.body.data.filter((pref: any) => pref.level === 'template');
      expect(workflowPreferences).to.have.length(2);

      const severities = workflowPreferences.map((pref: any) => pref.workflow.severity);
      expect(severities).to.include(SeverityLevelEnum.HIGH);
      expect(severities).to.include(SeverityLevelEnum.LOW);
      expect(severities).to.not.include(SeverityLevelEnum.MEDIUM);
    });

    it('should return preferences filtered by none severity', async () => {
      // Create template without explicit severity (defaults to none)
      await session.createTemplate({
        noFeedId: true,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'Notification without explicit severity',
          },
        ],
      });

      await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.HIGH,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'High severity notification',
          },
        ],
      });

      const response = await session.testAgent
        .get(`/v1/inbox/preferences?severity[]=${SeverityLevelEnum.NONE}`)
        .set('Authorization', `Bearer ${session.subscriberToken}`);

      expect(response.status).to.equal(200);
      expect(response.body.data).to.be.an('array');

      // Should include global preference and only the template without explicit severity
      const workflowPreferences = response.body.data.filter((pref: any) => pref.level === 'template');
      expect(workflowPreferences).to.have.length(1);
      expect(workflowPreferences[0].workflow.severity).to.equal(SeverityLevelEnum.NONE);
    });

    it('should return all preferences when no severity filter is applied', async () => {
      // Create templates with different severities
      await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.HIGH,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'High severity notification',
          },
        ],
      });

      await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.MEDIUM,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'Medium severity notification',
          },
        ],
      });

      const response = await session.testAgent
        .get('/v1/inbox/preferences')
        .set('Authorization', `Bearer ${session.subscriberToken}`);

      expect(response.status).to.equal(200);
      expect(response.body.data).to.be.an('array');

      // Should include global preference and all workflow preferences
      const workflowPreferences = response.body.data.filter((pref: any) => pref.level === 'template');
      expect(workflowPreferences).to.have.length(2); // high and medium severity templates

      const severities = workflowPreferences.map((pref: any) => pref.workflow.severity);
      expect(severities).to.include(SeverityLevelEnum.HIGH);
      expect(severities).to.include(SeverityLevelEnum.MEDIUM);
    });

    it('should combine severity filter with tags filter', async () => {
      const tags = ['urgent', 'important'];

      // Create high severity template with tags
      await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.HIGH,
        tags,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'High severity urgent notification',
          },
        ],
      });

      // Create high severity template without tags
      await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.HIGH,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'High severity notification without tags',
          },
        ],
      });

      // Create medium severity template with tags
      await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.MEDIUM,
        tags,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'Medium severity urgent notification',
          },
        ],
      });

      const response = await session.testAgent
        .get(`/v1/inbox/preferences?severity[]=${SeverityLevelEnum.HIGH}&tags[]=${tags[0]}&tags[]=${tags[1]}`)
        .set('Authorization', `Bearer ${session.subscriberToken}`);

      expect(response.status).to.equal(200);
      expect(response.body.data).to.be.an('array');

      // Should include global preference and only high severity template with tags
      const workflowPreferences = response.body.data.filter((pref: any) => pref.level === 'template');
      expect(workflowPreferences).to.have.length(1);
      expect(workflowPreferences[0].workflow.severity).to.equal(SeverityLevelEnum.HIGH);
      expect(workflowPreferences[0].workflow.tags).to.deep.equal(tags);
    });

    it('should return empty workflow preferences for non-existent severity', async () => {
      // Create only high severity template
      await session.createTemplate({
        noFeedId: true,
        severity: SeverityLevelEnum.HIGH,
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'High severity notification',
          },
        ],
      });

      const response = await session.testAgent
        .get(`/v1/inbox/preferences?severity[]=${SeverityLevelEnum.LOW}`)
        .set('Authorization', `Bearer ${session.subscriberToken}`);

      expect(response.status).to.equal(200);
      expect(response.body.data).to.be.an('array');

      // Should include only global preference, no workflow preferences
      const globalPreferences = response.body.data.filter((pref: any) => pref.level === 'global');
      const workflowPreferences = response.body.data.filter((pref: any) => pref.level === 'template');

      expect(globalPreferences).to.have.length(1);
      expect(workflowPreferences).to.have.length(0);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should return no global preferences ...)
 - globalPreference(response.body.data[0];

    expect(globalPreference.channels.email).to.equal(undefined);
    expect(...)
 - workflowPreference(response.body.data[1];

    expect(workflowPreference.channels.email).to.equal(true);
    expect(wor...)
 - response(await session.testAgent.get(`/v1/inbox/preferences`).set('Authorization', `Bearer InvalidToken`);

 ...)
 - workflowPreferences(response.body.data.slice(1);
    workflowPreferences.forEach((workflowPreference))
 - readOnly(false workflows', async ())
 - workflowPreference(response.body.data[1];

    expect(workflowPreference.channels.email).to.equal(true);
    expect(wor...)
 - workflowPreferences(response.body.data.filter((pref: any))
 - workflowPreferences(response.body.data.filter((pref: any))
 - severities(workflowPreferences.map((pref: any))
 - workflowPreferences(response.body.data.filter((pref: any))
 - workflowPreferences(response.body.data.filter((pref: any))
 - severities(workflowPreferences.map((pref: any))
 - workflowPreferences(response.body.data.filter((pref: any))
 - globalPreferences(response.body.data.filter((pref: any))
 - workflowPreferences(response.body.data.filter((pref: any))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/e2e/mark-notification-as.e2e.ts
TamaÃ±o: 9642 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import {
  MessageEntity,
  MessageRepository,
  NotificationTemplateEntity,
  SubscriberEntity,
  SubscriberRepository,
} from '@novu/dal';
import {
  ActorTypeEnum,
  ButtonTypeEnum,
  ChannelCTATypeEnum,
  StepTypeEnum,
  SystemAvatarIconEnum,
  TemplateVariableTypeEnum,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';
import { mapToDto } from '../utils/notification-mapper';

describe('Mark Notification As - /inbox/notifications/:id/{read,unread,archive,unarchive,snooze,unsnooze} (PATCH) #novu-v2', async () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity | null;
  let message: MessageEntity;
  const messageRepository = new MessageRepository();
  const subscriberRepository = new SubscriberRepository();
  let novuClient: Novu;
  const updateNotification = async ({
    id,
    status,
    body,
  }: {
    id: string;
    status: 'read' | 'unread' | 'archive' | 'unarchive' | 'snooze' | 'unsnooze';
    body?: any;
  }) => {
    return await session.testAgent
      .patch(`/v1/inbox/notifications/${id}/${status}`)
      .set('Authorization', `Bearer ${session.subscriberToken}`)
      .send(body);
  };

  const triggerEvent = async (templateToTrigger: NotificationTemplateEntity, times = 1) => {
    const promises: Array<Promise<unknown>> = [];
    for (let i = 0; i < times; i += 1) {
      promises.push(
        novuClient.trigger({
          workflowId: templateToTrigger.triggers[0].identifier,
          to: { subscriberId: session.subscriberId },
        })
      );
    }

    await Promise.all(promises);
    await session.waitForJobCompletion(templateToTrigger._id);
  };

  const removeUndefinedDeep = (obj) => {
    if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) return obj;

    const newObj = {};
    for (const key in obj) {
      if (obj[key] !== undefined) {
        newObj[key] = removeUndefinedDeep(obj[key]);
      }
    }

    return newObj;
  };

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);
    subscriber = await subscriberRepository.findBySubscriberId(session.environment._id, session.subscriberId);
    template = await session.createTemplate({
      noFeedId: true,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test content for <b>{{firstName}}</b>',
          cta: {
            type: ChannelCTATypeEnum.REDIRECT,
            data: {
              url: '',
            },
            action: {
              buttons: [
                { type: ButtonTypeEnum.PRIMARY, content: '' },
                { type: ButtonTypeEnum.SECONDARY, content: '' },
              ],
            },
          },
          variables: [
            {
              defaultValue: '',
              name: 'firstName',
              required: false,
              type: TemplateVariableTypeEnum.STRING,
            },
          ],
          actor: {
            type: ActorTypeEnum.SYSTEM_ICON,
            data: SystemAvatarIconEnum.WARNING,
          },
        },
      ],
    });
    await triggerEvent(template);
    message = (await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: template._id,
    })) as MessageEntity;
  });

  it('should throw bad request error when the notification id is not mongo id', async () => {
    const id = 'fake';
    const { body, status } = await updateNotification({ id, status: 'read' });
    expect(body.statusCode).to.equal(422);
    expect(body.errors.notificationId.messages[0]).to.equal(`notificationId must be a mongodb id`);
  });

  it("should throw not found error when the message doesn't exist", async () => {
    const id = '666c0dfa0b55d0f06f4aaa6c';
    const { body, status } = await updateNotification({ id, status: 'read' });

    expect(status).to.equal(404);
    expect(body.message).to.equal(`Notification with id: ${id} is not found.`);
  });

  it('should update the read status', async () => {
    const { body, status } = await updateNotification({ id: message._id, status: 'read' });
    const updatedMessage = (await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: template._id,
    })) as MessageEntity;

    expect(status).to.equal(200);
    expect(body.data).to.deep.equal(removeUndefinedDeep(mapToDto(updatedMessage)));
    expect(updatedMessage.seen).to.be.true;
    expect(updatedMessage.lastSeenDate).not.to.be.undefined;
    expect(body.data.isRead).to.be.true;
    expect(body.data.readAt).not.to.be.undefined;
    expect(body.data.isArchived).to.be.false;
    expect(body.data.archivedAt).to.be.undefined;
  });

  it('should update the unread status', async () => {
    const now = new Date();
    await messageRepository.update(
      { _id: message._id, _environmentId: message._environmentId },
      { $set: { seen: true, lastSeenDate: now, read: true, lastReadDate: now, archived: true, archivedAt: now } }
    );

    const { body, status } = await updateNotification({ id: message._id, status: 'unread' });

    const updatedMessage = (await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: template._id,
    })) as MessageEntity;

    expect(status).to.equal(200);
    expect(body.data).to.deep.equal(removeUndefinedDeep(mapToDto(updatedMessage)));
    expect(updatedMessage.seen).to.be.true;
    expect(updatedMessage.lastSeenDate).not.to.be.undefined;
    expect(body.data.isRead).to.be.false;
    expect(body.data.readAt).to.be.null;
    expect(body.data.isArchived).to.be.false;
    expect(body.data.archivedAt).to.be.null;
  });

  it('should update the archived status', async () => {
    const { body, status } = await updateNotification({ id: message._id, status: 'archive' });

    const updatedMessage = (await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: template._id,
    })) as MessageEntity;

    expect(status).to.equal(200);
    expect(body.data).to.deep.equal(removeUndefinedDeep(mapToDto(updatedMessage)));
    expect(updatedMessage.seen).to.be.true;
    expect(updatedMessage.lastSeenDate).not.to.be.undefined;
    expect(body.data.isRead).to.be.true;
    expect(body.data.readAt).not.to.be.undefined;
    expect(body.data.isArchived).to.be.true;
    expect(body.data.archivedAt).not.to.be.undefined;
  });

  it('should update the unarchived status', async () => {
    const now = new Date();
    await messageRepository.update(
      { _id: message._id, _environmentId: message._environmentId },
      { $set: { seen: true, lastSeenDate: now, read: true, lastReadDate: now, archived: true, archivedAt: now } }
    );

    const { body, status } = await updateNotification({ id: message._id, status: 'unarchive' });

    const updatedMessage = (await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: template._id,
    })) as MessageEntity;

    expect(status).to.equal(200);
    expect(body.data).to.deep.equal(removeUndefinedDeep(mapToDto(updatedMessage)));
    expect(updatedMessage.seen).to.be.true;
    expect(updatedMessage.lastSeenDate).not.to.be.undefined;
    expect(body.data.isRead).to.be.true;
    expect(body.data.readAt).not.to.be.undefined;
    expect(body.data.isArchived).to.be.false;
    expect(body.data.archivedAt).to.be.null;
  });

  it('should update the snoozed status', async () => {
    const snoozeUntil = new Date(Date.now() + 1000 * 60 * 60); // 1 hour in the future
    const { body, status } = await updateNotification({
      id: message._id,
      status: 'snooze',
      body: { snoozeUntil },
    });

    const updatedMessage = (await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: template._id,
    })) as MessageEntity;

    expect(status).to.equal(200);
    expect(body.data).to.deep.equal(removeUndefinedDeep(mapToDto(updatedMessage)));
    expect(updatedMessage.seen).to.be.true;
    expect(updatedMessage.lastSeenDate).not.to.be.undefined;
    expect(body.data.isSnoozed).to.be.true;
    expect(body.data.snoozedUntil).to.equal(snoozeUntil.toISOString());
  });

  it('should update the unsnoozed status', async () => {
    const now = new Date();
    const snoozeUntil = new Date(Date.now() + 1000 * 60 * 60); // 1 hour in the future

    // First set up a snoozed notification
    await updateNotification({
      id: message._id,
      status: 'snooze',
      body: { snoozeUntil },
    });

    // Then unsnooze it
    const { body, status } = await updateNotification({ id: message._id, status: 'unsnooze' });

    const updatedMessage = (await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: template._id,
    })) as MessageEntity;

    expect(status).to.equal(200);
    expect(body.data).to.deep.equal(removeUndefinedDeep(mapToDto(updatedMessage)));
    expect(updatedMessage.seen).to.be.true;
    expect(updatedMessage.lastSeenDate).not.to.be.undefined;
    expect(body.data.isSnoozed).to.be.false;
    expect(body.data.snoozedUntil).to.be.undefined;
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - updateNotification(async ({
    id,
    status,
    body,
  }: {
    id: string;
    status: 'read' | 'unread' | 'archi...)
 - times(1))
 - removeUndefinedDeep(obj))
 - message(await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId...)
 - updatedMessage(await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId...)
 - updatedMessage(await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId...)
 - updatedMessage(await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId...)
 - updatedMessage(await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId...)
 - updatedMessage(await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/e2e/mark-notifications-as-seen.e2e.ts
TamaÃ±o: 11476 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import {
  MessageEntity,
  MessageRepository,
  NotificationTemplateEntity,
  SubscriberEntity,
  SubscriberRepository,
} from '@novu/dal';
import { ActorTypeEnum, ChannelCTATypeEnum, StepTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Mark Notifications As Seen - /inbox/notifications/seen (POST) #novu-v2', async () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity | null;
  let messages: MessageEntity[];
  const messageRepository = new MessageRepository();
  const subscriberRepository = new SubscriberRepository();
  let novuClient: Novu;

  const markNotificationsAsSeen = async (body: any = {}) => {
    return await session.testAgent
      .post('/v1/inbox/notifications/seen')
      .set('Authorization', `Bearer ${session.subscriberToken}`)
      .send(body);
  };

  const triggerEvent = async (templateToTrigger: NotificationTemplateEntity, times = 1, payload: any = {}) => {
    const promises: Array<Promise<unknown>> = [];
    for (let i = 0; i < times; i += 1) {
      promises.push(
        novuClient.trigger({
          workflowId: templateToTrigger.triggers[0].identifier,
          to: { subscriberId: session.subscriberId },
          payload,
        })
      );
    }

    await Promise.all(promises);
    await session.waitForJobCompletion(templateToTrigger._id);
  };

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    subscriber = await subscriberRepository.findBySubscriberId(session.environment._id, session.subscriberId);

    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test content for <b>{{firstName}}</b>',
          cta: {
            type: ChannelCTATypeEnum.REDIRECT,
            data: {
              url: '/cypress/test-shell/example/test?test-param=true',
            },
          },
          actor: {
            type: ActorTypeEnum.NONE,
            data: null,
          },
        },
      ],
    });

    novuClient = new Novu({
      security: {
        secretKey: session.apiKey,
      },
      serverURL: session.serverUrl,
    });
  });

  describe('Mark specific notifications as seen by IDs', () => {
    beforeEach(async () => {
      await triggerEvent(template, 3);
      messages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id,
        _templateId: template._id,
      });
    });

    it('should mark specific notifications as seen by providing IDs', async () => {
      const messageIds = [messages[0]._id, messages[1]._id];
      const { status } = await markNotificationsAsSeen({ notificationIds: messageIds });

      expect(status).to.equal(204);

      const updatedMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id,
        _templateId: template._id,
      });

      const updatedMessage1 = updatedMessages.find((message) => message._id === messages[0]._id);
      const updatedMessage2 = updatedMessages.find((message) => message._id === messages[1]._id);
      const updatedMessage3 = updatedMessages.find((message) => message._id === messages[2]._id);

      expect(updatedMessage1?.seen).to.be.true;
      expect(updatedMessage1?.lastSeenDate).not.to.be.undefined;
      expect(updatedMessage2?.seen).to.be.true;
      expect(updatedMessage2?.lastSeenDate).not.to.be.undefined;
      expect(updatedMessage3?.seen).to.be.false; // Should not be marked as seen
    });

    it('should throw validation error for invalid notification IDs', async () => {
      const invalidBody = {
        notificationIds: ['invalid-id', 'another-invalid'],
      };

      const { body } = await session.testAgent
        .post('/v1/inbox/notifications/seen')
        .set('Authorization', `Bearer ${session.subscriberToken}`)
        .send(invalidBody)
        .expect(422);

      expect(body.message).to.include('Validation Error');
    });
  });

  describe('Mark notifications as seen by filters', () => {
    beforeEach(async () => {
      // Create notifications with different tags and data
      await triggerEvent(template, 2, { category: 'urgent', tags: ['important'] });
      await triggerEvent(template, 2, { category: 'normal', tags: ['regular'] });
      messages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id,
        _templateId: template._id,
      });
    });

    it('should mark all notifications as seen when no filters provided', async () => {
      const { status } = await markNotificationsAsSeen({});

      expect(status).to.equal(204);

      const updatedMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id,
        _templateId: template._id,
      });

      updatedMessages.forEach((message) => {
        expect(message.seen).to.be.true;
        expect(message.lastSeenDate).not.to.be.undefined;
      });
    });

    it('should mark notifications as seen by tags filter', async () => {
      // Create template with tags
      const taggedTemplate = await session.createTemplate({
        tags: ['important'],
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'Tagged notification',
          },
        ],
      });

      await triggerEvent(taggedTemplate, 2);

      const { status } = await markNotificationsAsSeen({ tags: ['important'] });

      expect(status).to.equal(204);

      const taggedMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id,
        _templateId: taggedTemplate._id,
      });

      taggedMessages.forEach((message) => {
        expect(message.seen).to.be.true;
        expect(message.lastSeenDate).not.to.be.undefined;
      });
    });

    it('should throw validation error for invalid JSON data', async () => {
      const invalidBody = {
        data: 'invalid-json-{',
      };

      const { body } = await session.testAgent
        .post('/v1/inbox/notifications/seen')
        .set('Authorization', `Bearer ${session.subscriberToken}`)
        .send(invalidBody)
        .expect(400);

      expect(body.message).to.include('Invalid JSON format for data parameter');
    });
  });

  describe('Priority handling', () => {
    beforeEach(async () => {
      await triggerEvent(template, 3);
      messages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id,
        _templateId: template._id,
      });
    });

    it('should prioritize notificationIds over filters when both are provided', async () => {
      const messageIds = [messages[0]._id];
      const { status } = await markNotificationsAsSeen({
        notificationIds: messageIds,
        tags: ['some-tag'], // This should be ignored
      });

      expect(status).to.equal(204);

      const updatedMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id,
        _templateId: template._id,
      });

      const updatedMessage1 = updatedMessages.find((message) => message._id === messages[0]._id);
      const updatedMessage2 = updatedMessages.find((message) => message._id === messages[1]._id);
      const updatedMessage3 = updatedMessages.find((message) => message._id === messages[2]._id);

      expect(updatedMessage1?.seen).to.be.true;
      expect(updatedMessage2?.seen).to.be.false; // Should not be affected by tags filter
      expect(updatedMessage3?.seen).to.be.false;
    });
  });

  describe('Error handling', () => {
    it('should handle non-existent notification IDs gracefully', async () => {
      const nonExistentId = '507f1f77bcf86cd799439011'; // Valid ObjectId format but doesn't exist
      const { status } = await markNotificationsAsSeen({ notificationIds: [nonExistentId] });

      expect(status).to.equal(204); // Should still succeed but no notifications updated
    });

    it('should validate array format for notificationIds', async () => {
      const invalidBody = {
        notificationIds: 'not-an-array',
      };

      await session.testAgent
        .post('/v1/inbox/notifications/seen')
        .set('Authorization', `Bearer ${session.subscriberToken}`)
        .send(invalidBody)
        .expect(422);
    });

    it('should validate array format for tags', async () => {
      const invalidBody = {
        tags: 'not-an-array',
      };

      await session.testAgent
        .post('/v1/inbox/notifications/seen')
        .set('Authorization', `Bearer ${session.subscriberToken}`)
        .send(invalidBody)
        .expect(422);
    });
  });

  describe('Side effects', () => {
    beforeEach(async () => {
      await triggerEvent(template, 2);
      messages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id,
        _templateId: template._id,
      });
    });

    it('should not affect read status when marking as seen', async () => {
      // First mark one message as read
      await messageRepository.update(
        {
          _id: messages[0]._id,
          _environmentId: session.environment._id,
        },
        { $set: { read: true, lastReadDate: new Date() } }
      );

      const messageIds = [messages[0]._id, messages[1]._id];
      await markNotificationsAsSeen({ notificationIds: messageIds });

      const updatedMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id,
        _templateId: template._id,
      });

      const updatedMessage1 = updatedMessages.find((message) => message._id === messages[0]._id);
      const updatedMessage2 = updatedMessages.find((message) => message._id === messages[1]._id);

      expect(updatedMessage1?.seen).to.be.true;
      expect(updatedMessage1?.read).to.be.true; // Should remain read
      expect(updatedMessage2?.seen).to.be.true;
      expect(updatedMessage2?.read).to.be.false; // Should remain unread
    });

    it('should not affect archived status when marking as seen', async () => {
      // First mark one message as archived
      await messageRepository.update(
        {
          _id: messages[0]._id,
          _environmentId: session.environment._id,
        },
        { $set: { archived: true, archivedAt: new Date() } }
      );

      const messageIds = [messages[0]._id, messages[1]._id];
      await markNotificationsAsSeen({ notificationIds: messageIds });

      const updatedMessages = await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id,
        _templateId: template._id,
      });

      const updatedMessage1 = updatedMessages.find((message) => message._id === messages[0]._id);
      const updatedMessage2 = updatedMessages.find((message) => message._id === messages[1]._id);

      expect(updatedMessage1?.seen).to.be.true;
      expect(updatedMessage1?.archived).to.be.true; // Should remain archived
      expect(updatedMessage2?.seen).to.be.true;
      expect(updatedMessage2?.archived).to.be.false; // Should remain unarchived
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - any({}))
 - any({}))
 - novuClient(new Novu({
      security: {
        secretKey: session.apiKey,
      },
      serverURL: session.se...)
 - messages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - updatedMessage1(updatedMessages.find((message))
 - updatedMessage2(updatedMessages.find((message))
 - updatedMessage3(updatedMessages.find((message))
 - messages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - updatedMessages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - taggedMessages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - messages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - updatedMessage1(updatedMessages.find((message))
 - updatedMessage2(updatedMessages.find((message))
 - updatedMessage3(updatedMessages.find((message))
 - invalidBody({
        notificationIds: 'not-an-array',
      };

      await session.testAgent
        .post('/v...)
 - invalidBody({
        tags: 'not-an-array',
      };

      await session.testAgent
        .post('/v1/inbox/not...)
 - messages(await messageRepository.find({
        _environmentId: session.environment._id,
        _subscriberI...)
 - updatedMessage1(updatedMessages.find((message))
 - updatedMessage2(updatedMessages.find((message))
 - updatedMessage1(updatedMessages.find((message))
 - updatedMessage2(updatedMessages.find((message))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/e2e/session.e2e.ts
TamaÃ±o: 42642 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  buildIntegrationKey,
  CacheInMemoryProviderService,
  CacheService,
  createContextHash,
  createHash,
  InvalidateCacheService,
} from '@novu/application-generic';
import { ContextRepository, IntegrationRepository, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum, ContextPayload, InAppProviderIdEnum, SeverityLevelEnum, StepTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { randomBytes } from 'crypto';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

const integrationRepository = new IntegrationRepository();
const contextRepository = new ContextRepository();
const mockSubscriberId = '12345';

describe('Session - /inbox/session (POST) #novu-v2', async () => {
  let session: UserSession;
  let cacheService: CacheService;
  let invalidateCache: InvalidateCacheService;
  let subscriberRepository: SubscriberRepository;
  const isSubscribersScheduleEnabled = process.env.IS_SUBSCRIBERS_SCHEDULE_ENABLED;
  const isContextEnabled = process.env.IS_CONTEXT_ENABLED;

  before(async () => {
    const cacheInMemoryProviderService = new CacheInMemoryProviderService();
    cacheService = new CacheService(cacheInMemoryProviderService);
    await cacheService.initialize();
    invalidateCache = new InvalidateCacheService(cacheService);
    subscriberRepository = new SubscriberRepository();
  });

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
      },
      invalidateCache
    );
    // @ts-expect-error
    process.env.IS_SUBSCRIBERS_SCHEDULE_ENABLED = 'true';
    // @ts-expect-error
    process.env.IS_CONTEXT_ENABLED = 'true';
  });

  afterEach(() => {
    // @ts-expect-error
    process.env.IS_SUBSCRIBERS_SCHEDULE_ENABLED = isSubscribersScheduleEnabled;
    // @ts-expect-error
    process.env.IS_CONTEXT_ENABLED = isContextEnabled;
  });

  const initializeSession = async ({
    applicationIdentifier,
    subscriberId,
    subscriberHash,
    subscriber,
    origin,
    defaultSchedule,
    context,
    contextHash,
  }: {
    applicationIdentifier: string;
    subscriberId?: string;
    subscriberHash?: string;
    subscriber?: Record<string, unknown>;
    origin?: string;
    defaultSchedule?: Record<string, unknown>;
    context?: ContextPayload;
    contextHash?: string;
  }) => {
    const request = session.testAgent.post('/v1/inbox/session');

    if (origin) {
      request.set('origin', origin);
    }

    return await request.send({
      applicationIdentifier,
      subscriberId,
      subscriberHash,
      subscriber,
      defaultSchedule,
      context,
      contextHash,
    });
  };

  it('should initialize session', async () => {
    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
        hmac: false,
      },
      invalidateCache
    );
    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriberId: mockSubscriberId,
    });

    expect(status).to.equal(201);
    expect(body.data.token).to.be.ok;
    expect(body.data.totalUnreadCount).to.equal(0);
  });

  it('should initialize session with HMAC', async () => {
    const secretKey = session.environment.apiKeys[0].key;
    const subscriberHash = createHash(secretKey, mockSubscriberId);

    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriberId: mockSubscriberId,
      subscriberHash,
    });

    expect(status).to.equal(201);
    expect(body.data.token).to.be.ok;
    expect(body.data.totalUnreadCount).to.equal(0);
  });

  it('should initialize session with subscriber object', async () => {
    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
        hmac: false,
      },
      invalidateCache
    );

    const subscriber = {
      subscriberId: mockSubscriberId,
      firstName: 'John',
      lastName: 'Doe',
      email: 'john@example.com',
    };

    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriber,
    });

    expect(status).to.equal(201);
    expect(body.data.token).to.be.ok;
    expect(body.data.totalUnreadCount).to.equal(0);
  });

  it('should create a new subscriber if it does not exist', async () => {
    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
        hmac: false,
      },
      invalidateCache
    );
    const subscriberId = `user-subscriber-id-${`${randomBytes(4).toString('hex')}`}`;

    const newRandomSubscriber = {
      subscriberId,
      firstName: 'Mike',
      lastName: 'Tyson',
      email: 'mike@example.com',
    };

    const res = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriber: newRandomSubscriber,
    });

    const { status, body } = res;

    expect(status).to.equal(201);
    expect(body.data.token).to.be.ok;
    expect(body.data.totalUnreadCount).to.equal(0);

    const storedSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);
    expect(storedSubscriber).to.exist;
    if (!storedSubscriber) {
      throw new Error('Subscriber exists but was not found');
    }

    expect(storedSubscriber.firstName).to.equal(newRandomSubscriber.firstName);
    expect(storedSubscriber.lastName).to.equal(newRandomSubscriber.lastName);
    expect(storedSubscriber.email).to.equal(newRandomSubscriber.email);
  });

  it('should upsert a subscriber', async () => {
    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
        hmac: false,
      },
      invalidateCache
    );
    const subscriberId = `user-subscriber-id-${`${randomBytes(4).toString('hex')}`}`;

    const newRandomSubscriber = {
      subscriberId,
      firstName: 'Mike',
      lastName: 'Tyson',
      email: 'mike@example.com',
    };

    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriber: newRandomSubscriber,
    });

    expect(status).to.equal(201);
    expect(body.data.token).to.be.ok;
    expect(body.data.totalUnreadCount).to.equal(0);

    const storedSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);
    expect(storedSubscriber).to.exist;
    if (!storedSubscriber) {
      throw new Error('Subscriber exists but was not found');
    }

    expect(storedSubscriber.firstName).to.equal(newRandomSubscriber.firstName);
    expect(storedSubscriber.lastName).to.equal(newRandomSubscriber.lastName);
    expect(storedSubscriber.email).to.equal(newRandomSubscriber.email);

    const updatedSubscriber = {
      subscriberId,
      firstName: 'Mike 2',
      lastName: 'Tyson 2',
      email: 'mike2@example.com',
    };

    const secretKey = session.environment.apiKeys[0].key;
    const subscriberHash = createHash(secretKey, subscriberId);
    const { body: updatedBody, status: updatedStatus } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriber: updatedSubscriber,
      subscriberHash,
    });

    expect(updatedStatus).to.equal(201);
    expect(updatedBody.data.token).to.be.ok;
    expect(updatedBody.data.totalUnreadCount).to.equal(0);

    const updatedStoredSubscriber = await subscriberRepository.findBySubscriberId(
      session.environment._id,
      subscriberId
    );
    expect(updatedStoredSubscriber).to.exist;
    if (!updatedStoredSubscriber) {
      throw new Error('Subscriber exists but was not found');
    }

    expect(updatedStoredSubscriber.firstName).to.equal(updatedSubscriber.firstName);
    expect(updatedStoredSubscriber.lastName).to.equal(updatedSubscriber.lastName);
    expect(updatedStoredSubscriber.email).to.equal(updatedSubscriber.email);

    const { body: upsertWithoutHmac, status: upsertedStatusWithoutHmac } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriber: {
        subscriberId,
        firstName: 'Mike 3',
        lastName: 'Tyson 3',
        email: 'mike3@example.com',
      },
    });

    expect(upsertedStatusWithoutHmac).to.equal(201);
    expect(upsertWithoutHmac.data.token).to.be.ok;
    expect(upsertWithoutHmac.data.totalUnreadCount).to.equal(0);

    const updatedStoredSubscriber2 = await subscriberRepository.findBySubscriberId(
      session.environment._id,
      subscriberId
    );
    expect(updatedStoredSubscriber2).to.exist;
    if (!updatedStoredSubscriber2) {
      throw new Error('Subscriber exists but was not found');
    }

    expect(updatedStoredSubscriber2.firstName).to.not.equal('Mike 3');
    expect(updatedStoredSubscriber2.lastName).to.not.equal('Tyson 3');
    expect(updatedStoredSubscriber2.email).to.not.equal('mike3@example.com');
  });

  it('should initialize session with origin header', async () => {
    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
        hmac: false,
      },
      invalidateCache
    );

    const origin = 'https://example.com';
    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriberId: mockSubscriberId,
      origin,
    });

    expect(status).to.equal(201);
    expect(body.data.token).to.be.ok;
    expect(body.data.totalUnreadCount).to.equal(0);
  });

  it('should throw an error when invalid applicationIdentifier provided', async () => {
    const { body, status } = await initializeSession({
      applicationIdentifier: 'some-not-existing-id',
      subscriberId: mockSubscriberId,
    });

    expect(status).to.equal(400);
    expect(body.message).to.contain('Please provide a valid application identifier');
  });

  it('should throw an error when no active integrations', async () => {
    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
        active: false,
      },
      invalidateCache
    );

    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriberId: mockSubscriberId,
    });

    expect(status).to.equal(404);
    expect(body.message).to.contain('The active in-app integration could not be found');
  });

  it('should throw an error when invalid subscriberHash provided', async () => {
    const invalidSecretKey = 'invalid-secret-key';
    const subscriberHash = createHash(invalidSecretKey, mockSubscriberId);

    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriberId: session.subscriberId,
      subscriberHash,
    });

    expect(status).to.equal(400);
    expect(body.message).to.contain('Please provide a valid HMAC hash');
  });

  it('should initialize session with valid context and contextHash when HMAC enabled', async () => {
    const secretKey = session.environment.apiKeys[0].key;
    const subscriberHash = createHash(secretKey, mockSubscriberId);
    const context: ContextPayload = { tenant: 'acme', app: 'dashboard' };
    const contextHash = createContextHash(secretKey, context);

    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriberId: mockSubscriberId,
      subscriberHash,
      context,
      contextHash,
    });

    expect(status).to.equal(201);
    expect(body.data.token).to.be.ok;
    expect(body.data.totalUnreadCount).to.equal(0);
  });

  it('should throw error when invalid contextHash provided', async () => {
    const secretKey = session.environment.apiKeys[0].key;
    const subscriberHash = createHash(secretKey, mockSubscriberId);
    const context: ContextPayload = { tenant: 'acme', app: 'dashboard' };
    const invalidContextHash = 'invalid-context-hash';

    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriberId: mockSubscriberId,
      subscriberHash,
      context,
      contextHash: invalidContextHash,
    });

    expect(status).to.equal(400);
    expect(body.message).to.contain('Please provide a valid context HMAC hash');
  });

  it('should throw error when context provided without contextHash when HMAC enabled', async () => {
    const secretKey = session.environment.apiKeys[0].key;
    const subscriberHash = createHash(secretKey, mockSubscriberId);
    const context: ContextPayload = { tenant: 'acme', app: 'dashboard' };

    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriberId: mockSubscriberId,
      subscriberHash,
      context,
    });

    expect(status).to.equal(400);
    expect(body.message).to.contain('Please provide a valid context HMAC hash');
  });

  it('should handle context with different key orders - hash should match', async () => {
    const secretKey = session.environment.apiKeys[0].key;
    const subscriberHash = createHash(secretKey, mockSubscriberId);

    // Create context with keys in one order
    const context1: ContextPayload = { tenant: 'acme', app: 'dashboard', env: 'prod' };
    const contextHash1 = createContextHash(secretKey, context1);

    // Create context with keys in different order - should produce same hash
    const context2: ContextPayload = { env: 'prod', tenant: 'acme', app: 'dashboard' };
    const contextHash2 = createContextHash(secretKey, context2);

    // Verify hashes match
    expect(contextHash1).to.equal(contextHash2);

    // Use context2 with contextHash1 (from different order) - should succeed
    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriberId: mockSubscriberId,
      subscriberHash,
      context: context2,
      contextHash: contextHash1,
    });

    expect(status).to.equal(201);
    expect(body.data.token).to.be.ok;
  });

  it('should accept context without contextHash when HMAC disabled', async () => {
    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
        hmac: false,
      },
      invalidateCache
    );

    const context: ContextPayload = { tenant: 'acme', app: 'dashboard' };

    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriberId: mockSubscriberId,
      context,
    });

    expect(status).to.equal(201);
    expect(body.data.token).to.be.ok;
  });

  it('should detect context tampering - different context should fail validation', async () => {
    const secretKey = session.environment.apiKeys[0].key;
    const subscriberHash = createHash(secretKey, mockSubscriberId);

    // Create hash for one context
    const originalContext: ContextPayload = { tenant: 'acme', app: 'dashboard' };
    const contextHash = createContextHash(secretKey, originalContext);

    // Try to use hash with different context (tampering attempt)
    const tamperedContext: ContextPayload = { tenant: 'malicious', app: 'dashboard' };

    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriberId: mockSubscriberId,
      subscriberHash,
      context: tamperedContext,
      contextHash,
    });

    expect(status).to.equal(400);
    expect(body.message).to.contain('Please provide a valid context HMAC hash');
  });

  it('should throw an error when subscriber object is missing subscriberId', async () => {
    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
        hmac: false,
      },
      invalidateCache
    );
    const subscriber = {
      firstName: 'John',
      lastName: 'Doe',
      email: 'john@example.com',
    };

    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriber,
    });

    expect(status).to.equal(422);
    expect(body.message).to.contain('Validation Error');
  });

  it('should return severity-based unread counts in session', async () => {
    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
        hmac: false,
      },
      invalidateCache
    );

    const novuClient = initNovuClassSdk(session);

    // Create templates with different severities
    const highSeverityTemplate = await session.createTemplate({
      noFeedId: true,
      severity: SeverityLevelEnum.HIGH,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'High severity notification',
        },
      ],
    });

    const mediumSeverityTemplate = await session.createTemplate({
      noFeedId: true,
      severity: SeverityLevelEnum.MEDIUM,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Medium severity notification',
        },
      ],
    });

    const lowSeverityTemplate = await session.createTemplate({
      noFeedId: true,
      severity: SeverityLevelEnum.LOW,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Low severity notification',
        },
      ],
    });

    // Trigger notifications with different severities
    await novuClient.trigger({
      workflowId: highSeverityTemplate.triggers[0].identifier,
      to: { subscriberId: mockSubscriberId },
    });

    await novuClient.trigger({
      workflowId: mediumSeverityTemplate.triggers[0].identifier,
      to: { subscriberId: mockSubscriberId },
    });

    await novuClient.trigger({
      workflowId: lowSeverityTemplate.triggers[0].identifier,
      to: { subscriberId: mockSubscriberId },
    });

    // Wait for jobs to complete
    await session.waitForJobCompletion(highSeverityTemplate._id);
    await session.waitForJobCompletion(mediumSeverityTemplate._id);
    await session.waitForJobCompletion(lowSeverityTemplate._id);

    // Initialize session and check severity counts
    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriberId: mockSubscriberId,
    });

    expect(status).to.equal(201);
    expect(body.data.token).to.be.ok;
    expect(body.data.totalUnreadCount).to.equal(3);
    expect(body.data.unreadCount).to.exist;
    expect(body.data.unreadCount.total).to.equal(3);
    expect(body.data.unreadCount.severity).to.exist;
    expect(body.data.unreadCount.severity.high).to.equal(1);
    expect(body.data.unreadCount.severity.medium).to.equal(1);
    expect(body.data.unreadCount.severity.low).to.equal(1);
    expect(body.data.unreadCount.severity.none).to.equal(0);
  });

  it('should return correct severity counts when no notifications exist', async () => {
    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
        hmac: false,
      },
      invalidateCache
    );

    const { body, status } = await session.testAgent.post('/v1/inbox/session').send({
      applicationIdentifier: session.environment.identifier,
      subscriberId: session.subscriberId,
    });

    expect(status).to.equal(201);
    expect(body.data.unreadCount).to.exist;
    expect(body.data.unreadCount.total).to.equal(0);
    expect(body.data.unreadCount.severity).to.exist;
    expect(body.data.unreadCount.severity.high).to.equal(0);
    expect(body.data.unreadCount.severity.medium).to.equal(0);
    expect(body.data.unreadCount.severity.low).to.equal(0);
    expect(body.data.unreadCount.severity.none).to.equal(0);
  });

  it('should return correct severity counts with mixed read/unread notifications', async () => {
    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
        hmac: false,
      },
      invalidateCache
    );

    const novuClient = initNovuClassSdk(session);

    const highSeverityTemplate = await session.createTemplate({
      noFeedId: true,
      severity: SeverityLevelEnum.HIGH,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'High severity notification',
        },
      ],
    });

    const mediumSeverityTemplate = await session.createTemplate({
      noFeedId: true,
      severity: SeverityLevelEnum.MEDIUM,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Medium severity notification',
        },
      ],
    });

    // Trigger multiple notifications of each severity
    await novuClient.trigger({
      workflowId: highSeverityTemplate.triggers[0].identifier,
      to: { subscriberId: session.subscriberId },
    });
    await novuClient.trigger({
      workflowId: highSeverityTemplate.triggers[0].identifier,
      to: { subscriberId: session.subscriberId },
    });
    await novuClient.trigger({
      workflowId: mediumSeverityTemplate.triggers[0].identifier,
      to: { subscriberId: session.subscriberId },
    });

    await session.waitForJobCompletion(highSeverityTemplate._id);
    await session.waitForJobCompletion(mediumSeverityTemplate._id);

    // Mark one high severity notification as read
    const { body: notifications } = await session.testAgent
      .get('/v1/inbox/notifications')
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    const highSeverityNotification = notifications.data.find((n: any) => n.severity === SeverityLevelEnum.HIGH);
    await session.testAgent
      .patch(`/v1/inbox/notifications/${highSeverityNotification.id}/read`)
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    const { body, status } = await session.testAgent.post('/v1/inbox/session').send({
      applicationIdentifier: session.environment.identifier,
      subscriberId: session.subscriberId,
    });

    expect(status).to.equal(201);
    expect(body.data.unreadCount).to.exist;
    expect(body.data.unreadCount.total).to.equal(2); // 1 unread high + 1 unread medium
    expect(body.data.unreadCount.severity).to.exist;
    expect(body.data.unreadCount.severity.high).to.equal(1); // 1 unread
    expect(body.data.unreadCount.severity.medium).to.equal(1);
    expect(body.data.unreadCount.severity.low).to.equal(0);
    expect(body.data.unreadCount.severity.none).to.equal(0);
  });

  it('should maintain backward compatibility with totalUnreadCount', async () => {
    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
        hmac: false,
      },
      invalidateCache
    );

    const novuClient = initNovuClassSdk(session);

    const highSeverityTemplate = await session.createTemplate({
      noFeedId: true,
      severity: SeverityLevelEnum.HIGH,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'High severity notification',
        },
      ],
    });

    await novuClient.trigger({
      workflowId: highSeverityTemplate.triggers[0].identifier,
      to: { subscriberId: session.subscriberId },
    });

    await session.waitForJobCompletion(highSeverityTemplate._id);

    const { body } = await session.testAgent.post('/v1/inbox/session').send({
      applicationIdentifier: session.environment.identifier,
      subscriberId: session.subscriberId,
    });

    // Both fields should exist and match for backward compatibility
    expect(body.data.totalUnreadCount).to.be.a('number');
    expect(body.data.unreadCount.total).to.be.a('number');
    expect(body.data.totalUnreadCount).to.equal(body.data.unreadCount.total);
  });

  it('should handle notifications with no severity (none)', async () => {
    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
        hmac: false,
      },
      invalidateCache
    );

    const novuClient = initNovuClassSdk(session);

    // Create template without severity (defaults to none)
    const noSeverityTemplate = await session.createTemplate({
      noFeedId: true,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Notification without explicit severity',
        },
      ],
    });

    await novuClient.trigger({
      workflowId: noSeverityTemplate.triggers[0].identifier,
      to: { subscriberId: session.subscriberId },
    });

    await session.waitForJobCompletion(noSeverityTemplate._id);

    const { body, status } = await session.testAgent.post('/v1/inbox/session').send({
      applicationIdentifier: session.environment.identifier,
      subscriberId: session.subscriberId,
    });

    expect(status).to.equal(201);
    expect(body.data.unreadCount).to.exist;
    expect(body.data.unreadCount.total).to.equal(1);
    expect(body.data.unreadCount.severity).to.exist;
    expect(body.data.unreadCount.severity.high).to.equal(0);
    expect(body.data.unreadCount.severity.medium).to.equal(0);
    expect(body.data.unreadCount.severity.low).to.equal(0);
    expect(body.data.unreadCount.severity.none).to.equal(1);
  });

  describe('defaultSchedule functionality', () => {
    it('should initialize session with valid defaultSchedule', async () => {
      await setIntegrationConfig(
        {
          _environmentId: session.environment._id,
          _organizationId: session.environment._organizationId,
          hmac: false,
        },
        invalidateCache
      );

      const defaultSchedule = {
        isEnabled: true,
        weeklySchedule: {
          monday: {
            isEnabled: true,
            hours: [{ start: '09:00 AM', end: '05:00 PM' }],
          },
          tuesday: {
            isEnabled: true,
            hours: [{ start: '09:00 AM', end: '05:00 PM' }],
          },
          wednesday: {
            isEnabled: true,
            hours: [{ start: '09:00 AM', end: '05:00 PM' }],
          },
          thursday: {
            isEnabled: true,
            hours: [{ start: '09:00 AM', end: '05:00 PM' }],
          },
          friday: {
            isEnabled: true,
            hours: [{ start: '09:00 AM', end: '05:00 PM' }],
          },
        },
      };

      const { body, status } = await initializeSession({
        applicationIdentifier: session.environment.identifier,
        subscriberId: `schedule-test-${randomBytes(4).toString('hex')}`,
        subscriber: {
          subscriberId: `schedule-test-${randomBytes(4).toString('hex')}`,
          firstName: 'Schedule',
          lastName: 'Test',
        },
        defaultSchedule,
      });

      expect(status).to.equal(201);
      expect(body.data.token).to.be.ok;
      expect(body.data.schedule).to.exist;
      expect(body.data.schedule.isEnabled).to.equal(true);
      expect(body.data.schedule.weeklySchedule).to.exist;
      expect(body.data.schedule.weeklySchedule.monday.isEnabled).to.equal(true);
      expect(body.data.schedule.weeklySchedule.monday.hours[0].start).to.equal('09:00 AM');
      expect(body.data.schedule.weeklySchedule.monday.hours[0].end).to.equal('05:00 PM');
      expect(body.data.schedule.weeklySchedule.tuesday.isEnabled).to.equal(true);
      expect(body.data.schedule.weeklySchedule.tuesday.hours[0].start).to.equal('09:00 AM');
      expect(body.data.schedule.weeklySchedule.tuesday.hours[0].end).to.equal('05:00 PM');
    });

    it('should initialize session with defaultSchedule when isEnabled is false', async () => {
      await setIntegrationConfig(
        {
          _environmentId: session.environment._id,
          _organizationId: session.environment._organizationId,
          hmac: false,
        },
        invalidateCache
      );

      const defaultSchedule = {
        isEnabled: false,
      };

      const { body, status } = await initializeSession({
        applicationIdentifier: session.environment.identifier,
        subscriberId: `schedule-disabled-${randomBytes(4).toString('hex')}`,
        defaultSchedule,
      });

      expect(status).to.equal(201);
      expect(body.data.token).to.be.ok;
      expect(body.data.schedule).to.exist;
      expect(body.data.schedule.isEnabled).to.equal(false);
      expect(body.data.schedule.weeklySchedule).to.not.exist;
    });

    it('should create schedule with isEnabled true when weeklySchedule is not provided', async () => {
      await setIntegrationConfig(
        {
          _environmentId: session.environment._id,
          _organizationId: session.environment._organizationId,
          hmac: false,
        },
        invalidateCache
      );

      const defaultSchedule = {
        isEnabled: true,
      };

      const { body, status } = await initializeSession({
        applicationIdentifier: session.environment.identifier,
        subscriberId: `schedule-enabled-only-${randomBytes(4).toString('hex')}`,
        defaultSchedule,
      });

      expect(status).to.equal(201);
      expect(body.data.token).to.be.ok;
      expect(body.data.schedule).to.exist;
      expect(body.data.schedule.isEnabled).to.equal(true);
      expect(body.data.schedule.weeklySchedule).to.not.exist;
    });

    it('should fail validation when isEnabled is true but weeklySchedule is empty', async () => {
      await setIntegrationConfig(
        {
          _environmentId: session.environment._id,
          _organizationId: session.environment._organizationId,
          hmac: false,
        },
        invalidateCache
      );

      const defaultSchedule = {
        isEnabled: true,
        weeklySchedule: {},
      };

      const { body, status } = await initializeSession({
        applicationIdentifier: session.environment.identifier,
        subscriberId: `schedule-empty-${randomBytes(4).toString('hex')}`,
        defaultSchedule,
      });

      expect(status).to.equal(422);
      expect(body.message).to.equal('Validation Error');
      expect(body.errors).to.exist;
      expect(body.errors.general).to.exist;
      expect(body.errors.general.messages).to.be.an('array');
      expect(body.errors.general.messages[0]).to.contain(
        'weeklySchedule must contain at least one day configuration when isEnabled is true'
      );
    });

    it('should fail validation with invalid time format', async () => {
      await setIntegrationConfig(
        {
          _environmentId: session.environment._id,
          _organizationId: session.environment._organizationId,
          hmac: false,
        },
        invalidateCache
      );

      const defaultSchedule = {
        isEnabled: true,
        weeklySchedule: {
          monday: {
            isEnabled: true,
            hours: [{ start: '25:00', end: '17:00' }], // Invalid 24-hour format
          },
        },
      };

      const { body, status } = await initializeSession({
        applicationIdentifier: session.environment.identifier,
        subscriberId: `schedule-invalid-time-${randomBytes(4).toString('hex')}`,
        defaultSchedule,
      });

      expect(status).to.equal(422);
      expect(body.message).to.equal('Validation Error');
      expect(body.errors).to.exist;
      expect(body.errors.general).to.exist;
      expect(body.errors.general.messages).to.be.an('array');
      expect(body.errors.general.messages.some((msg: string) => msg.includes('must be in 12-hour format'))).to.be.true;
    });

    it('should fail validation with invalid day name', async () => {
      await setIntegrationConfig(
        {
          _environmentId: session.environment._id,
          _organizationId: session.environment._organizationId,
          hmac: false,
        },
        invalidateCache
      );

      const defaultSchedule = {
        isEnabled: true,
        weeklySchedule: {
          invalidDay: {
            isEnabled: true,
            hours: [{ start: '09:00 AM', end: '05:00 PM' }],
          },
        },
      };

      const { body, status } = await initializeSession({
        applicationIdentifier: session.environment.identifier,
        subscriberId: `schedule-invalid-day-${randomBytes(4).toString('hex')}`,
        defaultSchedule,
      });

      expect(status).to.equal(422);
      expect(body.message).to.equal('Validation Error');
      expect(body.errors).to.exist;
      expect(body.errors.general).to.exist;
      expect(body.errors.general.messages).to.be.an('array');
      expect(body.errors.general.messages[0]).to.contain('weeklySchedule contains invalid day names');
    });

    it('should not set defaultSchedule when subscriber already has a schedule', async () => {
      await setIntegrationConfig(
        {
          _environmentId: session.environment._id,
          _organizationId: session.environment._organizationId,
          hmac: false,
        },
        invalidateCache
      );

      const subscriberId = `existing-schedule-${randomBytes(4).toString('hex')}`;

      // First, create a subscriber with a schedule
      const existingSchedule = {
        isEnabled: true,
        weeklySchedule: {
          monday: {
            isEnabled: true,
            hours: [{ start: '08:00 AM', end: '04:00 PM' }],
          },
        },
      };

      await initializeSession({
        applicationIdentifier: session.environment.identifier,
        subscriberId,
        defaultSchedule: existingSchedule,
      });

      // Now try to set a different defaultSchedule
      const newDefaultSchedule = {
        isEnabled: true,
        weeklySchedule: {
          tuesday: {
            isEnabled: true,
            hours: [{ start: '10:00 AM', end: '06:00 PM' }],
          },
        },
      };

      const { body, status } = await initializeSession({
        applicationIdentifier: session.environment.identifier,
        subscriberId,
        defaultSchedule: newDefaultSchedule,
      });

      expect(status).to.equal(201);
      expect(body.data.token).to.be.ok;
      expect(body.data.schedule).to.exist;
      expect(body.data.schedule.weeklySchedule.monday).to.exist; // Should keep existing schedule
      expect(body.data.schedule.weeklySchedule.tuesday).to.not.exist; // Should not use new defaultSchedule
    });

    it('should handle multiple time ranges in a day', async () => {
      await setIntegrationConfig(
        {
          _environmentId: session.environment._id,
          _organizationId: session.environment._organizationId,
          hmac: false,
        },
        invalidateCache
      );

      const defaultSchedule = {
        isEnabled: true,
        weeklySchedule: {
          monday: {
            isEnabled: true,
            hours: [
              { start: '09:00 AM', end: '12:00 PM' },
              { start: '01:00 PM', end: '05:00 PM' },
            ],
          },
        },
      };

      const { body, status } = await initializeSession({
        applicationIdentifier: session.environment.identifier,
        subscriberId: `multiple-ranges-${randomBytes(4).toString('hex')}`,
        defaultSchedule,
      });

      expect(status).to.equal(201);
      expect(body.data.token).to.be.ok;
      expect(body.data.schedule).to.exist;
      expect(body.data.schedule.weeklySchedule.monday.hours).to.have.length(2);
      expect(body.data.schedule.weeklySchedule.monday.hours[0].start).to.equal('09:00 AM');
      expect(body.data.schedule.weeklySchedule.monday.hours[0].end).to.equal('12:00 PM');
      expect(body.data.schedule.weeklySchedule.monday.hours[1].start).to.equal('01:00 PM');
      expect(body.data.schedule.weeklySchedule.monday.hours[1].end).to.equal('05:00 PM');
    });

    it('should handle different time formats (with/without leading zero)', async () => {
      await setIntegrationConfig(
        {
          _environmentId: session.environment._id,
          _organizationId: session.environment._organizationId,
          hmac: false,
        },
        invalidateCache
      );

      const defaultSchedule = {
        isEnabled: true,
        weeklySchedule: {
          monday: {
            isEnabled: true,
            hours: [{ start: '9:00 AM', end: '5:00 PM' }], // Without leading zero
          },
          tuesday: {
            isEnabled: true,
            hours: [{ start: '09:00 AM', end: '05:00 PM' }], // With leading zero
          },
        },
      };

      const { body, status } = await initializeSession({
        applicationIdentifier: session.environment.identifier,
        subscriberId: `time-format-${randomBytes(4).toString('hex')}`,
        defaultSchedule,
      });

      expect(status).to.equal(201);
      expect(body.data.token).to.be.ok;
      expect(body.data.schedule).to.exist;
      expect(body.data.schedule.weeklySchedule.monday.hours[0].start).to.equal('9:00 AM');
      expect(body.data.schedule.weeklySchedule.tuesday.hours[0].start).to.equal('09:00 AM');
    });

    it('should not create schedule when feature flag is disabled', async () => {
      // Disable the feature flag
      // @ts-expect-error process.env is not typed
      process.env.IS_SUBSCRIBERS_SCHEDULE_ENABLED = 'false';

      await setIntegrationConfig(
        {
          _environmentId: session.environment._id,
          _organizationId: session.environment._organizationId,
          hmac: false,
        },
        invalidateCache
      );

      const defaultSchedule = {
        isEnabled: true,
        weeklySchedule: {
          monday: {
            isEnabled: true,
            hours: [{ start: '09:00 AM', end: '05:00 PM' }],
          },
        },
      };

      const { body, status } = await initializeSession({
        applicationIdentifier: session.environment.identifier,
        subscriberId: `feature-flag-disabled-${randomBytes(4).toString('hex')}`,
        defaultSchedule,
      });

      expect(status).to.equal(201);
      expect(body.data.token).to.be.ok;
      expect(body.data.schedule).to.not.exist;

      // Re-enable the feature flag for other tests
      // @ts-expect-error process.env is not typed
      process.env.IS_SUBSCRIBERS_SCHEDULE_ENABLED = 'true';
    });
  });

  it('should create contexts in database and return contextKeys in session', async () => {
    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
        hmac: false,
      },
      invalidateCache
    );

    const context: ContextPayload = { teamId: 'team-123', projectId: 'project-456' };

    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriberId: mockSubscriberId,
      context,
    });

    expect(status).to.equal(201);
    expect(body.data.contextKeys).to.be.an('array');
    expect(body.data.contextKeys).to.have.lengthOf(2);
    expect(body.data.contextKeys).to.include('teamId:team-123');
    expect(body.data.contextKeys).to.include('projectId:project-456');

    const contexts = await contextRepository.find({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    expect(contexts).to.have.lengthOf(2);
    const contextKeys = contexts.map((c) => c.key);
    expect(contextKeys).to.include('teamId:team-123');
    expect(contextKeys).to.include('projectId:project-456');
  });

  it('should reuse existing contexts on subsequent sessions', async () => {
    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
        hmac: false,
      },
      invalidateCache
    );

    const context: ContextPayload = { teamId: 'team-789' };

    const firstSession = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriberId: mockSubscriberId,
      context,
    });

    expect(firstSession.status).to.equal(201);
    expect(firstSession.body.data.contextKeys).to.deep.equal(['teamId:team-789']);

    const contextsBefore = await contextRepository.find({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    const secondSession = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriberId: mockSubscriberId,
      context,
    });

    expect(secondSession.status).to.equal(201);
    expect(secondSession.body.data.contextKeys).to.deep.equal(['teamId:team-789']);

    const contextsAfter = await contextRepository.find({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    expect(contextsAfter.length).to.equal(contextsBefore.length);
  });

  it('should return empty contextKeys array when no context provided', async () => {
    await setIntegrationConfig(
      {
        _environmentId: session.environment._id,
        _organizationId: session.environment._organizationId,
        hmac: false,
      },
      invalidateCache
    );

    const { body, status } = await initializeSession({
      applicationIdentifier: session.environment.identifier,
      subscriberId: mockSubscriberId,
    });

    expect(status).to.equal(201);
    expect(body.data.contextKeys).to.be.an('array');
    expect(body.data.contextKeys).to.have.lengthOf(0);
  });
});

async function setIntegrationConfig(
  {
    _environmentId,
    _organizationId,
    hmac = true,
    active = true,
  }: { _environmentId: string; _organizationId: string; active?: boolean; hmac?: boolean },
  invalidateCache: InvalidateCacheService
) {
  await invalidateCache.invalidateQuery({
    key: buildIntegrationKey().invalidate({
      _organizationId,
    }),
  });

  await integrationRepository.update(
    {
      _environmentId,
      _organizationId,
      providerId: InAppProviderIdEnum.Novu,
      channel: ChannelTypeEnum.IN_APP,
      active: true,
    },
    {
      $set: {
        'credentials.hmac': hmac,
        active,
      },
    }
  );
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - setIntegrationConfig({
    _environmentId,
    _organizationId,
    hmac = true,
    active = true,
  }: { _environmentId: string; _organizationId: string; active?: boolean; hmac?: boolean },
  invalidateCache: InvalidateCacheService)
Asignaciones con arrow functions encontradas (posibles funciones):
 - mockSubscriberId('12345';

describe('Session - /inbox/session (POST) #novu-v2', async ())
 - isContextEnabled(process.env.IS_CONTEXT_ENABLED;

  before(async ())
 - subscriberRepository(new SubscriberRepository();
  });

  beforeEach(async ())
 - IS_CONTEXT_ENABLED('true';
  });

  afterEach(())
 - initializeSession(async ({
    applicationIdentifier,
    subscriberId,
    subscriberHash,
    subscriber,
    origin...)
 - request(session.testAgent.post('/v1/inbox/session');

    if (origin) {
      request.set('origin', origin);...)
 - storedSubscriber(await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);
    expect(sto...)
 - updatedStoredSubscriber2(await subscriberRepository.findBySubscriberId(
      session.environment._id,
      subscriberId
   ...)
 - highSeverityNotification(notifications.data.find((n: any))
 - IS_SUBSCRIBERS_SCHEDULE_ENABLED('true';
    });
  });

  it('should create contexts in database and return contextKeys in session', ...)
 - contextKeys(contexts.map((c))
 - contextsAfter(await contextRepository.find({
      _environmentId: session.environment._id,
      _organizationId:...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/e2e/snooze-unsnooze-notification.e2e.ts
TamaÃ±o: 7498 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { MessageRepository, NotificationTemplateEntity, SubscriberEntity, SubscriberRepository } from '@novu/dal';
import { ActorTypeEnum, ChannelTypeEnum, StepTypeEnum, SystemAvatarIconEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Snooze and Unsnooze Notifications - /inbox/notifications/:id/{snooze,unsnooze} (PATCH) #novu-v2', () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity;
  const messageRepository = new MessageRepository();
  const subscriberRepository = new SubscriberRepository();
  let novuClient: Novu;
  let notificationId: string;

  const snoozeNotification = async (id: string, snoozeUntil: Date) => {
    return await session.testAgent
      .patch(`/v1/inbox/notifications/${id}/snooze`)
      .set('Authorization', `Bearer ${session.subscriberToken}`)
      .send({ snoozeUntil });
  };

  const unsnoozeNotification = async (id: string) => {
    return await session.testAgent
      .patch(`/v1/inbox/notifications/${id}/unsnooze`)
      .set('Authorization', `Bearer ${session.subscriberToken}`)
      .send();
  };

  const getNotification = async (id: string) => {
    const response = await session.testAgent
      .get(`/v1/inbox/notifications`)
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    if (response.status !== 200) {
      return response;
    }

    // Find the specific notification in the results
    const notification = response.body.data.find((notif) => notif.id === id);
    if (notification) {
      // Return a response object that mimics a single notification endpoint response
      return {
        status: 200,
        body: notification,
      };
    }

    // Return 404 if notification not found
    return {
      status: 404,
      body: { message: 'Notification not found' },
    };
  };

  // Helper to get notifications with specific filters
  const getNotificationsWithFilter = async (filter: { snoozed?: boolean } = {}) => {
    let url = `/v1/inbox/notifications`;
    const queryParams: string[] = [];

    if (filter.snoozed !== undefined) {
      queryParams.push(`snoozed=${filter.snoozed}`);
    }

    if (queryParams.length > 0) {
      url += `?${queryParams.join('&')}`;
    }

    return await session.testAgent.get(url).set('Authorization', `Bearer ${session.subscriberToken}`);
  };

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    novuClient = initNovuClassSdk(session);

    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test snooze/unsnooze notification',
          actor: {
            type: ActorTypeEnum.SYSTEM_ICON,
            data: SystemAvatarIconEnum.WARNING,
          },
        },
      ],
    });

    // Trigger the notification
    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: { subscriberId: session.subscriberId },
    });

    // Wait for job to complete
    await session.waitForJobCompletion(template._id);

    subscriber = (await subscriberRepository.findBySubscriberId(
      session.environment._id,
      session.subscriberId
    )) as SubscriberEntity;

    // Find the notification
    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      _templateId: template._id,
      channel: ChannelTypeEnum.IN_APP,
    });

    expect(messages.length).to.be.greaterThan(0, 'No notifications found');
    notificationId = messages[0]._id;
  });

  it('should successfully snooze a notification', async () => {
    const snoozeUntil = new Date();
    snoozeUntil.setHours(snoozeUntil.getHours() + 1); // Snooze for 1 hour

    // Call the snooze API
    const snoozeResponse = await snoozeNotification(notificationId, snoozeUntil);
    expect(snoozeResponse.status).to.equal(200);

    // Verify through snoozed filter API that the notification is snoozed
    const snoozedList = await getNotificationsWithFilter({ snoozed: true });
    expect(snoozedList.status).to.equal(200);

    const snoozedNotification = snoozedList.body.data.find((notification) => notification.id === notificationId);
    expect(snoozedNotification).to.not.be.undefined;
    expect(snoozedNotification).to.have.property('snoozedUntil').that.is.not.null;

    // Verify the snooze time is approximately correct
    const responseSnoozedTime = new Date(snoozedNotification.snoozedUntil).getTime();
    const expectedSnoozeTime = snoozeUntil.getTime();
    expect(Math.abs(responseSnoozedTime - expectedSnoozeTime)).to.be.lessThan(5000);
  });

  it('should successfully unsnooze a notification', async () => {
    // First snooze the notification
    const snoozeUntil = new Date();
    snoozeUntil.setHours(snoozeUntil.getHours() + 1); // Snooze for 1 hour

    await snoozeNotification(notificationId, snoozeUntil);

    // Verify it's snoozed via API using the snoozed filter
    const snoozedList = await getNotificationsWithFilter({ snoozed: true });
    expect(snoozedList.status).to.equal(200);
    expect(snoozedList.body.data.some((notification) => notification.id === notificationId)).to.be.true;

    // Now unsnooze it
    const unsnoozeResponse = await unsnoozeNotification(notificationId);
    expect(unsnoozeResponse.status).to.equal(200);

    // Verify the notification has been unsnoozed via API
    const unsnoozedResponse = await getNotification(notificationId);
    expect(unsnoozedResponse.body).to.have.property('isSnoozed').that.equals(false);
  });

  it('should handle attempting to unsnooze a notification that is not snoozed', async () => {
    // Try to unsnooze a notification that hasn't been snoozed
    const response = await unsnoozeNotification(notificationId);

    // Should return a 404 error since the notification is not in a snoozed state
    expect(response.status).to.equal(404);
  });

  it('should reject snooze with invalid date', async () => {
    // Try to snooze with a past date
    const pastDate = new Date();
    pastDate.setHours(pastDate.getHours() - 1); // 1 hour in the past

    const response = await snoozeNotification(notificationId, pastDate);

    // Should be a validation error
    expect(response.status).to.equal(422); // Changed from 400 to 422 for validation errors
  });

  it('should reject snooze with duration exceeding tier limit', async () => {
    // Set a far future date (e.g., 180 days)
    const farFutureDate = new Date();
    farFutureDate.setDate(farFutureDate.getDate() + 180);

    const response = await snoozeNotification(notificationId, farFutureDate);

    expect(response.status).to.equal(402); // Payment Required
  });

  it('should ensure notifications can only be snoozed by their owner', async () => {
    // Create a second user
    const secondSession = new UserSession();
    await secondSession.initialize();

    // Try to access with wrong user's token
    const snoozeUntil = new Date();
    snoozeUntil.setHours(snoozeUntil.getHours() + 1);

    const response = await session.testAgent
      .patch(`/v1/inbox/notifications/${notificationId}/snooze`)
      .set('Authorization', `Bearer ${secondSession.subscriberToken}`)
      .send({ snoozeUntil });

    expect(response.status).to.equal(404);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - snoozeNotification(async (id: string, snoozeUntil: Date))
 - unsnoozeNotification(async (id: string))
 - getNotification(async (id: string))
 - notification(response.body.data.find((notif))
 - notificationId(messages[0]._id;
  });

  it('should successfully snooze a notification', async ())
 - snoozedNotification(snoozedList.body.data.find((notification))
 - expectedSnoozeTime(snoozeUntil.getTime();
    expect(Math.abs(responseSnoozedTime - expectedSnoozeTime)).to.be.lessThan...)
 - snoozedList(await getNotificationsWithFilter({ snoozed: true });
    expect(snoozedList.status).to.equal(200);
 ...)
 - unsnoozedResponse(await getNotification(notificationId);
    expect(unsnoozedResponse.body).to.have.property('isSnooze...)
 - response(await unsnoozeNotification(notificationId);

    // Should return a 404 error since the notification...)
 - response(await snoozeNotification(notificationId, pastDate);

    // Should be a validation error
    expect(...)
 - response(await snoozeNotification(notificationId, farFutureDate);

    expect(response.status).to.equal(402);...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/e2e/update-all-notifications.e2e.ts
TamaÃ±o: 9904 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { MessageRepository, NotificationTemplateEntity, SubscriberEntity, SubscriberRepository } from '@novu/dal';
import {
  ActorTypeEnum,
  ButtonTypeEnum,
  ChannelCTATypeEnum,
  StepTypeEnum,
  SystemAvatarIconEnum,
  TemplateVariableTypeEnum,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Update All Notifications - /inbox/notifications/{read,archive,read-archive} (POST) #novu-v2', async () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity | null;
  const messageRepository = new MessageRepository();
  const subscriberRepository = new SubscriberRepository();
  let novuClient: Novu;
  const updateAllNotifications = async ({
    action,
    tags,
  }: {
    action: 'read' | 'archive' | 'read-archive';
    tags?: string[];
  }) => {
    return await session.testAgent
      .post(`/v1/inbox/notifications/${action}`)
      .set('Authorization', `Bearer ${session.subscriberToken}`)
      .send({ tags });
  };

  const triggerEvent = async (templateToTrigger: NotificationTemplateEntity, times = 1) => {
    const promises: Array<Promise<unknown>> = [];
    for (let i = 0; i < times; i += 1) {
      promises.push(
        novuClient.trigger({
          workflowId: templateToTrigger.triggers[0].identifier,
          to: { subscriberId: session.subscriberId },
        })
      );
    }

    await Promise.all(promises);
    await session.waitForJobCompletion(templateToTrigger._id);
  };

  const removeUndefinedDeep = (obj) => {
    if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) return obj;

    const newObj = {};
    for (const key in obj) {
      if (obj[key] !== undefined) {
        newObj[key] = removeUndefinedDeep(obj[key]);
      }
    }

    return newObj;
  };

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);
    subscriber = await subscriberRepository.findBySubscriberId(session.environment._id, session.subscriberId);
    template = await session.createTemplate({
      noFeedId: true,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test content for <b>{{firstName}}</b>',
          cta: {
            type: ChannelCTATypeEnum.REDIRECT,
            data: {
              url: '',
            },
            action: {
              buttons: [
                { type: ButtonTypeEnum.PRIMARY, content: '' },
                { type: ButtonTypeEnum.SECONDARY, content: '' },
              ],
            },
          },
          variables: [
            {
              defaultValue: '',
              name: 'firstName',
              required: false,
              type: TemplateVariableTypeEnum.STRING,
            },
          ],
          actor: {
            type: ActorTypeEnum.SYSTEM_ICON,
            data: SystemAvatarIconEnum.WARNING,
          },
        },
      ],
    });
    await triggerEvent(template, 3);
  });

  it('should mark all unread notifications as read', async () => {
    const allMessages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: template._id,
    });
    expect(allMessages.length).to.equal(3);
    expect(allMessages.every((el) => !el.read)).to.be.true;

    const { status } = await updateAllNotifications({ action: 'read' });

    const allUpdatedMessages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: template._id,
    });

    expect(status).to.equal(204);
    expect(allUpdatedMessages.length).to.equal(3);
    expect(allUpdatedMessages.every((el) => el.read)).to.be.true;
  });

  it('should mark all unread notifications as read using tags', async () => {
    const tags = ['newsletter'];
    const templateWithTags = await session.createTemplate({
      noFeedId: true,
      tags,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test content for newsletter',
          actor: {
            type: ActorTypeEnum.SYSTEM_ICON,
            data: SystemAvatarIconEnum.WARNING,
          },
        },
      ],
    });
    await triggerEvent(templateWithTags, 4);

    const allMessages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
    });
    expect(allMessages.length).to.equal(7);
    expect(allMessages.every((el) => !el.read)).to.be.true;

    const { status } = await updateAllNotifications({ action: 'read', tags });

    const allUpdatedMessages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
    });

    expect(status).to.equal(204);
    expect(allUpdatedMessages.length).to.equal(7);

    const newsletterMessages = allUpdatedMessages.filter((el) => el.tags?.includes('newsletter'));
    expect(newsletterMessages.length).to.equal(4);
    expect(newsletterMessages.every((el) => el.read)).to.be.true;
  });

  it('should mark all notifications as archived', async () => {
    const allMessages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: template._id,
    });
    expect(allMessages.length).to.equal(3);
    expect(allMessages.every((el) => !el.read)).to.be.true;

    const { status } = await updateAllNotifications({ action: 'archive' });

    const allUpdatedMessages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: template._id,
    });

    expect(status).to.equal(204);
    expect(allUpdatedMessages.length).to.equal(3);
    expect(allUpdatedMessages.every((el) => el.archived)).to.be.true;
  });

  it('should mark all notifications as archived using tags', async () => {
    const tags = ['newsletter'];
    const templateWithTags = await session.createTemplate({
      noFeedId: true,
      tags,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test content for newsletter',
          actor: {
            type: ActorTypeEnum.SYSTEM_ICON,
            data: SystemAvatarIconEnum.WARNING,
          },
        },
      ],
    });
    await triggerEvent(templateWithTags, 4);

    const allMessages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
    });
    expect(allMessages.length).to.equal(7);
    expect(allMessages.every((el) => !el.read)).to.be.true;

    const { status } = await updateAllNotifications({ action: 'archive', tags });

    const allUpdatedMessages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
    });

    expect(status).to.equal(204);
    expect(allUpdatedMessages.length).to.equal(7);

    const newsletterMessages = allUpdatedMessages.filter((el) => el.tags?.includes('newsletter'));
    expect(newsletterMessages.length).to.equal(4);
    expect(newsletterMessages.every((el) => el.archived)).to.be.true;
  });

  it('should mark all read notifications as archived', async () => {
    const allMessages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: template._id,
    });
    expect(allMessages.length).to.equal(3);
    expect(allMessages.every((el) => !el.read)).to.be.true;

    await messageRepository.update(
      {
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id ?? '',
        _templateId: template._id,
      },
      { $set: { read: true } }
    );

    const { status } = await updateAllNotifications({ action: 'read-archive' });

    const allUpdatedMessages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: template._id,
    });

    expect(status).to.equal(204);
    expect(allUpdatedMessages.length).to.equal(3);
    expect(allUpdatedMessages.every((el) => el.archived)).to.be.true;
  });

  it('should mark all read notifications as archived using tags', async () => {
    const tags = ['newsletter'];
    const templateWithTags = await session.createTemplate({
      noFeedId: true,
      tags,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test content for newsletter',
          actor: {
            type: ActorTypeEnum.SYSTEM_ICON,
            data: SystemAvatarIconEnum.WARNING,
          },
        },
      ],
    });
    await triggerEvent(templateWithTags, 4);
    await messageRepository.update(
      {
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id ?? '',
        _templateId: templateWithTags._id,
      },
      { $set: { read: true } }
    );

    const allMessages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
    });
    expect(allMessages.length).to.equal(7);

    const { status } = await updateAllNotifications({ action: 'read-archive', tags });

    const allUpdatedMessages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
    });

    expect(status).to.equal(204);
    expect(allUpdatedMessages.length).to.equal(7);

    const newsletterMessages = allUpdatedMessages.filter((el) => el.tags?.includes('newsletter'));
    expect(newsletterMessages.length).to.equal(4);
    expect(newsletterMessages.every((el) => el.archived)).to.be.true;
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - updateAllNotifications(async ({
    action,
    tags,
  }: {
    action: 'read' | 'archive' | 'read-archive';
    tags?: st...)
 - times(1))
 - removeUndefinedDeep(obj))
 - template(await session.createTemplate({
      noFeedId: true,
      steps: [
        {
          type: StepTy...)
 - allMessages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - allUpdatedMessages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - allMessages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - newsletterMessages(allUpdatedMessages.filter((el))
 - allMessages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - allUpdatedMessages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - allMessages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - newsletterMessages(allUpdatedMessages.filter((el))
 - allMessages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - allUpdatedMessages(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - newsletterMessages(allUpdatedMessages.filter((el))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/e2e/update-notification-action.e2e.ts
TamaÃ±o: 7514 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import {
  MessageEntity,
  MessageRepository,
  NotificationTemplateEntity,
  SubscriberEntity,
  SubscriberRepository,
} from '@novu/dal';
import {
  ActorTypeEnum,
  ButtonTypeEnum,
  ChannelCTATypeEnum,
  StepTypeEnum,
  SystemAvatarIconEnum,
  TemplateVariableTypeEnum,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';
import { mapToDto } from '../utils/notification-mapper';

describe('Update Notification Action - /inbox/notifications/:id/{complete/revert} (PATCH) #novu-v2', async () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity | null;
  let message: MessageEntity;
  const messageRepository = new MessageRepository();
  const subscriberRepository = new SubscriberRepository();
  let novuClient: Novu;
  const updateNotificationAction = async ({
    id,
    action,
    actionType,
  }: {
    id: string;
    action: 'complete' | 'revert';
    actionType: ButtonTypeEnum;
  }) => {
    return await session.testAgent
      .patch(`/v1/inbox/notifications/${id}/${action}`)
      .set('Authorization', `Bearer ${session.subscriberToken}`)
      .send({ actionType });
  };

  const triggerEvent = async (templateToTrigger: NotificationTemplateEntity, times = 1) => {
    const promises: Array<Promise<unknown>> = [];
    for (let i = 0; i < times; i += 1) {
      promises.push(
        novuClient.trigger({
          workflowId: templateToTrigger.triggers[0].identifier,
          to: { subscriberId: session.subscriberId },
        })
      );
    }

    await Promise.all(promises);
    await session.waitForJobCompletion(templateToTrigger._id);
  };

  const removeUndefinedDeep = (obj) => {
    if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) return obj;

    const newObj = {};
    for (const key in obj) {
      if (obj[key] !== undefined) {
        newObj[key] = removeUndefinedDeep(obj[key]);
      }
    }

    return newObj;
  };

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);
    subscriber = await subscriberRepository.findBySubscriberId(session.environment._id, session.subscriberId);
    template = await session.createTemplate({
      noFeedId: true,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test content for <b>{{firstName}}</b>',
          cta: {
            type: ChannelCTATypeEnum.REDIRECT,
            data: {
              url: '',
            },
            action: {
              buttons: [
                { type: ButtonTypeEnum.PRIMARY, content: '' },
                { type: ButtonTypeEnum.SECONDARY, content: '' },
              ],
            },
          },
          variables: [
            {
              defaultValue: '',
              name: 'firstName',
              required: false,
              type: TemplateVariableTypeEnum.STRING,
            },
          ],
          actor: {
            type: ActorTypeEnum.SYSTEM_ICON,
            data: SystemAvatarIconEnum.WARNING,
          },
        },
      ],
    });
    await triggerEvent(template);
    message = (await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: template._id,
    })) as MessageEntity;
  });

  it('should throw bad request error when the notification id is not mongo id', async () => {
    const id = 'fake';
    const { body, status } = await updateNotificationAction({
      id,
      action: 'complete',
      actionType: ButtonTypeEnum.PRIMARY,
    });

    expect(status).to.equal(422);
    expect(body.statusCode).to.equal(422);
    expect(body.errors.notificationId.messages[0]).to.equal(`notificationId must be a mongodb id`);
  });

  it("should throw not found error when the message doesn't exist", async () => {
    const id = '666c0dfa0b55d0f06f4aaa6c';
    const { body, status } = await updateNotificationAction({
      id,
      action: 'complete',
      actionType: ButtonTypeEnum.PRIMARY,
    });

    expect(status).to.equal(404);
    expect(body.message).to.equal(`Notification with id: ${id} is not found.`);
  });

  it('should throw bad request error when the action cannot be performed on the primary button', async () => {
    const templateNoButtons = await session.createTemplate({
      noFeedId: true,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test No Buttons',
        },
      ],
    });
    await triggerEvent(templateNoButtons);
    const newMessage = (await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: templateNoButtons._id,
    })) as MessageEntity;

    const { body, status } = await updateNotificationAction({
      id: newMessage._id,
      action: 'complete',
      actionType: ButtonTypeEnum.PRIMARY,
    });

    expect(status).to.equal(400);
    expect(body.message).to.equal(`Could not perform action on the primary button because it does not exist.`);
  });

  it('should throw bad request error when the action cannot be performed on the secondary button', async () => {
    const templateNoButtons = await session.createTemplate({
      noFeedId: true,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test No Buttons',
        },
      ],
    });
    await triggerEvent(templateNoButtons);
    const newMessage = (await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: templateNoButtons._id,
    })) as MessageEntity;

    const { body, status } = await updateNotificationAction({
      id: newMessage._id,
      action: 'complete',
      actionType: ButtonTypeEnum.SECONDARY,
    });

    expect(status).to.equal(400);
    expect(body.message).to.equal(`Could not perform action on the secondary button because it does not exist.`);
  });

  it('should update the primary action status', async () => {
    const { body, status } = await updateNotificationAction({
      id: message._id,
      action: 'complete',
      actionType: ButtonTypeEnum.PRIMARY,
    });
    const updatedMessage = (await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: template._id,
    })) as MessageEntity;

    expect(status).to.equal(200);
    expect(body.data).to.deep.equal(removeUndefinedDeep(mapToDto(updatedMessage)));
    expect(body.data.primaryAction.isCompleted).to.be.true;
    expect(body.data.secondaryAction.isCompleted).to.be.false;
  });

  it('should update the secondary action status', async () => {
    const { body, status } = await updateNotificationAction({
      id: message._id,
      action: 'complete',
      actionType: ButtonTypeEnum.SECONDARY,
    });
    const updatedMessage = (await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id ?? '',
      _templateId: template._id,
    })) as MessageEntity;

    expect(status).to.equal(200);
    expect(body.data).to.deep.equal(removeUndefinedDeep(mapToDto(updatedMessage)));
    expect(body.data.primaryAction.isCompleted).to.be.false;
    expect(body.data.secondaryAction.isCompleted).to.be.true;
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - updateNotificationAction(async ({
    id,
    action,
    actionType,
  }: {
    id: string;
    action: 'complete' | 'revert...)
 - times(1))
 - removeUndefinedDeep(obj))
 - message(await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId...)
 - updatedMessage(await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/e2e/update-preferences.e2e.ts
TamaÃ±o: 21251 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailBlockTypeEnum, PreferenceLevelEnum, StepTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Update global preferences - /inbox/preferences (PATCH) #novu-v2', () => {
  let session: UserSession;
  const isSubscribersScheduleEnabled = process.env.IS_SUBSCRIBERS_SCHEDULE_ENABLED;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    // @ts-expect-error
    process.env.IS_SUBSCRIBERS_SCHEDULE_ENABLED = 'true';
  });

  afterEach(() => {
    // @ts-expect-error
    process.env.IS_SUBSCRIBERS_SCHEDULE_ENABLED = isSubscribersScheduleEnabled;
  });

  it('should throw error when made unauthorized call', async () => {
    const response = await session.testAgent
      .patch(`/v1/inbox/preferences`)
      .send({
        email: true,
        in_app: true,
        sms: false,
        push: false,
        chat: true,
      })
      .set('Authorization', `Bearer InvalidToken`);

    expect(response.status).to.equal(401);
  });

  it('should update global preferences', async () => {
    const response = await session.testAgent
      .patch('/v1/inbox/preferences')
      .send({
        email: true,
        in_app: true,
        sms: false,
        push: false,
        chat: true,
      })
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    expect(response.status).to.equal(200);
    expect(response.body.data.channels.email).to.equal(undefined);
    expect(response.body.data.channels.in_app).to.equal(undefined);
    expect(response.body.data.channels.sms).to.equal(undefined);
    expect(response.body.data.channels.push).to.equal(undefined);
    expect(response.body.data.channels.chat).to.equal(undefined);
    expect(response.body.data.level).to.equal(PreferenceLevelEnum.GLOBAL);
  });

  it('should update the particular channel sent in the body and return only active channels', async () => {
    await session.createTemplate({
      noFeedId: true,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test notification content',
        },
      ],
    });

    const response = await session.testAgent
      .patch('/v1/inbox/preferences')
      .send({
        in_app: true,
      })
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    expect(response.status).to.equal(200);
    expect(response.body.data.channels.email).to.equal(undefined);
    expect(response.body.data.channels.in_app).to.equal(true);
    expect(response.body.data.channels.sms).to.equal(undefined);
    expect(response.body.data.channels.push).to.equal(undefined);
    expect(response.body.data.channels.chat).to.equal(undefined);
    expect(response.body.data.level).to.equal(PreferenceLevelEnum.GLOBAL);

    const responseSecond = await session.testAgent
      .patch('/v1/inbox/preferences')
      .send({
        in_app: true,
      })
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    expect(responseSecond.status).to.equal(200);
    expect(responseSecond.body.data.channels.email).to.equal(undefined);
    expect(responseSecond.body.data.channels.in_app).to.equal(true);
    expect(responseSecond.body.data.channels.sms).to.equal(undefined);
    expect(responseSecond.body.data.channels.push).to.equal(undefined);
    expect(responseSecond.body.data.channels.chat).to.equal(undefined);
    expect(responseSecond.body.data.level).to.equal(PreferenceLevelEnum.GLOBAL);
  });

  describe('schedule functionality', () => {
    it('should update global preferences with schedule', async () => {
      const schedule = {
        isEnabled: true,
        weeklySchedule: {
          monday: {
            isEnabled: true,
            hours: [{ start: '09:00 AM', end: '05:00 PM' }],
          },
          tuesday: {
            isEnabled: true,
            hours: [{ start: '09:00 AM', end: '05:00 PM' }],
          },
          wednesday: {
            isEnabled: true,
            hours: [{ start: '09:00 AM', end: '05:00 PM' }],
          },
          thursday: {
            isEnabled: true,
            hours: [{ start: '09:00 AM', end: '05:00 PM' }],
          },
          friday: {
            isEnabled: true,
            hours: [{ start: '09:00 AM', end: '05:00 PM' }],
          },
        },
      };

      const response = await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          email: true,
          in_app: true,
          schedule,
        })
        .set('Authorization', `Bearer ${session.subscriberToken}`);

      expect(response.status).to.equal(200);
      expect(response.body.data.schedule).to.exist;
      expect(response.body.data.schedule.isEnabled).to.equal(true);
      expect(response.body.data.schedule.weeklySchedule).to.exist;
      expect(response.body.data.schedule.weeklySchedule.monday.isEnabled).to.equal(true);
      expect(response.body.data.schedule.weeklySchedule.monday.hours[0].start).to.equal('09:00 AM');
      expect(response.body.data.schedule.weeklySchedule.monday.hours[0].end).to.equal('05:00 PM');
      expect(response.body.data.schedule.weeklySchedule.tuesday.isEnabled).to.equal(true);
      expect(response.body.data.schedule.weeklySchedule.tuesday.hours[0].start).to.equal('09:00 AM');
      expect(response.body.data.schedule.weeklySchedule.tuesday.hours[0].end).to.equal('05:00 PM');
      expect(response.body.data.level).to.equal(PreferenceLevelEnum.GLOBAL);
    });

    it('should update schedule with disabled state', async () => {
      const schedule = {
        isEnabled: false,
      };

      const response = await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          schedule,
        })
        .set('Authorization', `Bearer ${session.subscriberToken}`);

      expect(response.status).to.equal(200);
      expect(response.body.data.schedule).to.exist;
      expect(response.body.data.schedule.isEnabled).to.equal(false);
      expect(response.body.data.schedule.weeklySchedule).to.not.exist;
    });

    it('should update schedule with multiple time ranges', async () => {
      const schedule = {
        isEnabled: true,
        weeklySchedule: {
          monday: {
            isEnabled: true,
            hours: [
              { start: '09:00 AM', end: '12:00 PM' },
              { start: '01:00 PM', end: '05:00 PM' },
            ],
          },
        },
      };

      const response = await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          schedule,
        })
        .set('Authorization', `Bearer ${session.subscriberToken}`);

      expect(response.status).to.equal(200);
      expect(response.body.data.schedule).to.exist;
      expect(response.body.data.schedule.weeklySchedule.monday.hours).to.have.length(2);
      expect(response.body.data.schedule.weeklySchedule.monday.hours[0].start).to.equal('09:00 AM');
      expect(response.body.data.schedule.weeklySchedule.monday.hours[0].end).to.equal('12:00 PM');
      expect(response.body.data.schedule.weeklySchedule.monday.hours[1].start).to.equal('01:00 PM');
      expect(response.body.data.schedule.weeklySchedule.monday.hours[1].end).to.equal('05:00 PM');
    });

    it('should fail validation when isEnabled is true but weeklySchedule is empty', async () => {
      const schedule = {
        isEnabled: true,
        weeklySchedule: {},
      };

      const response = await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          schedule,
        })
        .set('Authorization', `Bearer ${session.subscriberToken}`);

      expect(response.status).to.equal(422);
      expect(response.body.message).to.equal('Validation Error');
      expect(response.body.errors.general.messages).to.be.an('array');
      expect(response.body.errors.general.messages[0]).to.contain(
        'weeklySchedule must contain at least one day configuration when isEnabled is true'
      );
    });

    it('should fail validation with invalid time format', async () => {
      const schedule = {
        isEnabled: true,
        weeklySchedule: {
          monday: {
            isEnabled: true,
            hours: [{ start: '25:00', end: '17:00' }], // Invalid 24-hour format
          },
        },
      };

      const response = await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          schedule,
        })
        .set('Authorization', `Bearer ${session.subscriberToken}`);

      expect(response.status).to.equal(422);
      expect(response.body.message).to.equal('Validation Error');
      expect(response.body.errors.general.messages).to.be.an('array');
      expect(response.body.errors.general.messages.some((msg: string) => msg.includes('must be in 12-hour format'))).to
        .be.true;
    });

    it('should fail validation with invalid day name', async () => {
      const schedule = {
        isEnabled: true,
        weeklySchedule: {
          invalidDay: {
            isEnabled: true,
            hours: [{ start: '09:00 AM', end: '05:00 PM' }],
          },
        },
      };

      const response = await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          schedule,
        })
        .set('Authorization', `Bearer ${session.subscriberToken}`);

      expect(response.status).to.equal(422);
      expect(response.body.message).to.equal('Validation Error');
      expect(response.body.errors.general.messages).to.be.an('array');
      expect(response.body.errors.general.messages[0]).to.contain('weeklySchedule contains invalid day names');
    });

    it('should handle schedule with isEnabled true but no weeklySchedule', async () => {
      const schedule = {
        isEnabled: true,
      };

      const response = await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          schedule,
        })
        .set('Authorization', `Bearer ${session.subscriberToken}`);

      expect(response.status).to.equal(200);
      expect(response.body.data.schedule).to.exist;
      expect(response.body.data.schedule.isEnabled).to.equal(true);
      expect(response.body.data.schedule.weeklySchedule).to.not.exist;
    });

    it('should update existing schedule', async () => {
      // First, set a schedule
      const initialSchedule = {
        isEnabled: true,
        weeklySchedule: {
          monday: {
            isEnabled: true,
            hours: [{ start: '09:00 AM', end: '05:00 PM' }],
          },
        },
      };

      await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          schedule: initialSchedule,
        })
        .set('Authorization', `Bearer ${session.subscriberToken}`);

      // Then update it
      const updatedSchedule = {
        isEnabled: true,
        weeklySchedule: {
          tuesday: {
            isEnabled: true,
            hours: [{ start: '10:00 AM', end: '06:00 PM' }],
          },
          wednesday: {
            isEnabled: true,
            hours: [{ start: '08:00 AM', end: '04:00 PM' }],
          },
        },
      };

      const response = await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          schedule: updatedSchedule,
        })
        .set('Authorization', `Bearer ${session.subscriberToken}`);

      expect(response.status).to.equal(200);
      expect(response.body.data.schedule.weeklySchedule.monday).to.not.exist;
      expect(response.body.data.schedule.weeklySchedule.tuesday).to.exist;
      expect(response.body.data.schedule.weeklySchedule.tuesday.hours[0].start).to.equal('10:00 AM');
      expect(response.body.data.schedule.weeklySchedule.wednesday).to.exist;
      expect(response.body.data.schedule.weeklySchedule.wednesday.hours[0].start).to.equal('08:00 AM');
    });

    it('should handle schedule update with channels update', async () => {
      const schedule = {
        isEnabled: true,
        weeklySchedule: {
          monday: {
            isEnabled: true,
            hours: [{ start: '09:00 AM', end: '05:00 PM' }],
          },
        },
      };

      const response = await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          email: false,
          in_app: true,
          schedule,
        })
        .set('Authorization', `Bearer ${session.subscriberToken}`);

      expect(response.status).to.equal(200);
      expect(response.body.data.channels.email).to.equal(undefined);
      expect(response.body.data.channels.in_app).to.equal(undefined);
      expect(response.body.data.schedule).to.exist;
      expect(response.body.data.schedule.isEnabled).to.equal(true);
      expect(response.body.data.schedule.weeklySchedule.monday).to.exist;
    });
  });
});

describe('Update workflow preferences - /inbox/preferences/:workflowId (PATCH)', () => {
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should throw error when made unauthorized call', async () => {
    const workflow = await session.createTemplate({
      noFeedId: true,
    });

    const response = await session.testAgent
      .patch(`/v1/inbox/preferences/${workflow._id}`)
      .send({
        email: true,
        in_app: true,
        sms: false,
        push: false,
        chat: true,
      })
      .set('Authorization', `Bearer InvalidToken`);

    expect(response.status).to.equal(401);
  });

  it('should throw error when non-mongo id is passed', async () => {
    const id = '1234';
    const response = await session.testAgent
      .patch(`/v1/inbox/preferences/${id}`)
      .send({
        email: true,
        in_app: true,
        sms: false,
        push: false,
        chat: true,
      })
      .set('Authorization', `Bearer ${session.subscriberToken}`);
    expect(response.body.statusCode).to.equal(422);
    expect(response.body.errors.workflowId.messages[0]).to.equal(`workflowId must be a mongodb id`);
    expect(response.status).to.equal(422);
  });

  it('should throw error when non-existing workflow id is passed', async () => {
    const id = '666c0dfa0b55d0f06f4aaa6c';
    const response = await session.testAgent
      .patch(`/v1/inbox/preferences/${id}`)
      .send({
        email: true,
        in_app: true,
        sms: false,
        push: false,
        chat: true,
      })
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    expect(response.body.message).to.equal(`Workflow with id: ${id} is not found`);
    expect(response.status).to.equal(404);
  });

  it('should throw error when tried to update a critical workflow', async () => {
    const workflow = await session.createTemplate({
      noFeedId: true,
      critical: true,
    });

    const response = await session.testAgent
      .patch(`/v1/inbox/preferences/${workflow._id}`)
      .send({
        email: true,
        in_app: true,
        sms: false,
        push: false,
        chat: true,
      })
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    expect(response.body.message).to.equal(`Critical workflow with id: ${workflow._id} can not be updated`);
    expect(response.status).to.equal(400);
  });

  it('should update workflow preferences', async () => {
    const workflow = await session.createTemplate({
      noFeedId: true,
    });

    const response = await session.testAgent
      .patch(`/v1/inbox/preferences/${workflow._id}`)
      .send({
        email: true,
        in_app: false,
        sms: false,
        push: false,
        chat: true,
      })
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    expect(response.status).to.equal(200);
    expect(Object.keys(response.body.data.channels).length).to.equal(2);
    expect(response.body.data.channels.email).to.equal(true);
    expect(response.body.data.channels.in_app).to.equal(false);
    expect(response.body.data.level).to.equal(PreferenceLevelEnum.TEMPLATE);
  });

  it('should update the particular channel sent in the body and return all channels', async () => {
    const workflow = await session.createTemplate({
      noFeedId: true,
      steps: [
        {
          type: StepTypeEnum.SMS,
          content: 'Welcome to {{organizationName}}' as string,
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'Hello {{subscriber.lastName}}, Welcome to {{organizationName}}' as string,
        },
        {
          type: StepTypeEnum.EMAIL,
          content: [
            {
              type: EmailBlockTypeEnum.TEXT,
              content: 'Hello {{subscriber.lastName}}, Welcome to {{organizationName}}' as string,
            },
          ],
        },
        {
          type: StepTypeEnum.CHAT,
          content: 'Hello {{subscriber.lastName}}, Welcome to {{organizationName}}' as string,
        },
        {
          type: StepTypeEnum.PUSH,
          content: 'Hello {{subscriber.lastName}}, Welcome to {{organizationName}}' as string,
        },
      ],
    });

    const response = await session.testAgent
      .patch(`/v1/inbox/preferences/${workflow._id}`)
      .send({
        email: true,
        in_app: true,
        sms: false,
        push: false,
        chat: true,
      })
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    expect(response.status).to.equal(200);
    expect(response.body.data.channels.email).to.equal(true);
    expect(response.body.data.channels.in_app).to.equal(true);
    expect(response.body.data.channels.sms).to.equal(false);
    expect(response.body.data.channels.push).to.equal(false);
    expect(response.body.data.channels.chat).to.equal(true);
    expect(response.body.data.level).to.equal(PreferenceLevelEnum.TEMPLATE);

    const responseSecond = await session.testAgent
      .patch(`/v1/inbox/preferences/${workflow._id}`)
      .send({
        email: false,
        in_app: true,
      })
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    expect(responseSecond.status).to.equal(200);
    expect(responseSecond.body.data.channels.email).to.equal(false);
    expect(responseSecond.body.data.channels.in_app).to.equal(true);
    expect(responseSecond.body.data.channels.sms).to.equal(false);
    expect(responseSecond.body.data.channels.push).to.equal(false);
    expect(responseSecond.body.data.channels.chat).to.equal(true);
    expect(responseSecond.body.data.level).to.equal(PreferenceLevelEnum.TEMPLATE);
  });

  it('should unset the suscribers workflow preference for the specified channels when the global preference is updated', async () => {
    const workflow = await session.createTemplate({
      noFeedId: true,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test notification content',
        },
        {
          type: StepTypeEnum.EMAIL,
          content: 'Test notification content',
        },
      ],
    });

    const updateWorkflowPrefResponse = await session.testAgent
      .patch(`/v1/inbox/preferences/${workflow._id}`)
      .send({
        email: false,
        in_app: false,
      })
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    expect(updateWorkflowPrefResponse.status).to.equal(200);
    expect(updateWorkflowPrefResponse.body.data.channels.email).to.equal(false);
    expect(updateWorkflowPrefResponse.body.data.channels.in_app).to.equal(false);
    expect(updateWorkflowPrefResponse.body.data.channels.sms).to.equal(undefined);
    expect(updateWorkflowPrefResponse.body.data.channels.push).to.equal(undefined);
    expect(updateWorkflowPrefResponse.body.data.channels.chat).to.equal(undefined);
    expect(updateWorkflowPrefResponse.body.data.level).to.equal(PreferenceLevelEnum.TEMPLATE);

    const updateGlobalPrefResponse = await session.testAgent
      .patch(`/v1/inbox/preferences`)
      .send({
        email: true,
      })
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    expect(updateGlobalPrefResponse.status).to.equal(200);
    expect(updateGlobalPrefResponse.body.data.channels.email).to.equal(true);
    expect(updateGlobalPrefResponse.body.data.channels.in_app).to.equal(true);
    expect(updateGlobalPrefResponse.body.data.channels.sms).to.equal(undefined);
    expect(updateGlobalPrefResponse.body.data.channels.push).to.equal(undefined);
    expect(updateGlobalPrefResponse.body.data.channels.chat).to.equal(undefined);
    expect(updateGlobalPrefResponse.body.data.level).to.equal(PreferenceLevelEnum.GLOBAL);

    const getInboxPrefResponse = await session.testAgent
      .get(`/v1/inbox/preferences`)
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    const workflowPref = getInboxPrefResponse.body.data.find(
      (pref) => pref.level === PreferenceLevelEnum.TEMPLATE && pref.workflow.id === workflow._id
    );

    expect(getInboxPrefResponse.status).to.equal(200);
    expect(workflowPref.channels.email).to.equal(true);
    expect(workflowPref.channels.in_app).to.equal(false);
    expect(workflowPref.channels.sms).to.equal(undefined);
    expect(workflowPref.channels.push).to.equal(undefined);
    expect(workflowPref.channels.chat).to.equal(undefined);
    expect(workflowPref.level).to.equal(PreferenceLevelEnum.TEMPLATE);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - isSubscribersScheduleEnabled(process.env.IS_SUBSCRIBERS_SCHEDULE_ENABLED;

  beforeEach(async ())
 - IS_SUBSCRIBERS_SCHEDULE_ENABLED('true';
  });

  afterEach(())
 - IS_SUBSCRIBERS_SCHEDULE_ENABLED(isSubscribersScheduleEnabled;
  });

  it('should throw error when made unauthorized call', async ())
 - response(await session.testAgent
      .patch(`/v1/inbox/preferences`)
      .send({
        email: true,
   ...)
 - response(await session.testAgent
      .patch('/v1/inbox/preferences')
      .send({
        email: true,
   ...)
 - responseSecond(await session.testAgent
      .patch('/v1/inbox/preferences')
      .send({
        in_app: true,
  ...)
 - response(await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          email: tru...)
 - response(await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          schedule,
...)
 - response(await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          schedule,
...)
 - response(await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          schedule,
...)
 - response(await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          schedule,
...)
 - response(await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          schedule,
...)
 - response(await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          schedule,
...)
 - response(await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          schedule: ...)
 - response(await session.testAgent
        .patch('/v1/inbox/preferences')
        .send({
          email: fal...)
 - session(new UserSession();
    await session.initialize();
  });

  it('should throw error when made unautho...)
 - response(await session.testAgent
      .patch(`/v1/inbox/preferences/${workflow._id}`)
      .send({
        ...)
 - response(await session.testAgent
      .patch(`/v1/inbox/preferences/${id}`)
      .send({
        email: tru...)
 - response(await session.testAgent
      .patch(`/v1/inbox/preferences/${id}`)
      .send({
        email: tru...)
 - response(await session.testAgent
      .patch(`/v1/inbox/preferences/${workflow._id}`)
      .send({
        ...)
 - response(await session.testAgent
      .patch(`/v1/inbox/preferences/${workflow._id}`)
      .send({
        ...)
 - responseSecond(await session.testAgent
      .patch(`/v1/inbox/preferences/${workflow._id}`)
      .send({
        ...)
 - workflowPref(getInboxPrefResponse.body.data.find(
      (pref))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/index.ts
TamaÃ±o: 2884 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  GetSubscriberSchedule,
  GetSubscriberTemplatePreference,
  GetWorkflowByIdsUseCase,
  MessageInteractionService,
  StorageHelperService,
  UpsertControlValuesUseCase,
  WorkflowRunService,
} from '@novu/application-generic';
import { CommunityUserRepository } from '@novu/dal';
import { GenerateUniqueApiKey } from '../../environments-v1/usecases/generate-unique-api-key/generate-unique-api-key.usecase';
import { ParseEventRequest } from '../../events/usecases/parse-event-request';
import { VerifyPayload } from '../../events/usecases/verify-payload';
import { GetSubscriberGlobalPreference } from '../../subscribers/usecases/get-subscriber-global-preference';
import { BulkUpdatePreferences } from './bulk-update-preferences/bulk-update-preferences.usecase';
import { DeleteAllNotifications } from './delete-all-notifications/delete-all-notifications.usecase';
import { DeleteManyNotifications } from './delete-many-notifications/delete-many-notifications.usecase';
import { DeleteNotification } from './delete-notification/delete-notification.usecase';
import { GetInboxPreferences } from './get-inbox-preferences/get-inbox-preferences.usecase';
import { GetNotifications } from './get-notifications/get-notifications.usecase';
import { MarkManyNotificationsAs } from './mark-many-notifications-as/mark-many-notifications-as.usecase';
import { MarkNotificationAs } from './mark-notification-as/mark-notification-as.usecase';
import { MarkNotificationsAsSeen } from './mark-notifications-as-seen/mark-notifications-as-seen.usecase';
import { NotificationsCount } from './notifications-count/notifications-count.usecase';
import { Session } from './session/session.usecase';
import { SnoozeNotification } from './snooze-notification/snooze-notification.usecase';
import { UnsnoozeNotification } from './unsnooze-notification/unsnooze-notification.usecase';
import { UpdateAllNotifications } from './update-all-notifications/update-all-notifications.usecase';
import { UpdateNotificationAction } from './update-notification-action/update-notification-action.usecase';
import { UpdatePreferences } from './update-preferences/update-preferences.usecase';

export const USE_CASES = [
  Session,
  NotificationsCount,
  GetNotifications,
  MarkManyNotificationsAs,
  MarkNotificationAs,
  MarkNotificationsAsSeen,
  UpdateNotificationAction,
  UpdateAllNotifications,
  GetInboxPreferences,
  GetSubscriberGlobalPreference,
  GetSubscriberTemplatePreference,
  GetWorkflowByIdsUseCase,
  UpdatePreferences,
  BulkUpdatePreferences,
  SnoozeNotification,
  UnsnoozeNotification,
  DeleteNotification,
  DeleteManyNotifications,
  DeleteAllNotifications,
  GenerateUniqueApiKey,
  CommunityUserRepository,
  UpsertControlValuesUseCase,
  ParseEventRequest,
  VerifyPayload,
  StorageHelperService,
  MessageInteractionService,
  WorkflowRunService,
  GetSubscriberSchedule,
];


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/noop-send-webhook-message.usecase.ts
TamaÃ±o: 294 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { SendWebhookMessageCommand } from '@novu/application-generic';

@Injectable()
export class NoopSendWebhookMessage {
  async execute(_command: SendWebhookMessageCommand): Promise<{ eventId: string } | undefined> {
    return undefined;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class NoopSendWebhookMessage

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/bulk-update-preferences/bulk-update-preferences.command.ts
TamaÃ±o: 579 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

// apps/api/src/app/inbox/usecases/bulk-update-preferences/bulk-update-preferences.command.ts

import { Type } from 'class-transformer';
import { IsArray, IsDefined } from 'class-validator';

import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';
import { BulkUpdatePreferenceItemDto } from '../../dtos/bulk-update-preferences-request.dto';

export class BulkUpdatePreferencesCommand extends EnvironmentWithSubscriber {
  @IsDefined()
  @IsArray()
  @Type(() => BulkUpdatePreferenceItemDto)
  readonly preferences: BulkUpdatePreferenceItemDto[];
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class BulkUpdatePreferencesCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/bulk-update-preferences/bulk-update-preferences.spec.ts
TamaÃ±o: 14340 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, NotFoundException, UnprocessableEntityException } from '@nestjs/common';
import { AnalyticsService } from '@novu/application-generic';
import { EnvironmentRepository, NotificationTemplateRepository, SubscriberRepository } from '@novu/dal';
import { PreferenceLevelEnum, TriggerTypeEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { UpdatePreferences } from '../update-preferences/update-preferences.usecase';
import { BulkUpdatePreferencesCommand } from './bulk-update-preferences.command';
import { BulkUpdatePreferences } from './bulk-update-preferences.usecase';

const mockedSubscriber: any = {
  _id: '6447aff3d89122e250412c29',
  subscriberId: 'test-mockSubscriber',
  firstName: 'test',
  lastName: 'test',
};

const mockedWorkflow1: any = {
  _id: '6447aff3d89122e250412c28',
  name: 'test-workflow-1',
  critical: false,
  triggers: [{ identifier: 'test-trigger-1' }],
  tags: [],
  data: undefined,
};

const mockedWorkflow2: any = {
  _id: '6447aff3d89122e250412c30',
  name: 'test-workflow-2',
  critical: false,
  triggers: [{ identifier: 'test-trigger-2' }],
  tags: [],
  data: undefined,
};

const mockedInboxPreference1: any = {
  level: PreferenceLevelEnum.TEMPLATE,
  enabled: true,
  channels: {
    email: true,
    in_app: true,
    sms: false,
    push: false,
    chat: true,
  },
  workflow: {
    id: mockedWorkflow1._id,
    identifier: mockedWorkflow1.triggers[0].identifier,
    name: mockedWorkflow1.name,
    critical: mockedWorkflow1.critical,
    tags: mockedWorkflow1.tags,
    data: mockedWorkflow1.data,
  },
};

const mockedInboxPreference2: any = {
  level: PreferenceLevelEnum.TEMPLATE,
  enabled: true,
  channels: {
    email: false,
    in_app: true,
    sms: true,
    push: false,
    chat: true,
  },
  workflow: {
    id: mockedWorkflow2._id,
    identifier: mockedWorkflow2.triggers[0].identifier,
    name: mockedWorkflow2.name,
    critical: mockedWorkflow2.critical,
    tags: mockedWorkflow2.tags,
    data: mockedWorkflow2.data,
  },
};

describe('BulkUpdatePreferences', () => {
  let bulkUpdatePreferences: BulkUpdatePreferences;
  let subscriberRepositoryMock: sinon.SinonStubbedInstance<SubscriberRepository>;
  let analyticsServiceMock: sinon.SinonStubbedInstance<AnalyticsService>;
  let notificationTemplateRepositoryMock: sinon.SinonStubbedInstance<NotificationTemplateRepository>;
  let updatePreferencesUsecaseMock: sinon.SinonStubbedInstance<UpdatePreferences>;
  let environmentRepositoryMock: sinon.SinonStubbedInstance<EnvironmentRepository>;
  beforeEach(() => {
    subscriberRepositoryMock = sinon.createStubInstance(SubscriberRepository);
    analyticsServiceMock = sinon.createStubInstance(AnalyticsService);
    notificationTemplateRepositoryMock = sinon.createStubInstance(NotificationTemplateRepository);
    updatePreferencesUsecaseMock = sinon.createStubInstance(UpdatePreferences);
    environmentRepositoryMock = sinon.createStubInstance(EnvironmentRepository);
    bulkUpdatePreferences = new BulkUpdatePreferences(
      notificationTemplateRepositoryMock as any,
      subscriberRepositoryMock as any,
      analyticsServiceMock as any,
      updatePreferencesUsecaseMock as any,
      environmentRepositoryMock as any
    );
  });

  afterEach(() => {
    sinon.restore();
  });

  it('should throw exception when subscriber is not found', async () => {
    const command = BulkUpdatePreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
      preferences: [
        {
          workflowId: mockedWorkflow1._id,
          in_app: true,
        },
      ],
    });

    subscriberRepositoryMock.findBySubscriberId.resolves(undefined);

    try {
      await bulkUpdatePreferences.execute(command);
      expect.fail('Should throw an exception');
    } catch (error) {
      expect(error).to.be.instanceOf(NotFoundException);
      expect(error.message).to.equal(`Subscriber with id: ${command.subscriberId} is not found`);
    }
  });

  it('should throw exception when no preferences are provided', async () => {
    const command = BulkUpdatePreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'test-mockSubscriber',
      preferences: [],
    });

    subscriberRepositoryMock.findBySubscriberId.resolves(mockedSubscriber);

    try {
      await bulkUpdatePreferences.execute(command);
      expect.fail('Should throw an exception');
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal('No preferences provided for bulk update');
    }
  });

  it('should throw exception when preferences exceed maximum limit', async () => {
    const preferences = Array(101).fill({
      workflowIdOrInternalId: mockedWorkflow1._id,
      in_app: true,
    });

    const command = BulkUpdatePreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'test-mockSubscriber',
      preferences,
    });

    subscriberRepositoryMock.findBySubscriberId.resolves(mockedSubscriber);

    try {
      await bulkUpdatePreferences.execute(command);
      expect.fail('Should throw an exception');
    } catch (error) {
      expect(error).to.be.instanceOf(UnprocessableEntityException);
      expect(error.message).to.equal('preferences must contain no more than 100 elements');
    }
  });

  it('should correctly separate internal IDs from identifiers when querying workflows', async () => {
    const command = BulkUpdatePreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'test-mockSubscriber',
      preferences: [
        {
          workflowId: mockedWorkflow1._id,
          in_app: true,
        },
        {
          workflowId: 'test-trigger-2',
          in_app: false,
        },
      ],
    });

    subscriberRepositoryMock.findBySubscriberId.resolves(mockedSubscriber);
    notificationTemplateRepositoryMock.findForBulkPreferences.resolves([mockedWorkflow1, mockedWorkflow2]);
    environmentRepositoryMock.findOne.resolves({ _id: 'env-1' } as any);
    updatePreferencesUsecaseMock.execute.onFirstCall().resolves(mockedInboxPreference1);
    updatePreferencesUsecaseMock.execute.onSecondCall().resolves(mockedInboxPreference2);

    await bulkUpdatePreferences.execute(command);

    const findCallArgs = notificationTemplateRepositoryMock.findForBulkPreferences.firstCall.args;
    expect(findCallArgs[0]).to.equal('env-1'); // environmentId
    expect(findCallArgs[1]).to.deep.equal([mockedWorkflow1._id]); // internal IDs
    expect(findCallArgs[2]).to.deep.equal(['test-trigger-2']); // identifiers
  });

  it('should handle mixed ID types correctly', async () => {
    const nonObjectIdString = 'simple-identifier-string';

    const command = BulkUpdatePreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'test-mockSubscriber',
      preferences: [
        {
          workflowId: mockedWorkflow1._id, // ObjectId
          in_app: true,
        },
        {
          workflowId: nonObjectIdString, // Non-ObjectId string
          email: true,
        },
      ],
    });

    subscriberRepositoryMock.findBySubscriberId.resolves(mockedSubscriber);
    notificationTemplateRepositoryMock.findForBulkPreferences.resolves([
      mockedWorkflow1,
      { ...mockedWorkflow2, triggers: [{ type: TriggerTypeEnum.EVENT, identifier: nonObjectIdString }] },
    ]);
    environmentRepositoryMock.findOne.resolves({ _id: 'env-1' } as any);
    updatePreferencesUsecaseMock.execute.onFirstCall().resolves(mockedInboxPreference1);
    updatePreferencesUsecaseMock.execute.onSecondCall().resolves({
      ...mockedInboxPreference2,
      workflow: { ...mockedInboxPreference2.workflow, identifier: nonObjectIdString },
    });

    await bulkUpdatePreferences.execute(command);

    const findCallArgs = notificationTemplateRepositoryMock.findForBulkPreferences.firstCall.args;
    expect(findCallArgs[1]).to.include(mockedWorkflow1._id); // internal IDs
    expect(findCallArgs[2]).to.include(nonObjectIdString); // identifiers
  });

  it('should deduplicate preferences when different identifiers resolve to the same workflow', async () => {
    const internalId = mockedWorkflow1._id;
    const triggerIdentifier = mockedWorkflow1.triggers[0].identifier;

    const command = BulkUpdatePreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'test-mockSubscriber',
      preferences: [
        {
          workflowId: internalId,
          in_app: true,
          email: false,
        },
        {
          workflowId: triggerIdentifier,
          in_app: false,
          email: true,
        },
      ],
    });

    subscriberRepositoryMock.findBySubscriberId.resolves(mockedSubscriber);
    notificationTemplateRepositoryMock.findForBulkPreferences.resolves([mockedWorkflow1]);
    environmentRepositoryMock.findOne.resolves({ _id: 'env-1' } as any);
    updatePreferencesUsecaseMock.execute.resolves(mockedInboxPreference1);

    const result = await bulkUpdatePreferences.execute(command);

    expect(updatePreferencesUsecaseMock.execute.callCount).to.equal(1);

    const updateArgs = updatePreferencesUsecaseMock.execute.firstCall.args[0];
    expect(updateArgs).to.include({
      workflowIdOrIdentifier: internalId,
      in_app: false,
      email: true,
    });

    expect(result.length).to.equal(1);
  });

  it('should throw exception when a workflow is not found', async () => {
    const command = BulkUpdatePreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'test-mockSubscriber',
      preferences: [
        {
          workflowId: 'non-existent-id',
          in_app: true,
        },
      ],
    });

    subscriberRepositoryMock.findBySubscriberId.resolves(mockedSubscriber);
    notificationTemplateRepositoryMock.findForBulkPreferences.resolves([]);

    try {
      await bulkUpdatePreferences.execute(command);
      expect.fail('Should throw an exception');
    } catch (error) {
      expect(error).to.be.instanceOf(NotFoundException);
      expect(error.message).to.include('Workflows with ids: non-existent-id not found');
    }
  });

  it('should throw exception when a workflow is critical', async () => {
    const criticalWorkflow = { ...mockedWorkflow1, critical: true };

    const command = BulkUpdatePreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'test-mockSubscriber',
      preferences: [
        {
          workflowId: criticalWorkflow._id,
          in_app: true,
        },
      ],
    });

    subscriberRepositoryMock.findBySubscriberId.resolves(mockedSubscriber);
    notificationTemplateRepositoryMock.findForBulkPreferences.resolves([criticalWorkflow]);

    try {
      await bulkUpdatePreferences.execute(command);
      expect.fail('Should throw an exception');
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.include(`Critical workflows with ids: ${criticalWorkflow._id} cannot be updated`);
    }
  });

  it('should update multiple workflow preferences in parallel', async () => {
    const command = BulkUpdatePreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'test-mockSubscriber',
      preferences: [
        {
          workflowId: mockedWorkflow1._id,
          in_app: true,
          email: false,
        },
        {
          workflowId: mockedWorkflow2._id,
          sms: true,
          chat: true,
        },
      ],
    });

    subscriberRepositoryMock.findBySubscriberId.resolves(mockedSubscriber);
    notificationTemplateRepositoryMock.findForBulkPreferences.resolves([mockedWorkflow1, mockedWorkflow2]);
    environmentRepositoryMock.findOne.resolves({ _id: 'env-1' } as any);

    updatePreferencesUsecaseMock.execute.onFirstCall().resolves(mockedInboxPreference1);
    updatePreferencesUsecaseMock.execute.onSecondCall().resolves(mockedInboxPreference2);

    const result = await bulkUpdatePreferences.execute(command);

    expect(updatePreferencesUsecaseMock.execute.calledTwice).to.be.true;

    const firstCallArgs = updatePreferencesUsecaseMock.execute.firstCall.args[0];
    expect(firstCallArgs).to.include({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      subscriberId: command.subscriberId,
      workflowIdOrIdentifier: mockedWorkflow1._id,
      level: PreferenceLevelEnum.TEMPLATE,
      in_app: true,
      email: false,
    });

    const secondCallArgs = updatePreferencesUsecaseMock.execute.secondCall.args[0];
    expect(secondCallArgs).to.include({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      subscriberId: command.subscriberId,
      workflowIdOrIdentifier: mockedWorkflow2._id,
      level: PreferenceLevelEnum.TEMPLATE,
      sms: true,
      chat: true,
    });

    expect(analyticsServiceMock.mixpanelTrack.calledOnce).to.be.true;

    expect(result).to.deep.equal([mockedInboxPreference1, mockedInboxPreference2]);
  });

  it('should support lookup by workflow identifier', async () => {
    const command = BulkUpdatePreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'test-mockSubscriber',
      preferences: [
        {
          workflowId: 'test-trigger-1', // Using identifier instead of ID
          in_app: true,
        },
      ],
    });

    subscriberRepositoryMock.findBySubscriberId.resolves(mockedSubscriber);
    notificationTemplateRepositoryMock.findForBulkPreferences.resolves([mockedWorkflow1]);
    environmentRepositoryMock.findOne.resolves({ _id: 'env-1' } as any);
    updatePreferencesUsecaseMock.execute.resolves(mockedInboxPreference1);

    const result = await bulkUpdatePreferences.execute(command);

    const updateArgs = updatePreferencesUsecaseMock.execute.firstCall.args[0];
    expect(updateArgs.workflowIdOrIdentifier).to.equal(mockedWorkflow1._id);

    expect(result).to.deep.equal([mockedInboxPreference1]);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - any({
  level: PreferenceLevelEnum.TEMPLATE,
  enabled: true,
  channels: {
    email: false,
    in_app...)
 - bulkUpdatePreferences(new BulkUpdatePreferences(
      notificationTemplateRepositoryMock as any,
      subscriberReposito...)
 - command(BulkUpdatePreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
 ...)
 - command(BulkUpdatePreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
 ...)
 - command(BulkUpdatePreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
 ...)
 - findCallArgs(notificationTemplateRepositoryMock.findForBulkPreferences.firstCall.args;
    expect(findCallArgs[0]...)
 - findCallArgs(notificationTemplateRepositoryMock.findForBulkPreferences.firstCall.args;
    expect(findCallArgs[1]...)
 - updateArgs(updatePreferencesUsecaseMock.execute.firstCall.args[0];
    expect(updateArgs).to.include({
      wo...)
 - command(BulkUpdatePreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
 ...)
 - command(BulkUpdatePreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
 ...)
 - secondCallArgs(updatePreferencesUsecaseMock.execute.secondCall.args[0];
    expect(secondCallArgs).to.include({
   ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/bulk-update-preferences/bulk-update-preferences.usecase.ts
TamaÃ±o: 5298 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException, UnprocessableEntityException } from '@nestjs/common';
import { AnalyticsService, InstrumentUsecase } from '@novu/application-generic';
import {
  BaseRepository,
  EnvironmentRepository,
  NotificationTemplateEntity,
  NotificationTemplateRepository,
  SubscriberRepository,
} from '@novu/dal';
import { PreferenceLevelEnum } from '@novu/shared';
import { BulkUpdatePreferenceItemDto } from '../../dtos/bulk-update-preferences-request.dto';
import { AnalyticsEventsEnum } from '../../utils';
import { InboxPreference } from '../../utils/types';
import { UpdatePreferencesCommand } from '../update-preferences/update-preferences.command';
import { UpdatePreferences } from '../update-preferences/update-preferences.usecase';
import { BulkUpdatePreferencesCommand } from './bulk-update-preferences.command';

const MAX_BULK_LIMIT = 100;

@Injectable()
export class BulkUpdatePreferences {
  constructor(
    private notificationTemplateRepository: NotificationTemplateRepository,
    private subscriberRepository: SubscriberRepository,
    private analyticsService: AnalyticsService,
    private updatePreferencesUsecase: UpdatePreferences,
    private environmentRepository: EnvironmentRepository
  ) {}

  @InstrumentUsecase()
  async execute(command: BulkUpdatePreferencesCommand): Promise<InboxPreference[]> {
    const subscriber = await this.subscriberRepository.findBySubscriberId(command.environmentId, command.subscriberId);
    if (!subscriber) throw new NotFoundException(`Subscriber with id: ${command.subscriberId} is not found`);

    if (command.preferences.length === 0) {
      throw new BadRequestException('No preferences provided for bulk update');
    }

    if (command.preferences.length > MAX_BULK_LIMIT) {
      throw new UnprocessableEntityException(`preferences must contain no more than ${MAX_BULK_LIMIT} elements`);
    }

    const allWorkflowIds = command.preferences.map((preference) => preference.workflowId);
    const workflowInternalIds = allWorkflowIds.filter((id) => BaseRepository.isInternalId(id));
    const workflowIdentifiers = allWorkflowIds.filter((id) => !BaseRepository.isInternalId(id));

    const dbWorkflows = await this.notificationTemplateRepository.findForBulkPreferences(
      command.environmentId,
      workflowInternalIds,
      workflowIdentifiers
    );

    const allValidWorkflowsMap = new Map<string, NotificationTemplateEntity>();
    if (dbWorkflows && dbWorkflows.length > 0) {
      for (const workflow of dbWorkflows) {
        allValidWorkflowsMap.set(workflow._id, workflow);

        if (workflow.triggers?.[0]?.identifier) {
          allValidWorkflowsMap.set(workflow.triggers[0].identifier, workflow);
        }
      }
    }

    const invalidWorkflowIds = allWorkflowIds.filter((id) => !allValidWorkflowsMap.has(id));
    if (invalidWorkflowIds.length > 0) {
      throw new NotFoundException(`Workflows with ids: ${invalidWorkflowIds.join(', ')} not found`);
    }

    const criticalWorkflows = dbWorkflows.filter((workflow) => workflow.critical);
    if (criticalWorkflows.length > 0) {
      const criticalWorkflowIds = criticalWorkflows.map((workflow) => workflow._id);
      throw new BadRequestException(`Critical workflows with ids: ${criticalWorkflowIds.join(', ')} cannot be updated`);
    }

    // deduplicate preferences by workflow document ID, it ensures we only process one update per actual workflow document
    const workflowPreferencesMap = new Map<
      string,
      { preference: BulkUpdatePreferenceItemDto; workflow: NotificationTemplateEntity }
    >();
    for (const preference of command.preferences) {
      const workflow = allValidWorkflowsMap.get(preference.workflowId);
      if (workflow) {
        workflowPreferencesMap.set(workflow._id, {
          preference,
          workflow,
        });
      }
    }

    const environment = await this.environmentRepository.findOne({
      _id: command.environmentId,
    });

    const updatePromises = Array.from(workflowPreferencesMap.entries()).map(
      async ([workflowId, { preference, workflow }]) => {
        return this.updatePreferencesUsecase.execute(
          UpdatePreferencesCommand.create({
            organizationId: command.organizationId,
            subscriberId: command.subscriberId,
            environmentId: command.environmentId,
            level: PreferenceLevelEnum.TEMPLATE,
            chat: preference.chat,
            email: preference.email,
            in_app: preference.in_app,
            push: preference.push,
            sms: preference.sms,
            workflowIdOrIdentifier: workflowId,
            workflow,
            includeInactiveChannels: false,
            subscriber,
            // biome-ignore lint/style/noNonNullAssertion: environment is always found
            environment: environment!,
          })
        );
      }
    );

    const updatedPreferences = await Promise.all(updatePromises);

    this.analyticsService.mixpanelTrack(AnalyticsEventsEnum.UPDATE_PREFERENCES_BULK, '', {
      _organization: command.organizationId,
      _subscriber: subscriber._id,
      workflowIds: Array.from(workflowPreferencesMap.keys()),
      level: PreferenceLevelEnum.TEMPLATE,
    });

    return updatedPreferences;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - allWorkflowIds(command.preferences.map((preference))
 - workflowInternalIds(allWorkflowIds.filter((id))
 - workflowIdentifiers(allWorkflowIds.filter((id))
 - invalidWorkflowIds(allWorkflowIds.filter((id))
 - criticalWorkflows(dbWorkflows.filter((workflow))
 - criticalWorkflowIds(criticalWorkflows.map((workflow))
 - updatePromises(Array.from(workflowPreferencesMap.entries()).map(
      async ([workflowId, { preference, workflow }...)
Declaraciones 'export' encontradas:
- export class BulkUpdatePreferences

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/delete-all-notifications/delete-all-notifications.command.ts
TamaÃ±o: 731 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Type } from 'class-transformer';
import { IsArray, IsBoolean, IsDefined, IsOptional, IsString, ValidateNested } from 'class-validator';

import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';
import { NotificationFilter } from '../../utils/types';

class Filter implements NotificationFilter {
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @IsOptional()
  @IsBoolean()
  read?: boolean;

  @IsOptional()
  @IsBoolean()
  archived?: boolean;

  @IsOptional()
  @IsString()
  data?: string;
}

export class DeleteAllNotificationsCommand extends EnvironmentWithSubscriber {
  @IsDefined()
  @ValidateNested()
  @Type(() => Filter)
  readonly filters: Filter;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class DeleteAllNotificationsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/delete-all-notifications/delete-all-notifications.usecase.ts
TamaÃ±o: 5370 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import {
  AnalyticsService,
  buildFeedKey,
  buildMessageCountKey,
  InvalidateCacheService,
  messageWebhookMapper,
  SendWebhookMessage,
  WebSocketsQueueService,
} from '@novu/application-generic';
import { EnvironmentEntity, EnvironmentRepository, MessageEntity, MessageRepository } from '@novu/dal';
import { WebhookEventEnum, WebhookObjectTypeEnum, WebSocketEventEnum } from '@novu/shared';

import { GetSubscriber } from '../../../subscribers/usecases/get-subscriber';
import { AnalyticsEventsEnum } from '../../utils';
import { validateDataStructure } from '../../utils/validate-data';
import { DeleteAllNotificationsCommand } from './delete-all-notifications.command';

@Injectable()
export class DeleteAllNotifications {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private getSubscriber: GetSubscriber,
    private analyticsService: AnalyticsService,
    private messageRepository: MessageRepository,
    private webSocketsQueueService: WebSocketsQueueService,
    private sendWebhookMessage: SendWebhookMessage,
    private environmentRepository: EnvironmentRepository
  ) {}

  async execute(command: DeleteAllNotificationsCommand): Promise<void> {
    const subscriber = await this.getSubscriber.execute({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      subscriberId: command.subscriberId,
    });

    if (!subscriber) {
      throw new BadRequestException(`Subscriber with id: ${command.subscriberId} is not found.`);
    }

    let parsedData: unknown;
    if (command.filters.data) {
      try {
        parsedData = JSON.parse(command.filters.data);
        validateDataStructure(parsedData);
      } catch (error) {
        if (error instanceof BadRequestException) {
          throw error;
        }

        throw new BadRequestException('Invalid JSON format for data parameter');
      }
    }

    const filters: Record<string, unknown> = {
      ...command.filters,
    };

    if (parsedData) {
      filters.data = parsedData;
    }

    const deletedMessages = await this.messageRepository.deleteMessagesWithFilters({
      environmentId: command.environmentId,
      subscriberId: subscriber._id,
      contextKeys: command.contextKeys,
      filters,
    });

    await this.sendWebhookEvents(command, deletedMessages);

    await this.invalidateCache.invalidateQuery({
      key: buildFeedKey().invalidate({
        subscriberId: command.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    await this.invalidateCache.invalidateQuery({
      key: buildMessageCountKey().invalidate({
        subscriberId: command.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    this.analyticsService.track(AnalyticsEventsEnum.DELETE_ALL_NOTIFICATIONS, '', {
      _organization: command.organizationId,
      _subscriberId: subscriber._id,
      filters: command.filters,
      contextKeys: command.contextKeys,
    });

    this.webSocketsQueueService.add({
      name: 'sendMessage',
      data: {
        event: WebSocketEventEnum.UNREAD,
        userId: subscriber._id,
        _environmentId: command.environmentId,
        ...(command.contextKeys && { contextKeys: command.contextKeys }),
      },
      groupId: subscriber._organizationId,
    });
  }

  private async sendWebhookEvents(command: DeleteAllNotificationsCommand, deletedMessages: MessageEntity[]) {
    const environment = await this.environmentRepository.findOne(
      {
        _id: command.environmentId,
      },
      'webhookAppId identifier'
    );
    if (!environment) {
      throw new Error(`Environment not found for id ${command.environmentId}`);
    }

    await this.processWebhooksInBatches([WebhookEventEnum.MESSAGE_DELETED], deletedMessages, command, environment);
  }

  private async processWebhooksInBatches(
    eventTypes: WebhookEventEnum[],
    messages: MessageEntity[],
    command: DeleteAllNotificationsCommand,
    environment: EnvironmentEntity
  ): Promise<void> {
    const BATCH_SIZE = 100;
    const messageChunks = this.chunkArray(messages, BATCH_SIZE);

    for (const messageChunk of messageChunks) {
      const webhookPromises: Promise<{ eventId: string } | undefined>[] = [];

      for (const eventType of eventTypes) {
        webhookPromises.push(...this.createWebhookPromises(eventType, messageChunk, command, environment));
      }

      await Promise.all(webhookPromises);
    }
  }

  private chunkArray<T>(array: T[], chunkSize: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }

    return chunks;
  }

  private createWebhookPromises(
    eventType: WebhookEventEnum,
    messages: MessageEntity[],
    command: DeleteAllNotificationsCommand,
    environment: EnvironmentEntity
  ): Promise<{ eventId: string } | undefined>[] {
    return messages.map((message) =>
      this.sendWebhookMessage.execute({
        eventType,
        objectType: WebhookObjectTypeEnum.MESSAGE,
        payload: {
          object: messageWebhookMapper(message, command.subscriberId),
        },
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        environment,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class DeleteAllNotifications

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/delete-many-notifications/delete-many-notifications.command.ts
TamaÃ±o: 316 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsArray, IsDefined, IsString } from 'class-validator';

import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class DeleteManyNotificationsCommand extends EnvironmentWithSubscriber {
  @IsDefined()
  @IsArray()
  @IsString({ each: true })
  readonly ids: string[];
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class DeleteManyNotificationsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/delete-many-notifications/delete-many-notifications.usecase.ts
TamaÃ±o: 6675 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import {
  buildFeedKey,
  buildMessageCountKey,
  EventType,
  InvalidateCacheService,
  LogRepository,
  MessageInteractionService,
  MessageInteractionTrace,
  mapEventTypeToTitle,
  messageWebhookMapper,
  PinoLogger,
  SendWebhookMessage,
  StepType,
  WebSocketsQueueService,
} from '@novu/application-generic';
import { EnvironmentEntity, EnvironmentRepository, MessageEntity, MessageRepository } from '@novu/dal';
import { DeliveryLifecycleStatusEnum, WebhookEventEnum, WebhookObjectTypeEnum, WebSocketEventEnum } from '@novu/shared';

import { GetSubscriber } from '../../../subscribers/usecases/get-subscriber';
import { DeleteManyNotificationsCommand } from './delete-many-notifications.command';

@Injectable()
export class DeleteManyNotifications {
  constructor(
    private invalidateCacheService: InvalidateCacheService,
    private webSocketsQueueService: WebSocketsQueueService,
    private getSubscriber: GetSubscriber,
    private messageRepository: MessageRepository,
    private messageInteractionService: MessageInteractionService,
    private logger: PinoLogger,
    private sendWebhookMessage: SendWebhookMessage,
    private environmentRepository: EnvironmentRepository
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: DeleteManyNotificationsCommand): Promise<void> {
    const subscriber = await this.getSubscriber.execute({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      subscriberId: command.subscriberId,
    });
    if (!subscriber) {
      throw new BadRequestException(`Subscriber with id: ${command.subscriberId} is not found.`);
    }

    const deletedMessages = await this.messageRepository.deleteMessagesByIds({
      environmentId: command.environmentId,
      subscriberId: subscriber._id,
      ids: command.ids,
    });

    await this.logTraces({
      command,
      subscriberId: subscriber.subscriberId,
      _subscriberId: subscriber._id,
      messages: deletedMessages,
    });

    await this.invalidateCacheService.invalidateQuery({
      key: buildFeedKey().invalidate({
        subscriberId: subscriber.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    await this.invalidateCacheService.invalidateQuery({
      key: buildMessageCountKey().invalidate({
        subscriberId: subscriber.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    const environment = await this.environmentRepository.findOne(
      {
        _id: command.environmentId,
      },
      'webhookAppId identifier'
    );
    if (!environment) {
      throw new Error(`Environment not found for id ${command.environmentId}`);
    }

    await this.processWebhooksInBatches([WebhookEventEnum.MESSAGE_DELETED], deletedMessages, command, environment);

    this.webSocketsQueueService.add({
      name: 'sendMessage',
      data: {
        event: WebSocketEventEnum.UNREAD,
        userId: subscriber._id,
        _environmentId: subscriber._environmentId,
        ...(command.contextKeys && { contextKeys: command.contextKeys }),
      },
      groupId: subscriber._organizationId,
    });
  }

  private async processWebhooksInBatches(
    eventTypes: WebhookEventEnum[],
    messages: MessageEntity[],
    command: DeleteManyNotificationsCommand,
    environment: EnvironmentEntity
  ): Promise<void> {
    const BATCH_SIZE = 100;
    const messageChunks = this.chunkArray(messages, BATCH_SIZE);

    for (const messageChunk of messageChunks) {
      const webhookPromises: Promise<{ eventId: string } | undefined>[] = [];

      for (const eventType of eventTypes) {
        webhookPromises.push(...this.sendWebhookEvents(messageChunk, eventType, command, environment));
      }

      await Promise.all(webhookPromises);
    }
  }

  private chunkArray<T>(array: T[], chunkSize: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }

    return chunks;
  }

  private sendWebhookEvents(
    deletedMessages: MessageEntity[],
    eventType: WebhookEventEnum,
    command: DeleteManyNotificationsCommand,
    environment: EnvironmentEntity
  ): Promise<{ eventId: string } | undefined>[] {
    return deletedMessages.map((message) =>
      this.sendWebhookMessage.execute({
        eventType: eventType,
        objectType: WebhookObjectTypeEnum.MESSAGE,
        payload: {
          object: messageWebhookMapper(message, command.subscriberId),
        },
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        environment: environment,
      })
    );
  }

  private async logTraces({
    command,
    subscriberId,
    _subscriberId,
    messages,
  }: {
    command: DeleteManyNotificationsCommand;
    subscriberId: string;
    _subscriberId: string;
    messages?: MessageEntity[];
  }): Promise<void> {
    if (!messages || !Array.isArray(messages)) {
      return;
    }

    const allTraceData: MessageInteractionTrace[] = [];

    for (const message of messages) {
      if (!message._jobId) continue;

      allTraceData.push(
        createTraceLog({
          message,
          command,
          eventType: 'message_deleted',
          subscriberId,
          _subscriberId,
        })
      );
    }

    if (allTraceData.length > 0) {
      try {
        await this.messageInteractionService.trace(allTraceData, DeliveryLifecycleStatusEnum.INTERACTED);
      } catch (error) {
        this.logger.warn({ err: error }, `Failed to create engagement traces for ${allTraceData.length} messages`);
      }
    }
  }
}

function createTraceLog({
  message,
  command,
  eventType,
  subscriberId,
  _subscriberId,
}: {
  message: MessageEntity;
  command: DeleteManyNotificationsCommand;
  eventType: EventType;
  subscriberId: string;
  _subscriberId: string;
}): MessageInteractionTrace {
  return {
    created_at: LogRepository.formatDateTime64(new Date()),
    organization_id: message._organizationId,
    environment_id: message._environmentId,
    user_id: command.subscriberId,
    subscriber_id: _subscriberId,
    external_subscriber_id: subscriberId,
    event_type: eventType,
    title: mapEventTypeToTitle(eventType),
    message: `Message ${eventType.replace('message_', '')} for subscriber ${message._subscriberId}`,
    raw_data: null,
    status: 'success',
    entity_type: 'step_run',
    entity_id: message._jobId,
    step_run_type: message.channel as StepType,
    workflow_run_identifier: '',
    _notificationId: message._notificationId,
  };
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - createTraceLog({
  message,
  command,
  eventType,
  subscriberId,
  _subscriberId,
}: {
  message: MessageEntity;
  command: DeleteManyNotificationsCommand;
  eventType: EventType;
  subscriberId: string;
  _subscriberId: string;
})
Declaraciones 'export' encontradas:
- export class DeleteManyNotifications

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/delete-notification/delete-notification.command.ts
TamaÃ±o: 286 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsMongoId } from 'class-validator';

import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class DeleteNotificationCommand extends EnvironmentWithSubscriber {
  @IsDefined()
  @IsMongoId()
  readonly notificationId: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class DeleteNotificationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/delete-notification/delete-notification.usecase.ts
TamaÃ±o: 2193 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { AnalyticsService } from '@novu/application-generic';
import { MessageRepository } from '@novu/dal';

import { GetSubscriber } from '../../../subscribers/usecases/get-subscriber';
import { AnalyticsEventsEnum } from '../../utils';
import { DeleteManyNotificationsCommand } from '../delete-many-notifications/delete-many-notifications.command';
import { DeleteManyNotifications } from '../delete-many-notifications/delete-many-notifications.usecase';
import { DeleteNotificationCommand } from './delete-notification.command';

@Injectable()
export class DeleteNotification {
  constructor(
    private deleteManyNotifications: DeleteManyNotifications,
    private getSubscriber: GetSubscriber,
    private analyticsService: AnalyticsService,
    private messageRepository: MessageRepository
  ) {}

  async execute(command: DeleteNotificationCommand): Promise<void> {
    const subscriber = await this.getSubscriber.execute({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      subscriberId: command.subscriberId,
    });
    if (!subscriber) {
      throw new BadRequestException(`Subscriber with id: ${command.subscriberId} is not found.`);
    }

    const message = await this.messageRepository.findOne({
      _environmentId: command.environmentId,
      _subscriberId: subscriber._id,
      _id: command.notificationId,
      contextKeys: command.contextKeys,
    });
    if (!message) {
      throw new NotFoundException(`Notification with id: ${command.notificationId} is not found.`);
    }

    await this.deleteManyNotifications.execute(
      DeleteManyNotificationsCommand.create({
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        subscriberId: command.subscriberId,
        ids: [command.notificationId],
        contextKeys: command.contextKeys,
      })
    );

    this.analyticsService.mixpanelTrack(AnalyticsEventsEnum.DELETE_NOTIFICATION, '', {
      _organization: command.organizationId,
      _subscriber: subscriber._id,
      _notification: command.notificationId,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class DeleteNotification

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/get-inbox-preferences/get-inbox-preferences.command.ts
TamaÃ±o: 692 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SeverityLevelEnum, WorkflowCriticalityEnum } from '@novu/shared';
import { IsArray, IsEnum, IsOptional, IsString } from 'class-validator';
import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';
import { IsEnumOrArray } from '../../../shared/validators/is-enum-or-array';

export class GetInboxPreferencesCommand extends EnvironmentWithSubscriber {
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  readonly tags?: string[];

  @IsOptional()
  @IsEnumOrArray(SeverityLevelEnum)
  readonly severity?: SeverityLevelEnum | SeverityLevelEnum[];

  @IsOptional()
  @IsEnum(WorkflowCriticalityEnum)
  readonly criticality: WorkflowCriticalityEnum;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class GetInboxPreferencesCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/get-inbox-preferences/get-inbox-preferences.spec.ts
TamaÃ±o: 10435 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { AnalyticsService } from '@novu/application-generic';
import { SubscriberRepository } from '@novu/dal';
import {
  ChannelTypeEnum,
  ISubscriberPreferenceResponse,
  ITemplateConfiguration,
  PreferenceLevelEnum,
  PreferenceOverrideSourceEnum,
  PreferencesTypeEnum,
  SeverityLevelEnum,
  TriggerTypeEnum,
  WorkflowCriticalityEnum,
} from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { GetSubscriberGlobalPreference } from '../../../subscribers/usecases/get-subscriber-global-preference';
import { GetSubscriberPreference } from '../../../subscribers/usecases/get-subscriber-preference';
import { GetInboxPreferencesCommand } from './get-inbox-preferences.command';
import { GetInboxPreferences } from './get-inbox-preferences.usecase';

const mockedWorkflow = {
  _id: '123',
  name: 'workflow',
  triggers: [{ identifier: '123', type: TriggerTypeEnum.EVENT, variables: [] }],
  critical: false,
  tags: [],
  createdAt: '2023-01-01T00:00:00.000Z',
  severity: SeverityLevelEnum.NONE,
} satisfies ITemplateConfiguration;
const mockedWorkflowPreference = {
  type: PreferencesTypeEnum.USER_WORKFLOW,
  template: mockedWorkflow,
  preference: {
    enabled: true,
    channels: {
      email: true,
      in_app: true,
      sms: false,
      push: false,
      chat: true,
    },
    overrides: [
      {
        channel: ChannelTypeEnum.EMAIL,
        source: PreferenceOverrideSourceEnum.SUBSCRIBER,
      },
    ],
  },
} satisfies ISubscriberPreferenceResponse;

const mockedGlobalPreferences = {
  enabled: true,
  channels: {
    email: true,
    in_app: true,
    sms: false,
    push: false,
    chat: true,
  },
};

describe('GetInboxPreferences', () => {
  let getInboxPreferences: GetInboxPreferences;

  let analyticsServiceMock: sinon.SinonStubbedInstance<AnalyticsService>;
  let getSubscriberGlobalPreferenceMock: sinon.SinonStubbedInstance<GetSubscriberGlobalPreference>;
  let getSubscriberPreferenceMock: sinon.SinonStubbedInstance<GetSubscriberPreference>;
  let subscriberRepositoryMock: sinon.SinonStubbedInstance<SubscriberRepository>;
  beforeEach(() => {
    getSubscriberPreferenceMock = sinon.createStubInstance(GetSubscriberPreference);
    analyticsServiceMock = sinon.createStubInstance(AnalyticsService);
    getSubscriberGlobalPreferenceMock = sinon.createStubInstance(GetSubscriberGlobalPreference);
    subscriberRepositoryMock = sinon.createStubInstance(SubscriberRepository);

    getInboxPreferences = new GetInboxPreferences(
      getSubscriberGlobalPreferenceMock as any,
      analyticsServiceMock as any,
      getSubscriberPreferenceMock as any,
      subscriberRepositoryMock as any
    );
  });

  afterEach(() => {
    sinon.restore();
  });

  it('it should throw exception when subscriber is not found', async () => {
    const command = GetInboxPreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'bad-subscriber-id',
      criticality: WorkflowCriticalityEnum.NON_CRITICAL,
    });

    subscriberRepositoryMock.findBySubscriberId.resolves(null);

    try {
      await getInboxPreferences.execute(command);
    } catch (error) {
      expect(error).to.be.instanceOf(Error);
      expect(error.message).to.equal(`Subscriber ${command.subscriberId} not found`);
    }
  });

  it('it should return subscriber preferences', async () => {
    const command = GetInboxPreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'test-mockSubscriber',
      criticality: WorkflowCriticalityEnum.NON_CRITICAL,
    });

    subscriberRepositoryMock.findBySubscriberId.resolves({
      _id: 'test-mockSubscriber',
      subscriberId: 'test-mockSubscriber',
      firstName: 'test',
      lastName: 'test',
      email: 'test@test.com',
      _organizationId: 'org-1',
      _environmentId: 'env-1',
      deleted: false,
    } as any);

    getSubscriberGlobalPreferenceMock.execute.resolves({
      preference: mockedGlobalPreferences,
    });
    getSubscriberPreferenceMock.execute.resolves([mockedWorkflowPreference]);

    const result = await getInboxPreferences.execute(command);

    expect(getSubscriberGlobalPreferenceMock.execute.calledOnce).to.be.true;
    expect(getSubscriberGlobalPreferenceMock.execute.firstCall.args[0]).to.deep.equal({
      organizationId: command.organizationId,
      environmentId: command.environmentId,
      subscriberId: command.subscriberId,
      includeInactiveChannels: false,
      subscriber: {
        _id: 'test-mockSubscriber',
        subscriberId: 'test-mockSubscriber',
        firstName: 'test',
        lastName: 'test',
        email: 'test@test.com',
        _organizationId: 'org-1',
        _environmentId: 'env-1',
        deleted: false,
      },
    });

    expect(getSubscriberPreferenceMock.execute.calledOnce).to.be.true;
    expect(getSubscriberPreferenceMock.execute.firstCall.args[0]).to.deep.equal({
      environmentId: command.environmentId,
      subscriberId: command.subscriberId,
      organizationId: command.organizationId,
      tags: undefined,
      severity: undefined,
      includeInactiveChannels: false,
      criticality: command.criticality,
      subscriber: {
        _id: 'test-mockSubscriber',
        subscriberId: 'test-mockSubscriber',
        firstName: 'test',
        lastName: 'test',
        email: 'test@test.com',
        _organizationId: 'org-1',
        _environmentId: 'env-1',
        deleted: false,
      },
    });

    expect(result).to.deep.equal([
      {
        level: PreferenceLevelEnum.GLOBAL,
        ...mockedGlobalPreferences,
      },
      {
        ...mockedWorkflowPreference.preference,
        level: PreferenceLevelEnum.TEMPLATE,
        workflow: {
          id: mockedWorkflow._id,
          identifier: mockedWorkflow.triggers[0].identifier,
          name: mockedWorkflow.name,
          critical: mockedWorkflow.critical,
          tags: mockedWorkflow.tags,
          severity: mockedWorkflow.severity,
        },
      },
    ]);
  });

  it('it should return subscriber preferences filtered by tags', async () => {
    const workflowsWithTags = [
      {
        template: {
          _id: '111',
          name: 'workflow',
          triggers: [{ identifier: '111', type: TriggerTypeEnum.EVENT, variables: [] }],
          critical: false,
          tags: ['newsletter'],
          createdAt: '2023-01-01T00:00:00.000Z',
          severity: SeverityLevelEnum.HIGH,
        },
        preference: mockedWorkflowPreference.preference,
        type: PreferencesTypeEnum.USER_WORKFLOW,
      },
      {
        template: {
          _id: '222',
          name: 'workflow',
          triggers: [{ identifier: '222', type: TriggerTypeEnum.EVENT, variables: [] }],
          critical: false,
          tags: ['security'],
          createdAt: '2023-01-02T00:00:00.000Z',
          severity: SeverityLevelEnum.HIGH,
        },
        preference: mockedWorkflowPreference.preference,
        type: PreferencesTypeEnum.USER_WORKFLOW,
      },
    ] satisfies ISubscriberPreferenceResponse[];
    const command = GetInboxPreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'test-mockSubscriber',
      tags: ['newsletter', 'security'],
      severity: [SeverityLevelEnum.HIGH],
      criticality: WorkflowCriticalityEnum.NON_CRITICAL,
    });

    subscriberRepositoryMock.findBySubscriberId.resolves({
      _id: 'test-mockSubscriber',
      subscriberId: 'test-mockSubscriber',
      firstName: 'test',
      lastName: 'test',
      email: 'test@test.com',
      _organizationId: 'org-1',
      _environmentId: 'env-1',
      deleted: false,
    } as any);

    getSubscriberGlobalPreferenceMock.execute.resolves({
      preference: mockedGlobalPreferences,
    });
    getSubscriberPreferenceMock.execute.resolves(workflowsWithTags);

    const result = await getInboxPreferences.execute(command);

    expect(getSubscriberGlobalPreferenceMock.execute.calledOnce).to.be.true;
    expect(getSubscriberGlobalPreferenceMock.execute.firstCall.args[0]).to.deep.equal({
      organizationId: command.organizationId,
      environmentId: command.environmentId,
      subscriberId: command.subscriberId,
      includeInactiveChannels: false,
      subscriber: {
        _id: 'test-mockSubscriber',
        subscriberId: 'test-mockSubscriber',
        firstName: 'test',
        lastName: 'test',
        email: 'test@test.com',
        _organizationId: 'org-1',
        _environmentId: 'env-1',
        deleted: false,
      },
    });

    expect(getSubscriberPreferenceMock.execute.calledOnce).to.be.true;
    expect(getSubscriberPreferenceMock.execute.firstCall.args[0]).to.deep.equal({
      environmentId: command.environmentId,
      subscriberId: command.subscriberId,
      organizationId: command.organizationId,
      tags: command.tags,
      severity: command.severity,
      includeInactiveChannels: false,
      criticality: command.criticality,
      subscriber: {
        _id: 'test-mockSubscriber',
        subscriberId: 'test-mockSubscriber',
        firstName: 'test',
        lastName: 'test',
        email: 'test@test.com',
        _organizationId: 'org-1',
        _environmentId: 'env-1',
        deleted: false,
      },
    });

    expect(result).to.deep.equal([
      { level: PreferenceLevelEnum.GLOBAL, ...mockedGlobalPreferences },
      {
        level: PreferenceLevelEnum.TEMPLATE,
        workflow: {
          id: workflowsWithTags[0].template._id,
          identifier: workflowsWithTags[0].template.triggers[0].identifier,
          name: workflowsWithTags[0].template.name,
          critical: workflowsWithTags[0].template.critical,
          tags: workflowsWithTags[0].template.tags,
          severity: workflowsWithTags[0].template.severity,
        },
        ...mockedWorkflowPreference.preference,
      },
      {
        level: PreferenceLevelEnum.TEMPLATE,
        workflow: {
          id: workflowsWithTags[1].template._id,
          identifier: workflowsWithTags[1].template.triggers[0].identifier,
          name: workflowsWithTags[1].template.name,
          critical: workflowsWithTags[1].template.critical,
          tags: workflowsWithTags[1].template.tags,
          severity: workflowsWithTags[1].template.severity,
        },
        ...mockedWorkflowPreference.preference,
      },
    ]);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockedGlobalPreferences({
  enabled: true,
  channels: {
    email: true,
    in_app: true,
    sms: false,
    push: false,...)
 - getInboxPreferences(new GetInboxPreferences(
      getSubscriberGlobalPreferenceMock as any,
      analyticsServiceMock ...)
 - command(GetInboxPreferencesCommand.create({
      environmentId: 'env-1',
      organizationId: 'org-1',
   ...)
 - result(await getInboxPreferences.execute(command);

    expect(getSubscriberGlobalPreferenceMock.execute.ca...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/get-inbox-preferences/get-inbox-preferences.usecase.ts
TamaÃ±o: 4403 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { AnalyticsService, InstrumentUsecase } from '@novu/application-generic';
import { SubscriberEntity, SubscriberRepository } from '@novu/dal';
import { PreferenceLevelEnum, SeverityLevelEnum } from '@novu/shared';
import {
  GetSubscriberGlobalPreference,
  GetSubscriberGlobalPreferenceCommand,
} from '../../../subscribers/usecases/get-subscriber-global-preference';
import {
  GetSubscriberPreference,
  GetSubscriberPreferenceCommand,
} from '../../../subscribers/usecases/get-subscriber-preference';
import { AnalyticsEventsEnum } from '../../utils';
import { InboxPreference } from '../../utils/types';
import { GetInboxPreferencesCommand } from './get-inbox-preferences.command';

@Injectable()
export class GetInboxPreferences {
  constructor(
    private getSubscriberGlobalPreference: GetSubscriberGlobalPreference,
    private analyticsService: AnalyticsService,
    private getSubscriberPreference: GetSubscriberPreference,
    private subscriberRepository: SubscriberRepository
  ) {}

  @InstrumentUsecase()
  async execute(command: GetInboxPreferencesCommand): Promise<InboxPreference[]> {
    const subscriber = await this.getSubscriber(command);
    if (!subscriber) {
      throw new NotFoundException(`Subscriber with id ${command.subscriberId} not found`);
    }

    const globalPreference = await this.getSubscriberGlobalPreference.execute(
      GetSubscriberGlobalPreferenceCommand.create({
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        subscriberId: command.subscriberId,
        includeInactiveChannels: false,
        subscriber,
      })
    );

    const updatedGlobalPreference = {
      level: PreferenceLevelEnum.GLOBAL,
      ...globalPreference.preference,
    };

    const severity = command.severity
      ? Array.isArray(command.severity)
        ? command.severity
        : [command.severity]
      : undefined;

    const subscriberWorkflowPreferences = await this.getSubscriberPreference.execute(
      GetSubscriberPreferenceCommand.create({
        environmentId: command.environmentId,
        subscriberId: command.subscriberId,
        organizationId: command.organizationId,
        tags: command.tags,
        severity,
        subscriber,
        includeInactiveChannels: false,
        criticality: command.criticality,
      })
    );
    const workflowPreferences = subscriberWorkflowPreferences.map((subscriberWorkflowPreference) => {
      return {
        ...subscriberWorkflowPreference.preference,
        level: PreferenceLevelEnum.TEMPLATE,
        workflow: {
          id: subscriberWorkflowPreference.template._id,
          identifier: subscriberWorkflowPreference.template.triggers[0].identifier,
          name: subscriberWorkflowPreference.template.name,
          critical: subscriberWorkflowPreference.template.critical,
          tags: subscriberWorkflowPreference.template.tags,
          severity: subscriberWorkflowPreference.template.severity ?? SeverityLevelEnum.NONE,
        },
      } satisfies InboxPreference;
    });

    const sortedWorkflowPreferences = workflowPreferences.sort((a, b) => {
      const aCreatedAt = subscriberWorkflowPreferences.find((preference) => preference.template._id === a.workflow?.id)
        ?.template.createdAt;
      const bCreatedAt = subscriberWorkflowPreferences.find((preference) => preference.template._id === b.workflow?.id)
        ?.template.createdAt;

      if (!aCreatedAt && !bCreatedAt) return 0;
      if (!aCreatedAt) return 1;
      if (!bCreatedAt) return -1;

      return new Date(aCreatedAt).getTime() - new Date(bCreatedAt).getTime();
    });

    this.analyticsService.mixpanelTrack(AnalyticsEventsEnum.FETCH_PREFERENCES, '', {
      _organization: command.organizationId,
      subscriberId: command.subscriberId,
      workflowSize: sortedWorkflowPreferences.length,
      tags: command.tags || [],
    });

    return [updatedGlobalPreference, ...sortedWorkflowPreferences];
  }

  private async getSubscriber(command: GetInboxPreferencesCommand): Promise<SubscriberEntity> {
    const subscriber = await this.subscriberRepository.findBySubscriberId(command.environmentId, command.subscriberId);

    if (!subscriber) {
      throw new NotFoundException(`Subscriber ${command.subscriberId} not found`);
    }

    return subscriber;
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowPreferences(subscriberWorkflowPreferences.map((subscriberWorkflowPreference))
 - sortedWorkflowPreferences(workflowPreferences.sort((a, b))
 - aCreatedAt(subscriberWorkflowPreferences.find((preference))
 - bCreatedAt(subscriberWorkflowPreferences.find((preference))
Declaraciones 'export' encontradas:
- export class GetInboxPreferences

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/get-notifications/get-notifications.command.ts
TamaÃ±o: 1187 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SeverityLevelEnum } from '@novu/shared';
import { IsArray, IsBoolean, IsDefined, IsInt, IsMongoId, IsOptional, IsString, Max, Min } from 'class-validator';

import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';
import { CursorPaginationParams } from '../../../shared/types';
import { IsEnumOrArray } from '../../../shared/validators/is-enum-or-array';

export class GetNotificationsCommand extends EnvironmentWithSubscriber implements CursorPaginationParams {
  @IsInt()
  @Min(1)
  @Max(100)
  readonly limit: number;

  @IsOptional()
  @IsMongoId()
  readonly after?: string;

  @IsDefined()
  @IsInt()
  @Min(0)
  readonly offset: number;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  readonly tags?: string[];

  @IsOptional()
  @IsBoolean()
  readonly read?: boolean;

  @IsOptional()
  @IsBoolean()
  readonly archived?: boolean;

  @IsOptional()
  @IsBoolean()
  readonly snoozed?: boolean;

  @IsOptional()
  @IsBoolean()
  readonly seen?: boolean;

  @IsOptional()
  @IsString()
  readonly data?: string;

  @IsOptional()
  @IsEnumOrArray(SeverityLevelEnum)
  readonly severity?: SeverityLevelEnum | SeverityLevelEnum[];
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class GetNotificationsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/get-notifications/get-notifications.spec.ts
TamaÃ±o: 4739 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException } from '@nestjs/common';
import { AnalyticsService } from '@novu/application-generic';
import { ChannelTypeEnum, MessageRepository } from '@novu/dal';
import { ChannelCTATypeEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { GetSubscriber } from '../../../subscribers/usecases/get-subscriber';
import { AnalyticsEventsEnum } from '../../utils';
import { mapToDto } from '../../utils/notification-mapper';
import type { GetNotificationsCommand } from './get-notifications.command';
import { GetNotifications } from './get-notifications.usecase';

const mockSubscriber: any = { _id: '123', subscriberId: 'test-mockSubscriber' };
const mockMessages: any = [
  {
    _id: '_id',
    content: '',
    read: false,
    seen: false,
    archived: false,
    createdAt: new Date(),
    lastReadAt: new Date(),
    channel: ChannelTypeEnum.IN_APP,
    subscriber: mockSubscriber,
    actorSubscriber: mockSubscriber,
    cta: {
      type: ChannelCTATypeEnum.REDIRECT,
      data: {},
    },
  },
];

describe('GetNotifications', () => {
  let getNotifications: GetNotifications;
  let getSubscriberMock: sinon.SinonStubbedInstance<GetSubscriber>;
  let messageRepositoryMock: sinon.SinonStubbedInstance<MessageRepository>;
  let analyticsServiceMock: sinon.SinonStubbedInstance<AnalyticsService>;

  beforeEach(() => {
    getSubscriberMock = sinon.createStubInstance(GetSubscriber);
    messageRepositoryMock = sinon.createStubInstance(MessageRepository);
    analyticsServiceMock = sinon.createStubInstance(AnalyticsService);

    getNotifications = new GetNotifications(
      getSubscriberMock as any,
      analyticsServiceMock as any,
      messageRepositoryMock as any
    );
  });

  afterEach(() => {
    sinon.restore();
  });

  it('it should throw exception when subscriber is not found', async () => {
    const command: GetNotificationsCommand = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
      limit: 10,
      offset: 0,
    };

    getSubscriberMock.execute.resolves(undefined);

    try {
      await getNotifications.execute(command);
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal(`Subscriber with id: ${command.subscriberId} is not found.`);
    }
  });

  it('it should throw exception when filtering for unread and archived notifications', async () => {
    const command: GetNotificationsCommand = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
      limit: 10,
      offset: 0,
      read: false,
      archived: true,
    };

    getSubscriberMock.execute.resolves(mockSubscriber);

    try {
      await getNotifications.execute(command);
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal(`Filtering for unread and archived notifications is not supported.`);
    }
  });

  it("should not track analytics when doesn't have any data", async () => {
    const command: GetNotificationsCommand = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: mockSubscriber.subscriberId,
      limit: 10,
      offset: 0,
    };

    getSubscriberMock.execute.resolves(mockSubscriber);
    messageRepositoryMock.paginate.resolves({ data: [], hasMore: false });

    await getNotifications.execute(command);

    expect(analyticsServiceMock.mixpanelTrack.calledOnce).to.be.false;
  });

  it('should return the paginated data with filters', async () => {
    const command: GetNotificationsCommand = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: mockSubscriber.subscriberId,
      limit: 10,
      offset: 0,
    };

    getSubscriberMock.execute.resolves(mockSubscriber);
    messageRepositoryMock.paginate.resolves({ data: mockMessages, hasMore: false });

    const result = await getNotifications.execute(command);

    expect(result.data).to.deep.equal(mapToDto(mockMessages));
    expect(result.filter).to.deep.equal({
      tags: command.tags,
      read: command.read,
      data: command.data,
      archived: command.archived,
      snoozed: command.snoozed,
      severity: command.severity,
      seen: command.seen,
    });
    expect(result.hasMore).to.be.false;
    expect(analyticsServiceMock.mixpanelTrack.calledOnce).to.be.true;
    expect(analyticsServiceMock.mixpanelTrack.firstCall.args).to.deep.equal([
      AnalyticsEventsEnum.FETCH_NOTIFICATIONS,
      '',
      {
        _subscriber: mockSubscriber.subscriberId,
        _organization: command.organizationId,
        feedSize: mockMessages.length,
      },
    ]);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - any([
  {
    _id: '_id',
    content: '',
    read: false,
    seen: false,
    archived: false,
    cr...)
 - getNotifications(new GetNotifications(
      getSubscriberMock as any,
      analyticsServiceMock as any,
      messa...)
 - GetNotificationsCommand({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
    ...)
 - GetNotificationsCommand({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
    ...)
 - GetNotificationsCommand({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: mockSubscriber.su...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/get-notifications/get-notifications.usecase.ts
TamaÃ±o: 3391 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { AnalyticsService, buildFeedKey, CachedQuery } from '@novu/application-generic';
import { ChannelTypeEnum, MessageRepository } from '@novu/dal';

import { GetSubscriber } from '../../../subscribers/usecases/get-subscriber';
import type { GetNotificationsResponseDto } from '../../dtos/get-notifications-response.dto';
import { AnalyticsEventsEnum } from '../../utils';
import { mapToDto } from '../../utils/notification-mapper';
import { NotificationFilter } from '../../utils/types';
import { validateDataStructure } from '../../utils/validate-data';
import type { GetNotificationsCommand } from './get-notifications.command';

@Injectable()
export class GetNotifications {
  constructor(
    private getSubscriber: GetSubscriber,
    private analyticsService: AnalyticsService,
    private messageRepository: MessageRepository
  ) {}

  @CachedQuery({
    builder: ({ environmentId, subscriberId, ...command }: GetNotificationsCommand) =>
      buildFeedKey().cache({
        environmentId,
        subscriberId,
        ...command,
      }),
  })
  async execute(command: GetNotificationsCommand): Promise<GetNotificationsResponseDto> {
    const subscriber = await this.getSubscriber.execute({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      subscriberId: command.subscriberId,
    });

    if (!subscriber) {
      throw new BadRequestException(`Subscriber with id: ${command.subscriberId} is not found.`);
    }

    if (command.read === false && command.archived === true) {
      throw new BadRequestException('Filtering for unread and archived notifications is not supported.');
    }

    let parsedData;
    if (command.data) {
      try {
        parsedData = JSON.parse(command.data);
        validateDataStructure(parsedData);
      } catch (error) {
        if (error instanceof BadRequestException) {
          throw error;
        }
        throw new BadRequestException('Invalid JSON format for data parameter');
      }
    }

    const severity = command.severity
      ? Array.isArray(command.severity)
        ? command.severity
        : [command.severity]
      : undefined;
    const { data: feed, hasMore } = await this.messageRepository.paginate(
      {
        environmentId: command.environmentId,
        subscriberId: subscriber._id,
        channel: ChannelTypeEnum.IN_APP,
        contextKeys: command.contextKeys,
        tags: command.tags,
        read: command.read,
        archived: command.archived,
        snoozed: command.snoozed,
        seen: command.seen,
        data: parsedData,
        severity,
      },
      {
        limit: command.limit,
        offset: command.offset,
        after: command.after,
      }
    );

    if (feed.length) {
      this.analyticsService.mixpanelTrack(AnalyticsEventsEnum.FETCH_NOTIFICATIONS, '', {
        _subscriber: subscriber.subscriberId,
        _organization: command.organizationId,
        feedSize: feed.length,
      });
    }

    const filters: NotificationFilter = {
      tags: command.tags,
      read: command.read,
      archived: command.archived,
      snoozed: command.snoozed,
      seen: command.seen,
      data: parsedData,
      severity: command.severity,
    };

    return {
      data: mapToDto(feed),
      hasMore,
      filter: filters,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class GetNotifications

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/mark-many-notifications-as/mark-many-notifications-as.command.ts
TamaÃ±o: 539 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsArray, IsBoolean, IsDate, IsDefined, IsMongoId, IsOptional } from 'class-validator';

import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class MarkManyNotificationsAsCommand extends EnvironmentWithSubscriber {
  @IsDefined()
  @IsArray()
  @IsMongoId({ each: true })
  readonly ids: string[];

  @IsOptional()
  @IsBoolean()
  readonly read?: boolean;

  @IsOptional()
  @IsBoolean()
  readonly archived?: boolean;

  @IsOptional()
  @IsDate()
  readonly snoozedUntil?: Date | null;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class MarkManyNotificationsAsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/mark-many-notifications-as/mark-many-notifications-as.spec.ts
TamaÃ±o: 6671 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException } from '@nestjs/common';
import {
  buildFeedKey,
  buildMessageCountKey,
  InvalidateCacheService,
  PinoLogger,
  SendWebhookMessage,
  TraceLogRepository,
  WebSocketsQueueService,
} from '@novu/application-generic';
import { ChannelTypeEnum, EnvironmentRepository, MessageRepository } from '@novu/dal';
import { ChannelCTATypeEnum, WebSocketEventEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { GetSubscriber } from '../../../subscribers/usecases/get-subscriber';
import type { MarkManyNotificationsAsCommand } from './mark-many-notifications-as.command';
import { MarkManyNotificationsAs } from './mark-many-notifications-as.usecase';

const mockSubscriber: any = { _id: '123', subscriberId: 'test-mockSubscriber' };
const mockEnvironment: any = { _id: 'env-1', webhookAppId: 'webhook-app-id', identifier: 'test-env' };
const mockMessage: any = [
  {
    _id: '_id',
    content: '',
    read: false,
    archived: false,
    createdAt: new Date(),
    lastReadAt: new Date(),
    channel: ChannelTypeEnum.IN_APP,
    subscriber: mockSubscriber,
    actorSubscriber: mockSubscriber,
    cta: {
      type: ChannelCTATypeEnum.REDIRECT,
      data: {},
    },
  },
];

describe('MarkManyNotificationsAs', () => {
  let markManyNotificationsAs: MarkManyNotificationsAs;
  let invalidateCacheMock: sinon.SinonStubbedInstance<InvalidateCacheService>;
  let webSocketsQueueServiceMock: sinon.SinonStubbedInstance<WebSocketsQueueService>;
  let getSubscriberMock: sinon.SinonStubbedInstance<GetSubscriber>;
  let messageRepositoryMock: sinon.SinonStubbedInstance<MessageRepository>;
  let traceLogRepositoryMock: sinon.SinonStubbedInstance<TraceLogRepository>;
  let loggerMock: sinon.SinonStubbedInstance<PinoLogger>;
  let sendWebhookMessageMock: sinon.SinonStubbedInstance<SendWebhookMessage>;
  let environmentRepositoryMock: sinon.SinonStubbedInstance<EnvironmentRepository>;
  beforeEach(() => {
    invalidateCacheMock = sinon.createStubInstance(InvalidateCacheService);
    webSocketsQueueServiceMock = sinon.createStubInstance(WebSocketsQueueService);
    getSubscriberMock = sinon.createStubInstance(GetSubscriber);
    messageRepositoryMock = sinon.createStubInstance(MessageRepository);
    traceLogRepositoryMock = sinon.createStubInstance(TraceLogRepository);
    loggerMock = sinon.createStubInstance(PinoLogger);
    sendWebhookMessageMock = sinon.createStubInstance(SendWebhookMessage);
    environmentRepositoryMock = sinon.createStubInstance(EnvironmentRepository);
    markManyNotificationsAs = new MarkManyNotificationsAs(
      invalidateCacheMock as any,
      webSocketsQueueServiceMock as any,
      getSubscriberMock as any,
      messageRepositoryMock as any,
      traceLogRepositoryMock as any,
      loggerMock as any,
      sendWebhookMessageMock as any,
      environmentRepositoryMock as any
    );
  });

  afterEach(() => {
    sinon.restore();
  });

  it('should throw exception when subscriber is not found', async () => {
    const command: MarkManyNotificationsAsCommand = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
      ids: ['notification-id'],
      read: true,
    };

    getSubscriberMock.execute.resolves(undefined);

    try {
      await markManyNotificationsAs.execute(command);
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal(`Subscriber with id: ${command.subscriberId} is not found.`);
    }
  });

  it('should call the updateMessagesStatusByIds on the repository', async () => {
    const command: MarkManyNotificationsAsCommand = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
      ids: [mockMessage._id],
      read: true,
    };

    getSubscriberMock.execute.resolves(mockSubscriber);
    messageRepositoryMock.updateMessagesStatusByIds.resolves(mockMessage);
    environmentRepositoryMock.findOne.resolves(mockEnvironment);

    await markManyNotificationsAs.execute(command);

    expect(messageRepositoryMock.updateMessagesStatusByIds.calledOnce).to.be.true;
    expect(messageRepositoryMock.updateMessagesStatusByIds.firstCall.args).to.deep.equal([
      {
        environmentId: command.environmentId,
        subscriberId: mockSubscriber._id,
        ids: command.ids,
        read: command.read,
        archived: command.archived,
        snoozedUntil: command.snoozedUntil,
      },
    ]);
  });

  it('should invalidate the cache', async () => {
    const command: MarkManyNotificationsAsCommand = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
      ids: [mockMessage._id],
      read: true,
    };

    getSubscriberMock.execute.resolves(mockSubscriber);
    messageRepositoryMock.findOne.resolves(mockMessage);
    messageRepositoryMock.updateMessagesStatusByIds.resolves(mockMessage);
    environmentRepositoryMock.findOne.resolves(mockEnvironment);

    await markManyNotificationsAs.execute(command);

    expect(invalidateCacheMock.invalidateQuery.calledTwice).to.be.true;
    expect(invalidateCacheMock.invalidateQuery.firstCall.args).to.deep.equal([
      {
        key: buildFeedKey().invalidate({
          subscriberId: mockSubscriber.subscriberId,
          _environmentId: command.environmentId,
        }),
      },
    ]);
    expect(invalidateCacheMock.invalidateQuery.secondCall.args).to.deep.equal([
      {
        key: buildMessageCountKey().invalidate({
          subscriberId: mockSubscriber.subscriberId,
          _environmentId: command.environmentId,
        }),
      },
    ]);
  });

  it('should send the websocket unread event', async () => {
    const command: MarkManyNotificationsAsCommand = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
      ids: [mockMessage._id],
      read: true,
    };

    getSubscriberMock.execute.resolves(mockSubscriber);
    messageRepositoryMock.findOne.resolves(mockMessage);
    messageRepositoryMock.updateMessagesStatusByIds.resolves(mockMessage);
    environmentRepositoryMock.findOne.resolves(mockEnvironment);

    await markManyNotificationsAs.execute(command);

    expect(webSocketsQueueServiceMock.add.calledOnce).to.be.true;
    expect(webSocketsQueueServiceMock.add.firstCall.args).to.deep.equal([
      {
        name: 'sendMessage',
        data: {
          event: WebSocketEventEnum.UNREAD,
          userId: mockSubscriber._id,
          _environmentId: mockSubscriber._environmentId,
        },
        groupId: mockSubscriber._organizationId,
      },
    ]);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - any([
  {
    _id: '_id',
    content: '',
    read: false,
    archived: false,
    createdAt: new Date...)
 - markManyNotificationsAs(new MarkManyNotificationsAs(
      invalidateCacheMock as any,
      webSocketsQueueServiceMock as a...)
 - MarkManyNotificationsAsCommand({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
    ...)
 - MarkManyNotificationsAsCommand({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
    ...)
 - MarkManyNotificationsAsCommand({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
    ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/mark-many-notifications-as/mark-many-notifications-as.usecase.ts
TamaÃ±o: 8147 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import {
  buildFeedKey,
  buildMessageCountKey,
  EventType,
  InvalidateCacheService,
  LogRepository,
  MessageInteractionService,
  MessageInteractionTrace,
  mapEventTypeToTitle,
  messageWebhookMapper,
  PinoLogger,
  SendWebhookMessage,
  StepType,
  WebSocketsQueueService,
} from '@novu/application-generic';
import { EnvironmentEntity, EnvironmentRepository, MessageEntity, MessageRepository } from '@novu/dal';
import { DeliveryLifecycleStatusEnum, WebhookEventEnum, WebhookObjectTypeEnum, WebSocketEventEnum } from '@novu/shared';

import { GetSubscriber } from '../../../subscribers/usecases/get-subscriber';
import { MarkManyNotificationsAsCommand } from './mark-many-notifications-as.command';

@Injectable()
export class MarkManyNotificationsAs {
  constructor(
    private invalidateCacheService: InvalidateCacheService,
    private webSocketsQueueService: WebSocketsQueueService,
    private getSubscriber: GetSubscriber,
    private messageRepository: MessageRepository,
    private messageInteractionService: MessageInteractionService,
    private logger: PinoLogger,
    private sendWebhookMessage: SendWebhookMessage,
    private environmentRepository: EnvironmentRepository
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: MarkManyNotificationsAsCommand): Promise<void> {
    const subscriber = await this.getSubscriber.execute({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      subscriberId: command.subscriberId,
    });
    if (!subscriber) {
      throw new BadRequestException(`Subscriber with id: ${command.subscriberId} is not found.`);
    }

    const updatedMessages = await this.messageRepository.updateMessagesStatusByIds({
      environmentId: command.environmentId,
      subscriberId: subscriber._id,
      ids: command.ids,
      read: command.read,
      archived: command.archived,
      snoozedUntil: command.snoozedUntil,
    });

    await this.logTraces({
      command,
      subscriberId: subscriber.subscriberId,
      _subscriberId: subscriber._id,
      messages: updatedMessages,
    });

    await this.invalidateCacheService.invalidateQuery({
      key: buildFeedKey().invalidate({
        subscriberId: subscriber.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    await this.invalidateCacheService.invalidateQuery({
      key: buildMessageCountKey().invalidate({
        subscriberId: subscriber.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    const environment = await this.environmentRepository.findOne(
      {
        _id: command.environmentId,
      },
      'webhookAppId identifier'
    );
    if (!environment) {
      throw new Error(`Environment not found for id ${command.environmentId}`);
    }

    const eventTypes: WebhookEventEnum[] = [];

    if (command.read !== undefined) {
      const eventType = command.read ? WebhookEventEnum.MESSAGE_READ : WebhookEventEnum.MESSAGE_UNREAD;
      eventTypes.push(eventType);
    }

    if (command.archived !== undefined) {
      const eventType = command.archived ? WebhookEventEnum.MESSAGE_ARCHIVED : WebhookEventEnum.MESSAGE_UNARCHIVED;
      eventTypes.push(eventType);
    }

    if (command.snoozedUntil !== undefined) {
      // do not change to !== null, as null is a indication of unsnooze
      const eventType = command.snoozedUntil ? WebhookEventEnum.MESSAGE_SNOOZED : WebhookEventEnum.MESSAGE_UNSNOOZED;
      eventTypes.push(eventType);
    }

    await this.processWebhooksInBatches(eventTypes, updatedMessages, command, environment);

    this.webSocketsQueueService.add({
      name: 'sendMessage',
      data: {
        event: WebSocketEventEnum.UNREAD,
        userId: subscriber._id,
        _environmentId: subscriber._environmentId,
        ...(command.contextKeys && { contextKeys: command.contextKeys }),
      },
      groupId: subscriber._organizationId,
    });
  }

  private async processWebhooksInBatches(
    eventTypes: WebhookEventEnum[],
    messages: MessageEntity[],
    command: MarkManyNotificationsAsCommand,
    environment: EnvironmentEntity
  ): Promise<void> {
    const BATCH_SIZE = 100;
    const messageChunks = this.chunkArray(messages, BATCH_SIZE);

    for (const messageChunk of messageChunks) {
      const webhookPromises: Promise<{ eventId: string } | undefined>[] = [];

      for (const eventType of eventTypes) {
        webhookPromises.push(...this.sendWebhookEvents(messageChunk, eventType, command, environment));
      }

      await Promise.all(webhookPromises);
    }
  }

  private chunkArray<T>(array: T[], chunkSize: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }

    return chunks;
  }

  private sendWebhookEvents(
    updatedMessages: MessageEntity[],
    eventType: WebhookEventEnum,
    command: MarkManyNotificationsAsCommand,
    environment: EnvironmentEntity
  ): Promise<{ eventId: string } | undefined>[] {
    return updatedMessages.map((message) =>
      this.sendWebhookMessage.execute({
        eventType: eventType,
        objectType: WebhookObjectTypeEnum.MESSAGE,
        payload: {
          object: messageWebhookMapper(message, command.subscriberId),
        },
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        environment: environment,
      })
    );
  }

  private async logTraces({
    command,
    subscriberId,
    _subscriberId,
    messages,
  }: {
    command: MarkManyNotificationsAsCommand;
    subscriberId: string;
    _subscriberId: string;
    messages?: MessageEntity[];
  }): Promise<void> {
    if (!messages || !Array.isArray(messages)) {
      return;
    }

    const allTraceData: MessageInteractionTrace[] = [];

    for (const message of messages) {
      if (!message._jobId) continue;

      if (command.read !== undefined) {
        allTraceData.push(
          createTraceLog({
            message,
            command,
            eventType: command.read ? 'message_read' : 'message_unread',
            subscriberId,
            _subscriberId,
          })
        );
      }

      if (command.snoozedUntil !== undefined) {
        allTraceData.push(
          createTraceLog({
            message,
            command,
            eventType: 'message_snoozed',
            subscriberId,
            _subscriberId,
          })
        );
      }

      if (command.archived !== undefined) {
        allTraceData.push(
          createTraceLog({
            message,
            command,
            eventType: command.archived ? 'message_archived' : 'message_unarchived',
            subscriberId,
            _subscriberId,
          })
        );
      }
    }

    if (allTraceData.length > 0) {
      try {
        await this.messageInteractionService.trace(allTraceData, DeliveryLifecycleStatusEnum.INTERACTED);
      } catch (error) {
        this.logger.warn({ err: error }, `Failed to create engagement traces for ${allTraceData.length} messages`);
      }
    }
  }
}

function createTraceLog({
  message,
  command,
  eventType,
  subscriberId,
  _subscriberId,
}: {
  message: MessageEntity;
  command: MarkManyNotificationsAsCommand;
  eventType: EventType;
  subscriberId: string;
  _subscriberId: string;
}): MessageInteractionTrace {
  return {
    created_at: LogRepository.formatDateTime64(new Date()),
    organization_id: message._organizationId,
    environment_id: message._environmentId,
    user_id: command.subscriberId,
    subscriber_id: _subscriberId,
    external_subscriber_id: subscriberId,
    event_type: eventType,
    title: mapEventTypeToTitle(eventType),
    message: `Message ${eventType.replace('message_', '')} for subscriber ${message._subscriberId}`,
    raw_data: null,
    status: 'success',
    entity_type: 'step_run',
    entity_id: message._jobId,
    step_run_type: message.channel as StepType,
    workflow_run_identifier: '',
    _notificationId: message._notificationId,
  };
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - createTraceLog({
  message,
  command,
  eventType,
  subscriberId,
  _subscriberId,
}: {
  message: MessageEntity;
  command: MarkManyNotificationsAsCommand;
  eventType: EventType;
  subscriberId: string;
  _subscriberId: string;
})
Declaraciones 'export' encontradas:
- export class MarkManyNotificationsAs

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/mark-notification-as/mark-notification-as.command.ts
TamaÃ±o: 507 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsBoolean, IsDate, IsDefined, IsMongoId, IsOptional } from 'class-validator';

import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class MarkNotificationAsCommand extends EnvironmentWithSubscriber {
  @IsDefined()
  @IsMongoId()
  readonly notificationId: string;

  @IsOptional()
  @IsBoolean()
  readonly read?: boolean;

  @IsOptional()
  @IsBoolean()
  readonly archived?: boolean;

  @IsOptional()
  @IsDate()
  readonly snoozedUntil?: Date | null;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class MarkNotificationAsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/mark-notification-as/mark-notification-as.spec.ts
TamaÃ±o: 5957 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, NotFoundException } from '@nestjs/common';
import { AnalyticsService } from '@novu/application-generic';
import { ChannelTypeEnum, MessageRepository } from '@novu/dal';
import { ChannelCTATypeEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { GetSubscriber } from '../../../subscribers/usecases/get-subscriber';
import { AnalyticsEventsEnum } from '../../utils';
import { mapToDto } from '../../utils/notification-mapper';
import { MarkManyNotificationsAsCommand } from '../mark-many-notifications-as/mark-many-notifications-as.command';
import { MarkManyNotificationsAs } from '../mark-many-notifications-as/mark-many-notifications-as.usecase';
import type { MarkNotificationAsCommand } from './mark-notification-as.command';
import { MarkNotificationAs } from './mark-notification-as.usecase';

const mockSubscriber: any = { _id: '6447aff5d89122e250412c79', subscriberId: '6447aff5d89122e250412c79' };
const mockMessage: any = {
  _id: '666c0dfa0b55d0f06f4aaa6c',
  content: '',
  read: false,
  archived: false,
  createdAt: new Date(),
  lastReadAt: new Date(),
  channel: ChannelTypeEnum.IN_APP,
  subscriber: mockSubscriber,
  actorSubscriber: mockSubscriber,
  cta: {
    type: ChannelCTATypeEnum.REDIRECT,
    data: {},
  },
};

describe('MarkNotificationAs', () => {
  let updateNotification: MarkNotificationAs;
  let markManyNotificationsAsMock: sinon.SinonStubbedInstance<MarkManyNotificationsAs>;
  let getSubscriberMock: sinon.SinonStubbedInstance<GetSubscriber>;
  let analyticsServiceMock: sinon.SinonStubbedInstance<AnalyticsService>;
  let messageRepositoryMock: sinon.SinonStubbedInstance<MessageRepository>;

  beforeEach(() => {
    markManyNotificationsAsMock = sinon.createStubInstance(MarkManyNotificationsAs);
    getSubscriberMock = sinon.createStubInstance(GetSubscriber);
    analyticsServiceMock = sinon.createStubInstance(AnalyticsService);
    messageRepositoryMock = sinon.createStubInstance(MessageRepository);

    updateNotification = new MarkNotificationAs(
      markManyNotificationsAsMock as any,
      getSubscriberMock as any,
      analyticsServiceMock as any,
      messageRepositoryMock as any
    );
  });

  afterEach(() => {
    sinon.restore();
  });

  it('should throw exception when subscriber is not found', async () => {
    const command: MarkNotificationAsCommand = {
      environmentId: '6447aff3d89122e250412c23',
      organizationId: '6447aff3d89122e250412c1d',
      subscriberId: '6447aff5d89122e250412c79',
      notificationId: '666c0dfa0b55d0f06f4aaa1f',
      read: true,
    };

    getSubscriberMock.execute.resolves(undefined);

    try {
      await updateNotification.execute(command);
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal(`Subscriber with id: ${command.subscriberId} is not found.`);
    }
  });

  it('should throw exception when the message is not found', async () => {
    const command: MarkNotificationAsCommand = {
      environmentId: '6447aff3d89122e250412c23',
      organizationId: '6447aff3d89122e250412c1d',
      subscriberId: '6447aff5d89122e250412c79',
      notificationId: '666c0dfa0b55d0f06f4aaa1f',
      read: true,
    };

    getSubscriberMock.execute.resolves(mockSubscriber);
    messageRepositoryMock.findOne.resolves(undefined);

    try {
      await updateNotification.execute(command);
    } catch (error) {
      expect(error).to.be.instanceOf(NotFoundException);
      expect(error.message).to.equal(`Notification with id: ${command.notificationId} is not found.`);
    }
  });

  it('should call the mark many notifications usecase to update the status', async () => {
    const command: MarkNotificationAsCommand = {
      environmentId: '6447aff3d89122e250412c23',
      organizationId: '6447aff3d89122e250412c1d',
      subscriberId: '6447aff5d89122e250412c79',
      notificationId: mockMessage._id,
      read: true,
    };
    const updatedMessageMock = { ...mockMessage, read: true };

    getSubscriberMock.execute.resolves(mockSubscriber);
    messageRepositoryMock.findOne.onFirstCall().resolves(mockMessage);
    messageRepositoryMock.findOne.onSecondCall().resolves(updatedMessageMock);
    markManyNotificationsAsMock.execute.resolves();

    const updatedMessage = await updateNotification.execute(command);

    expect(markManyNotificationsAsMock.execute.calledOnce).to.be.true;
    expect(markManyNotificationsAsMock.execute.firstCall.args).to.deep.equal([
      MarkManyNotificationsAsCommand.create({
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        subscriberId: command.subscriberId,
        ids: [command.notificationId],
        read: command.read,
        archived: command.archived,
        snoozedUntil: command.snoozedUntil,
        contextKeys: command.contextKeys,
      }),
    ]);
    expect(mapToDto(updatedMessageMock)).to.deep.equal(updatedMessage);
  });

  it('should send the analytics', async () => {
    const command: MarkNotificationAsCommand = {
      environmentId: '6447aff3d89122e250412c23',
      organizationId: '6447aff3d89122e250412c1d',
      subscriberId: '6447aff5d89122e250412c79',
      notificationId: mockMessage._id,
      read: true,
    };

    getSubscriberMock.execute.resolves(mockSubscriber);
    messageRepositoryMock.findOne.resolves(mockMessage);

    await updateNotification.execute(command);

    expect(analyticsServiceMock.mixpanelTrack.calledOnce).to.be.true;
    expect(analyticsServiceMock.mixpanelTrack.firstCall.args).to.deep.equal([
      AnalyticsEventsEnum.MARK_NOTIFICATION_AS,
      '',
      {
        _organization: command.organizationId,
        _subscriber: mockSubscriber._id,
        _notification: command.notificationId,
        read: command.read,
        archived: command.archived,
        snoozedUntil: command.snoozedUntil,
      },
    ]);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - any({
  _id: '666c0dfa0b55d0f06f4aaa6c',
  content: '',
  read: false,
  archived: false,
  createdAt: n...)
 - updateNotification(new MarkNotificationAs(
      markManyNotificationsAsMock as any,
      getSubscriberMock as any,
  ...)
 - MarkNotificationAsCommand({
      environmentId: '6447aff3d89122e250412c23',
      organizationId: '6447aff3d89122e250412c1d',...)
 - MarkNotificationAsCommand({
      environmentId: '6447aff3d89122e250412c23',
      organizationId: '6447aff3d89122e250412c1d',...)
 - updatedMessage(await updateNotification.execute(command);

    expect(markManyNotificationsAsMock.execute.calledOnc...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/mark-notification-as/mark-notification-as.usecase.ts
TamaÃ±o: 2738 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { AnalyticsService } from '@novu/application-generic';
import { MessageEntity, MessageRepository } from '@novu/dal';

import { GetSubscriber } from '../../../subscribers/usecases/get-subscriber';
import { AnalyticsEventsEnum } from '../../utils';
import { mapToDto } from '../../utils/notification-mapper';
import { InboxNotification } from '../../utils/types';
import { MarkManyNotificationsAsCommand } from '../mark-many-notifications-as/mark-many-notifications-as.command';
import { MarkManyNotificationsAs } from '../mark-many-notifications-as/mark-many-notifications-as.usecase';
import { MarkNotificationAsCommand } from './mark-notification-as.command';

@Injectable()
export class MarkNotificationAs {
  constructor(
    private markManyNotificationsAs: MarkManyNotificationsAs,
    private getSubscriber: GetSubscriber,
    private analyticsService: AnalyticsService,
    private messageRepository: MessageRepository
  ) {}

  async execute(command: MarkNotificationAsCommand): Promise<InboxNotification> {
    const subscriber = await this.getSubscriber.execute({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      subscriberId: command.subscriberId,
    });
    if (!subscriber) {
      throw new BadRequestException(`Subscriber with id: ${command.subscriberId} is not found.`);
    }

    const message = await this.messageRepository.findOne({
      _environmentId: command.environmentId,
      _subscriberId: subscriber._id,
      _id: command.notificationId,
      contextKeys: command.contextKeys,
    });
    if (!message) {
      throw new NotFoundException(`Notification with id: ${command.notificationId} is not found.`);
    }

    await this.markManyNotificationsAs.execute(
      MarkManyNotificationsAsCommand.create({
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        subscriberId: command.subscriberId,
        ids: [command.notificationId],
        read: command.read,
        archived: command.archived,
        snoozedUntil: command.snoozedUntil,
        contextKeys: command.contextKeys,
      })
    );

    this.analyticsService.mixpanelTrack(AnalyticsEventsEnum.MARK_NOTIFICATION_AS, '', {
      _organization: command.organizationId,
      _subscriber: subscriber._id,
      _notification: command.notificationId,
      read: command.read,
      archived: command.archived,
      snoozedUntil: command.snoozedUntil,
    });

    return mapToDto(
      (await this.messageRepository.findOne({
        _environmentId: command.environmentId,
        _id: command.notificationId,
      })) as MessageEntity
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class MarkNotificationAs

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/mark-notifications-as-seen/mark-notifications-as-seen.command.ts
TamaÃ±o: 486 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsArray, IsMongoId, IsOptional, IsString } from 'class-validator';

import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class MarkNotificationsAsSeenCommand extends EnvironmentWithSubscriber {
  @IsOptional()
  @IsArray()
  @IsMongoId({ each: true })
  readonly notificationIds?: string[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  readonly tags?: string[];

  @IsOptional()
  @IsString()
  readonly data?: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class MarkNotificationsAsSeenCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/mark-notifications-as-seen/mark-notifications-as-seen.usecase.ts
TamaÃ±o: 9314 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import {
  AnalyticsService,
  buildFeedKey,
  buildMessageCountKey,
  InvalidateCacheService,
  LogRepository,
  MessageInteractionService,
  MessageInteractionTrace,
  mapEventTypeToTitle,
  messageWebhookMapper,
  PinoLogger,
  SendWebhookMessage,
  StepType,
  WebSocketsQueueService,
} from '@novu/application-generic';
import { EnvironmentEntity, EnvironmentRepository, MessageEntity, MessageRepository } from '@novu/dal';
import { DeliveryLifecycleStatusEnum, WebhookEventEnum, WebhookObjectTypeEnum, WebSocketEventEnum } from '@novu/shared';

import { GetSubscriber } from '../../../subscribers/usecases/get-subscriber';
import { AnalyticsEventsEnum } from '../../utils';
import { validateDataStructure } from '../../utils/validate-data';
import { MarkNotificationsAsSeenCommand } from './mark-notifications-as-seen.command';

@Injectable()
export class MarkNotificationsAsSeen {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private getSubscriber: GetSubscriber,
    private analyticsService: AnalyticsService,
    private messageRepository: MessageRepository,
    private webSocketsQueueService: WebSocketsQueueService,
    private messageInteractionService: MessageInteractionService,
    private logger: PinoLogger,
    private sendWebhookMessage: SendWebhookMessage,
    private environmentRepository: EnvironmentRepository
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: MarkNotificationsAsSeenCommand): Promise<void> {
    const { notificationIds, tags, data, contextKeys } = command;

    // Return early if notificationIds is an empty array
    if (notificationIds && notificationIds.length === 0) {
      return;
    }

    const subscriber = await this.getSubscriber.execute({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      subscriberId: command.subscriberId,
    });
    const environment = await this.environmentRepository.findOne(
      {
        _id: command.environmentId,
      },
      'webhookAppId identifier'
    );
    if (!environment) {
      throw new Error(`Environment not found for id ${command.environmentId}`);
    }

    if (!subscriber) {
      throw new BadRequestException(`Subscriber with id: ${command.subscriberId} is not found.`);
    }

    let updatedMessages: MessageEntity[] = [];
    // If notificationIds are provided, use them; otherwise use filters
    if (notificationIds && notificationIds.length > 0) {
      updatedMessages = await this.messageRepository.updateMessagesStatusByIds({
        environmentId: command.environmentId,
        subscriberId: subscriber._id,
        contextKeys,
        ids: notificationIds,
        seen: true,
      });

      await this.processWebhooksInBatches(updatedMessages, command, subscriber.subscriberId, environment);

      await this.logTraces({
        command,
        subscriberId: subscriber.subscriberId,
        _subscriberId: subscriber._id,
        method: 'by_ids',
      });

      this.analyticsService.track(AnalyticsEventsEnum.MARK_NOTIFICATIONS_AS_SEEN, '', {
        _organization: command.organizationId,
        _subscriberId: subscriber._id,
        method: 'by_ids',
        count: notificationIds.length,
      });
    } else {
      // Use filter-based approach
      let parsedData: unknown;
      if (data) {
        try {
          parsedData = JSON.parse(data);
          validateDataStructure(parsedData);
        } catch (error) {
          if (error instanceof BadRequestException) {
            throw error;
          }
          throw new BadRequestException('Invalid JSON format for data parameter');
        }
      }

      const fromFilters: Record<string, unknown> = {};
      if (tags) {
        fromFilters.tags = tags;
      }
      if (parsedData) {
        fromFilters.data = parsedData;
      }

      await this.messageRepository.updateMessagesFromToStatus({
        environmentId: command.environmentId,
        subscriberId: subscriber._id,
        contextKeys,
        from: fromFilters,
        to: {
          seen: true,
        },
      });

      await this.logTraces({
        command,
        subscriberId: subscriber.subscriberId,
        _subscriberId: subscriber._id,
        method: 'by_filters',
      });

      this.analyticsService.track(AnalyticsEventsEnum.MARK_NOTIFICATIONS_AS_SEEN, '', {
        _organization: command.organizationId,
        _subscriberId: subscriber._id,
        method: 'by_filters',
        filters: fromFilters,
      });
    }

    // Invalidate caches
    await this.invalidateCache.invalidateQuery({
      key: buildFeedKey().invalidate({
        subscriberId: command.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    await this.invalidateCache.invalidateQuery({
      key: buildMessageCountKey().invalidate({
        subscriberId: command.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    this.webSocketsQueueService.add({
      name: 'sendMessage',
      data: {
        event: WebSocketEventEnum.UNSEEN,
        userId: subscriber._id,
        _environmentId: command.environmentId,
        ...(contextKeys && { contextKeys }),
      },
      groupId: subscriber._organizationId,
    });
  }

  private async processWebhooksInBatches(
    messages: MessageEntity[],
    command: MarkNotificationsAsSeenCommand,
    subscriberId: string,
    environment: EnvironmentEntity
  ): Promise<void> {
    const BATCH_SIZE = 100;
    const messageChunks = this.chunkArray(messages, BATCH_SIZE);

    for (const messageChunk of messageChunks) {
      const webhookPromises = messageChunk.map((message) =>
        this.sendWebhookMessage.execute({
          eventType: WebhookEventEnum.MESSAGE_SEEN,
          objectType: WebhookObjectTypeEnum.MESSAGE,
          payload: {
            object: messageWebhookMapper(message, subscriberId),
          },
          organizationId: command.organizationId,
          environmentId: command.environmentId,
          environment,
        })
      );

      await Promise.all(webhookPromises);
    }
  }

  private chunkArray<T>(array: T[], chunkSize: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }

    return chunks;
  }

  private async logTraces({
    command,
    subscriberId,
    _subscriberId,
    method,
  }: {
    command: MarkNotificationsAsSeenCommand;
    subscriberId: string;
    _subscriberId: string;
    method: 'by_ids' | 'by_filters';
  }): Promise<void> {
    let messages: MessageEntity[] = [];

    if (method === 'by_ids' && command.notificationIds && command.notificationIds.length > 0) {
      messages = await this.messageRepository.find({
        _environmentId: command.environmentId,
        _subscriberId,
        _id: { $in: command.notificationIds },
      });
    } else if (method === 'by_filters') {
      // For filter-based approach, we need to fetch messages that match the filters
      const fromFilters: Record<string, unknown> = {};
      if (command.tags) {
        fromFilters.tags = command.tags;
      }
      if (command.data) {
        try {
          const parsedData = JSON.parse(command.data);
          fromFilters.data = parsedData;
        } catch {
          // If data parsing fails, skip trace logging for this case
          return;
        }
      }

      messages = await this.messageRepository.find({
        _environmentId: command.environmentId,
        _subscriberId,
        ...fromFilters,
      });
    }

    if (!messages || !Array.isArray(messages) || messages.length === 0) {
      return;
    }

    const allTraceData: MessageInteractionTrace[] = [];

    for (const message of messages) {
      if (!message._jobId) continue;

      allTraceData.push(
        this.createTraceLog({
          message,
          command,
          subscriberId,
          _subscriberId,
        })
      );
    }

    if (allTraceData.length > 0) {
      try {
        await this.messageInteractionService.trace(allTraceData, DeliveryLifecycleStatusEnum.INTERACTED);
      } catch (error) {
        this.logger.warn({ err: error }, `Failed to create seen traces for ${allTraceData.length} messages`);
      }
    }
  }

  private createTraceLog({
    message,
    command,
    subscriberId,
    _subscriberId,
  }: {
    message: MessageEntity;
    command: MarkNotificationsAsSeenCommand;
    subscriberId: string;
    _subscriberId: string;
  }): MessageInteractionTrace {
    return {
      created_at: LogRepository.formatDateTime64(new Date()),
      organization_id: message._organizationId,
      environment_id: message._environmentId,
      user_id: command.subscriberId,
      subscriber_id: _subscriberId,
      external_subscriber_id: subscriberId,
      event_type: 'message_seen',
      title: mapEventTypeToTitle('message_seen'),
      message: `Message seen for subscriber ${message._subscriberId}`,
      raw_data: null,
      status: 'success',
      entity_type: 'step_run',
      entity_id: message._jobId,
      step_run_type: message.channel as StepType,
      workflow_run_identifier: '',
      _notificationId: message._notificationId,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - webhookPromises(messageChunk.map((message))
Declaraciones 'export' encontradas:
- export class MarkNotificationsAsSeen

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/notifications-count/notifications-count.command.ts
TamaÃ±o: 1043 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SubscriberEntity } from '@novu/dal';
import { SeverityLevelEnum } from '@novu/shared';
import { IsArray, IsBoolean, IsDefined, IsOptional, IsString } from 'class-validator';
import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';
import { IsEnumOrArray } from '../../../shared/validators/is-enum-or-array';
import { NotificationFilter } from '../../utils/types';

class NotificationsFilter implements NotificationFilter {
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @IsOptional()
  @IsBoolean()
  read?: boolean;

  @IsOptional()
  @IsBoolean()
  archived?: boolean;

  @IsOptional()
  @IsBoolean()
  snoozed?: boolean;

  @IsOptional()
  @IsBoolean()
  seen?: boolean;

  @IsOptional()
  @IsEnumOrArray(SeverityLevelEnum)
  severity?: SeverityLevelEnum | SeverityLevelEnum[];
}

export class NotificationsCountCommand extends EnvironmentWithSubscriber {
  @IsDefined()
  @IsArray()
  filters: NotificationsFilter[];

  @IsOptional()
  subscriber?: SubscriberEntity;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class NotificationsCountCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/notifications-count/notifications-count.spec.ts
TamaÃ±o: 7896 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException } from '@nestjs/common';
import { buildMessageCountKey, CachedQuery } from '@novu/application-generic';
import { MessageRepository, OrganizationRepository, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { NotificationsCountCommand } from './notifications-count.command';
import { NotificationsCount } from './notifications-count.usecase';

sinon.stub(CachedQuery);
sinon.stub(buildMessageCountKey);

describe('NotificationsCount', () => {
  let notificationsCount: NotificationsCount;
  let messageRepository: sinon.SinonStubbedInstance<MessageRepository>;
  let subscriberRepository: sinon.SinonStubbedInstance<SubscriberRepository>;

  beforeEach(() => {
    messageRepository = sinon.createStubInstance(MessageRepository);
    subscriberRepository = sinon.createStubInstance(SubscriberRepository);
    notificationsCount = new NotificationsCount(messageRepository as any, subscriberRepository as any);
  });

  describe('execute', () => {
    it('should throw BadRequestException if subscriber is not found', async () => {
      subscriberRepository.findBySubscriberId.resolves(null);

      const command: NotificationsCountCommand = {
        organizationId: 'organizationId',
        environmentId: 'environmentId',
        subscriberId: 'subscriber-id',
        filters: [{ read: false }],
      };

      try {
        await notificationsCount.execute(command);
      } catch (error) {
        expect(error).to.be.instanceOf(BadRequestException);
        expect(error.message).to.equal(
          `Subscriber ${command.subscriberId} doesn't exist in environment ${command.environmentId}`
        );
      }
    });

    it('it should throw exception when filtering for unread and archived notifications', async () => {
      const subscriber = { _id: 'subscriber-id' };
      const command: NotificationsCountCommand = {
        environmentId: 'env-1',
        organizationId: 'org-1',
        subscriberId: 'not-found',
        filters: [{ read: false, archived: true }],
      };

      subscriberRepository.findBySubscriberId.resolves(subscriber as any);

      try {
        await notificationsCount.execute(command);
      } catch (error) {
        expect(error).to.be.instanceOf(BadRequestException);
        expect(error.message).to.equal(`Filtering for unread and archived notifications is not supported.`);
      }
    });

    it('should return the correct count of notifications', async () => {
      const subscriber = { _id: 'subscriber-id' };
      const count = 42;

      subscriberRepository.findBySubscriberId.resolves(subscriber as any);
      messageRepository.getCount.resolves(count);

      const command: NotificationsCountCommand = {
        organizationId: 'organizationId',
        environmentId: 'environmentId',
        subscriberId: 'subscriber-id',
        filters: [{ read: false }],
      };

      const result = await notificationsCount.execute(command);
      const filter = { read: false };

      expect(result).to.deep.equal({ data: [{ count, filter }] });
      expect(subscriberRepository.findBySubscriberId.calledOnce).to.be.true;
      expect(messageRepository.getCount.calledOnce).to.be.true;
      expect(
        messageRepository.getCount.calledWith(
          command.environmentId,
          subscriber._id,
          ChannelTypeEnum.IN_APP,
          {
            ...filter,
            severity: undefined,
          },
          {
            limit: 99,
          }
        )
      ).to.be.true;
    });

    it('should construct the query correctly', async () => {
      const environmentId = 'environmentId';
      const subscriber = { _id: 'subscriber-id' };
      const count = 42;

      subscriberRepository.findBySubscriberId.resolves(subscriber as any);
      messageRepository.getCount.resolves(count);

      await notificationsCount.execute({
        organizationId: 'organizationId',
        environmentId,
        subscriberId: 'subscriber-id',
        filters: [{ read: true }],
      });

      expect(
        messageRepository.getCount.calledWith(
          environmentId,
          subscriber._id,
          ChannelTypeEnum.IN_APP,
          { read: true, severity: undefined },
          { limit: 99 }
        )
      ).to.be.true;

      await notificationsCount.execute({
        organizationId: 'organizationId',
        environmentId,
        subscriberId: 'subscriber-id',
        filters: [{ read: false }],
      });

      expect(
        messageRepository.getCount.calledWith(
          environmentId,
          subscriber._id,
          ChannelTypeEnum.IN_APP,
          { read: false, severity: undefined },
          { limit: 99 }
        )
      ).to.be.true;

      await notificationsCount.execute({
        organizationId: 'organizationId',
        environmentId,
        subscriberId: 'subscriber-id',
        filters: [{}],
      });

      expect(
        messageRepository.getCount.calledWith(
          environmentId,
          subscriber._id,
          ChannelTypeEnum.IN_APP,
          { severity: undefined },
          { limit: 99 }
        )
      ).to.be.true;

      await notificationsCount.execute({
        organizationId: 'organizationId',
        environmentId,
        subscriberId: 'subscriber-id',
        filters: [{ archived: true }],
      });

      expect(
        messageRepository.getCount.calledWith(
          environmentId,
          subscriber._id,
          ChannelTypeEnum.IN_APP,
          { archived: true, severity: undefined },
          { limit: 99 }
        )
      ).to.be.true;

      await notificationsCount.execute({
        organizationId: 'organizationId',
        environmentId,
        subscriberId: 'subscriber-id',
        filters: [{ archived: false }],
      });

      expect(
        messageRepository.getCount.calledWith(
          environmentId,
          subscriber._id,
          ChannelTypeEnum.IN_APP,
          { archived: false, severity: undefined },
          { limit: 99 }
        )
      ).to.be.true;

      await notificationsCount.execute({
        organizationId: 'organizationId',
        environmentId,
        subscriberId: 'subscriber-id',
        filters: [{ snoozed: true }],
      });

      expect(
        messageRepository.getCount.calledWith(
          environmentId,
          subscriber._id,
          ChannelTypeEnum.IN_APP,
          { snoozed: true, severity: undefined },
          { limit: 99 }
        )
      ).to.be.true;

      await notificationsCount.execute({
        organizationId: 'organizationId',
        environmentId,
        subscriberId: 'subscriber-id',
        filters: [{ snoozed: false }],
      });

      expect(
        messageRepository.getCount.calledWith(
          environmentId,
          subscriber._id,
          ChannelTypeEnum.IN_APP,
          { snoozed: false, severity: undefined },
          { limit: 99 }
        )
      ).to.be.true;

      await notificationsCount.execute({
        organizationId: 'organizationId',
        environmentId,
        subscriberId: 'subscriber-id',
        filters: [{}],
      });

      expect(
        messageRepository.getCount.calledWith(
          environmentId,
          subscriber._id,
          ChannelTypeEnum.IN_APP,
          { severity: undefined },
          { limit: 99 }
        )
      ).to.be.true;

      await notificationsCount.execute({
        organizationId: 'organizationId',
        environmentId,
        subscriberId: 'subscriber-id',
        filters: [{ read: true, archived: true }],
      });

      expect(
        messageRepository.getCount.calledWith(
          environmentId,
          subscriber._id,
          ChannelTypeEnum.IN_APP,
          { read: true, archived: true, severity: undefined },
          { limit: 99 }
        )
      ).to.be.true;
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - notificationsCount(new NotificationsCount(messageRepository as any, subscriberRepository as any);
  });

  describe('ex...)
 - NotificationsCountCommand({
        organizationId: 'organizationId',
        environmentId: 'environmentId',
        subscrib...)
 - NotificationsCountCommand({
        environmentId: 'env-1',
        organizationId: 'org-1',
        subscriberId: 'not-found'...)
 - filter({ read: false };

      expect(result).to.deep.equal({ data: [{ count, filter }] });
      expect(su...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/notifications-count/notifications-count.usecase.ts
TamaÃ±o: 2557 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { buildMessageCountKey, CachedQuery } from '@novu/application-generic';
import { MessageRepository, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/shared';
import type { NotificationFilter } from '../../utils/types';
import type { NotificationsCountCommand } from './notifications-count.command';

const MAX_NOTIFICATIONS_COUNT = 99;

@Injectable()
export class NotificationsCount {
  constructor(
    private messageRepository: MessageRepository,
    private subscriberRepository: SubscriberRepository
  ) {}

  @CachedQuery({
    builder: ({ environmentId, subscriberId, ...command }: NotificationsCountCommand) =>
      buildMessageCountKey().cache({
        environmentId,
        subscriberId,
        ...command,
        subscriber: {
          _id: command?.subscriber?._id,
          _organizationId: command?.subscriber?._organizationId,
          _environmentId: command?.subscriber?._environmentId,
          subscriberId: command?.subscriber?.subscriberId,
        },
      }),
  })
  async execute(
    command: NotificationsCountCommand
  ): Promise<{ data: Array<{ count: number; filter: NotificationFilter }> }> {
    const subscriber =
      command.subscriber ??
      (await this.subscriberRepository.findBySubscriberId(command.environmentId, command.subscriberId, true, '_id'));

    if (!subscriber) {
      throw new BadRequestException(
        `Subscriber ${command.subscriberId} doesn't exist in environment ${command.environmentId}`
      );
    }

    const hasUnsupportedFilter = command.filters.some((filter) => filter.read === false && filter.archived === true);
    if (hasUnsupportedFilter) {
      throw new BadRequestException('Filtering for unread and archived notifications is not supported.');
    }

    const getCountPromises = command.filters.map((filter) => {
      const severity = filter.severity
        ? Array.isArray(filter.severity)
          ? filter.severity
          : [filter.severity]
        : undefined;

      return this.messageRepository.getCount(
        command.environmentId,
        subscriber._id,
        ChannelTypeEnum.IN_APP,
        {
          ...filter,
          severity,
        },
        {
          limit: MAX_NOTIFICATIONS_COUNT,
        },
        command.contextKeys
      );
    });

    const counts = await Promise.all(getCountPromises);
    const result = counts.map((count, index) => ({ count, filter: command.filters[index] }));

    return { data: result };
  }
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - MAX_NOTIFICATIONS_COUNT(99;

@Injectable()
export class NotificationsCount {
  constructor(
    private messageRepository: M...)
 - hasUnsupportedFilter(command.filters.some((filter))
 - getCountPromises(command.filters.map((filter))
 - result(counts.map((count, index))
Declaraciones 'export' encontradas:
- export class NotificationsCount

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/session/session.command.ts
TamaÃ±o: 515 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { Type } from 'class-transformer';
import { IsDefined, IsOptional, IsString, ValidateNested } from 'class-validator';

import { SubscriberSessionRequestDto } from '../../dtos/subscriber-session-request.dto';

export class SessionCommand extends BaseCommand {
  @IsDefined()
  @ValidateNested()
  @Type(() => SubscriberSessionRequestDto)
  readonly requestData: SubscriberSessionRequestDto;

  @IsOptional()
  @IsString()
  readonly origin?: string;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class SessionCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/session/session.spec.ts
TamaÃ±o: 21505 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, NotFoundException } from '@nestjs/common';
import {
  AnalyticsService,
  CreateOrUpdateSubscriberUseCase,
  FeatureFlagsService,
  GetSubscriberSchedule,
  PinoLogger,
  SelectIntegration,
  UpsertControlValuesUseCase,
} from '@novu/application-generic';
import {
  CommunityOrganizationRepository,
  CommunityUserRepository,
  ContextRepository,
  EnvironmentRepository,
  IntegrationRepository,
  MessageRepository,
  MessageTemplateRepository,
  NotificationTemplateRepository,
  PreferencesRepository,
} from '@novu/dal';
import { ApiServiceLevelEnum, ChannelTypeEnum, InAppProviderIdEnum, SeverityLevelEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { AuthService } from '../../../auth/services/auth.service';
import { GenerateUniqueApiKey } from '../../../environments-v1/usecases/generate-unique-api-key/generate-unique-api-key.usecase';
import { CreateNovuIntegrations } from '../../../integrations/usecases/create-novu-integrations/create-novu-integrations.usecase';
import { GetOrganizationSettings } from '../../../organization/usecases/get-organization-settings/get-organization-settings.usecase';
import { SubscriberSessionResponseDto } from '../../dtos/subscriber-session-response.dto';
import { AnalyticsEventsEnum } from '../../utils';
import * as encryption from '../../utils/encryption';
import { NotificationsCount } from '../notifications-count/notifications-count.usecase';
import { UpdatePreferences } from '../update-preferences/update-preferences.usecase';
import { SessionCommand } from './session.command';
import { Session } from './session.usecase';

const mockIntegration = {
  _id: '_id',
  _environmentId: '_environmentId',
  _organizationId: '_organizationId',
  providerId: InAppProviderIdEnum.Novu,
  channel: ChannelTypeEnum.IN_APP,
  credentials: { hmac: true },
  active: true,
  name: 'In-App Integration',
  identifier: 'in-app-integration',
  primary: true,
  priority: 1,
  deleted: false,
  deletedAt: '',
  deletedBy: '',
};

const mockSeverityCounts = [
  { severity: SeverityLevelEnum.HIGH, count: 10 },
  { severity: SeverityLevelEnum.MEDIUM, count: 20 },
];

describe('Session', () => {
  let session: Session;
  let environmentRepository: sinon.SinonStubbedInstance<EnvironmentRepository>;
  let createSubscriber: sinon.SinonStubbedInstance<CreateOrUpdateSubscriberUseCase>;
  let authService: sinon.SinonStubbedInstance<AuthService>;
  let selectIntegration: sinon.SinonStubbedInstance<SelectIntegration>;
  let analyticsService: sinon.SinonStubbedInstance<AnalyticsService>;
  let notificationsCount: sinon.SinonStubbedInstance<NotificationsCount>;
  let integrationRepository: sinon.SinonStubbedInstance<IntegrationRepository>;
  let organizationRepository: sinon.SinonStubbedInstance<CommunityOrganizationRepository>;
  let communityOrganizationRepository: sinon.SinonStubbedInstance<CommunityOrganizationRepository>;
  let contextRepository: sinon.SinonStubbedInstance<ContextRepository>;
  let generateUniqueApiKey: sinon.SinonStubbedInstance<GenerateUniqueApiKey>;
  let createNovuIntegrationsUsecase: sinon.SinonStubbedInstance<CreateNovuIntegrations>;
  let communityUserRepository: sinon.SinonStubbedInstance<CommunityUserRepository>;
  let notificationTemplateRepository: sinon.SinonStubbedInstance<NotificationTemplateRepository>;
  let messageTemplateRepository: sinon.SinonStubbedInstance<MessageTemplateRepository>;
  let preferencesRepository: sinon.SinonStubbedInstance<PreferencesRepository>;
  let upsertControlValuesUseCase: sinon.SinonStubbedInstance<UpsertControlValuesUseCase>;
  let getOrganizationSettingsUsecase: sinon.SinonStubbedInstance<GetOrganizationSettings>;
  let logger: sinon.SinonStubbedInstance<PinoLogger>;
  let featureFlagsService: sinon.SinonStubbedInstance<FeatureFlagsService>;
  let messageRepository: sinon.SinonStubbedInstance<MessageRepository>;
  let getSubscriberSchedule: sinon.SinonStubbedInstance<GetSubscriberSchedule>;
  let updatePreferencesUsecase: sinon.SinonStubbedInstance<UpdatePreferences>;

  beforeEach(() => {
    environmentRepository = sinon.createStubInstance(EnvironmentRepository);
    createSubscriber = sinon.createStubInstance(CreateOrUpdateSubscriberUseCase);
    authService = sinon.createStubInstance(AuthService);
    selectIntegration = sinon.createStubInstance(SelectIntegration);
    analyticsService = sinon.createStubInstance(AnalyticsService);
    notificationsCount = sinon.createStubInstance(NotificationsCount);
    integrationRepository = sinon.createStubInstance(IntegrationRepository);
    organizationRepository = sinon.createStubInstance(CommunityOrganizationRepository);
    communityOrganizationRepository = sinon.createStubInstance(CommunityOrganizationRepository);
    contextRepository = sinon.createStubInstance(ContextRepository);
    generateUniqueApiKey = sinon.createStubInstance(GenerateUniqueApiKey);
    createNovuIntegrationsUsecase = sinon.createStubInstance(CreateNovuIntegrations);
    communityUserRepository = sinon.createStubInstance(CommunityUserRepository);
    notificationTemplateRepository = sinon.createStubInstance(NotificationTemplateRepository);
    messageTemplateRepository = sinon.createStubInstance(MessageTemplateRepository);
    preferencesRepository = sinon.createStubInstance(PreferencesRepository);
    upsertControlValuesUseCase = sinon.createStubInstance(UpsertControlValuesUseCase);
    getOrganizationSettingsUsecase = sinon.createStubInstance(GetOrganizationSettings);
    logger = sinon.createStubInstance(PinoLogger);
    featureFlagsService = sinon.createStubInstance(FeatureFlagsService);
    messageRepository = sinon.createStubInstance(MessageRepository);
    getSubscriberSchedule = sinon.createStubInstance(GetSubscriberSchedule);
    updatePreferencesUsecase = sinon.createStubInstance(UpdatePreferences);

    session = new Session(
      environmentRepository as any,
      createSubscriber as any,
      authService as any,
      selectIntegration as any,
      analyticsService as any,
      notificationsCount as any,
      integrationRepository as any,
      organizationRepository as any,
      communityOrganizationRepository as any,
      contextRepository as any,
      generateUniqueApiKey as any,
      createNovuIntegrationsUsecase as any,
      communityUserRepository as any,
      notificationTemplateRepository as any,
      messageTemplateRepository as any,
      messageRepository as any,
      preferencesRepository as any,
      upsertControlValuesUseCase as any,
      getOrganizationSettingsUsecase as any,
      logger as any,
      featureFlagsService as any,
      getSubscriberSchedule as any,
      updatePreferencesUsecase as any
    );

    messageRepository.getCountBySeverity.resolves(mockSeverityCounts);
  });

  it('should throw an error if the environment is not found', async () => {
    const command: SessionCommand = {
      requestData: {
        applicationIdentifier: 'invalid-app-id',
        subscriber: {
          subscriberId: 'subscriber-id',
        },
      },
    };

    environmentRepository.findEnvironmentByIdentifier.resolves(null);

    try {
      await session.execute(command);
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal('Please provide a valid application identifier');
    }
  });

  it('should throw an error if the in-app integration is not found', async () => {
    const command: SessionCommand = {
      requestData: {
        applicationIdentifier: 'app-id',
        subscriber: {
          subscriberId: 'subscriber-id',
        },
      },
    };

    environmentRepository.findEnvironmentByIdentifier.resolves({
      _id: 'env-id',
      _organizationId: 'org-id',
      apiKeys: [{ key: 'api-key', _userId: 'user-id' }],
    } as any);
    selectIntegration.execute.resolves(undefined);

    try {
      await session.execute(command);
    } catch (error) {
      expect(error).to.be.instanceOf(NotFoundException);
      expect(error.message).to.equal('The active in-app integration could not be found');
    }
  });

  it('should validate HMAC encryption and return the session response', async () => {
    const command: SessionCommand = {
      requestData: {
        applicationIdentifier: 'app-id',
        subscriber: {
          subscriberId: 'subscriber-id',
        },
        subscriberHash: 'hash',
      },
    };
    const subscriber = { _id: 'subscriber-id' };
    const organization = { _id: 'org-id', apiServiceLevel: ApiServiceLevelEnum.FREE };
    const notificationCount = { data: [{ count: 10, filter: {} }] };
    const token = 'token';

    environmentRepository.findEnvironmentByIdentifier.resolves({
      _id: 'env-id',
      _organizationId: 'org-id',
      apiKeys: [{ key: 'api-key', _userId: 'user-id' }],
      name: 'Development',
    } as any);
    organizationRepository.findById.resolves(organization as any);
    selectIntegration.execute.resolves(mockIntegration);
    createSubscriber.execute.resolves(subscriber as any);
    notificationsCount.execute.resolves(notificationCount);
    authService.getSubscriberWidgetToken.resolves(token);
    getOrganizationSettingsUsecase.execute.resolves({
      removeNovuBranding: false,
      defaultLocale: 'en_US',
    });

    const validateHmacEncryptionStub = sinon.stub(encryption, 'validateHmacEncryption');

    await session.execute(command);

    expect(validateHmacEncryptionStub.calledOnce).to.be.true;
    validateHmacEncryptionStub.restore();
  });

  it('should return correct removeNovuBranding value when set on the organization', async () => {
    const command: SessionCommand = {
      requestData: {
        applicationIdentifier: 'app-id',
        subscriber: {
          subscriberId: 'subscriber-id',
        },
        subscriberHash: 'hash',
      },
    };
    const subscriber = { _id: 'subscriber-id' };
    const organization = { _id: 'org-id', apiServiceLevel: ApiServiceLevelEnum.FREE };
    const environment = { _id: 'env-id', _organizationId: 'org-id', name: 'env-name', apiKeys: [{ key: 'api-key' }] };
    const notificationCount = { data: [{ count: 10, filter: {} }] };
    const token = 'token';

    environmentRepository.findEnvironmentByIdentifier.resolves(environment as any);
    organizationRepository.findById.resolves(organization as any);
    selectIntegration.execute.resolves({ ...mockIntegration, credentials: { hmac: false } });
    createSubscriber.execute.resolves(subscriber as any);
    notificationsCount.execute.resolves(notificationCount);
    authService.getSubscriberWidgetToken.resolves(token);

    getOrganizationSettingsUsecase.execute.resolves({
      removeNovuBranding: false,
      defaultLocale: 'en_US',
    });
    const response: SubscriberSessionResponseDto = await session.execute(command);
    expect(response.removeNovuBranding).to.equal(false);

    getOrganizationSettingsUsecase.execute.resolves({
      removeNovuBranding: true,
      defaultLocale: 'en_US',
    });
    const responseWithRemoveNovuBranding: SubscriberSessionResponseDto = await session.execute(command);
    expect(responseWithRemoveNovuBranding.removeNovuBranding).to.equal(true);
  });

  it('should create a subscriber and return the session response', async () => {
    const command: SessionCommand = {
      requestData: {
        applicationIdentifier: 'app-id',
        subscriber: {
          subscriberId: 'subscriber-id',
        },
        subscriberHash: 'hash',
      },
      origin: 'origin',
    };

    const organization = { _id: 'org-id', apiServiceLevel: ApiServiceLevelEnum.FREE };
    const environment = { _id: 'env-id', _organizationId: 'org-id', name: 'env-name', apiKeys: [{ key: 'api-key' }] };
    const integration = { ...mockIntegration, credentials: { hmac: false } };
    const subscriber = { _id: 'subscriber-id' };
    const notificationCount = { data: [{ count: 10, filter: {} }] };
    const token = 'token';

    environmentRepository.findEnvironmentByIdentifier.resolves(environment as any);
    selectIntegration.execute.resolves(integration);
    organizationRepository.findById.resolves(organization as any);
    createSubscriber.execute.resolves(subscriber as any);
    notificationsCount.execute.resolves(notificationCount);
    authService.getSubscriberWidgetToken.resolves(token);
    getOrganizationSettingsUsecase.execute.resolves({
      removeNovuBranding: false,
      defaultLocale: 'en_US',
    });

    const response: SubscriberSessionResponseDto = await session.execute(command);

    expect(response.token).to.equal(token);
    expect(response.unreadCount.total).to.equal(notificationCount.data[0].count);
    expect(response.unreadCount.severity[SeverityLevelEnum.HIGH]).to.equal(mockSeverityCounts[0].count);
    expect(response.unreadCount.severity[SeverityLevelEnum.MEDIUM]).to.equal(mockSeverityCounts[1].count);
    expect(response.unreadCount.severity[SeverityLevelEnum.LOW]).to.equal(0);
    expect(response.unreadCount.severity[SeverityLevelEnum.NONE]).to.equal(0);
    expect(
      analyticsService.mixpanelTrack.calledWith(AnalyticsEventsEnum.SESSION_INITIALIZED, '', {
        _organization: environment._organizationId,
        environmentName: environment.name,
        _subscriber: subscriber._id,
        origin: command.origin,
        context: undefined,
      })
    ).to.be.true;
  });

  it('should return the correct maxSnoozeDurationHours value for different service levels', async () => {
    const command: SessionCommand = {
      requestData: {
        applicationIdentifier: 'app-id',
        subscriber: { subscriberId: 'subscriber-id' },
        subscriberHash: 'hash',
      },
    };

    const environment = { _id: 'env-id', _organizationId: 'org-id', name: 'env-name', apiKeys: [{ key: 'api-key' }] };
    const organization = { _id: 'org-id', apiServiceLevel: ApiServiceLevelEnum.FREE };
    const integration = { ...mockIntegration, credentials: { hmac: false } };
    const subscriber = { _id: 'subscriber-id' };
    const notificationCount = { data: [{ count: 10, filter: {} }] };
    const token = 'token';

    organizationRepository.findById.resolves(organization as any);
    environmentRepository.findEnvironmentByIdentifier.resolves(environment as any);
    selectIntegration.execute.resolves(integration);
    createSubscriber.execute.resolves(subscriber as any);
    notificationsCount.execute.resolves(notificationCount);
    authService.getSubscriberWidgetToken.resolves(token);
    getOrganizationSettingsUsecase.execute.resolves({
      removeNovuBranding: false,
      defaultLocale: 'en_US',
    });

    // FREE plan should have 24 hours max snooze duration
    organizationRepository.findById.resolves({ apiServiceLevel: ApiServiceLevelEnum.FREE } as any);
    const freeResponse: SubscriberSessionResponseDto = await session.execute(command);
    expect(freeResponse.maxSnoozeDurationHours).to.equal(24);

    // PRO plan should have 90 days max snooze duration
    organizationRepository.findById.resolves({ apiServiceLevel: ApiServiceLevelEnum.PRO } as any);
    const proResponse: SubscriberSessionResponseDto = await session.execute(command);
    expect(proResponse.maxSnoozeDurationHours).to.equal(90 * 24);

    // BUSINESS/TEAM plan should have 90 days max snooze duration
    organizationRepository.findById.resolves({ apiServiceLevel: ApiServiceLevelEnum.BUSINESS } as any);
    const businessResponse: SubscriberSessionResponseDto = await session.execute(command);
    expect(businessResponse.maxSnoozeDurationHours).to.equal(90 * 24);

    // ENTERPRISE plan should have 90 days max snooze duration
    organizationRepository.findById.resolves({ apiServiceLevel: ApiServiceLevelEnum.ENTERPRISE } as any);
    const enterpriseResponse: SubscriberSessionResponseDto = await session.execute(command);
    expect(enterpriseResponse.maxSnoozeDurationHours).to.equal(90 * 24);
  });

  it('should upsert contexts and return contextKeys when context is provided', async () => {
    const command: SessionCommand = {
      requestData: {
        applicationIdentifier: 'app-id',
        subscriber: { subscriberId: 'subscriber-id' },
        context: { teamId: 'team-123', projectId: 'project-456' },
      },
    };

    const environment = {
      _id: 'env-id',
      _organizationId: 'org-id',
      name: 'env-name',
      apiKeys: [{ key: 'api-key' }],
    };
    const organization = { _id: 'org-id', apiServiceLevel: ApiServiceLevelEnum.FREE };
    const subscriber = { _id: 'subscriber-id' };
    const notificationCount = { data: [{ count: 10, filter: {} }] };
    const token = 'token';
    const mockContexts = [{ key: 'teamId:team-123' }, { key: 'projectId:project-456' }];

    environmentRepository.findEnvironmentByIdentifier.resolves(environment as any);
    organizationRepository.findById.resolves(organization as any);
    selectIntegration.execute.resolves({ ...mockIntegration, credentials: { hmac: false } });
    createSubscriber.execute.resolves(subscriber as any);
    notificationsCount.execute.resolves(notificationCount);
    authService.getSubscriberWidgetToken.resolves(token);
    getOrganizationSettingsUsecase.execute.resolves({
      removeNovuBranding: false,
      defaultLocale: 'en_US',
    });
    featureFlagsService.getFlag.resolves(true);
    contextRepository.findOrCreateContextsFromPayload.resolves(mockContexts as any);

    const response: SubscriberSessionResponseDto = await session.execute(command);

    expect(contextRepository.findOrCreateContextsFromPayload.calledOnce).to.be.true;
    expect(
      contextRepository.findOrCreateContextsFromPayload.calledWith(
        environment._id,
        environment._organizationId,
        command.requestData.context
      )
    ).to.be.true;

    expect(response.contextKeys).to.deep.equal(['teamId:team-123', 'projectId:project-456']);
  });

  it('should validate context HMAC when HMAC is enabled and context is provided', async () => {
    const command: SessionCommand = {
      requestData: {
        applicationIdentifier: 'app-id',
        subscriber: { subscriberId: 'subscriber-id' },
        subscriberHash: 'subscriber-hash',
        context: { teamId: 'team-123' },
        contextHash: 'context-hash',
      },
    };

    const environment = {
      _id: 'env-id',
      _organizationId: 'org-id',
      name: 'env-name',
      apiKeys: [{ key: 'api-key' }],
    };
    const organization = { _id: 'org-id', apiServiceLevel: ApiServiceLevelEnum.FREE };
    const subscriber = { _id: 'subscriber-id' };
    const notificationCount = { data: [{ count: 10, filter: {} }] };
    const token = 'token';
    const mockContexts = [{ key: 'teamId:team-123' }];

    environmentRepository.findEnvironmentByIdentifier.resolves(environment as any);
    organizationRepository.findById.resolves(organization as any);
    selectIntegration.execute.resolves(mockIntegration);
    createSubscriber.execute.resolves(subscriber as any);
    notificationsCount.execute.resolves(notificationCount);
    authService.getSubscriberWidgetToken.resolves(token);
    getOrganizationSettingsUsecase.execute.resolves({
      removeNovuBranding: false,
      defaultLocale: 'en_US',
    });
    featureFlagsService.getFlag.resolves(true);
    contextRepository.findOrCreateContextsFromPayload.resolves(mockContexts as any);

    const validateHmacEncryptionStub = sinon.stub(encryption, 'validateHmacEncryption');
    const validateContextHmacEncryptionStub = sinon.stub(encryption, 'validateContextHmacEncryption');

    await session.execute(command);

    expect(validateContextHmacEncryptionStub.calledOnce).to.be.true;
    expect(
      validateContextHmacEncryptionStub.calledWith(
        sinon.match({
          apiKey: environment.apiKeys[0].key,
          context: command.requestData.context,
          contextHash: command.requestData.contextHash,
        })
      )
    ).to.be.true;

    validateHmacEncryptionStub.restore();
    validateContextHmacEncryptionStub.restore();
  });

  it('should return empty contextKeys array when no context is provided', async () => {
    const command: SessionCommand = {
      requestData: {
        applicationIdentifier: 'app-id',
        subscriber: { subscriberId: 'subscriber-id' },
      },
    };

    const environment = {
      _id: 'env-id',
      _organizationId: 'org-id',
      name: 'env-name',
      apiKeys: [{ key: 'api-key' }],
    };
    const organization = { _id: 'org-id', apiServiceLevel: ApiServiceLevelEnum.FREE };
    const subscriber = { _id: 'subscriber-id' };
    const notificationCount = { data: [{ count: 10, filter: {} }] };
    const token = 'token';

    environmentRepository.findEnvironmentByIdentifier.resolves(environment as any);
    organizationRepository.findById.resolves(organization as any);
    selectIntegration.execute.resolves({ ...mockIntegration, credentials: { hmac: false } });
    createSubscriber.execute.resolves(subscriber as any);
    notificationsCount.execute.resolves(notificationCount);
    authService.getSubscriberWidgetToken.resolves(token);
    getOrganizationSettingsUsecase.execute.resolves({
      removeNovuBranding: false,
      defaultLocale: 'en_US',
    });
    featureFlagsService.getFlag.resolves(true);

    const response: SubscriberSessionResponseDto = await session.execute(command);

    expect(contextRepository.findOrCreateContextsFromPayload.called).to.be.false;

    expect(response.contextKeys).to.deep.equal([]);
  });
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockSeverityCounts([
  { severity: SeverityLevelEnum.HIGH, count: 10 },
  { severity: SeverityLevelEnum.MEDIUM, count: ...)
 - session(new Session(
      environmentRepository as any,
      createSubscriber as any,
      authService as...)
 - SessionCommand({
      requestData: {
        applicationIdentifier: 'invalid-app-id',
        subscriber: {
      ...)
 - SessionCommand({
      requestData: {
        applicationIdentifier: 'app-id',
        subscriber: {
          subs...)
 - validateHmacEncryptionStub(sinon.stub(encryption, 'validateHmacEncryption');

    await session.execute(command);

    expect(v...)
 - SubscriberSessionResponseDto(await session.execute(command);
    expect(responseWithRemoveNovuBranding.removeNovuBranding).to.equ...)
 - SubscriberSessionResponseDto(await session.execute(command);

    expect(response.token).to.equal(token);
    expect(response.unr...)
 - SubscriberSessionResponseDto(await session.execute(command);
    expect(enterpriseResponse.maxSnoozeDurationHours).to.equal(90 * ...)
 - SubscriberSessionResponseDto(await session.execute(command);

    expect(contextRepository.findOrCreateContextsFromPayload.called...)
 - validateContextHmacEncryptionStub(sinon.stub(encryption, 'validateContextHmacEncryption');

    await session.execute(command);

    e...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/session/session.usecase.ts
TamaÃ±o: 28725 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  NotFoundException,
  UnprocessableEntityException,
} from '@nestjs/common';
import {
  AnalyticsService,
  CreateOrUpdateSubscriberCommand,
  CreateOrUpdateSubscriberUseCase,
  encryptApiKey,
  FeatureFlagsService,
  GetSubscriberSchedule,
  GetSubscriberScheduleCommand,
  generateTimestampHex,
  LogDecorator,
  PinoLogger,
  SelectIntegration,
  SelectIntegrationCommand,
  shortId,
  UpsertControlValuesCommand,
  UpsertControlValuesUseCase,
} from '@novu/application-generic';
import {
  CommunityOrganizationRepository,
  CommunityUserRepository,
  ContextRepository,
  EnvironmentEntity,
  EnvironmentRepository,
  IntegrationRepository,
  MessageRepository,
  MessageTemplateRepository,
  NotificationTemplateRepository,
  PreferencesRepository,
  SubscriberEntity,
} from '@novu/dal';
import {
  ApiServiceLevelEnum,
  ChannelTypeEnum,
  ContextPayload,
  ControlValuesLevelEnum,
  CustomDataType,
  FeatureFlagsKeysEnum,
  FeatureNameEnum,
  getFeatureForTierAsNumber,
  InAppProviderIdEnum,
  PreferenceLevelEnum,
  PreferencesTypeEnum,
  ResourceOriginEnum,
  ResourceTypeEnum,
  Schedule,
  StepTypeEnum,
} from '@novu/shared';
import { createHash } from 'crypto';
import { differenceInHours } from 'date-fns';
import { AuthService } from '../../../auth/services/auth.service';
import { EnvironmentResponseDto } from '../../../environments-v1/dtos/environment-response.dto';
import { GenerateUniqueApiKey } from '../../../environments-v1/usecases/generate-unique-api-key/generate-unique-api-key.usecase';
import { CreateNovuIntegrationsCommand } from '../../../integrations/usecases/create-novu-integrations/create-novu-integrations.command';
import { CreateNovuIntegrations } from '../../../integrations/usecases/create-novu-integrations/create-novu-integrations.usecase';
import { GetOrganizationSettingsCommand } from '../../../organization/usecases/get-organization-settings/get-organization-settings.command';
import { GetOrganizationSettings } from '../../../organization/usecases/get-organization-settings/get-organization-settings.usecase';
import { ScheduleDto } from '../../../shared/dtos/schedule';
import { isHmacValid } from '../../../shared/helpers/is-valid-hmac';
import { SubscriberDto, SubscriberSessionRequestDto } from '../../dtos/subscriber-session-request.dto';
import { SubscriberSessionResponseDto } from '../../dtos/subscriber-session-response.dto';
import { AnalyticsEventsEnum } from '../../utils';
import { validateContextHmacEncryption, validateHmacEncryption } from '../../utils/encryption';
import { NotificationsCountCommand } from '../notifications-count/notifications-count.command';
import { NotificationsCount } from '../notifications-count/notifications-count.usecase';
import { UpdatePreferencesCommand } from '../update-preferences/update-preferences.command';
import { UpdatePreferences } from '../update-preferences/update-preferences.usecase';
import { SessionCommand } from './session.command';

const ALLOWED_ORIGINS_REGEX = new RegExp(process.env.FRONT_BASE_URL || '');
const KEYLESS_RETENTION_TIME_IN_HOURS = parseInt(process.env.KEYLESS_RETENTION_TIME_IN_HOURS || '', 10) || 24;
const MAX_NOTIFICATIONS_COUNT = 99;

@Injectable()
export class Session {
  private readonly KEYLESS_ENVIRONMENT_PREFIX = 'pk_keyless_';

  constructor(
    private environmentRepository: EnvironmentRepository,
    private createSubscriber: CreateOrUpdateSubscriberUseCase,
    private authService: AuthService,
    private selectIntegration: SelectIntegration,
    private analyticsService: AnalyticsService,
    private notificationsCount: NotificationsCount,
    private integrationRepository: IntegrationRepository,
    private organizationRepository: CommunityOrganizationRepository,
    private communityOrganizationRepository: CommunityOrganizationRepository,
    private contextRepository: ContextRepository,
    private generateUniqueApiKey: GenerateUniqueApiKey,
    private createNovuIntegrationsUsecase: CreateNovuIntegrations,
    private communityUserRepository: CommunityUserRepository,
    private notificationTemplateRepository: NotificationTemplateRepository,
    private messageTemplateRepository: MessageTemplateRepository,
    private messageRepository: MessageRepository,
    private preferencesRepository: PreferencesRepository,
    private upsertControlValuesUseCase: UpsertControlValuesUseCase,
    private getOrganizationSettingsUsecase: GetOrganizationSettings,
    private logger: PinoLogger,
    private featureFlagsService: FeatureFlagsService,
    private getSubscriberSchedule: GetSubscriberSchedule,
    private updatePreferencesUsecase: UpdatePreferences
  ) {
    this.logger.setContext(this.constructor.name);
  }

  @LogDecorator()
  async execute(command: SessionCommand): Promise<SubscriberSessionResponseDto> {
    this.validateRequestData(command.requestData);

    const subscriber = this.buildPlatformSubscriber(command.requestData);
    const applicationIdentifier = await this.getApplicationIdentifier(command.requestData);

    const environment = await this.environmentRepository.findEnvironmentByIdentifier(applicationIdentifier);
    if (!environment) {
      throw new BadRequestException('Please provide a valid application identifier');
    }

    const inAppIntegration = await this.selectIntegration.execute(
      SelectIntegrationCommand.create({
        environmentId: environment._id,
        organizationId: environment._organizationId,
        channelType: ChannelTypeEnum.IN_APP,
        providerId: InAppProviderIdEnum.Novu,
        filterData: {},
      })
    );

    if (!inAppIntegration) {
      throw new NotFoundException('The active in-app integration could not be found');
    }

    if (inAppIntegration.credentials.hmac) {
      validateHmacEncryption({
        apiKey: environment.apiKeys[0].key,
        subscriberId: subscriber.subscriberId,
        subscriberHash: command.requestData.subscriberHash,
      });

      if (command.requestData.context) {
        validateContextHmacEncryption({
          apiKey: environment.apiKeys[0].key,
          context: command.requestData.context,
          contextHash: command.requestData.contextHash,
        });
      }
    }

    const contextKeys = await this.resolveContexts(
      environment._id,
      environment._organizationId,
      command.requestData.context
    );

    const subscriberEntity = await this.createSubscriber.execute(
      CreateOrUpdateSubscriberCommand.create({
        environmentId: environment._id,
        organizationId: environment._organizationId,
        subscriberId: subscriber.subscriberId,
        firstName: subscriber.firstName,
        lastName: subscriber.lastName,
        phone: subscriber.phone,
        email: subscriber.email,
        avatar: subscriber.avatar,
        data: subscriber.data as CustomDataType,
        timezone: subscriber.timezone,
        allowUpdate: isHmacValid(
          environment.apiKeys[0].key,
          subscriber.subscriberId,
          command.requestData.subscriberHash
        ),
      })
    );

    this.analyticsService.mixpanelTrack(AnalyticsEventsEnum.SESSION_INITIALIZED, '', {
      _organization: environment._organizationId,
      environmentName: environment.name,
      _subscriber: subscriberEntity._id,
      origin: command.requestData.applicationIdentifier ? command.origin : 'keyless',
      context: contextKeys,
    });

    const { data } = await this.notificationsCount.execute(
      NotificationsCountCommand.create({
        organizationId: environment._organizationId,
        environmentId: environment._id,
        subscriberId: subscriber.subscriberId,
        filters: [{ read: false, snoozed: false }],
        subscriber: subscriberEntity,
        contextKeys,
      })
    );
    const [{ count: totalUnreadCount }] = data;

    // get severity-based unread counts
    const severityCounts = await this.messageRepository.getCountBySeverity(
      environment._id,
      subscriberEntity._id,
      ChannelTypeEnum.IN_APP,
      { read: false, snoozed: false },
      { limit: MAX_NOTIFICATIONS_COUNT },
      contextKeys
    );

    const unreadCount: SubscriberSessionResponseDto['unreadCount'] = {
      total: totalUnreadCount,
      severity: {
        high: 0,
        medium: 0,
        low: 0,
        none: 0,
      },
    };

    for (const { severity, count } of severityCounts) {
      if (severity in unreadCount.severity) {
        unreadCount.severity[severity] = count;
      }
    }

    const [token, organization] = await Promise.all([
      this.authService.getSubscriberWidgetToken(subscriberEntity, contextKeys),
      this.organizationRepository.findById(environment._organizationId),
    ]);

    if (!organization) {
      throw new NotFoundException('Organization not found');
    }

    const schedulePromise = this.createDefaultSchedule({
      environment,
      defaultSchedule: command.requestData.defaultSchedule,
      subscriber: subscriberEntity,
    });

    const [{ removeNovuBranding }, maxSnoozeDurationHours, schedule] = await Promise.all([
      this.getOrganizationSettingsUsecase.execute(
        GetOrganizationSettingsCommand.create({
          organizationId: environment._organizationId,
          organization,
        })
      ),
      this.getMaxSnoozeDurationHours(organization.apiServiceLevel),
      schedulePromise,
    ]);

    /**
     * We want to prevent the playground inbox demo from marking the integration as connected
     * And only treat the real customer domain or local environment as valid origins
     */
    const isOriginFromNovu = ALLOWED_ORIGINS_REGEX.test(command.origin ?? '');
    if (!isOriginFromNovu && !inAppIntegration.connected) {
      this.analyticsService.mixpanelTrack(AnalyticsEventsEnum.INBOX_CONNECTED, '', {
        _organization: environment._organizationId,
        environmentName: environment.name,
      });

      await this.integrationRepository.updateOne(
        {
          _id: inAppIntegration._id,
          _organizationId: environment._organizationId,
          _environmentId: environment._id,
        },
        {
          $set: {
            connected: true,
          },
        }
      );
    }

    return {
      applicationIdentifier: environment.identifier,
      token,
      totalUnreadCount,
      unreadCount,
      removeNovuBranding,
      maxSnoozeDurationHours,
      isDevelopmentMode: environment.name.toLowerCase() !== 'production',
      schedule,
      contextKeys,
    };
  }

  private async createDefaultSchedule({
    environment,
    defaultSchedule,
    subscriber,
  }: {
    environment: EnvironmentEntity;
    defaultSchedule?: ScheduleDto;
    subscriber: SubscriberEntity;
  }): Promise<Schedule | undefined> {
    const isSubscribersScheduleEnabled = await this.featureFlagsService.getFlag({
      key: FeatureFlagsKeysEnum.IS_SUBSCRIBERS_SCHEDULE_ENABLED,
      defaultValue: false,
      environment: { _id: environment._id },
      organization: { _id: environment._organizationId },
    });

    if (!isSubscribersScheduleEnabled) {
      return undefined;
    }

    const schedule = await this.getSubscriberSchedule.execute(
      GetSubscriberScheduleCommand.create({
        organizationId: environment._organizationId,
        environmentId: environment._id,
        _subscriberId: subscriber._id,
      })
    );

    if (schedule || !defaultSchedule) {
      return schedule;
    }

    const updatedGlobalPreference = await this.updatePreferencesUsecase.execute(
      UpdatePreferencesCommand.create({
        organizationId: environment._organizationId,
        environmentId: environment._id,
        subscriber,
        subscriberId: subscriber.subscriberId,
        level: PreferenceLevelEnum.GLOBAL,
        includeInactiveChannels: false,
        schedule: defaultSchedule,
      })
    );

    return updatedGlobalPreference.schedule;
  }

  private validateRequestData(requestData: SubscriberSessionRequestDto): void {
    if (!requestData.applicationIdentifier && this.extractSubscriberInfo(requestData, true)?.subscriberId) {
      throw new UnprocessableEntityException(
        'A valid application identifier is required when providing subscriber information'
      );
    }
  }

  private buildPlatformSubscriber(requestData: SubscriberSessionRequestDto): SubscriberDto {
    if (!requestData.applicationIdentifier || this.isKeylessApplication(requestData.applicationIdentifier)) {
      return { subscriberId: 'keyless-subscriber-id' };
    }

    return this.extractSubscriberInfo(requestData);
  }

  private isKeylessApplication(applicationIdentifier: string): boolean {
    return applicationIdentifier.startsWith(this.KEYLESS_ENVIRONMENT_PREFIX);
  }

  private extractSubscriberInfo(requestData: SubscriberSessionRequestDto): SubscriberDto;
  private extractSubscriberInfo(requestData: SubscriberSessionRequestDto, safe: true): SubscriberDto | null;
  private extractSubscriberInfo(requestData: SubscriberSessionRequestDto, safe: boolean = false): SubscriberDto | null {
    const subscriber: SubscriberDto | null = this.normalizeSubscriber(requestData.subscriber);

    if (subscriber?.subscriberId) {
      return subscriber;
    }

    // TODO: Backward compatibility support - remove in future versions (see NV-5801)
    if (requestData.subscriberId) {
      return { subscriberId: requestData.subscriberId };
    }

    if (safe) {
      return null;
    }

    throw new UnprocessableEntityException('Subscriber ID is required');
  }

  private normalizeSubscriber(subscriber: string | SubscriberDto | null | undefined): SubscriberDto | null {
    if (!subscriber) {
      return null;
    }

    if (typeof subscriber === 'string') {
      return { subscriberId: subscriber };
    }

    return subscriber;
  }

  private async getApplicationIdentifier(requestData: SubscriberSessionRequestDto): Promise<string> {
    const isKeylessInitialize = !requestData.applicationIdentifier;
    const isKeyless = requestData.applicationIdentifier?.includes(this.KEYLESS_ENVIRONMENT_PREFIX);
    const isKeylessExpired = isKeyless ? await this.isKeylessExpired(requestData.applicationIdentifier) : false;

    const applicationIdentifier =
      isKeylessInitialize || isKeylessExpired
        ? (await this.processKeyless()).identifier
        : requestData.applicationIdentifier;

    return applicationIdentifier;
  }

  private async resolveContexts(
    environmentId: string,
    organizationId: string,
    context?: ContextPayload
  ): Promise<string[] | undefined> {
    const isContextsEnabled = await this.featureFlagsService.getFlag({
      key: FeatureFlagsKeysEnum.IS_CONTEXT_ENABLED,
      defaultValue: false,
      environment: { _id: environmentId },
      organization: { _id: organizationId },
    });

    if (!isContextsEnabled) {
      return undefined;
    }

    if (!context) {
      return [];
    }

    const contexts = await this.contextRepository.findOrCreateContextsFromPayload(
      environmentId,
      organizationId,
      context
    );

    return contexts.map((context) => context.key);
  }

  private async getMaxSnoozeDurationHours(apiServiceLevel: ApiServiceLevelEnum) {
    if (process.env.NOVU_ENTERPRISE !== 'true') {
      return 0;
    }

    const tierLimitMs = getFeatureForTierAsNumber(
      FeatureNameEnum.PLATFORM_MAX_SNOOZE_DURATION,
      apiServiceLevel || ApiServiceLevelEnum.FREE,
      true
    );

    return tierLimitMs / 1000 / 60 / 60;
  }

  async isKeylessExpired(applicationIdentifier: string | undefined) {
    if (!applicationIdentifier) {
      return true; // If no identifier is provided, consider it expired
    }

    const parts = applicationIdentifier.replace(this.KEYLESS_ENVIRONMENT_PREFIX, '').split('_');
    if (parts.length < 1) {
      return true; // Invalid format, consider expired
    }

    const createdDate = parts[0];

    if (!createdDate || createdDate.length < 8) {
      // Ensure we have at least 4 bytes (8 hex chars)
      return true; // Invalid timestamp format, consider expired
    }

    try {
      const createdDateTimestamp = timestampHexToDate(createdDate);
      const now = new Date();
      const diffTimeInHours = differenceInHours(now, createdDateTimestamp);

      if (diffTimeInHours > KEYLESS_RETENTION_TIME_IN_HOURS) {
        return true;
      }
    } catch (error) {
      this.logger.error({ err: error }, 'Error parsing timestamp');

      // If there's any error parsing the timestamp, consider it expired
      return true;
    }

    return false;
  }

  async processKeyless(): Promise<EnvironmentResponseDto> {
    if (process.env.NOVU_ENTERPRISE !== 'true') {
      throw new BadRequestException('Keyless is not supported in community edition');
    }

    const organization = await this.communityOrganizationRepository.findById(process.env.KEYLESS_ORGANIZATION_ID!);

    if (!organization) {
      this.logger.error('Keyless Organization not found');
      throw new InternalServerErrorException('Keyless Organization not found');
    }

    const isKeylessEnabled = await this.featureFlagsService.getFlag({
      key: FeatureFlagsKeysEnum.IS_KEYLESS_ENVIRONMENT_CREATION_ENABLED,
      defaultValue: false,
      organization,
    });

    if (!isKeylessEnabled) {
      throw new BadRequestException('Keyless environment creation is currently disabled.');
    }

    const user = await this.communityUserRepository.findByEmail(process.env.KEYLESS_USER_EMAIL!);

    if (!user) {
      throw new InternalServerErrorException('Keyless User not found');
    }

    const key = `sk_${await this.generateUniqueApiKey.execute()}`;
    const encryptedApiKey = encryptApiKey(key);
    const hashedApiKey = createHash('sha256').update(key).digest('hex');

    const encodedDate = generateTimestampHex();
    const identifier = `${this.KEYLESS_ENVIRONMENT_PREFIX}${encodedDate}_${shortId(4)}`;
    const environment = await this.environmentRepository.create({
      _organizationId: organization._id,
      name: `Keyless ${new Date().toISOString()}`,
      identifier,
      apiKeys: [
        {
          key: encryptedApiKey,
          _userId: user._id,
          hash: hashedApiKey,
        },
      ],
    });

    await this.createNovuIntegrationsUsecase.execute(
      CreateNovuIntegrationsCommand.create({
        environmentId: environment._id,
        organizationId: environment._organizationId,
        userId: user._id,
        name: 'Keyless Integration',
        channels: [ChannelTypeEnum.IN_APP],
      })
    );

    await this.createWorkflowsUsecase(environment._id, environment._organizationId, user._id);

    const environmentDto = this.convertEnvironmentEntityToDto(environment);

    this.logger.info('Keyless environment created successfully');

    return environmentDto;
  }

  async createWorkflowsUsecase(environmentId: string, organizationId: string, userId: string) {
    const inAppTemplate = await this.messageTemplateRepository.create({
      type: StepTypeEnum.IN_APP,
      content: '',
      avatar: 'https://dashboard.novu.co/images/info.svg',
      _environmentId: environmentId,
      _organizationId: organizationId,
      _creatorId: userId,
      active: true,
      name: 'In-App Notification',
      controls: {
        schema: {
          type: 'object',
          properties: {
            subject: {
              type: 'string',
            },
            body: {
              type: 'string',
            },
            skip: {
              type: 'object',
            },
            disableOutputSanitization: {
              type: 'boolean',
            },
            avatar: {
              type: 'string',
              pattern:
                '^(?:\\{\\{[^}]*\\}\\}.*|(?!mailto:)(?:https?:\\/\\/[^\\s/$.?#][^\\s]*(?:\\{\\{[^}]*\\}\\})*[^\\s]*)|\\/[^\\s]*(?:\\{\\{[^}]*\\}\\})*[^\\s]*)$',
            },
            primaryAction: {
              type: 'object',
              properties: {
                label: {
                  type: 'string',
                },
                redirect: {
                  type: 'object',
                  properties: {
                    url: {
                      type: 'string',
                      pattern:
                        '^(?:\\{\\{[^}]*\\}\\}.*|(?!mailto:)(?:https?:\\/\\/[^\\s/$.?#][^\\s]*(?:\\{\\{[^}]*\\}\\})*[^\\s]*)|\\/[^\\s]*(?:\\{\\{[^}]*\\}\\})*[^\\s]*)$',
                    },
                    target: {
                      type: 'string',
                      enum: ['_self', '_blank', '_parent', '_top', '_unfencedTop'],
                    },
                  },
                  required: ['url', 'target'],
                  additionalProperties: false,
                },
              },
              required: ['label'],
              additionalProperties: false,
            },
            secondaryAction: {
              type: 'object',
              properties: {
                label: {
                  type: 'string',
                },
                redirect: {
                  type: 'object',
                  properties: {
                    url: {
                      type: 'string',
                      pattern:
                        '^(?:\\{\\{[^}]*\\}\\}.*|(?!mailto:)(?:https?:\\/\\/[^\\s/$.?#][^\\s]*(?:\\{\\{[^}]*\\}\\})*[^\\s]*)|\\/[^\\s]*(?:\\{\\{[^}]*\\}\\})*[^\\s]*)$',
                    },
                    target: {
                      type: 'string',
                      enum: ['_self', '_blank', '_parent', '_top', '_unfencedTop'],
                    },
                  },
                  required: ['url', 'target'],
                  additionalProperties: false,
                },
              },
              required: ['label'],
              additionalProperties: false,
            },
            data: {
              type: 'object',
            },
            redirect: {
              type: 'object',
              properties: {
                url: {
                  type: 'string',
                  pattern:
                    '^(?:\\{\\{[^}]*\\}\\}.*|(?!mailto:)(?:https?:\\/\\/[^\\s/$.?#][^\\s]*(?:\\{\\{[^}]*\\}\\})*[^\\s]*)|\\/[^\\s]*(?:\\{\\{[^}]*\\}\\})*[^\\s]*)$',
                },
                target: {
                  type: 'string',
                  enum: ['_self', '_blank', '_parent', '_top', '_unfencedTop'],
                },
              },
              required: ['url', 'target'],
              additionalProperties: false,
            },
          },
          additionalProperties: false,
        },
        uiSchema: {
          group: 'IN_APP',
          properties: {
            body: {
              component: 'IN_APP_BODY',
              placeholder: '',
            },
            avatar: {
              component: 'IN_APP_AVATAR',
              placeholder: 'https://dashboard.novu.co/images/info.svg',
            },
            subject: {
              component: 'IN_APP_PRIMARY_SUBJECT',
              placeholder: '',
            },
            primaryAction: {
              component: 'IN_APP_BUTTON_DROPDOWN',
              placeholder: null,
            },
            secondaryAction: {
              component: 'IN_APP_BUTTON_DROPDOWN',
              placeholder: null,
            },
            redirect: {
              component: 'URL_TEXT_BOX',
              placeholder: {
                url: {
                  placeholder: '',
                },
                target: {
                  placeholder: '_self',
                },
              },
            },
            skip: {
              component: 'QUERY_EDITOR',
            },
            disableOutputSanitization: {
              component: 'IN_APP_DISABLE_SANITIZATION_SWITCH',
              placeholder: false,
            },
            data: {
              component: 'DATA',
              placeholder: null,
            },
          },
        },
      },
    });

    const workflow = await this.notificationTemplateRepository.create({
      _environmentId: environmentId,
      _organizationId: organizationId,
      _creatorId: userId,
      name: 'Hello World!',
      description: 'A hello world workflow',
      active: true,
      draft: false,
      critical: false,
      tags: [],
      type: ResourceTypeEnum.BRIDGE,
      origin: ResourceOriginEnum.NOVU_CLOUD,
      steps: [
        {
          name: 'In-App Notification',
          template: inAppTemplate,
          active: true,
          stepId: 'in-app-step',
          filters: [],
          _templateId: inAppTemplate._id,
          _id: inAppTemplate._id,
        },
      ],
      triggers: [
        {
          type: 'event',
          identifier: 'hello-world',
          variables: [
            { name: 'subject', type: 'string' },
            { name: 'body', type: 'string' },
          ],
        },
      ],
    });

    await this.preferencesRepository.create({
      _templateId: workflow._id,
      _environmentId: environmentId,
      _organizationId: organizationId,
      _userId: userId,
      type: PreferencesTypeEnum.USER_WORKFLOW,
      preferences: {
        all: {
          enabled: true,
          readOnly: false,
        },
        channels: {
          [ChannelTypeEnum.IN_APP]: {
            enabled: true,
            readOnly: false,
          },
          [ChannelTypeEnum.EMAIL]: {
            enabled: true,
            readOnly: false,
          },
          [ChannelTypeEnum.SMS]: {
            enabled: true,
            readOnly: false,
          },
          [ChannelTypeEnum.PUSH]: {
            enabled: true,
            readOnly: false,
          },
          [ChannelTypeEnum.CHAT]: {
            enabled: true,
            readOnly: false,
          },
        },
      },
    });

    await this.preferencesRepository.create({
      _templateId: workflow._id,
      _environmentId: environmentId,
      _organizationId: organizationId,
      _userId: userId,
      type: PreferencesTypeEnum.WORKFLOW_RESOURCE,
      preferences: {
        all: {
          enabled: true,
          readOnly: false,
        },
        channels: {
          [ChannelTypeEnum.IN_APP]: {
            enabled: true,
            readOnly: false,
          },
          [ChannelTypeEnum.EMAIL]: {
            enabled: true,
            readOnly: false,
          },
          [ChannelTypeEnum.SMS]: {
            enabled: true,
            readOnly: false,
          },
          [ChannelTypeEnum.PUSH]: {
            enabled: true,
            readOnly: false,
          },
          [ChannelTypeEnum.CHAT]: {
            enabled: true,
            readOnly: false,
          },
        },
      },
    });

    await this.upsertControlValuesUseCase.execute(
      UpsertControlValuesCommand.create({
        organizationId,
        environmentId,
        stepId: workflow.steps[0]._templateId,
        level: ControlValuesLevelEnum.STEP_CONTROLS,
        workflowId: workflow._id,
        newControlValues: {
          body: '{{payload.body}}',
          avatar: 'https://dashboard.novu.co/images/avatar.svg',
          subject: '{{payload.subject}}',
          primaryAction: {
            label: '{{payload.primaryActionText}}',
            redirect: {
              url: '{{payload.primaryActionUrl}}',
              target: '_blank',
            },
          },
          secondaryAction: {
            label: '{{payload.secondaryActionText}}',
            redirect: {
              url: '{{payload.secondaryActionUrl}}',
              target: '_blank',
            },
          },
          redirect: null,
          disableOutputSanitization: false,
          data: null,
        },
      })
    );

    return workflow;
  }

  private convertEnvironmentEntityToDto(environment: EnvironmentEntity) {
    const dto = new EnvironmentResponseDto();

    dto._id = environment._id;
    dto.name = environment.name;
    dto._organizationId = environment._organizationId;
    dto.identifier = environment.identifier;
    dto._parentId = environment._parentId;

    if (environment.apiKeys && environment.apiKeys.length > 0) {
      dto.apiKeys = environment.apiKeys.map((apiKey) => ({
        key: apiKey.key,
        hash: apiKey.hash,
        _userId: apiKey._userId,
      }));
    }

    return dto;
  }
}

function timestampHexToDate(timestampHex) {
  if (!timestampHex || typeof timestampHex !== 'string' || timestampHex.length < 8) {
    throw new Error('Invalid timestamp hex format');
  }

  const buffer = Buffer.from(timestampHex, 'hex');
  if (buffer.length < 4) {
    throw new Error('Buffer too small to read 32-bit integer');
  }

  const timestamp = buffer.readUInt32BE(0);

  return new Date(timestamp * 1000);
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - timestampHexToDate(timestampHex)
Asignaciones con arrow functions encontradas (posibles funciones):
 - contexts(await this.contextRepository.findOrCreateContextsFromPayload(
      environmentId,
      organizatio...)
 - apiKeys(environment.apiKeys.map((apiKey))
Declaraciones 'export' encontradas:
- export class Session

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/snooze-notification/snooze-notification.command.ts
TamaÃ±o: 398 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Type } from 'class-transformer';
import { IsDate, IsDefined, IsMongoId } from 'class-validator';
import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class SnoozeNotificationCommand extends EnvironmentWithSubscriber {
  @IsDefined()
  @IsMongoId()
  readonly notificationId: string;

  @Type(() => Date)
  @IsDate()
  readonly snoozeUntil: Date;
}


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Declaraciones 'export' encontradas:
- export class SnoozeNotificationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÃ“N ###

- Revisa package.json para dependencias y scripts.
- Usa mÃ³dulos (import/export) y prueba con node o bundler.
- AÃ±ade un README con pasos de instalaciÃ³n (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/snooze-notification/snooze-notification.spec.ts
TamaÃ±o: 9220 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpException, HttpStatus, NotFoundException } from '@nestjs/common';
import {
  AnalyticsService,
  CreateExecutionDetails,
  CreateExecutionDetailsCommand,
  PinoLogger,
  StandardQueueService,
} from '@novu/application-generic';
import {
  CommunityOrganizationRepository,
  JobEntity,
  JobRepository,
  MessageEntity,
  MessageRepository,
  OrganizationEntity,
} from '@novu/dal';
import { ApiServiceLevelEnum, ChannelTypeEnum, JobStatusEnum, SeverityLevelEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { InboxNotification } from '../../utils/types';
import { MarkNotificationAsCommand } from '../mark-notification-as/mark-notification-as.command';
import { MarkNotificationAs } from '../mark-notification-as/mark-notification-as.usecase';
import { SnoozeNotificationCommand } from './snooze-notification.command';
import { SnoozeNotification } from './snooze-notification.usecase';

describe('SnoozeNotification', () => {
  const validNotificationId = '507f1f77bcf86cd799439011';
  const validEnvId = '507f1f77bcf86cd799439012';
  const validOrgId = '507f1f77bcf86cd799439013';
  const validJobId = '507f1f77bcf86cd799439014';
  const validSubscriberId = '507f1f77bcf86cd799439015';

  // Snooze durations in days
  const SNOOZE_DURATION = {
    ONE_HOUR: 1 / 24,
    ONE_DAY: 1,
    THIRTY_DAYS: 30, // Exceeds free tier limit
    NINETY_DAYS: 90, // Paid tier max
    HUNDRED_DAYS: 100, // Exceeds paid tier limit
  };

  let snoozeNotification: SnoozeNotification;
  let loggerMock: sinon.SinonStubbedInstance<PinoLogger>;
  let messageRepositoryMock: sinon.SinonStubbedInstance<MessageRepository>;
  let jobRepositoryMock: sinon.SinonStubbedInstance<JobRepository>;
  let standardQueueServiceMock: sinon.SinonStubbedInstance<StandardQueueService>;
  let organizationRepositoryMock: sinon.SinonStubbedInstance<CommunityOrganizationRepository>;
  let createExecutionDetailsMock: sinon.SinonStubbedInstance<CreateExecutionDetails>;
  let markNotificationAsMock: sinon.SinonStubbedInstance<MarkNotificationAs>;
  let analyticsServiceMock: sinon.SinonStubbedInstance<AnalyticsService>;

  const mockMessage: MessageEntity = {
    _id: validNotificationId,
    _jobId: validJobId,
    _environmentId: validEnvId,
    channel: ChannelTypeEnum.IN_APP,
    _subscriberId: validSubscriberId,
  } as MessageEntity;

  const mockJob: JobEntity = {
    _id: validJobId,
    _environmentId: validEnvId,
    _organizationId: validOrgId,
    _userId: validSubscriberId,
    payload: {
      subscriberId: validSubscriberId,
    },
    transactionId: 'transaction-id',
    status: JobStatusEnum.PENDING,
  } as JobEntity;

  const mockNotification: InboxNotification = {
    id: validNotificationId,
    transactionId: 'transaction-id',
    body: 'Test notification',
    to: {
      subscriberId: validSubscriberId,
      id: validSubscriberId,
    },
    isSeen: false,
    isRead: false,
    isArchived: false,
    isSnoozed: true,
    snoozedUntil: new Date().toISOString(),
    createdAt: new Date().toISOString(),
    channelType: ChannelTypeEnum.IN_APP,
    severity: SeverityLevelEnum.NONE,
  };

  beforeEach(() => {
    loggerMock = sinon.createStubInstance(PinoLogger);
    messageRepositoryMock = sinon.createStubInstance(MessageRepository);
    jobRepositoryMock = sinon.createStubInstance(JobRepository);
    standardQueueServiceMock = sinon.createStubInstance(StandardQueueService);
    organizationRepositoryMock = sinon.createStubInstance(CommunityOrganizationRepository);
    createExecutionDetailsMock = sinon.createStubInstance(CreateExecutionDetails);
    markNotificationAsMock = sinon.createStubInstance(MarkNotificationAs);
    analyticsServiceMock = sinon.createStubInstance(AnalyticsService);

    // Mock the MarkNotificationAsCommand.create method
    sinon.stub(MarkNotificationAsCommand, 'create').returns({
      environmentId: validEnvId,
      organizationId: validOrgId,
      subscriberId: validSubscriberId,
      notificationId: validNotificationId,
      snoozedUntil: new Date(),
    } as MarkNotificationAsCommand);

    sinon.stub(CreateExecutionDetailsCommand, 'create').returns({} as any);
    sinon.stub(CreateExecutionDetailsCommand, 'getDetailsFromJob').returns({} as any);

    // @ts-expect-error Mocking the withTransaction method
    messageRepositoryMock.withTransaction = sinon.stub().callsFake((callback) => callback());

    snoozeNotification = new SnoozeNotification(
      loggerMock as any,
      messageRepositoryMock as any,
      jobRepositoryMock as any,
      standardQueueServiceMock as any,
      organizationRepositoryMock as any,
      createExecutionDetailsMock as any,
      markNotificationAsMock as any,
      analyticsServiceMock as any
    );

    sinon.stub(JobRepository, 'createObjectId').returns('new-job-id');

    jobRepositoryMock.create.resolves(mockJob);
    jobRepositoryMock.findOne.resolves(mockJob);
    markNotificationAsMock.execute.resolves(mockNotification);
    createExecutionDetailsMock.execute.resolves();

    const orgEntity = {
      _id: validOrgId,
      name: 'Test Org',
      apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
      createdAt: '2023-01-01T00:00:00.000Z',
      updatedAt: '2023-01-01T00:00:00.000Z',
    } as OrganizationEntity;

    organizationRepositoryMock.findOne.resolves(orgEntity);
    standardQueueServiceMock.add.resolves();
    messageRepositoryMock.findOne.resolves(mockMessage);
  });

  afterEach(() => {
    sinon.restore();
  });

  it('should throw NotFoundException when notification is not found', async () => {
    const command = createCommand(SNOOZE_DURATION.ONE_HOUR);
    messageRepositoryMock.findOne.resolves(null);

    try {
      await snoozeNotification.execute(command);
      expect.fail('Should have thrown NotFoundException');
    } catch (err) {
      expect(err).to.be.instanceOf(NotFoundException);
    }
  });

  it('should throw HttpException when snooze duration exceeds free tier limit (24 hours)', async () => {
    // Testing with 30 days (exceeds free tier 24-hour limit)
    const command = createCommand(SNOOZE_DURATION.THIRTY_DAYS);

    // Set organization to free tier
    const freeOrgEntity = {
      _id: validOrgId,
      name: 'Test Org',
      apiServiceLevel: ApiServiceLevelEnum.FREE,
      createdAt: '2023-01-01T00:00:00.000Z',
      updatedAt: '2023-01-01T00:00:00.000Z',
    } as OrganizationEntity;

    organizationRepositoryMock.findOne.resolves(freeOrgEntity);

    try {
      await snoozeNotification.execute(command);
      expect.fail('Should have thrown HttpException');
    } catch (err) {
      expect(err).to.be.instanceOf(HttpException);
      expect(err.getStatus()).to.equal(HttpStatus.PAYMENT_REQUIRED);
    }
  });

  it('should throw HttpException when snooze duration exceeds paid tier limit (90 days)', async () => {
    // Create a command with duration exceeding 90 days (paid tier max)
    const command = createCommand(SNOOZE_DURATION.HUNDRED_DAYS);

    try {
      await snoozeNotification.execute(command);
      expect.fail('Should have thrown HttpException');
    } catch (err) {
      expect(err).to.be.instanceOf(HttpException);
      expect(err.getStatus()).to.equal(HttpStatus.PAYMENT_REQUIRED);
    }
  });

  it('should successfully snooze a notification', async () => {
    const command = createCommand(SNOOZE_DURATION.ONE_HOUR);

    const result = await snoozeNotification.execute(command);

    expect(result).to.deep.equal(mockNotification);
    expect(jobRepositoryMock.create.calledOnce).to.be.true;
    const createCallArg = jobRepositoryMock.create.firstCall.args[0];
    expect(createCallArg).to.have.property('status', JobStatusEnum.PENDING);
    expect(createCallArg).to.have.property('delay').that.is.a('number');
    expect(createCallArg.payload).to.have.property('unsnooze', true);

    expect(markNotificationAsMock.execute.calledOnce).to.be.true;
    expect(standardQueueServiceMock.add.calledOnce).to.be.true;
    expect(createExecutionDetailsMock.execute.called).to.be.true;
  });

  it('should enqueue job with correct parameters', async () => {
    const delay = 3600000; // 1 hour in milliseconds

    await snoozeNotification.enqueueJob(mockJob, delay);

    expect(standardQueueServiceMock.add.calledOnce).to.be.true;
    const addCallArg = standardQueueServiceMock.add.firstCall.args[0];

    expect(addCallArg.data).to.deep.equal({
      _environmentId: mockJob._environmentId,
      _id: mockJob._id,
      _organizationId: mockJob._organizationId,
      _userId: mockJob._userId,
    });

    if (addCallArg.options) {
      expect(addCallArg.options).to.have.property('delay', delay);
      expect(addCallArg.options).to.have.property('attempts', 3);
      expect(addCallArg.options.backoff).to.have.property('type', 'exponential');
    }
  });

  function createCommand(days: number): SnoozeNotificationCommand {
    const snoozeUntil = new Date();
    snoozeUntil.setDate(snoozeUntil.getDate() + days);

    return {
      environmentId: validEnvId,
      organizationId: validOrgId,
      subscriberId: validSubscriberId,
      notificationId: validNotificationId,
      snoozeUntil,
    } as SnoozeNotificationCommand;
  }
});


### ANALISIS AUTOMATICO (ESPAÃ‘OL) ###

Funciones 'function' encontradas:
 - createCommand(days: number)
Asignaciones con arrow functions encontradas (posibles funciones):
 - InboxNotification({
    id: validNotificationId,
    transactionId: 'transaction-id',
    body: 'Test notification',
 ...)
 - withTransaction(sinon.stub().callsFake((callback))
 - orgEntity({
      _id: validOrgId,
      name: 'Test Org',
      apiServiceLevel: ApiServiceLevelEnum.BUSINESS...)
 - command(createCommand(SNOOZE_DURATION.ONE_HOUR);
    messageRepositoryMock.findOne.resolves(null);

    try ...)
 - freeOrgEntity({
      _id: validOrgId,
      name: 'Test Org',
      apiServiceLevel: ApiServiceLevelEnum.FREE,
  ...)
 - command(createCommand(SNOOZE_DURATION.HUNDRED_DAYS);

    try {
      await snoozeNotification.execute(comma...)
 - createCallArg(jobRepositoryMock.create.firstCall.args[0];
    expect(createCallArg).to.have.property('status', Job...)

