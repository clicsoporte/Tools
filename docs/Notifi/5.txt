   "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Subscribers"],
        "security": [
          {
            "bearerAuth": []
          },
          {
            "secretKey": []
          }
        ]
      }
    },
    "/v1/subscribers/{subscriberId}/credentials/{providerId}/oauth/callback": {
      "get": {
        "operationId": "SubscribersV1Controller_chatOauthCallback",
        "x-speakeasy-name-override": "chatAccessOauthCallBack",
        "x-speakeasy-group": "Subscribers.Authentication",
        "summary": "Handle providers oauth redirect",
        "parameters": [
          {
            "name": "subscriberId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "providerId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "hmacHash",
            "required": true,
            "in": "query",
            "description": "HMAC hash for the request",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "environmentId",
            "required": true,
            "in": "query",
            "description": "The ID of the environment, must be a valid MongoDB ID",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "integrationIdentifier",
            "required": false,
            "in": "query",
            "description": "Optional integration identifier",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "code",
            "required": true,
            "in": "query",
            "description": "Optional authorization code returned from the OAuth provider",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns plain text response.",
            "content": {
              "text/html": {
                "schema": {
                  "type": "string"
                }
              }
            },
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            }
          },
          "302": {
            "description": "Redirects to the specified URL.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Location": {
                "description": "The URL to redirect to.",
                "schema": {
                  "type": "string",
                  "example": "https://www.novu.co"
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Subscribers"],
        "security": [
          {
            "secretKey": []
          }
        ]
      }
    },
    "/v1/subscribers/{subscriberId}/credentials/{providerId}/oauth": {
      "get": {
        "operationId": "SubscribersV1Controller_chatAccessOauth",
        "x-speakeasy-name-override": "chatAccessOauth",
        "x-speakeasy-group": "Subscribers.Authentication",
        "summary": "Handle chat oauth",
        "parameters": [
          {
            "name": "subscriberId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "providerId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "hmacHash",
            "required": true,
            "in": "query",
            "description": "HMAC hash for the request",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "environmentId",
            "required": true,
            "in": "query",
            "description": "The ID of the environment, must be a valid MongoDB ID",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "integrationIdentifier",
            "required": false,
            "in": "query",
            "description": "Optional integration identifier",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Subscribers"],
        "security": [
          {
            "secretKey": []
          }
        ]
      }
    },
    "/v2/subscribers": {
      "get": {
        "operationId": "SubscriberController_getSubscribers",
        "x-speakeasy-name-override": "search",
        "parameters": [
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Subscribers"],
        "security": [
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/v2/subscribers": {
      "get": {
        "operationId": "SubscribersController_searchSubscribers",
        "x-speakeasy-name-override": "search",
        "summary": "Search for subscribers",
        "parameters": [
          {
            "name": "after",
            "required": false,
            "in": "query",
            "description": "Cursor for pagination indicating the starting point after which to fetch results.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "before",
            "required": false,
            "in": "query",
            "description": "Cursor for pagination indicating the ending point before which to fetch results.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "email",
            "required": false,
            "in": "query",
            "description": "Email address of the subscriber to filter results.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "name",
            "required": false,
            "in": "query",
            "description": "Name of the subscriber to filter results.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "phone",
            "required": false,
            "in": "query",
            "description": "Phone number of the subscriber to filter results.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "subscriberId",
            "required": false,
            "in": "query",
            "description": "Unique identifier of the subscriber to filter results.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "orderDirection",
            "required": false,
            "in": "query",
            "schema": {
              "enum": ["ASC", "DESC"],
              "type": "string"
            }
          },
          {
            "name": "orderBy",
            "required": false,
            "in": "query",
            "schema": {}
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of subscribers retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSubscribersResponseDto"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Subscribers"],
        "security": [
          {
            "api-key": []
          },
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/v1/messages": {
      "get": {
        "operationId": "MessagesController_getMessages",
        "summary": "Get messages",
        "description": "Returns a list of messages, could paginate using the `page` query parameter",
        "parameters": [
          {
            "name": "channel",
            "required": false,
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/ChannelTypeEnum"
            }
          },
          {
            "name": "subscriberId",
            "required": false,
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "transactionId",
            "required": false,
            "in": "query",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "page",
            "required": false,
            "in": "query",
            "schema": {
              "default": 0,
              "type": "number"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "schema": {
              "default": 10,
              "type": "number"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActivitiesResponseDto"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Messages"],
        "security": [
          {
            "bearerAuth": []
          },
          {
            "secretKey": []
          }
        ]
      }
    },
    "/v1/messages/{messageId}": {
      "delete": {
        "operationId": "MessagesController_deleteMessage",
        "summary": "Delete message",
        "description": "Deletes a message entity from the Novu platform",
        "parameters": [
          {
            "name": "messageId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteMessageResponseDto"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Messages"],
        "security": [
          {
            "bearerAuth": []
          },
          {
            "secretKey": []
          }
        ]
      }
    },
    "/v1/messages/transaction/{transactionId}": {
      "delete": {
        "operationId": "MessagesController_deleteMessagesByTransactionId",
        "x-speakeasy-name-override": "deleteByTransactionId",
        "summary": "Delete messages by transactionId",
        "description": "Deletes messages entity from the Novu platform using TransactionId of message",
        "parameters": [
          {
            "name": "channel",
            "required": false,
            "in": "query",
            "description": "The channel of the message to be deleted",
            "schema": {
              "enum": ["in_app", "email", "sms", "chat", "push"],
              "type": "string"
            }
          },
          {
            "name": "transactionId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "description": ""
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Messages"],
        "security": [
          {
            "bearerAuth": []
          },
          {
            "secretKey": []
          }
        ]
      }
    },
    "/v1/topics": {
      "post": {
        "operationId": "TopicsController_createTopic",
        "summary": "Topic creation",
        "description": "Create a topic",
        "parameters": [
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTopicRequestDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateTopicResponseDto"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Topics"],
        "security": [
          {
            "bearerAuth": []
          },
          {
            "secretKey": []
          }
        ]
      },
      "get": {
        "operationId": "TopicsController_listTopics",
        "summary": "Get topic list filtered ",
        "description": "Returns a list of topics that can be paginated using the `page` query parameter and filtered by the topic key with the `key` query parameter",
        "parameters": [
          {
            "name": "page",
            "required": false,
            "in": "query",
            "example": 0,
            "description": "The page number to retrieve (starts from 0)",
            "schema": {
              "format": "int64",
              "type": "integer"
            }
          },
          {
            "name": "pageSize",
            "required": false,
            "in": "query",
            "example": 10,
            "description": "The number of items to return per page (default: 10)",
            "schema": {
              "format": "int64",
              "type": "integer"
            }
          },
          {
            "name": "key",
            "required": false,
            "in": "query",
            "example": "exampleKey",
            "description": "A filter key to apply to the results",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FilterTopicsResponseDto"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Topics"],
        "security": [
          {
            "bearerAuth": []
          },
          {
            "secretKey": []
          }
        ]
      }
    },
    "/v1/topics/{topicKey}/subscribers": {
      "post": {
        "operationId": "TopicsController_assign",
        "x-speakeasy-name-override": "assign",
        "x-speakeasy-group": "Topics.Subscribers",
        "summary": "Subscribers addition",
        "description": "Add subscribers to a topic by key",
        "parameters": [
          {
            "name": "topicKey",
            "required": true,
            "in": "path",
            "description": "The topic key",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddSubscribersRequestDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssignSubscriberToTopicDto"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Topics"],
        "security": [
          {
            "bearerAuth": []
          },
          {
            "secretKey": []
          }
        ]
      }
    },
    "/v1/topics/{topicKey}/subscribers/{externalSubscriberId}": {
      "get": {
        "operationId": "TopicsController_getTopicSubscriber",
        "x-speakeasy-group": "Topics.Subscribers",
        "summary": "Check topic subscriber",
        "description": "Check if a subscriber belongs to a certain topic",
        "parameters": [
          {
            "name": "topicKey",
            "required": true,
            "in": "path",
            "description": "The topic key",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "externalSubscriberId",
            "required": true,
            "in": "path",
            "description": "The external subscriber id",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TopicSubscriberDto"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Topics"],
        "security": [
          {
            "bearerAuth": []
          },
          {
            "secretKey": []
          }
        ]
      }
    },
    "/v1/topics/{topicKey}/subscribers/removal": {
      "post": {
        "operationId": "TopicsController_removeSubscribers",
        "x-speakeasy-name-override": "remove",
        "x-speakeasy-group": "Topics.Subscribers",
        "summary": "Subscribers removal",
        "description": "Remove subscribers from a topic",
        "parameters": [
          {
            "name": "topicKey",
            "required": true,
            "in": "path",
            "description": "The topic key",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RemoveSubscribersRequestDto"
              }
            }
          }
        },
        "responses": {
          "204": {
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "description": ""
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Topics"],
        "security": [
          {
            "bearerAuth": []
          },
          {
            "secretKey": []
          }
        ]
      }
    },
    "/v1/topics/{topicKey}": {
      "delete": {
        "operationId": "TopicsController_deleteTopic",
        "summary": "Delete topic",
        "description": "Delete a topic by its topic key if it has no subscribers",
        "parameters": [
          {
            "name": "topicKey",
            "required": true,
            "in": "path",
            "description": "The topic key",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "The topic has been deleted correctly",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Topics"],
        "security": [
          {
            "bearerAuth": []
          },
          {
            "secretKey": []
          }
        ]
      },
      "get": {
        "operationId": "TopicsController_getTopic",
        "summary": "Get topic",
        "description": "Get a topic by its topic key",
        "parameters": [
          {
            "name": "topicKey",
            "required": true,
            "in": "path",
            "description": "The topic key",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetTopicResponseDto"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Topics"],
        "security": [
          {
            "bearerAuth": []
          },
          {
            "secretKey": []
          }
        ]
      },
      "patch": {
        "operationId": "TopicsController_renameTopic",
        "x-speakeasy-name-override": "rename",
        "summary": "Rename a topic",
        "description": "Rename a topic by providing a new name",
        "parameters": [
          {
            "name": "topicKey",
            "required": true,
            "in": "path",
            "description": "The topic key",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RenameTopicRequestDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RenameTopicResponseDto"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Topics"],
        "security": [
          {
            "bearerAuth": []
          },
          {
            "secretKey": []
          }
        ]
      }
    },
    "/v2/workflows": {
      "post": {
        "operationId": "WorkflowController_create",
        "parameters": [
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "201": {
            "description": ""
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Workflows"],
        "security": [
          {
            "bearerAuth": []
          }
        ]
      },
      "get": {
        "operationId": "WorkflowController_searchWorkflows",
        "parameters": [
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Workflows"],
        "security": [
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/v2/workflows/{workflowId}/sync": {
      "put": {
        "operationId": "WorkflowController_sync",
        "parameters": [
          {
            "name": "workflowId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Workflows"],
        "security": [
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/v2/workflows/{workflowId}": {
      "put": {
        "operationId": "WorkflowController_update",
        "parameters": [
          {
            "name": "workflowId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Workflows"],
        "security": [
          {
            "bearerAuth": []
          }
        ]
      },
      "get": {
        "operationId": "WorkflowController_getWorkflow",
        "parameters": [
          {
            "name": "workflowId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "environmentId",
            "required": true,
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Workflows"],
        "security": [
          {
            "bearerAuth": []
          }
        ]
      },
      "delete": {
        "operationId": "WorkflowController_removeWorkflow",
        "parameters": [
          {
            "name": "workflowId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": ""
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Workflows"],
        "security": [
          {
            "bearerAuth": []
          }
        ]
      },
      "patch": {
        "operationId": "WorkflowController_patchWorkflow",
        "parameters": [
          {
            "name": "workflowId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Workflows"],
        "security": [
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/v2/workflows/{workflowId}/step/{stepId}/preview": {
      "post": {
        "operationId": "WorkflowController_generatePreview",
        "parameters": [
          {
            "name": "workflowId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "stepId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "201": {
            "description": ""
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Workflows"],
        "security": [
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/v2/workflows/{workflowId}/steps/{stepId}": {
      "get": {
        "operationId": "WorkflowController_getWorkflowStepData",
        "x-speakeasy-name-override": "getStepData",
        "parameters": [
          {
            "name": "workflowId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "stepId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Workflows"],
        "security": [
          {
            "bearerAuth": []
          }
        ]
      },
      "patch": {
        "operationId": "WorkflowController_patchWorkflowStepData",
        "parameters": [
          {
            "name": "workflowId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "stepId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Workflows"],
        "security": [
          {
            "bearerAuth": []
          }
        ]
      }
    },
    "/v2/workflows/{workflowId}/test-data": {
      "get": {
        "operationId": "WorkflowController_getWorkflowTestData",
        "x-speakeasy-name-override": "getWorkflowTestData",
        "parameters": [
          {
            "name": "workflowId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "idempotency-key",
            "in": "header",
            "description": "A header for idempotency purposes",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          },
          "400": {
            "description": "Bad Request",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "405": {
            "description": "Method Not Allowed",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "409": {
            "description": "Conflict",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "413": {
            "description": "Payload Too Large",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "414": {
            "description": "URI Too Long",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported Media Type",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable Entity",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ValidationErrorDto"
                }
              }
            }
          },
          "429": {
            "description": "The client has sent too many requests in a given amount of time. ",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "API rate limit exceeded"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorDto"
                }
              }
            }
          },
          "503": {
            "description": "The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.",
            "headers": {
              "Content-Type": {
                "$ref": "#/components/headers/Content-Type"
              },
              "RateLimit-Limit": {
                "$ref": "#/components/headers/RateLimit-Limit"
              },
              "RateLimit-Remaining": {
                "$ref": "#/components/headers/RateLimit-Remaining"
              },
              "RateLimit-Reset": {
                "$ref": "#/components/headers/RateLimit-Reset"
              },
              "RateLimit-Policy": {
                "$ref": "#/components/headers/RateLimit-Policy"
              },
              "Idempotency-Key": {
                "$ref": "#/components/headers/Idempotency-Key"
              },
              "Idempotency-Replay": {
                "$ref": "#/components/headers/Idempotency-Replay"
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Please wait some time, then try again."
                }
              }
            }
          }
        },
        "tags": ["Workflows"],
        "security": [
          {
            "bearerAuth": []
          }
        ]
      }
    }
  },
  "info": {
    "title": "Novu API",
    "description": "Novu REST API. Please see https://docs.novu.co/api-reference for more details.",
    "version": "1.0",
    "contact": {
      "name": "Novu Support",
      "url": "https://discord.gg/novu",
      "email": "support@novu.co"
    },
    "termsOfService": "https://novu.co/terms",
    "license": {
      "name": "MIT",
      "url": "https://opensource.org/license/mit"
    }
  },
  "tags": [
    {
      "name": "Events",
      "description": "Events represent a change in state of a subscriber. They are used to trigger workflows, and enable you to send notifications to subscribers based on their actions.",
      "externalDocs": {
        "url": "https://docs.novu.co/workflows"
      }
    },
    {
      "name": "Subscribers",
      "description": "A subscriber in Novu represents someone who should receive a message. A subscribers profile information contains important attributes about the subscriber that will be used in messages (name, email). The subscriber object can contain other key-value pairs that can be used to further personalize your messages.",
      "externalDocs": {
        "url": "https://docs.novu.co/subscribers/subscribers"
      }
    },
    {
      "name": "Topics",
      "description": "Topics are a way to group subscribers together so that they can be notified of events at once. A topic is identified by a custom key. This can be helpful for things like sending out marketing emails or notifying users of new features. Topics can also be used to send notifications to the subscribers who have been grouped together based on their interests, location, activities and much more.",
      "externalDocs": {
        "url": "https://docs.novu.co/subscribers/topics"
      }
    },
    {
      "name": "Notification",
      "description": "A notification conveys information from source to recipient, triggered by a workflow acting as a message blueprint. Notifications can be individual or bundled as digest for user-friendliness.",
      "externalDocs": {
        "url": "https://docs.novu.co/getting-started/introduction"
      }
    },
    {
      "name": "Integrations",
      "description": "With the help of the Integration Store, you can easily integrate your favorite delivery provider. During the runtime of the API, the Integrations Store is responsible for storing the configurations of all the providers.",
      "externalDocs": {
        "url": "https://docs.novu.co/platform/integrations/overview"
      }
    },
    {
      "name": "Layouts",
      "description": "Novu allows the creation of layouts - a specific HTML design or structure to wrap content of email notifications. Layouts can be manipulated and assigned to new or existing workflows within the Novu platform, allowing users to create, manage, and assign these layouts to workflows, so they can be reused to structure the appearance of notifications sent through the platform.",
      "externalDocs": {
        "url": "https://docs.novu.co/content-creation-design/layouts"
      }
    },
    {
      "name": "Workflows",
      "description": "All notifications are sent via a workflow. Each workflow acts as a container for the logic and blueprint that are associated with a type of notification in your system.",
      "externalDocs": {
        "url": "https://docs.novu.co/workflows"
      }
    },
    {
      "name": "Notification Templates",
      "description": "Deprecated. Use Workflows (/workflows) instead, which provide the same functionality under a new name."
    },
    {
      "name": "Workflow groups",
      "description": "Workflow groups are used to organize workflows into logical groups."
    },
    {
      "name": "Changes",
      "description": "Changes represent a change in state of an environment. They are analagous to a pending pull request in git, enabling you to test changes before they are applied to your environment and atomically apply them when you are ready.",
      "externalDocs": {
        "url": "https://docs.novu.co/platform/environments#promoting-pending-changes-to-production"
      }
    },
    {
      "name": "Environments",
      "description": "Novu uses the concept of environments to ensure logical separation of your data and configuration. This means that subscribers, and preferences created in one environment are never accessible to another.",
      "externalDocs": {
        "url": "https://docs.novu.co/platform/environments"
      }
    },
    {
      "name": "Inbound Parse",
      "description": "Inbound Webhook is a feature that allows processing of incoming emails for a domain or subdomain. The feature parses the contents of the email and POSTs the information to a specified URL in a multipart/form-data format.",
      "externalDocs": {
        "url": "https://docs.novu.co/platform/inbound-parse-webhook"
      }
    },
    {
      "name": "Feeds",
      "description": "Novu provides a notification activity feed that monitors every outgoing message associated with its relevant metadata. This can be used to monitor activity and discover potential issues with a specific provider or a channel type.",
      "externalDocs": {
        "url": "https://docs.novu.co/activity-feed"
      }
    },
    {
      "name": "Tenants",
      "description": "A tenant represents a group of users. As a developer, when your apps have organizations, they are referred to as tenants. Tenants in Novu provides the ability to tailor specific notification experiences to users of different groups or organizations.",
      "externalDocs": {
        "url": "https://docs.novu.co/tenants"
      }
    },
    {
      "name": "Messages",
      "description": "A message in Novu represents a notification delivered to a recipient on a particular channel. Messages contain information about the request that triggered its delivery, a view of the data sent to the recipient, and a timeline of its lifecycle events. Learn more about messages.",
      "externalDocs": {
        "url": "https://docs.novu.co/workflows/messages"
      }
    },
    {
      "name": "Organizations",
      "description": "An organization serves as a separate entity within your Novu account. Each organization you create has its own separate integration store, workflows, subscribers, and API keys. This separation of resources allows you to manage multi-tenant environments and separate domains within a single account.",
      "externalDocs": {
        "url": "https://docs.novu.co/platform/organizations"
      }
    },
    {
      "name": "Execution Details",
      "description": "Execution details are used to track the execution of a workflow. They provided detailed information on the execution of a workflow, including the status of each step, the input and output of each step, and the overall status of the execution.",
      "externalDocs": {
        "url": "https://docs.novu.co/activity-feed"
      }
    }
  ],
  "servers": [
    {
      "url": "https://api.novu.co"
    },
    {
      "url": "https://eu.api.novu.co"
    }
  ],
  "components": {
    "securitySchemes": {
      "secretKey": {
        "type": "apiKey",
        "name": "Authorization",
        "in": "header",
        "description": "API key authentication. Allowed headers-- \"Authorization: ApiKey <api_key>\"."
      },
      "bearerAuth": {
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "JWT"
      }
    },
    "schemas": {
      "DataWrapperDto": {
        "type": "object",
        "properties": {
          "data": {
            "type": "object"
          }
        },
        "required": ["data"]
      },
      "ErrorDto": {
        "type": "object",
        "properties": {
          "statusCode": {
            "type": "number",
            "description": "HTTP status code of the error response.",
            "example": 404
          },
          "timestamp": {
            "type": "string",
            "description": "Timestamp of when the error occurred.",
            "example": "2024-12-12T13:00:00Z"
          },
          "path": {
            "type": "string",
            "description": "The path where the error occurred.",
            "example": "/api/v1/resource"
          },
          "message": {
            "type": "string",
            "description": "A detailed error message.",
            "example": "Resource not found."
          },
          "ctx": {
            "type": "object",
            "description": "Optional context object for additional error details.",
            "additionalProperties": true,
            "example": {
              "workflowId": "some_wf_id",
              "stepId": "some_wf_id"
            }
          },
          "errorId": {
            "type": "string",
            "description": "Optional unique identifier for the error, useful for tracking using Sentry and \n      New Relic, only available for 500.",
            "example": "abc123"
          }
        },
        "required": ["statusCode", "timestamp", "path", "message"]
      },
      "ValidationErrorDto": {
        "type": "object",
        "properties": {
          "statusCode": {
            "type": "number",
            "description": "HTTP status code of the error response.",
            "example": 404
          },
          "timestamp": {
            "type": "string",
            "description": "Timestamp of when the error occurred.",
            "example": "2024-12-12T13:00:00Z"
          },
          "path": {
            "type": "string",
            "description": "The path where the error occurred.",
            "example": "/api/v1/resource"
          },
          "message": {
            "type": "string",
            "description": "A detailed error message.",
            "example": "Resource not found."
          },
          "ctx": {
            "type": "object",
            "description": "Optional context object for additional error details.",
            "additionalProperties": true,
            "example": {
              "workflowId": "some_wf_id",
              "stepId": "some_wf_id"
            }
          },
          "errorId": {
            "type": "string",
            "description": "Optional unique identifier for the error, useful for tracking using Sentry and \n      New Relic, only available for 500.",
            "example": "abc123"
          },
          "errors": {
            "type": "object",
            "description": "A record of validation errors keyed by field name",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "messages": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "value": {
                  "oneOf": [
                    {
                      "type": "string",
                      "nullable": true
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "object",
                      "additionalProperties": true
                    },
                    {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "additionalProperties": true
                      }
                    }
                  ]
                }
              },
              "required": ["messages", "value"],
              "example": {
                "messages": ["Field is required", "Invalid format"],
                "value": "xx xx xx "
              }
            },
            "example": {
              "fieldName1": {
                "messages": ["Field is required", "Must be a valid email address"],
                "value": "invalidEmail"
              },
              "fieldName2": {
                "messages": ["Must be at least 18 years old"],
                "value": 17
              },
              "fieldName3": {
                "messages": ["Must be a boolean value"],
                "value": true
              },
              "fieldName4": {
                "messages": ["Must be a valid object"],
                "value": {
                  "key": "value"
                }
              }
            }
          }
        },
        "required": ["statusCode", "timestamp", "path", "message", "errors"]
      },
      "TriggerEventResponseDto": {
        "type": "object",
        "properties": {
          "acknowledged": {
            "type": "boolean",
            "description": "Indicates whether the trigger was acknowledged or not"
          },
          "status": {
            "type": "string",
            "description": "Status of the trigger",
            "enum": [
              "error",
              "trigger_not_active",
              "no_workflow_active_steps_defined",
              "no_workflow_steps_defined",
              "processed",
              "no_tenant_found"
            ]
          },
          "error": {
            "description": "In case of an error, this field will contain the error message(s)",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "transactionId": {
            "type": "string",
            "description": "The returned transaction ID of the trigger"
          }
        },
        "required": ["acknowledged", "status"]
      },
      "ChannelCredentialsDto": {
        "type": "object",
        "properties": {
          "webhookUrl": {
            "type": "string",
            "description": "The URL for the webhook associated with the channel."
          },
          "deviceTokens": {
            "description": "An array of device tokens for push notifications.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "SubscriberChannelDto": {
        "type": "object",
        "properties": {
          "providerId": {
            "type": "string",
            "description": "The ID of the chat or push provider.",
            "enum": [
              "slack",
              "discord",
              "msteams",
              "mattermost",
              "ryver",
              "zulip",
              "grafana-on-call",
              "getstream",
              "rocket-chat",
              "whatsapp-business",
              "fcm",
              "apns",
              "expo",
              "one-signal",
              "pushpad",
              "push-webhook",
              "pusher-beams"
            ]
          },
          "integrationIdentifier": {
            "type": "string",
            "description": "An optional identifier for the integration."
          },
          "credentials": {
            "description": "Credentials for the channel.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChannelCredentialsDto"
              }
            ]
          }
        },
        "required": ["providerId", "credentials"]
      },
      "SubscriberPayloadDto": {
        "type": "object",
        "properties": {
          "subscriberId": {
            "type": "string",
            "description": "The internal identifier you used to create this subscriber, usually correlates to the id the user in your systems"
          },
          "email": {
            "type": "string",
            "description": "The email address of the subscriber."
          },
          "firstName": {
            "type": "string",
            "description": "The first name of the subscriber."
          },
          "lastName": {
            "type": "string",
            "description": "The last name of the subscriber."
          },
          "phone": {
            "type": "string",
            "description": "The phone number of the subscriber."
          },
          "avatar": {
            "type": "string",
            "description": "An HTTP URL to the profile image of your subscriber."
          },
          "locale": {
            "type": "string",
            "description": "The locale of the subscriber."
          },
          "data": {
            "type": "object",
            "description": "An optional payload object that can contain any properties.",
            "additionalProperties": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "number"
                }
              ]
            }
          },
          "channels": {
            "description": "An optional array of subscriber channels.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SubscriberChannelDto"
            }
          }
        },
        "required": ["subscriberId"]
      },
      "TenantPayloadDto": {
        "type": "object",
        "properties": {
          "identifier": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "data": {
            "type": "object"
          }
        }
      },
      "TriggerRecipientsTypeEnum": {
        "type": "string",
        "enum": ["Subscriber", "Topic"]
      },
      "TopicPayloadDto": {
        "type": "object",
        "properties": {
          "topicKey": {
            "type": "string"
          },
          "type": {
            "$ref": "#/components/schemas/TriggerRecipientsTypeEnum"
          }
        },
        "required": ["topicKey", "type"]
      },
      "WorkflowToStepControlValuesDto": {
        "type": "object",
        "properties": {
          "steps": {
            "type": "object",
            "description": "A mapping of step IDs to their corresponding data.",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": true
            }
          }
        }
      },
      "TriggerEventRequestDto": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The trigger identifier of the workflow you wish to send. This identifier can be found on the workflow page.",
            "example": "workflow_identifier"
          },
          "payload": {
            "type": "object",
            "description": "The payload object is used to pass additional custom information that could be \n    used to render the workflow, or perform routing rules based on it. \n      This data will also be available when fetching the notifications feed from the API to display certain parts of the UI.",
            "additionalProperties": true,
            "example": {
              "comment_id": "string",
              "post": {
                "text": "string"
              }
            }
          },
          "bridgeUrl": {
            "type": "string",
            "description": "A URL to bridge for additional processing.",
            "example": "https://example.com/bridge"
          },
          "overrides": {
            "type": "object",
            "description": "This could be used to override provider specific configurations",
            "example": {
              "fcm": {
                "data": {
                  "key": "value"
                }
              }
            },
            "additionalProperties": {
              "type": "object",
              "additionalProperties": true
            }
          },
          "to": {
            "description": "The recipients list of people who will receive the notification.",
            "oneOf": [
              {
                "type": "array",
                "items": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/SubscriberPayloadDto"
                    },
                    {
                      "$ref": "#/components/schemas/TopicPayloadDto"
                    },
                    {
                      "type": "string",
                      "description": "Unique identifier of a subscriber in your systems",
                      "example": "SUBSCRIBER_ID"
                    }
                  ]
                }
              },
              {
                "type": "string",
                "description": "Unique identifier of a subscriber in your systems",
                "example": "SUBSCRIBER_ID"
              },
              {
                "$ref": "#/components/schemas/SubscriberPayloadDto"
              },
              {
                "$ref": "#/components/schemas/TopicPayloadDto"
              }
            ]
          },
          "transactionId": {
            "type": "string",
            "description": "A unique identifier for this transaction, we will generate a UUID if not provided."
          },
          "actor": {
            "description": "It is used to display the Avatar of the provided actor's subscriber id or actor object.\n    If a new actor object is provided, we will create a new subscriber in our system",
            "oneOf": [
              {
                "type": "string",
                "description": "Unique identifier of a subscriber in your systems"
              },
              {
                "$ref": "#/components/schemas/SubscriberPayloadDto"
              }
            ]
          },
          "tenant": {
            "description": "It is used to specify a tenant context during trigger event.\n    Existing tenants will be updated with the provided details.",
            "oneOf": [
              {
                "type": "string",
                "description": "Unique identifier of a tenant in your system"
              },
              {
                "$ref": "#/components/schemas/TenantPayloadDto"
              }
            ]
          },
          "controls": {
            "description": "Additional control configurations.",
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowToStepControlValuesDto"
              }
            ]
          }
        },
        "required": ["name", "to"]
      },
      "BulkTriggerEventDto": {
        "type": "object",
        "properties": {
          "events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TriggerEventRequestDto"
            }
          }
        },
        "required": ["events"]
      },
      "TriggerEventToAllRequestDto": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The trigger identifier associated for the template you wish to send. This identifier can be found on the template page."
          },
          "payload": {
            "type": "object",
            "example": {
              "comment_id": "string",
              "post": {
                "text": "string"
              }
            },
            "description": "The payload object is used to pass additional information that \n    could be used to render the template, or perform routing rules based on it. \n      For In-App channel, payload data are also available in <Inbox />",
            "additionalProperties": true
          },
          "overrides": {
            "type": "object",
            "description": "This could be used to override provider specific configurations",
            "example": {
              "fcm": {
                "data": {
                  "key": "value"
                }
              }
            }
          },
          "transactionId": {
            "type": "string",
            "description": "A unique identifier for this transaction, we will generated a UUID if not provided."
          },
          "actor": {
            "description": "It is used to display the Avatar of the provided actor's subscriber id or actor object.\n    If a new actor object is provided, we will create a new subscriber in our system\n    ",
            "oneOf": [
              {
                "type": "string",
                "description": "Unique identifier of a subscriber in your systems"
              },
              {
                "$ref": "#/components/schemas/SubscriberPayloadDto"
              }
            ]
          },
          "tenant": {
            "description": "It is used to specify a tenant context during trigger event.\n    If a new tenant object is provided, we will create a new tenant.\n    ",
            "oneOf": [
              {
                "type": "string",
                "description": "Unique identifier of a tenant in your system"
              },
              {
                "$ref": "#/components/schemas/TenantPayloadDto"
              }
            ]
          }
        },
        "required": ["name", "payload", "transactionId", "actor", "tenant"]
      },
      "DataBooleanDto": {
        "type": "object",
        "properties": {
          "data": {
            "type": "boolean"
          }
        },
        "required": ["data"]
      },
      "ChannelTypeEnum": {
        "type": "string",
        "description": "Channel type through which the message is sent",
        "enum": ["in_app", "email", "sms", "chat", "push"]
      },
      "StepTypeEnum": {
        "type": "string",
        "description": "Channels of the notification",
        "enum": ["in_app", "email", "sms", "chat", "push", "digest", "trigger", "delay", "custom"]
      },
      "ActivityNotificationSubscriberResponseDto": {
        "type": "object",
        "properties": {
          "firstName": {
            "type": "string",
            "description": "First name of the subscriber"
          },
          "subscriberId": {
            "type": "string",
            "description": "External unique identifier of the subscriber"
          },
          "_id": {
            "type": "string",
            "description": "Internal to Novu unique identifier of the subscriber"
          },
          "lastName": {
            "type": "string",
            "description": "Last name of the subscriber"
          },
          "email": {
            "type": "string",
            "description": "Email address of the subscriber"
          },
          "phone": {
            "type": "string",
            "description": "Phone number of the subscriber"
          }
        },
        "required": ["subscriberId", "_id"]
      },
      "NotificationTriggerVariable": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the variable"
          }
        },
        "required": ["name"]
      },
      "NotificationTriggerDto": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["event"],
            "description": "Type of the trigger"
          },
          "identifier": {
            "type": "string",
            "description": "Identifier of the trigger"
          },
          "variables": {
            "description": "Variables of the trigger",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationTriggerVariable"
            }
          },
          "subscriberVariables": {
            "description": "Subscriber variables of the trigger",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationTriggerVariable"
            }
          }
        },
        "required": ["type", "identifier", "variables"]
      },
      "ActivityNotificationTemplateResponseDto": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "description": "Unique identifier of the template"
          },
          "name": {
            "type": "string",
            "description": "Name of the template"
          },
          "triggers": {
            "description": "Triggers of the template",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationTriggerDto"
            }
          }
        },
        "required": ["name", "triggers"]
      },
      "DigestTypeEnum": {
        "type": "string",
        "description": "The Digest Type",
        "enum": ["regular", "backoff", "timed"]
      },
      "DigestUnitEnum": {
        "type": "string",
        "description": "Regular digest: Unit for backoff",
        "enum": ["seconds", "minutes", "hours", "days", "weeks", "months"]
      },
      "OrdinalEnum": {
        "type": "string",
        "description": "Ordinal position for the digest",
        "enum": ["1", "2", "3", "4", "5", "last"]
      },
      "OrdinalValueEnum": {
        "type": "string",
        "description": "Value of the ordinal",
        "enum": [
          "day",
          "weekday",
          "weekend",
          "sunday",
          "monday",
          "tuesday",
          "wednesday",
          "thursday",
          "friday",
          "saturday"
        ]
      },
      "MonthlyTypeEnum": {
        "type": "string",
        "description": "Type of monthly schedule",
        "enum": ["each", "on"]
      },
      "DigestTimedConfigDto": {
        "type": "object",
        "properties": {
          "atTime": {
            "type": "string",
            "description": "Time at which the digest is triggered"
          },
          "weekDays": {
            "type": "array",
            "description": "Days of the week for the digest",
            "items": {
              "type": "string",
              "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]
            }
          },
          "monthDays": {
            "description": "Specific days of the month for the digest",
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          "ordinal": {
            "$ref": "#/components/schemas/OrdinalEnum"
          },
          "ordinalValue": {
            "$ref": "#/components/schemas/OrdinalValueEnum"
          },
          "monthlyType": {
            "$ref": "#/components/schemas/MonthlyTypeEnum"
          },
          "cronExpression": {
            "type": "string",
            "description": "Cron expression for scheduling"
          }
        }
      },
      "DigestMetadataDto": {
        "type": "object",
        "properties": {
          "digestKey": {
            "type": "string",
            "description": "Optional key for the digest"
          },
          "amount": {
            "type": "number",
            "description": "Amount for the digest"
          },
          "unit": {
            "type": "string",
            "description": "Unit of the digest",
            "enum": ["seconds", "minutes", "hours", "days", "weeks", "months"]
          },
          "type": {
            "$ref": "#/components/schemas/DigestTypeEnum"
          },
          "events": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": true
            },
            "description": "Optional array of events associated with the digest, represented as key-value pairs"
          },
          "backoff": {
            "type": "boolean",
            "description": "Regular digest: Indicates if backoff is enabled for the regular digest"
          },
          "backoffAmount": {
            "type": "number",
            "description": "Regular digest: Amount for backoff"
          },
          "backoffUnit": {
            "$ref": "#/components/schemas/DigestUnitEnum"
          },
          "updateMode": {
            "type": "boolean",
            "description": "Regular digest: Indicates if the digest should update"
          },
          "timed": {
            "description": "Configuration for timed digest",
            "allOf": [
              {
                "$ref": "#/components/schemas/DigestTimedConfigDto"
              }
            ]
          }
        },
        "required": ["type"]
      },
      "ExecutionDetailsStatusEnum": {
        "type": "string",
        "description": "Status of the execution detail",
        "enum": ["Success", "Warning", "Failed", "Pending", "Queued", "ReadConfirmation"]
      },
      "ProvidersIdEnum": {
        "type": "string",
        "description": "Provider ID of the job",
        "enum": [
          "emailjs",
          "mailgun",
          "mailjet",
          "mandrill",
          "nodemailer",
          "postmark",
          "sendgrid",
          "sendinblue",
          "ses",
          "netcore",
          "infobip-email",
          "resend",
          "plunk",
          "mailersend",
          "mailtrap",
          "clickatell",
          "outlook365",
          "novu-email",
          "sparkpost",
          "email-webhook",
          "braze",
          "nexmo",
          "plivo",
          "sms77",
          "sms-central",
          "sns",
          "telnyx",
          "twilio",
          "gupshup",
          "firetext",
          "infobip-sms",
          "burst-sms",
          "bulk-sms",
          "isend-sms",
          "forty-six-elks",
          "kannel",
          "maqsam",
          "termii",
          "africas-talking",
          "novu-sms",
          "sendchamp",
          "generic-sms",
          "clicksend",
          "bandwidth",
          "messagebird",
          "simpletexting",
          "azure-sms",
          "ring-central",
          "brevo-sms",
          "eazy-sms",
          "mobishastra",
          "fcm",
          "apns",
          "expo",
          "one-signal",
          "pushpad",
          "push-webhook",
          "pusher-beams",
          "novu",
          "slack",
          "discord",
          "msteams",
          "mattermost",
          "ryver",
          "zulip",
          "grafana-on-call",
          "getstream",
          "rocket-chat",
          "whatsapp-business"
        ]
      },
      "ExecutionDetailsSourceEnum": {
        "type": "string",
        "description": "Source of the execution detail",
        "enum": ["Credentials", "Internal", "Payload", "Webhook"]
      },
      "ActivityNotificationExecutionDetailResponseDto": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "description": "Unique identifier of the execution detail"
          },
          "createdAt": {
            "type": "string",
            "description": "Creation time of the execution detail"
          },
          "status": {
            "$ref": "#/components/schemas/ExecutionDetailsStatusEnum"
          },
          "detail": {
            "type": "string",
            "description": "Detailed information about the execution"
          },
          "isRetry": {
            "type": "boolean",
            "description": "Whether the execution is a retry or not"
          },
          "isTest": {
            "type": "boolean",
            "description": "Whether the execution is a test or not"
          },
          "providerId": {
            "$ref": "#/components/schemas/ProvidersIdEnum"
          },
          "raw": {
            "type": "string",
            "description": "Raw data of the execution"
          },
          "source": {
            "$ref": "#/components/schemas/ExecutionDetailsSourceEnum"
          }
        },
        "required": ["_id", "status", "detail", "isRetry", "isTest", "providerId", "source"]
      },
      "BuilderFieldTypeEnum": {
        "type": "string",
        "enum": ["BOOLEAN", "TEXT", "DATE", "NUMBER", "STATEMENT", "LIST", "MULTI_LIST", "GROUP"]
      },
      "FieldFilterPartDto": {
        "type": "object",
        "properties": {
          "field": {
            "type": "string"
          },
          "value": {
            "type": "string"
          },
          "operator": {
            "type": "string",
            "enum": [
              "LARGER",
              "SMALLER",
              "LARGER_EQUAL",
              "SMALLER_EQUAL",
              "EQUAL",
              "NOT_EQUAL",
              "ALL_IN",
              "ANY_IN",
              "NOT_IN",
              "BETWEEN",
              "NOT_BETWEEN",
              "LIKE",
              "NOT_LIKE",
              "IN"
            ]
          },
          "on": {
            "type": "string",
            "enum": ["subscriber", "payload"]
          }
        },
        "required": ["field", "value", "operator", "on"]
      },
      "StepFilterDto": {
        "type": "object",
        "properties": {
          "isNegated": {
            "type": "boolean"
          },
          "type": {
            "$ref": "#/components/schemas/BuilderFieldTypeEnum"
          },
          "value": {
            "type": "string",
            "enum": ["AND", "OR"]
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FieldFilterPartDto"
            }
          }
        },
        "required": ["isNegated", "type", "value", "children"]
      },
      "MessageTemplateDto": {
        "type": "object",
        "properties": {}
      },
      "ActivityNotificationStepResponseDto": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "description": "Unique identifier of the step"
          },
          "active": {
            "type": "boolean",
            "description": "Whether the step is active or not"
          },
          "replyCallback": {
            "type": "object",
            "description": "Reply callback settings"
          },
          "controlVariables": {
            "type": "object",
            "description": "Control variables"
          },
          "metadata": {
            "type": "object",
            "description": "Metadata for the workflow step"
          },
          "issues": {
            "type": "object",
            "description": "Step issues"
          },
          "filters": {
            "description": "Filter criteria for the step",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StepFilterDto"
            }
          },
          "template": {
            "description": "Optional template for the step",
            "allOf": [
              {
                "$ref": "#/components/schemas/MessageTemplateDto"
              }
            ]
          },
          "variants": {
            "description": "Variants of the step",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ActivityNotificationStepResponseDto"
            }
          },
          "_templateId": {
            "type": "string",
            "description": "The identifier for the template associated with this step"
          },
          "name": {
            "type": "string",
            "description": "The name of the step"
          },
          "_parentId": {
            "type": "string",
            "description": "The unique identifier for the parent step"
          }
        },
        "required": ["_id", "active", "filters", "_templateId"]
      },
      "ActivityNotificationJobResponseDto": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "description": "Unique identifier of the job"
          },
          "type": {
            "type": "string",
            "description": "Type of the job"
          },
          "digest": {
            "description": "Optional digest for the job, including metadata and events",
            "allOf": [
              {
                "$ref": "#/components/schemas/DigestMetadataDto"
              }
            ]
          },
          "executionDetails": {
            "description": "Execution details of the job",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ActivityNotificationExecutionDetailResponseDto"
            }
          },
          "step": {
            "description": "Step details of the job",
            "allOf": [
              {
                "$ref": "#/components/schemas/ActivityNotificationStepResponseDto"
              }
            ]
          },
          "payload": {
            "type": "object",
            "description": "Optional payload for the job"
          },
          "providerId": {
            "$ref": "#/components/schemas/ProvidersIdEnum"
          },
          "status": {
            "type": "string",
            "description": "Status of the job"
          },
          "updatedAt": {
            "type": "string",
            "description": "Updated time of the notification"
          }
        },
        "required": ["_id", "type", "executionDetails", "step", "providerId", "status"]
      },
      "ActivityNotificationResponseDto": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "description": "Unique identifier of the notification"
          },
          "_environmentId": {
            "type": "string",
            "description": "Environment ID of the notification"
          },
          "_organizationId": {
            "type": "string",
            "description": "Organization ID of the notification"
          },
          "_subscriberId": {
            "type": "string",
            "description": "Subscriber ID of the notification"
          },
          "transactionId": {
            "type": "string",
            "description": "Transaction ID of the notification"
          },
          "_templateId": {
            "type": "string",
            "description": "Template ID of the notification"
          },
          "_digestedNotificationId": {
            "type": "string",
            "description": "Digested Notification ID"
          },
          "createdAt": {
            "type": "string",
            "description": "Creation time of the notification"
          },
          "updatedAt": {
            "type": "string",
            "description": "Last updated time of the notification"
          },
          "channels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StepTypeEnum"
            }
          },
          "subscriber": {
            "description": "Subscriber of the notification",
            "allOf": [
              {
                "$ref": "#/components/schemas/ActivityNotificationSubscriberResponseDto"
              }
            ]
          },
          "template": {
            "description": "Template of the notification",
            "allOf": [
              {
                "$ref": "#/components/schemas/ActivityNotificationTemplateResponseDto"
              }
            ]
          },
          "jobs": {
            "description": "Jobs of the notification",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ActivityNotificationJobResponseDto"
            }
          },
          "payload": {
            "type": "object",
            "description": "Payload of the notification"
          },
          "tags": {
            "description": "Tags associated with the notification",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "controls": {
            "type": "object",
            "description": "Controls associated with the notification"
          },
          "to": {
            "type": "object",
            "description": "To field for subscriber definition"
          }
        },
        "required": ["_environmentId", "_organizationId", "_subscriberId", "transactionId"]
      },
      "ActivitiesResponseDto": {
        "type": "object",
        "properties": {
          "hasMore": {
            "type": "boolean",
            "description": "Indicates if there are more activities in the result set"
          },
          "data": {
            "description": "Array of activity notifications",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ActivityNotificationResponseDto"
            }
          },
          "pageSize": {
            "type": "number",
            "description": "Page size of the activities"
          },
          "page": {
            "type": "number",
            "description": "Current page of the activities"
          }
        },
        "required": ["hasMore", "data", "pageSize", "page"]
      },
      "ActivityStatsResponseDto": {
        "type": "object",
        "properties": {
          "weeklySent": {
            "type": "number"
          },
          "monthlySent": {
            "type": "number"
          }
        },
        "required": ["weeklySent", "monthlySent"]
      },
      "ActivityGraphStatesResponse": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string"
          },
          "count": {
            "type": "number"
          },
          "templates": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "channels": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": ["in_app", "email", "sms", "chat", "push"]
            }
          }
        },
        "required": ["_id", "count", "templates", "channels"]
      },
      "CredentialsDto": {
        "type": "object",
        "properties": {
          "apiKey": {
            "type": "string"
          },
          "user": {
            "type": "string"
          },
          "secretKey": {
            "type": "string"
          },
          "domain": {
            "type": "string"
          },
          "password": {
            "type": "string"
          },
          "host": {
            "type": "string"
          },
          "port": {
            "type": "string"
          },
          "secure": {
            "type": "boolean"
          },
          "region": {
            "type": "string"
          },
          "accountSid": {
            "type": "string"
          },
          "messageProfileId": {
            "type": "string"
          },
          "token": {
            "type": "string"
          },
          "from": {
            "type": "string"
          },
          "senderName": {
            "type": "string"
          },
          "projectName": {
            "type": "string"
          },
          "applicationId": {
            "type": "string"
          },
          "clientId": {
            "type": "string"
          },
          "requireTls": {
            "type": "boolean"
          },
          "ignoreTls": {
            "type": "boolean"
          },
          "tlsOptions": {
            "type": "object"
          },
          "baseUrl": {
            "type": "string"
          },
          "webhookUrl": {
            "type": "string"
          },
          "redirectUrl": {
            "type": "string"
          },
          "hmac": {
            "type": "boolean"
          },
          "serviceAccount": {
            "type": "string"
          },
          "ipPoolName": {
            "type": "string"
          },
          "apiKeyRequestHeader": {
            "type": "string"
          },
          "secretKeyRequestHeader": {
            "type": "string"
          },
          "idPath": {
            "type": "string"
          },
          "datePath": {
            "type": "string"
          },
          "apiToken": {
            "type": "string"
          },
          "authenticateByToken": {
            "type": "boolean"
          },
          "authenticationTokenKey": {
            "type": "string"
          },
          "instanceId": {
            "type": "string"
          },
          "alertUid": {
            "type": "string"
          },
          "title": {
            "type": "string"
          },
          "imageUrl": {
            "type": "string"
          },
          "state": {
            "type": "string"
          },
          "externalLink": {
            "type": "string"
          },
          "channelId": {
            "type": "string"
          },
          "phoneNumberIdentification": {
            "type": "string"
          },
          "accessKey": {
            "type": "string"
          }
        }
      },
      "IntegrationResponseDto": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "description": "The unique identifier of the integration record in the database. This is automatically generated."
          },
          "_environmentId": {
            "type": "string",
            "description": "The unique identifier for the environment associated with this integration. This links to the Environment collection."
          },
          "_organizationId": {
            "type": "string",
            "description": "The unique identifier for the organization that owns this integration. This links to the Organization collection."
          },
          "name": {
            "type": "string",
            "description": "The name of the integration, which is used to identify it in the user interface."
          },
          "identifier": {
            "type": "string",
            "description": "A unique string identifier for the integration, often used for API calls or internal references."
          },
          "providerId": {
            "type": "string",
            "description": "The identifier for the provider of the integration (e.g., \"mailgun\", \"twilio\")."
          },
          "channel": {
            "type": "string",
            "description": "The channel type for the integration, which defines how the integration communicates (e.g., email, SMS).",
            "enum": ["in_app", "email", "sms", "chat", "push"]
          },
          "credentials": {
            "description": "The credentials required for the integration to function, including API keys and other sensitive information.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CredentialsDto"
              }
            ]
          },
          "active": {
            "type": "boolean",
            "description": "Indicates whether the integration is currently active. An active integration will process events and messages."
          },
          "deleted": {
            "type": "boolean",
            "description": "Indicates whether the integration has been marked as deleted (soft delete)."
          },
          "deletedAt": {
            "type": "string",
            "description": "The timestamp indicating when the integration was deleted. This is set when the integration is soft deleted."
          },
          "deletedBy": {
            "type": "string",
            "description": "The identifier of the user who performed the deletion of this integration. Useful for audit trails."
          },
          "primary": {
            "type": "boolean",
            "description": "Indicates whether this integration is marked as primary. A primary integration is often the default choice for processing."
          },
          "conditions": {
            "description": "An array of conditions associated with the integration that may influence its behavior or processing logic.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StepFilterDto"
            }
          }
        },
        "required": [
          "_environmentId",
          "_organizationId",
          "name",
          "identifier",
          "providerId",
          "channel",
          "credentials",
          "active",
          "deleted",
          "primary"
        ]
      },
      "CreateIntegrationRequestDto": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the integration"
          },
          "identifier": {
            "type": "string",
            "description": "The unique identifier for the integration"
          },
          "_environmentId": {
            "type": "string",
            "description": "The ID of the associated environment",
            "format": "uuid"
          },
          "providerId": {
            "type": "string",
            "description": "The provider ID for the integration"
          },
          "channel": {
            "type": "string",
            "enum": ["in_app", "email", "sms", "chat", "push"],
            "description": "The channel type for the integration"
          },
          "credentials": {
            "description": "The credentials for the integration",
            "allOf": [
              {
                "$ref": "#/components/schemas/CredentialsDto"
              }
            ]
          },
          "active": {
            "type": "boolean",
            "description": "If the integration is active, the validation on the credentials field will run"
          },
          "check": {
            "type": "boolean",
            "description": "Flag to check the integration status"
          },
          "conditions": {
            "description": "Conditions for the integration",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StepFilterDto"
            }
          }
        },
        "required": ["providerId", "channel"]
      },
      "UpdateIntegrationRequestDto": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "identifier": {
            "type": "string"
          },
          "_environmentId": {
            "type": "string"
          },
          "active": {
            "type": "boolean",
            "description": "If the integration is active the validation on the credentials field will run"
          },
          "credentials": {
            "$ref": "#/components/schemas/CredentialsDto"
          },
          "removeNovuBranding": {
            "type": "boolean",
            "description": "If true, the Novu branding will be removed from the Inbox component"
          },
          "check": {
            "type": "boolean"
          },
          "conditions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StepFilterDto"
            }
          }
        }
      },
      "PaginatedResponseDto": {
        "type": "object",
        "properties": {
          "page": {
            "type": "number",
            "description": "The current page of the paginated response"
          },
          "hasMore": {
            "type": "boolean",
            "description": "Does the list have more items to fetch"
          },
          "pageSize": {
            "type": "number",
            "description": "Number of items on each page"
          },
          "data": {
            "description": "The list of items matching the query",
            "type": "array",
            "items": {
              "type": "object"
            }
          }
        },
        "required": ["page", "hasMore", "pageSize", "data"]
      },
      "ChannelCredentials": {
        "type": "object",
        "properties": {
          "webhookUrl": {
            "type": "string",
            "description": "Webhook URL used by chat app integrations. The webhook should be obtained from the chat app provider.",
            "example": "https://example.com/webhook"
          },
          "channel": {
            "type": "string",
            "description": "Channel specification for Mattermost chat notifications.",
            "example": "general"
          },
          "deviceTokens": {
            "description": "Contains an array of the subscriber device tokens for a given provider. Used on Push integrations.",
            "example": ["token1", "token2", "token3"],
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "alertUid": {
            "type": "string",
            "description": "Alert UID for Grafana on-call webhook payload.",
            "example": "12345-abcde"
          },
          "title": {
            "type": "string",
            "description": "Title to be used with Grafana on-call webhook.",
            "example": "Critical Alert"
          },
          "imageUrl": {
            "type": "string",
            "description": "Image URL property for Grafana on-call webhook.",
            "example": "https://example.com/image.png"
          },
          "state": {
            "type": "string",
            "description": "State property for Grafana on-call webhook.",
            "example": "resolved"
          },
          "externalUrl": {
            "type": "string",
            "description": "Link to upstream details property for Grafana on-call webhook.",
            "example": "https://example.com/details"
          }
        }
      },
      "ChannelSettings": {
        "type": "object",
        "properties": {
          "providerId": {
            "type": "string",
            "enum": [
              "slack",
              "discord",
              "msteams",
              "mattermost",
              "ryver",
              "zulip",
              "grafana-on-call",
              "getstream",
              "rocket-chat",
              "whatsapp-business",
              "fcm",
              "apns",
              "expo",
              "one-signal",
              "pushpad",
              "push-webhook",
              "pusher-beams"
            ],
            "description": "The provider identifier for the credentials"
          },
          "integrationIdentifier": {
            "type": "string",
            "description": "The integration identifier"
          },
          "credentials": {
            "description": "Credentials payload for the specified provider",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChannelCredentials"
              }
            ]
          },
          "_integrationId": {
            "type": "string",
            "description": "The unique identifier of the integration associated with this channel."
          }
        },
        "required": ["providerId", "integrationIdentifier", "credentials", "_integrationId"]
      },
      "SubscriberResponseDto": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "description": "The internal ID generated by Novu for your subscriber. This ID does not match the `subscriberId` used in your queries. Refer to `subscriberId` for that identifier."
          },
          "firstName": {
            "type": "string",
            "description": "The first name of the subscriber."
          },
          "lastName": {
            "type": "string",
            "description": "The last name of the subscriber."
          },
          "email": {
            "type": "string",
            "description": "The email address of the subscriber.",
            "nullable": true
          },
          "phone": {
            "type": "string",
            "description": "The phone number of the subscriber."
          },
          "avatar": {
            "type": "string",
            "description": "The URL of the subscriber's avatar image."
          },
          "locale": {
            "type": "string",
            "description": "The locale setting of the subscriber, indicating their preferred language or region."
          },
          "subscriberId": {
            "type": "string",
            "description": "The identifier used to create this subscriber, which typically corresponds to the user ID in your system."
          },
          "channels": {
            "description": "An array of channel settings associated with the subscriber.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChannelSettings"
            }
          },
          "topics": {
            "description": "An array of topics that the subscriber is subscribed to.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "isOnline": {
            "type": "boolean",
            "description": "Indicates whether the subscriber is currently online."
          },
          "lastOnlineAt": {
            "type": "string",
            "description": "The timestamp indicating when the subscriber was last online, in ISO 8601 format."
          },
          "_organizationId": {
            "type": "string",
            "description": "The unique identifier of the organization to which the subscriber belongs."
          },
          "_environmentId": {
            "type": "string",
            "description": "The unique identifier of the environment associated with this subscriber."
          },
          "deleted": {
            "type": "boolean",
            "description": "Indicates whether the subscriber has been deleted."
          },
          "createdAt": {
            "type": "string",
            "description": "The timestamp indicating when the subscriber was created, in ISO 8601 format."
          },
          "updatedAt": {
            "type": "string",
            "description": "The timestamp indicating when the subscriber was last updated, in ISO 8601 format."
          },
          "__v": {
            "type": "number",
            "description": "The version of the subscriber document."
          }
        },
        "required": [
          "firstName",
          "lastName",
          "email",
          "subscriberId",
          "isOnline",
          "lastOnlineAt",
          "_organizationId",
          "_environmentId",
          "deleted",
          "createdAt",
          "updatedAt"
        ]
      },
      "CreateSubscriberRequestDto": {
        "type": "object",
        "properties": {
          "subscriberId": {
            "type": "string",
            "description": "The internal identifier you used to create this subscriber, usually correlates to the id the user in your systems"
          },
          "email": {
            "type": "string",
            "description": "The email address of the subscriber."
          },
          "firstName": {
            "type": "string",
            "description": "The first name of the subscriber."
          },
          "lastName": {
            "type": "string",
            "description": "The last name of the subscriber."
          },
          "phone": {
            "type": "string",
            "description": "The phone number of the subscriber."
          },
          "avatar": {
            "type": "string",
            "description": "An HTTP URL to the profile image of your subscriber."
          },
          "locale": {
            "type": "string",
            "description": "The locale of the subscriber."
          },
          "data": {
            "type": "object",
            "description": "An optional payload object that can contain any properties.",
            "additionalProperties": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "number"
                }
              ]
            }
          },
          "channels": {
            "description": "An optional array of subscriber channels.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SubscriberChannelDto"
            }
          }
        },
        "required": ["subscriberId"]
      },
      "UpdatedSubscriberDto": {
        "type": "object",
        "properties": {
          "subscriberId": {
            "type": "string",
            "description": "The ID of the subscriber that was updated."
          }
        },
        "required": ["subscriberId"]
      },
      "CreatedSubscriberDto": {
        "type": "object",
        "properties": {
          "subscriberId": {
            "type": "string",
            "description": "The ID of the subscriber that was created."
          }
        },
        "required": ["subscriberId"]
      },
      "FailedOperationDto": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "The error message associated with the failed operation."
          },
          "subscriberId": {
            "type": "string",
            "description": "The subscriber ID associated with the failed operation. This field is optional."
          }
        }
      },
      "BulkCreateSubscriberResponseDto": {
        "type": "object",
        "properties": {
          "updated": {
            "description": "An array of subscribers that were successfully updated.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UpdatedSubscriberDto"
            }
          },
          "created": {
            "description": "An array of subscribers that were successfully created.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreatedSubscriberDto"
            }
          },
          "failed": {
            "description": "An array of failed operations with error messages and optional subscriber IDs.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FailedOperationDto"
            }
          }
        },
        "required": ["updated", "created", "failed"]
      },
      "BulkSubscriberCreateDto": {
        "type": "object",
        "properties": {
          "subscribers": {
            "description": "An array of subscribers to be created in bulk.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateSubscriberRequestDto"
            }
          }
        },
        "required": ["subscribers"]
      },
      "UpdateSubscriberRequestDto": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "description": "The email address of the subscriber.",
            "example": "john.doe@example.com"
          },
          "firstName": {
            "type": "string",
            "description": "The first name of the subscriber.",
            "example": "John"
          },
          "lastName": {
            "type": "string",
            "description": "The last name of the subscriber.",
            "example": "Doe"
          },
          "phone": {
            "type": "string",
            "description": "The phone number of the subscriber.",
            "example": "+1234567890"
          },
          "avatar": {
            "type": "string",
            "description": "The avatar URL of the subscriber.",
            "example": "https://example.com/avatar.jpg"
          },
          "locale": {
            "type": "string",
            "description": "The locale of the subscriber, for example \"en-US\".",
            "example": "en-US"
          },
          "data": {
            "type": "object",
            "description": "Custom data associated with the subscriber. Can contain any additional properties.",
            "additionalProperties": true,
            "example": {
              "preferences": {
                "notifications": true,
                "theme": "dark"
              },
              "tags": ["premium", "newsletter"]
            }
          },
          "channels": {
            "description": "An array of communication channels for the subscriber.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SubscriberChannelDto"
            }
          }
        }
      },
      "UpdateSubscriberChannelRequestDto": {
        "type": "object",
        "properties": {
          "providerId": {
            "type": "string",
            "enum": [
              "slack",
              "discord",
              "msteams",
              "mattermost",
              "ryver",
              "zulip",
              "grafana-on-call",
              "getstream",
              "rocket-chat",
              "whatsapp-business",
              "fcm",
              "apns",
              "expo",
              "one-signal",
              "pushpad",
              "push-webhook",
              "pusher-beams"
            ],
            "description": "The provider identifier for the credentials"
          },
          "integrationIdentifier": {
            "type": "string",
            "description": "The integration identifier"
          },
          "credentials": {
            "description": "Credentials payload for the specified provider",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChannelCredentials"
              }
            ]
          }
        },
        "required": ["providerId", "integrationIdentifier", "credentials"]
      },
      "UpdateSubscriberOnlineFlagRequestDto": {
        "type": "object",
        "properties": {
          "isOnline": {
            "type": "boolean"
          }
        },
        "required": ["isOnline"]
      },
      "DeleteSubscriberResponseDto": {
        "type": "object",
        "properties": {
          "acknowledged": {
            "type": "boolean",
            "description": "A boolean stating the success of the action"
          },
          "status": {
            "type": "string",
            "description": "The status enum for the performed action",
            "enum": ["deleted"]
          }
        },
        "required": ["acknowledged", "status"]
      },
      "TriggerTypeEnum": {
        "type": "string",
        "description": "The type of the trigger",
        "enum": ["event"]
      },
      "NotificationTriggerVariableResponse": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the variable"
          },
          "value": {
            "type": "object",
            "description": "The value of the variable"
          },
          "type": {
            "type": "string",
            "enum": ["String", "Array", "Boolean"],
            "description": "The type of the variable"
          }
        },
        "required": ["name"]
      },
      "TriggerReservedVariableResponse": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["tenant", "actor"],
            "description": "The type of the reserved variable"
          },
          "variables": {
            "description": "The reserved variables of the trigger",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": ["type", "variables"]
      },
      "NotificationTriggerResponse": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/TriggerTypeEnum"
          },
          "identifier": {
            "type": "string",
            "description": "The identifier of the trigger"
          },
          "variables": {
            "description": "The variables of the trigger",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationTriggerVariableResponse"
            }
          },
          "subscriberVariables": {
            "description": "The subscriber variables of the trigger",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationTriggerVariableResponse"
            }
          },
          "reservedVariables": {
            "description": "The reserved variables of the trigger",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TriggerReservedVariableResponse"
            }
          }
        },
        "required": ["type", "identifier", "variables"]
      },
      "TemplateResponse": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "description": "Unique identifier of the workflow"
          },
          "name": {
            "type": "string",
            "description": "Name of the workflow"
          },
          "critical": {
            "type": "boolean",
            "description": "Critical templates will always be delivered to the end user and should be hidden from the subscriber preferences screen"
          },
          "triggers": {
            "description": "Triggers are the events that will trigger the workflow.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationTriggerResponse"
            }
          }
        },
        "required": ["_id", "name", "critical", "triggers"]
      },
      "PreferenceChannels": {
        "type": "object",
        "properties": {
          "email": {
            "type": "boolean"
          },
          "sms": {
            "type": "boolean"
          },
          "in_app": {
            "type": "boolean"
          },
          "chat": {
            "type": "boolean"
          },
          "push": {
            "type": "boolean"
          }
        }
      },
      "Preference": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "Sets if the workflow is fully enabled for all channels or not for the subscriber."
          },
          "channels": {
            "description": "Subscriber preferences for the different channels regarding this workflow",
            "allOf": [
              {
                "$ref": "#/components/schemas/PreferenceChannels"
              }
            ]
          }
        },
        "required": ["enabled", "channels"]
      },
      "UpdateSubscriberPreferenceResponseDto": {
        "type": "object",
        "properties": {
          "template": {
            "description": "The workflow information and if it is critical or not",
            "allOf": [
              {
                "$ref": "#/components/schemas/TemplateResponse"
              }
            ]
          },
          "preference": {
            "description": "The preferences of the subscriber regarding the related workflow",
            "allOf": [
              {
                "$ref": "#/components/schemas/Preference"
              }
            ]
          }
        },
        "required": ["template", "preference"]
      },
      "GetSubscriberPreferencesResponseDto": {
        "type": "object",
        "properties": {
          "template": {
            "description": "The workflow information and if it is critical or not",
            "allOf": [
              {
                "$ref": "#/components/schemas/TemplateResponse"
              }
            ]
          },
          "preference": {
            "description": "The preferences of the subscriber regarding the related workflow",
            "allOf": [
              {
                "$ref": "#/components/schemas/Preference"
              }
            ]
          }
        },
        "required": ["preference"]
      },
      "ChannelPreference": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/ChannelTypeEnum"
          },
          "enabled": {
            "type": "boolean",
            "description": "If channel is enabled or not"
          }
        },
        "required": ["type", "enabled"]
      },
      "UpdateSubscriberPreferenceRequestDto": {
        "type": "object",
        "properties": {
          "channel": {
            "description": "Optional preferences for each channel type in the assigned workflow.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ChannelPreference"
              }
            ]
          },
          "enabled": {
            "type": "boolean",
            "description": "Indicates whether the workflow is fully enabled for all channels for the subscriber."
          }
        }
      },
      "UpdateSubscriberPreferenceGlobalResponseDto": {
        "type": "object",
        "properties": {
          "preference": {
            "description": "The preferences of the subscriber regarding the related workflow",
            "allOf": [
              {
                "$ref": "#/components/schemas/Preference"
              }
            ]
          }
        },
        "required": ["preference"]
      },
      "UpdateSubscriberGlobalPreferencesRequestDto": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "Enable or disable the subscriber global preferences."
          },
          "preferences": {
            "description": "The subscriber global preferences for every ChannelTypeEnum.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChannelPreference"
            }
          }
        }
      },
      "EmailBlockTypeEnum": {
        "type": "string",
        "description": "Type of the email block",
        "enum": ["button", "text"]
      },
      "TextAlignEnum": {
        "type": "string",
        "description": "Text alignment for the email block",
        "enum": ["center", "left", "right"]
      },
      "EmailBlockStyles": {
        "type": "object",
        "properties": {
          "textAlign": {
            "$ref": "#/components/schemas/TextAlignEnum"
          }
        },
        "required": ["textAlign"]
      },
      "EmailBlock": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/EmailBlockTypeEnum"
          },
          "content": {
            "type": "string",
            "description": "Content of the email block"
          },
          "url": {
            "type": "string",
            "description": "URL associated with the email block, if any"
          },
          "styles": {
            "description": "Styles applied to the email block",
            "allOf": [
              {
                "$ref": "#/components/schemas/EmailBlockStyles"
              }
            ]
          }
        },
        "required": ["type", "content"]
      },
      "ChannelCTATypeEnum": {
        "type": "string",
        "description": "Type of call to action",
        "enum": ["redirect"]
      },
      "MessageCTAData": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "URL for the call to action"
          }
        }
      },
      "MessageActionStatusEnum": {
        "type": "string",
        "description": "Status of the message action",
        "enum": ["pending", "done"]
      },
      "ButtonTypeEnum": {
        "type": "string",
        "description": "Type of button for the action result",
        "enum": ["primary", "secondary"]
      },
      "MessageButton": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/ButtonTypeEnum"
          },
          "content": {
            "type": "string",
            "description": "Content of the button"
          },
          "resultContent": {
            "type": "string",
            "description": "Content of the result when the button is clicked"
          }
        },
        "required": ["type", "content"]
      },
      "MessageActionResult": {
        "type": "object",
        "properties": {
          "payload": {
            "type": "object",
            "description": "Payload of the action result"
          },
          "type": {
            "$ref": "#/components/schemas/ButtonTypeEnum"
          }
        }
      },
      "MessageAction": {
        "type": "object",
        "properties": {
          "status": {
            "$ref": "#/components/schemas/MessageActionStatusEnum"
          },
          "buttons": {
            "description": "List of buttons associated with the message action",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MessageButton"
            }
          },
          "result": {
            "description": "Result of the message action",
            "allOf": [
              {
                "$ref": "#/components/schemas/MessageActionResult"
              }
            ]
          }
        }
      },
      "MessageCTA": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/ChannelCTATypeEnum"
          },
          "data": {
            "description": "Data associated with the call to action",
            "allOf": [
              {
                "$ref": "#/components/schemas/MessageCTAData"
              }
            ]
          },
          "action": {
            "description": "Action associated with the call to action",
            "allOf": [
              {
                "$ref": "#/components/schemas/MessageAction"
              }
            ]
          }
        },
        "required": ["data"]
      },
      "ActorTypeEnum": {
        "type": "string",
        "description": "The type of the actor, indicating the role in the notification process.",
        "enum": ["none", "user", "system_icon", "system_custom"]
      },
      "ActorFeedItemDto": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "description": "The data associated with the actor, can be null if not applicable.",
            "nullable": true,
            "example": null
          },
          "type": {
            "$ref": "#/components/schemas/ActorTypeEnum"
          }
        },
        "required": ["data", "type"]
      },
      "SubscriberFeedResponseDto": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "description": "The internal ID generated by Novu for your subscriber. This ID does not match the `subscriberId` used in your queries. Refer to `subscriberId` for that identifier."
          },
          "firstName": {
            "type": "string",
            "description": "The first name of the subscriber."
          },
          "lastName": {
            "type": "string",
            "description": "The last name of the subscriber."
          },
          "avatar": {
            "type": "string",
            "description": "The URL of the subscriber's avatar image."
          },
          "subscriberId": {
            "type": "string",
            "description": "The identifier used to create this subscriber, which typically corresponds to the user ID in your system."
          }
        },
        "required": ["firstName", "lastName", "subscriberId"]
      },
      "NotificationFeedItemDto": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "description": "Unique identifier for the notification.",
            "example": "615c1f2f9b0c5b001f8e4e3b"
          },
          "_templateId": {
            "type": "string",
            "description": "Identifier for the template used to generate the notification.",
            "example": "template_12345"
          },
          "_environmentId": {
            "type": "string",
            "description": "Identifier for the environment where the notification is sent.",
            "example": "env_67890"
          },
          "_messageTemplateId": {
            "type": "string",
            "description": "Identifier for the message template used.",
            "example": "message_template_54321"
          },
          "_organizationId": {
            "type": "string",
            "description": "Identifier for the organization sending the notification.",
            "example": "org_98765"
          },
          "_notificationId": {
            "type": "string",
            "description": "Unique identifier for the notification instance.",
            "example": "notification_123456"
          },
          "_subscriberId": {
            "type": "string",
            "description": "Unique identifier for the subscriber receiving the notification.",
            "example": "subscriber_112233"
          },
          "_feedId": {
            "type": "string",
            "description": "Identifier for the feed associated with the notification.",
            "example": "feed_445566"
          },
          "_jobId": {
            "type": "string",
            "description": "Identifier for the job that triggered the notification.",
            "example": "job_778899"
          },
          "createdAt": {
            "type": "string",
            "description": "Timestamp indicating when the notification was created.",
            "format": "date-time",
            "nullable": true,
            "example": "2024-12-10T10:10:59.639Z"
          },
          "updatedAt": {
            "type": "string",
            "description": "Timestamp indicating when the notification was last updated.",
            "format": "date-time",
            "nullable": true,
            "example": "2024-12-10T10:10:59.639Z"
          },
          "actor": {
            "description": "Actor details related to the notification, if applicable.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ActorFeedItemDto"
              }
            ]
          },
          "subscriber": {
            "description": "Subscriber details associated with this notification.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SubscriberFeedResponseDto"
              }
            ]
          },
          "transactionId": {
            "type": "string",
            "description": "Unique identifier for the transaction associated with the notification.",
            "example": "transaction_123456"
          },
          "templateIdentifier": {
            "type": "string",
            "description": "Identifier for the template used, if applicable.",
            "nullable": true,
            "example": "template_abcdef"
          },
          "providerId": {
            "type": "string",
            "description": "Identifier for the provider that sends the notification.",
            "nullable": true,
            "example": "provider_xyz"
          },
          "content": {
            "type": "string",
            "description": "The main content of the notification.",
            "example": "This is a test notification content."
          },
          "subject": {
            "type": "string",
            "description": "The subject line for email notifications, if applicable.",
            "nullable": true,
            "example": "Test Notification Subject"
          },
          "channel": {
            "$ref": "#/components/schemas/ChannelTypeEnum"
          },
          "read": {
            "type": "boolean",
            "description": "Indicates whether the notification has been read by the subscriber.",
            "example": false
          },
          "seen": {
            "type": "boolean",
            "description": "Indicates whether the notification has been seen by the subscriber.",
            "example": true
          },
          "deleted": {
            "type": "boolean",
            "description": "Indicates whether the notification has been deleted.",
            "example": false
          },
          "deviceTokens": {
            "description": "Device tokens for push notifications, if applicable.",
            "nullable": true,
            "example": ["token1", "token2"],
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "cta": {
            "description": "Call-to-action information associated with the notification.",
            "allOf": [
              {
                "$ref": "#/components/schemas/MessageCTA"
              }
            ]
          },
          "status": {
            "type": "string",
            "description": "Current status of the notification.",
            "enum": ["sent", "error", "warning"],
            "example": "sent"
          },
          "payload": {
            "type": "object",
            "description": "The payload that was used to send the notification trigger.",
            "additionalProperties": true,
            "example": {
              "key": "value"
            }
          },
          "overrides": {
            "type": "object",
            "description": "Provider-specific overrides used when triggering the notification.",
            "additionalProperties": true,
            "example": {
              "overrideKey": "overrideValue"
            }
          }
        },
        "required": [
          "_id",
          "_templateId",
          "_environmentId",
          "_messageTemplateId",
          "_organizationId",
          "_notificationId",
          "_subscriberId",
          "_feedId",
          "_jobId",
          "transactionId",
          "content",
          "channel",
          "read",
          "seen",
          "deleted",
          "cta",
          "status"
        ]
      },
      "FeedResponseDto": {
        "type": "object",
        "properties": {
          "totalCount": {
            "type": "number",
            "description": "Total number of notifications available.",
            "example": 5
          },
          "hasMore": {
            "type": "boolean",
            "description": "Indicates if there are more notifications to load.",
            "example": true
          },
          "data": {
            "description": "Array of notifications returned in the response.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationFeedItemDto"
            }
          },
          "pageSize": {
            "type": "number",
            "description": "The number of notifications returned in this response.",
            "example": 2
          },
          "page": {
            "type": "number",
            "description": "The current page number of the notifications.",
            "example": 1
          }
        },
        "required": ["hasMore", "data", "pageSize", "page"]
      },
      "UnseenCountResponse": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          }
        },
        "required": ["count"]
      },
      "NotificationGroup": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "_environmentId": {
            "type": "string"
          },
          "_organizationId": {
            "type": "string"
          },
          "_parentId": {
            "type": "string"
          }
        },
        "required": ["name", "_environmentId", "_organizationId"]
      },
      "DigestRegularMetadata": {
        "type": "object",
        "properties": {
          "amount": {
            "type": "number"
          },
          "unit": {
            "type": "string",
            "enum": ["seconds", "minutes", "hours", "days", "weeks", "months"]
          },
          "digestKey": {
            "type": "string"
          },
          "type": {
            "type": "string",
            "enum": ["regular", "backoff"]
          },
          "backoff": {
            "type": "boolean"
          },
          "backoffAmount": {
            "type": "number"
          },
          "backoffUnit": {
            "type": "string",
            "enum": ["seconds", "minutes", "hours", "days", "weeks", "months"]
          },
          "updateMode": {
            "type": "boolean"
          }
        },
        "required": ["type"]
      },
      "TimedConfig": {
        "type": "object",
        "properties": {
          "atTime": {
            "type": "string"
          },
          "weekDays": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]
            }
          },
          "monthDays": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "ordinal": {
            "type": "string",
            "enum": ["1", "2", "3", "4", "5", "last"]
          },
          "ordinalValue": {
            "type": "string",
            "enum": [
              "day",
              "weekday",
              "weekend",
              "sunday",
              "monday",
              "tuesday",
              "wednesday",
              "thursday",
              "friday",
              "saturday"
            ]
          },
          "monthlyType": {
            "type": "string",
            "enum": ["each", "on"]
          }
        }
      },
      "DigestTimedMetadata": {
        "type": "object",
        "properties": {
          "amount": {
            "type": "number"
          },
          "unit": {
            "type": "string",
            "enum": ["seconds", "minutes", "hours", "days", "weeks", "months"]
          },
          "digestKey": {
            "type": "string"
          },
          "type": {
            "type": "string",
            "enum": ["timed"]
          },
          "timed": {
            "$ref": "#/components/schemas/TimedConfig"
          }
        },
        "required": ["type"]
      },
      "DelayRegularMetadata": {
        "type": "object",
        "properties": {
          "amount": {
            "type": "number"
          },
          "unit": {
            "type": "string",
            "enum": ["seconds", "minutes", "hours", "days", "weeks", "months"]
          },
          "type": {
            "type": "string",
            "enum": ["regular"]
          }
        },
        "required": ["type"]
      },
      "DelayScheduledMetadata": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["scheduled"]
          },
          "delayPath": {
            "type": "string"
          }
        },
        "required": ["type", "delayPath"]
      },
      "MessageTemplate": {
        "type": "object",
        "properties": {}
      },
      "ReplyCallback": {
        "type": "object",
        "properties": {
          "active": {
            "type": "boolean",
            "description": "Indicates whether the reply callback is active."
          },
          "url": {
            "type": "string",
            "description": "The URL to which replies should be sent."
          }
        }
      },
      "NotificationStepData": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "description": "Unique identifier for the notification step."
          },
          "uuid": {
            "type": "string",
            "description": "Universally unique identifier for the notification step."
          },
          "name": {
            "type": "string",
            "description": "Name of the notification step."
          },
          "_templateId": {
            "type": "string",
            "description": "ID of the template associated with this notification step."
          },
          "active": {
            "type": "boolean",
            "description": "Indicates whether the notification step is active."
          },
          "shouldStopOnFail": {
            "type": "boolean",
            "description": "Determines if the process should stop on failure."
          },
          "template": {
            "description": "Message template used in this notification step.",
            "allOf": [
              {
                "$ref": "#/components/schemas/MessageTemplate"
              }
            ]
          },
          "filters": {
            "description": "Filters applied to this notification step.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StepFilterDto"
            }
          },
          "_parentId": {
            "type": "string",
            "description": "ID of the parent notification step, if applicable."
          },
          "metadata": {
            "description": "Metadata associated with the workflow step. Can vary based on the type of step.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/DigestRegularMetadata"
              },
              {
                "$ref": "#/components/schemas/DigestTimedMetadata"
              },
              {
                "$ref": "#/components/schemas/DelayRegularMetadata"
              },
              {
                "$ref": "#/components/schemas/DelayScheduledMetadata"
              }
            ]
          },
          "replyCallback": {
            "description": "Callback information for replies, including whether it is active and the callback URL.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ReplyCallback"
              }
            ]
          }
        }
      },
      "NotificationStepDto": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "description": "Unique identifier for the notification step."
          },
          "uuid": {
            "type": "string",
            "description": "Universally unique identifier for the notification step."
          },
          "name": {
            "type": "string",
            "description": "Name of the notification step."
          },
          "_templateId": {
            "type": "string",
            "description": "ID of the template associated with this notification step."
          },
          "active": {
            "type": "boolean",
            "description": "Indicates whether the notification step is active."
          },
          "shouldStopOnFail": {
            "type": "boolean",
            "description": "Determines if the process should stop on failure."
          },
          "template": {
            "description": "Message template used in this notification step.",
            "allOf": [
              {
                "$ref": "#/components/schemas/MessageTemplate"
              }
            ]
          },
          "filters": {
            "description": "Filters applied to this notification step.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StepFilterDto"
            }
          },
          "_parentId": {
            "type": "string",
            "description": "ID of the parent notification step, if applicable."
          },
          "metadata": {
            "description": "Metadata associated with the workflow step. Can vary based on the type of step.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/DigestRegularMetadata"
              },
              {
                "$ref": "#/components/schemas/DigestTimedMetadata"
              },
              {
                "$ref": "#/components/schemas/DelayRegularMetadata"
              },
              {
                "$ref": "#/components/schemas/DelayScheduledMetadata"
              }
            ]
          },
          "replyCallback": {
            "description": "Callback information for replies, including whether it is active and the callback URL.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ReplyCallback"
              }
            ]
          },
          "variants": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationStepData"
            }
          }
        }
      },
      "NotificationTrigger": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["event"]
          },
          "identifier": {
            "type": "string"
          },
          "variables": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationTriggerVariable"
            }
          },
          "subscriberVariables": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationTriggerVariable"
            }
          }
        },
        "required": ["type", "identifier", "variables", "subscriberVariables"]
      },
      "WorkflowResponse": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "active": {
            "type": "boolean"
          },
          "draft": {
            "type": "boolean"
          },
          "preferenceSettings": {
            "$ref": "#/components/schemas/PreferenceChannels"
          },
          "critical": {
            "type": "boolean"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "steps": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationStepDto"
            }
          },
          "_organizationId": {
            "type": "string"
          },
          "_creatorId": {
            "type": "string"
          },
          "_environmentId": {
            "type": "string"
          },
          "triggers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationTrigger"
            }
          },
          "_notificationGroupId": {
            "type": "string"
          },
          "_parentId": {
            "type": "string"
          },
          "deleted": {
            "type": "boolean"
          },
          "deletedAt": {
            "type": "string"
          },
          "deletedBy": {
            "type": "string"
          },
          "notificationGroup": {
            "$ref": "#/components/schemas/NotificationGroup"
          },
          "data": {
            "type": "object"
          }
        },
        "required": [
          "name",
          "description",
          "active",
          "draft",
          "preferenceSettings",
          "critical",
          "tags",
          "steps",
          "_organizationId",
          "_creatorId",
          "_environmentId",
          "triggers",
          "_notificationGroupId",
          "deleted",
          "deletedAt",
          "deletedBy"
        ]
      },
      "MessageStatusEnum": {
        "type": "string",
        "description": "Status of the message",
        "enum": ["sent", "error", "warning"]
      },
      "MessageResponseDto": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "description": "Unique identifier for the message"
          },
          "_templateId": {
            "type": "string",
            "description": "Template ID associated with the message"
          },
          "_environmentId": {
            "type": "string",
            "description": "Environment ID where the message is sent"
          },
          "_messageTemplateId": {
            "type": "string",
            "description": "Message template ID"
          },
          "_organizationId": {
            "type": "string",
            "description": "Organization ID associated with the message"
          },
          "_notificationId": {
            "type": "string",
            "description": "Notification ID associated with the message"
          },
          "_subscriberId": {
            "type": "string",
            "description": "Subscriber ID associated with the message"
          },
          "subscriber": {
            "description": "Subscriber details, if available",
            "allOf": [
              {
                "$ref": "#/components/schemas/SubscriberResponseDto"
              }
            ]
          },
          "template": {
            "description": "Workflow template associated with the message",
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowResponse"
              }
            ]
          },
          "templateIdentifier": {
            "type": "string",
            "description": "Identifier for the message template"
          },
          "createdAt": {
            "type": "string",
            "description": "Creation date of the message"
          },
          "lastSeenDate": {
            "type": "string",
            "description": "Last seen date of the message, if available"
          },
          "lastReadDate": {
            "type": "string",
            "description": "Last read date of the message, if available"
          },
          "content": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/EmailBlock"
              },
              {
                "type": "string",
                "description": "String representation of the content"
              }
            ],
            "description": "Content of the message, can be an email block or a string"
          },
          "transactionId": {
            "type": "string",
            "description": "Transaction ID associated with the message"
          },
          "subject": {
            "type": "string",
            "description": "Subject of the message, if applicable"
          },
          "channel": {
            "$ref": "#/components/schemas/ChannelTypeEnum"
          },
          "read": {
            "type": "boolean",
            "description": "Indicates if the message has been read"
          },
          "seen": {
            "type": "boolean",
            "description": "Indicates if the message has been seen"
          },
          "email": {
            "type": "string",
            "description": "Email address associated with the message, if applicable"
          },
          "phone": {
            "type": "string",
            "description": "Phone number associated with the message, if applicable"
          },
          "directWebhookUrl": {
            "type": "string",
            "description": "Direct webhook URL for the message, if applicable"
          },
          "providerId": {
            "type": "string",
            "description": "Provider ID associated with the message, if applicable"
          },
          "deviceTokens": {
            "description": "Device tokens associated with the message, if applicable",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "title": {
            "type": "string",
            "description": "Title of the message, if applicable"
          },
          "cta": {
            "description": "Call to action associated with the message",
            "allOf": [
              {
                "$ref": "#/components/schemas/MessageCTA"
              }
            ]
          },
          "_feedId": {
            "type": "string",
            "description": "Feed ID associated with the message, if applicable"
          },
          "status": {
            "$ref": "#/components/schemas/MessageStatusEnum"
          },
          "errorId": {
            "type": "string",
            "description": "Error ID if the message has an error"
          },
          "errorText": {
            "type": "string",
            "description": "Error text if the message has an error"
          },
          "payload": {
            "type": "object",
            "description": "The payload that was used to send the notification trigger"
          },
          "overrides": {
            "type": "object",
            "description": "Provider specific overrides used when triggering the notification"
          }
        },
        "required": [
          "_templateId",
          "_environmentId",
          "_messageTemplateId",
          "_organizationId",
          "_notificationId",
          "_subscriberId",
          "createdAt",
          "content",
          "transactionId",
          "channel",
          "read",
          "seen",
          "cta",
          "status"
        ]
      },
      "MessageMarkAsRequestDto": {
        "type": "object",
        "properties": {
          "messageId": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          },
          "markAs": {
            "type": "string",
            "enum": ["read", "seen", "unread", "unseen"]
          }
        },
        "required": ["messageId", "markAs"]
      },
      "MarkAllMessageAsRequestDto": {
        "type": "object",
        "properties": {
          "feedIdentifier": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "description": "Optional feed identifier or array of feed identifiers"
          },
          "markAs": {
            "type": "string",
            "enum": ["read", "seen", "unread", "unseen"],
            "description": "Mark all subscriber messages as read, unread, seen or unseen"
          }
        },
        "required": ["markAs"]
      },
      "MarkMessageActionAsSeenDto": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "enum": ["pending", "done"],
            "description": "Message action status"
          },
          "payload": {
            "type": "object",
            "description": "Message action payload"
          }
        },
        "required": ["status"]
      },
      "String": {
        "type": "object",
        "properties": {}
      },
      "ListSubscribersResponseDto": {
        "type": "object",
        "properties": {
          "data": {
            "description": "List of returned Subscribers",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SubscriberResponseDto"
            }
          },
          "next": {
            "type": "string",
            "description": "The cursor for the next page of results, or null if there are no more pages.",
            "nullable": true
          },
          "previous": {
            "type": "string",
            "description": "The cursor for the previous page of results, or null if this is the first page.",
            "nullable": true
          }
        },
        "required": ["data", "next", "previous"]
      },
      "DeleteMessageResponseDto": {
        "type": "object",
        "properties": {
          "acknowledged": {
            "type": "boolean",
            "description": "A boolean stating the success of the action"
          },
          "status": {
            "type": "string",
            "description": "The status enum for the performed action",
            "enum": ["deleted"]
          }
        },
        "required": ["acknowledged", "status"]
      },
      "CreateTopicResponseDto": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "description": "The unique identifier for the Topic created."
          },
          "key": {
            "type": "string",
            "description": "User defined custom key and provided by the user that will be an unique identifier for the Topic created."
          }
        },
        "required": ["key"]
      },
      "CreateTopicRequestDto": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "User defined custom key and provided by the user that will be an unique identifier for the Topic created."
          },
          "name": {
            "type": "string",
            "description": "User defined custom name and provided by the user that will name the Topic created."
          }
        },
        "required": ["key", "name"]
      },
      "AddSubscribersRequestDto": {
        "type": "object",
        "properties": {
          "subscribers": {
            "description": "List of subscriber identifiers that will be associated to the topic",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": ["subscribers"]
      },
      "FailedAssignmentsDto": {
        "type": "object",
        "properties": {
          "notFound": {
            "description": "List of subscriber IDs that were not found",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AssignSubscriberToTopicDto": {
        "type": "object",
        "properties": {
          "succeeded": {
            "description": "List of successfully assigned subscriber IDs",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "failed": {
            "description": "Details about failed assignments",
            "allOf": [
              {
                "$ref": "#/components/schemas/FailedAssignmentsDto"
              }
            ]
          }
        },
        "required": ["succeeded"]
      },
      "TopicSubscriberDto": {
        "type": "object",
        "properties": {
          "_organizationId": {
            "type": "string",
            "description": "Unique identifier for the organization",
            "example": "org_123456789"
          },
          "_environmentId": {
            "type": "string",
            "description": "Unique identifier for the environment",
            "example": "env_123456789"
          },
          "_subscriberId": {
            "type": "string",
            "description": "Unique identifier for the subscriber",
            "example": "sub_123456789"
          },
          "_topicId": {
            "type": "string",
            "description": "Unique identifier for the topic",
            "example": "topic_123456789"
          },
          "topicKey": {
            "type": "string",
            "description": "Key associated with the topic",
            "example": "my_topic_key"
          },
          "externalSubscriberId": {
            "type": "string",
            "description": "External identifier for the subscriber",
            "example": "external_subscriber_123"
          }
        },
        "required": [
          "_organizationId",
          "_environmentId",
          "_subscriberId",
          "_topicId",
          "topicKey",
          "externalSubscriberId"
        ]
      },
      "RemoveSubscribersRequestDto": {
        "type": "object",
        "properties": {
          "subscribers": {
            "description": "List of subscriber identifiers that will be removed to the topic",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": ["subscribers"]
      },
      "TopicDto": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string"
          },
          "_organizationId": {
            "type": "string"
          },
          "_environmentId": {
            "type": "string"
          },
          "key": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "subscribers": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": ["_organizationId", "_environmentId", "key", "name", "subscribers"]
      },
      "FilterTopicsResponseDto": {
        "type": "object",
        "properties": {
          "data": {
            "example": [],
            "description": "The list of topics",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TopicDto"
            }
          },
          "page": {
            "type": "number",
            "example": 1,
            "description": "The current page number"
          },
          "pageSize": {
            "type": "number",
            "example": 10,
            "description": "The number of items per page"
          },
          "totalCount": {
            "type": "number",
            "example": 10,
            "description": "The total number of items"
          }
        },
        "required": ["data", "page", "pageSize", "totalCount"]
      },
      "GetTopicResponseDto": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string"
          },
          "_organizationId": {
            "type": "string"
          },
          "_environmentId": {
            "type": "string"
          },
          "key": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "subscribers": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": ["_organizationId", "_environmentId", "key", "name", "subscribers"]
      },
      "RenameTopicResponseDto": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string"
          },
          "_organizationId": {
            "type": "string"
          },
          "_environmentId": {
            "type": "string"
          },
          "key": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "subscribers": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": ["_organizationId", "_environmentId", "key", "name", "subscribers"]
      },
      "RenameTopicRequestDto": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "User defined custom name and provided by the user to rename the topic."
          }
        },
        "required": ["name"]
      }
    },
    "headers": {
      "Content-Type": {
        "required": true,
        "description": "The MIME type of the response body.",
        "schema": {
          "type": "string"
        },
        "example": "application/json"
      },
      "RateLimit-Limit": {
        "required": false,
        "description": "The number of requests that the client is permitted to make per second. The actual maximum may differ when burst is enabled.",
        "schema": {
          "type": "string"
        },
        "example": "100"
      },
      "RateLimit-Remaining": {
        "required": false,
        "description": "The number of requests remaining until the next window.",
        "schema": {
          "type": "string"
        },
        "example": "93"
      },
      "RateLimit-Reset": {
        "required": false,
        "description": "The remaining seconds until a request of the same cost will be refreshed.",
        "schema": {
          "type": "string"
        },
        "example": "8"
      },
      "RateLimit-Policy": {
        "required": false,
        "description": "The rate limit policy that was used to evaluate the request.",
        "schema": {
          "type": "string"
        },
        "example": "100;w=1;burst=110;comment=\"token bucket\";category=\"trigger\";cost=\"single\""
      },
      "Retry-After": {
        "required": false,
        "description": "The number of seconds after which the client may retry the request that was previously rejected.",
        "schema": {
          "type": "string"
        },
        "example": "8"
      },
      "Idempotency-Key": {
        "required": false,
        "description": "The idempotency key used to evaluate the request.",
        "schema": {
          "type": "string"
        },
        "example": "8"
      },
      "Idempotency-Replay": {
        "required": false,
        "description": "Whether the request was a replay of a previous request.",
        "schema": {
          "type": "string"
        },
        "example": "true"
      },
      "Link": {
        "required": false,
        "description": "A link to the documentation.",
        "schema": {
          "type": "string"
        },
        "example": "https://docs.novu.co/"
      }
    }
  },
  "externalDocs": {
    "description": "Novu Documentation",
    "url": "https://docs.novu.co"
  },
  "security": [
    {
      "secretKey": []
    },
    {
      "bearerAuth": []
    }
  ],
  "x-speakeasy-name-override": [
    {
      "operationId": "^.*get.*",
      "methodNameOverride": "retrieve"
    },
    {
      "operationId": "^.*retrieve.*",
      "methodNameOverride": "retrieve"
    },
    {
      "operationId": "^.*create.*",
      "methodNameOverride": "create"
    },
    {
      "operationId": "^.*update.*",
      "methodNameOverride": "update"
    },
    {
      "operationId": "^.*list.*",
      "methodNameOverride": "list"
    },
    {
      "operationId": "^.*delete.*",
      "methodNameOverride": "delete"
    },
    {
      "operationId": "^.*remove.*",
      "methodNameOverride": "delete"
    }
  ],
  "x-speakeasy-retries": {
    "strategy": "backoff",
    "backoff": {
      "initialInterval": 1000,
      "maxInterval": 30000,
      "maxElapsedTime": 3600000,
      "exponent": 1.5
    },
    "statusCodes": [408, 409, 429, "5XX"],
    "retryConnectionErrors": true
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

{
"openapi": "3.0.0",
"paths": {
"/v1/events/trigger": {
"post": {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Aade un README describiendo qu hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/apps/api/swc-register.js
Tamao: 1365 bytes
Lenguaje detectado: JavaScript

### CONTENIDO ORIGINAL ###

/** biome-ignore-all lint/style/noCommonJs: <explanation> */
const { transformFileSync } = require('@swc/core');
const { addHook } = require('pirates');

require('ts-node').register({
  transpileOnly: true,
  compilerOptions: {
    module: 'commonjs',
    target: 'es5',
    esModuleInterop: false,
  },
});

addHook(
  (code, filename) => {
    try {
      const result = transformFileSync(filename, {
        jsc: {
          target: 'es5',
          parser: {
            syntax: 'typescript',
            tsx: true,
            decorators: true,
            dynamicImport: true,
          },
          transform: {
            decoratorMetadata: true,
            useDefineForClassFields: false,
          },
          keepClassNames: true,
          preserveAllComments: true,
        },
        module: {
          type: 'commonjs',
          strictMode: false,
          noInterop: false,
        },
        sourceMaps: true,
        inlineSourcesContent: true,
        minify: false,
      });

      return result.code;
    } catch (error) {
      console.error(`Error transforming file ${filename}:`, error);

      return code;
    }
  },
  {
    exts: ['.ts', '.tsx'],
    matcher: (filename) => {
      if (filename.includes('.source')) {
        return false;
      }

      return filename.endsWith('.ts') || filename.endsWith('.tsx');
    },
  }
);


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - result(transformFileSync(filename, {
        jsc: {
          target: 'es5',
          parser: {
          ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/tsconfig.build.json
Tamao: 588 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "noImplicitAny": false,
    "removeComments": true,
    "allowSyntheticDefaultImports": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "strictNullChecks": true,
    "target": "es6",
    "esModuleInterop": false,
    "sourceMap": true,
    "skipLibCheck": true,
    "outDir": "./dist",
    "baseUrl": "./src"
  },
  "include": ["src/**/*", "src/**/*.d.ts"],
  "exclude": ["node_modules", "**/*.spec.ts", "**/*.e2e.ts", "**/*.e2e-ee.ts"]
}


### ANALISIS AUTOMATICO (ESPAOL) ###

{
"extends": "../../tsconfig.json",
"compilerOptions": {
"module": "commonjs",
"declaration": true,
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Aade un README describiendo qu hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/apps/api/tsconfig.json
Tamao: 351 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "allowJs": false,
    "allowSyntheticDefaultImports": true,
    "emitDecoratorMetadata": true,
    "esModuleInterop": true,
    "module": "commonjs",
    "skipLibCheck": true,
    "sourceMap": true,
    "strictNullChecks": true,
    "target": "es6"
  },
  "exclude": ["node_modules"]
}


### ANALISIS AUTOMATICO (ESPAOL) ###

{
"extends": "../../tsconfig.json",
"compilerOptions": {
"allowJs": false,
"allowSyntheticDefaultImports": true,
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Aade un README describiendo qu hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/apps/api/tsconfig.spec.json
Tamao: 219 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "extends": "apps/api/tsconfig.json",
  "compilerOptions": {
    "strictNullChecks": false,
    "types": ["node", "mocha"],
    "esModuleInterop": false,
    "skipLibCheck": true
  },
  "exclude": ["node_modules"]
}


### ANALISIS AUTOMATICO (ESPAOL) ###

{
"extends": "apps/api/tsconfig.json",
"compilerOptions": {
"strictNullChecks": false,
"types": ["node", "mocha"],
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Aade un README describiendo qu hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/apps/api/webpack.config.js
Tamao: 129 bytes
Lenguaje detectado: JavaScript

### CONTENIDO ORIGINAL ###

// biome-ignore lint/style/noCommonJs: <explanation>
module.exports = (options) => ({
  ...options,
  devtool: 'source-map',
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - exports(options))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/.vscode/settings.json
Tamao: 747 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "mochaExplorer.configFile": ".mocharc.json",
  "mochaExplorer.files": ["e2e/setup.ts", "e2e/**/*.e2e.ts", "src/**/*.e2e.ts", "src/**/**/*.spec.ts"],
  "mochaExplorer.require": ["./swc-register.js"],
  "mochaExplorer.env": {
    "NODE_ENV": "test"
  },
  "jest.runMode": "on-demand",
  "jest.enable": false,
  // Biome configuration
  "editor.defaultFormatter": "biomejs.biome",
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.biome": "explicit",
    "source.organizeImports.biome": "explicit"
  },
  "[typescript]": {
    "editor.defaultFormatter": "biomejs.biome"
  },
  "[javascript]": {
    "editor.defaultFormatter": "biomejs.biome"
  },
  "[json]": {
    "editor.defaultFormatter": "biomejs.biome"
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

{
"mochaExplorer.configFile": ".mocharc.json",
"mochaExplorer.files": ["e2e/setup.ts", "e2e/**/*.e2e.ts", "src/**/*.e2e.ts", "src/**/**/*.spec.ts"],
"mochaExplorer.require": ["./swc-register.js"],
"mochaExplorer.env": {
// Biome configuration
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Aade un README describiendo qu hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/apps/api/admin/connect-to-dal.ts
Tamao: 393 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { DalService } from '@novu/dal';

const dalService = new DalService();

export async function connect(databaseQuery: () => Promise<void>) {
  try {
    await dalService.connect(process.env.MONGO_URL);
    await databaseQuery();
  } catch (e) {
    console.error(e);
  } finally {
    if (dalService.isConnected()) {
      await dalService.disconnect();
    }
    process.exit(0);
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - connect(databaseQuery: ()
Asignaciones con arrow functions encontradas (posibles funciones):
 - dalService(new DalService();

export async function connect(databaseQuery: ())
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/admin/make-json-backup.ts
Tamao: 763 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { existsSync, promises } from 'node:fs';
import { format } from 'date-fns';

const backupFolder = `${__dirname}/backups`;

export async function makeJsonBackup(folder: string, fileName: string, obj: unknown) {
  try {
    const fullFolderPath = `${backupFolder}/${folder}`;
    if (!existsSync(fullFolderPath)) {
      await promises.mkdir(fullFolderPath, { recursive: true });
    }

    const dateString = format(new Date(), 'yyyy-MM-dd:HH:mm:ss:SSS');
    const fullFileName = `${dateString}_${fileName}`;
    await promises.writeFile(`${fullFolderPath}/${fullFileName}.json`, JSON.stringify(obj));
    console.log(`The backup JSON was written to file ${fullFileName}`);
  } catch (e) {
    console.error('Error writing backup JSON to file:', e);
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - makeJsonBackup(folder: string, fileName: string, obj: unknown)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/admin/remove-organization.ts
Tamao: 4431 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import '../src/config';
import {
  BaseRepository,
  ChangeRepository,
  CommunityMemberRepository,
  CommunityOrganizationRepository,
  EnforceEnvOrOrgIds,
  EnvironmentId,
  EnvironmentRepository,
  FeedRepository,
  IntegrationRepository,
  LayoutRepository,
  MessageRepository,
  MessageTemplateRepository,
  NotificationGroupRepository,
  NotificationTemplateRepository,
  OrganizationId,
  SubscriberRepository,
  TenantRepository,
  TopicRepository,
  TopicSubscribersRepository,
} from '@novu/dal';

import { connect } from './connect-to-dal';
import { makeJsonBackup } from './make-json-backup';

const args = process.argv.slice(2);
const ORG_ID = args[0];
const folder = 'remove-organization';

async function removeData<T extends BaseRepository<object, E, EnforceEnvOrOrgIds>, E extends { _id?: string }>(
  repository: T,
  model: string,
  organizationId: OrganizationId,
  environmentIds: EnvironmentId[]
) {
  const data = await repository.find({
    _organizationId: organizationId,
    _environmentId: {
      $in: environmentIds,
    },
  });
  console.log(`Found ${data.length} ${model} from all environments of the organization`);

  if (data.length > 0) {
    console.log(`Removing ${data.length} ${model} from all environments of the organization`);
    await makeJsonBackup(folder, model, data);
    await repository._model.deleteMany({
      _id: {
        $in: data.map((change) => change._id),
      },
    });
  }
}

connect(async () => {
  const organizationRepository = new CommunityOrganizationRepository();
  const environmentRepository = new EnvironmentRepository();
  const memberRepository = new CommunityMemberRepository();

  const organization = await organizationRepository.findById(ORG_ID);
  if (!organization) {
    throw new Error(`Organization with id ${ORG_ID} is not found`);
  }

  console.log(`The organization ${organization.name} is found`);

  const membersOfOrganization = await memberRepository._model.find({
    _organizationId: organization._id,
  });
  console.log(`The organization has ${membersOfOrganization.length} members`);

  if (membersOfOrganization.length > 0) {
    console.log(`Removing members from organization`);
    await makeJsonBackup(folder, 'members', membersOfOrganization);
    await memberRepository._model.deleteMany({
      _organizationId: organization._id,
    });
  }

  const environmentsOfOrganization = await environmentRepository.findOrganizationEnvironments(organization._id);
  const envIds = environmentsOfOrganization.map((env) => env._id);

  await removeData(new ChangeRepository(), 'changes', organization._id, envIds);
  // await removeData(new ExecutionDetailsRepository(), 'executiondetails', organization._id, envIds);
  await removeData(new FeedRepository(), 'feeds', organization._id, envIds);
  await removeData(new IntegrationRepository(), 'integrations', organization._id, envIds);
  // await removeData(new JobRepository(), 'jobs', organization._id, envIds);
  await removeData(new LayoutRepository(), 'layouts', organization._id, envIds);
  await removeData(new MessageRepository(), 'messages', organization._id, envIds);
  await removeData(new MessageTemplateRepository(), 'messagetemplates', organization._id, envIds);
  await removeData(new NotificationGroupRepository(), 'notificationgroups', organization._id, envIds);
  // await removeData(new NotificationRepository(), 'notifications', organization._id, envIds);
  await removeData(new NotificationTemplateRepository(), 'workflows', organization._id, envIds);
  await removeData(new SubscriberRepository(), 'subscribers', organization._id, envIds);
  await removeData(new TenantRepository(), 'tenants', organization._id, envIds);
  await removeData(new TopicRepository(), 'topics', organization._id, envIds);
  await removeData(new TopicSubscribersRepository(), 'topicsubscribers', organization._id, envIds);

  if (environmentsOfOrganization.length > 0) {
    console.log(`Removing all environments of the organization ${organization.name}`);
    await makeJsonBackup(folder, 'environments', environmentsOfOrganization);
    await environmentRepository._model.deleteMany({
      _id: {
        $in: envIds,
      },
      _organizationId: organization._id,
    });
  }

  console.log(`Removing the organization ${organization.name}`);
  await makeJsonBackup(folder, 'organization', organization);
  await organizationRepository.delete({ _id: organization._id });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - data(await repository.find({
    _organizationId: organizationId,
    _environmentId: {
      $in: enviro...)
 - envIds(environmentsOfOrganization.map((env))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/admin/remove-user-account.ts
Tamao: 1304 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import '../src/config';
import { CommunityMemberRepository, CommunityUserRepository } from '@novu/dal';
import { normalizeEmail } from '@novu/shared';
import { connect } from './connect-to-dal';
import { makeJsonBackup } from './make-json-backup';

const args = process.argv.slice(2);
const EMAIL = args[0];
const folder = 'remove-user-account';

connect(async () => {
  const userRepository = new CommunityUserRepository();
  const memberRepository = new CommunityMemberRepository();

  const email = normalizeEmail(EMAIL);
  const user = await userRepository.findByEmail(email);
  if (!user) {
    throw new Error(`User account with email ${email} is not found`);
  }

  console.log(`The user with email: ${email} is found`);

  const memberOfOrganizations = await memberRepository._model.find({
    _userId: user._id,
  });
  console.log(`User is a member of ${memberOfOrganizations.length} organizations`);

  if (memberOfOrganizations.length > 0) {
    console.log(`Removing user from all organizations`);
    await makeJsonBackup(folder, 'members', memberOfOrganizations);
    await memberRepository._model.deleteMany({
      _userId: user._id,
    });
  }

  console.log(`Removing user account`);
  await makeJsonBackup(folder, 'user', user);
  await userRepository.delete({ _id: user._id });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - folder('remove-user-account';

connect(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/e2e/compile-email-template.e2e.ts
Tamao: 12227 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import {
  CompileEmailTemplate,
  CompileEmailTemplateCommand,
  CompileTemplate,
  GetLayoutUseCase,
  GetNovuLayout,
} from '@novu/application-generic';
import { DalService, LayoutRepository, OrganizationRepository } from '@novu/dal';
import { ChannelTypeEnum, EmailBlockTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

const dalService = new DalService();

describe('Compile E-mail Template', () => {
  let useCase: CompileEmailTemplate;
  let session: UserSession;
  const layoutRepository = new LayoutRepository();

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [],
      providers: [
        CompileEmailTemplate,
        CompileTemplate,
        GetLayoutUseCase,
        GetNovuLayout,
        OrganizationRepository,
        LayoutRepository,
        {
          provide: DalService,
          useFactory: async () => {
            await dalService.connect(process.env.MONGO_URL);

            return dalService;
          },
        },
      ],
    }).compile();

    session = new UserSession();
    await session.initialize();

    useCase = moduleRef.get<CompileEmailTemplate>(CompileEmailTemplate);
  });

  it('should compile a template with custom layout defined', async () => {
    const layout = await layoutRepository.create({
      name: 'Test Layout',
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _creatorId: session.user._id as string,
      content: '<div>An layout wrapper <div>{{{body}}}</div></div>',
      isDefault: true,
      deleted: false,
      channel: ChannelTypeEnum.EMAIL,
    });

    const { html, subject } = await useCase.execute(
      CompileEmailTemplateCommand.create({
        organizationId: session.organization._id,
        environmentId: session.environment._id,
        layoutId: layout._id,
        preheader: null,
        content: '<div>{{name}}</div>',
        payload: { name: 'Test', header: 'Header Test' },
        userId: session.user._id,
        contentType: 'customHtml',
        subject: 'A title for {{header}}',
      })
    );

    expect(html).to.equal('<div>An layout wrapper <div><div>Test</div></div></div>');
    expect(subject).to.equal('A title for Header Test');
  });

  it('should compile a template with custom layout defined for visual editor', async () => {
    const layout = await layoutRepository.create({
      name: 'Test Layout',
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _creatorId: session.user._id as string,
      content: '<div>An layout wrapper <div>{{{body}}}</div></div>',
      isDefault: true,
      deleted: false,
      channel: ChannelTypeEnum.EMAIL,
    });

    const { html, subject } = await useCase.execute(
      CompileEmailTemplateCommand.create({
        organizationId: session.organization._id,
        environmentId: session.environment._id,
        layoutId: layout._id,
        preheader: null,
        content: [
          {
            content: '<div>{{name}}</div>',
            type: EmailBlockTypeEnum.TEXT,
          },
        ],
        payload: { name: 'Test', header: 'Header Test' },
        userId: session.user._id,
        contentType: 'editor',
        subject: 'A title for {{header}}',
      })
    );

    expect(html).to.contain('<div>An layout wrapper <div>');
    expect(html).to.contain('<div>Test</div>');
    expect(html).not.to.contain('{{');

    expect(subject).to.equal('A title for Header Test');
  });

  it('should apply subject variable if provided', async () => {
    const subjectText = 'Novu Test';
    const { html, subject } = await useCase.execute(
      CompileEmailTemplateCommand.create({
        organizationId: session.organization._id,
        environmentId: session.environment._id,
        layoutId: null,
        preheader: null,
        content: [
          {
            content: '<p>{{subject}}</p>',
            type: EmailBlockTypeEnum.TEXT,
          },
        ],
        payload: { subject: subjectText },
        userId: session.user._id,
        contentType: 'editor',
        subject: '{{subject}}',
      })
    );

    expect(html).to.contain('<!DOCTYPE html');
    expect(html).not.to.contain('{{subject}}');
    expect(html).to.contain(`<p>${subjectText}</p>`);

    expect(subject).to.equal(subjectText);
  });

  it('should apply sender name variable if provided', async () => {
    const senderNameTest = 'Novu Test';
    const { html, senderName } = await useCase.execute(
      CompileEmailTemplateCommand.create({
        organizationId: session.organization._id,
        environmentId: session.environment._id,
        layoutId: null,
        preheader: null,
        content: [
          {
            content: '<p>{{senderName}}</p>',
            type: EmailBlockTypeEnum.TEXT,
          },
        ],
        payload: { senderName: senderNameTest },
        userId: session.user._id,
        contentType: 'editor',
        subject: 'sub',
        senderName: '{{senderName}}',
      })
    );

    expect(html).to.contain('<!DOCTYPE html');
    expect(html).not.to.contain('{{senderName}}');
    expect(html).to.contain(`<p>${senderNameTest}</p>`);

    expect(senderName).to.equal(senderNameTest);
  });

  describe('Backwards compatibility', () => {
    it('should compile e-mail template for custom html without layouts attached for backwards compatibility', async () => {
      const { html, subject } = await useCase.execute(
        CompileEmailTemplateCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          layoutId: null,
          preheader: null,
          content: '<div>{{name}}</div>',
          payload: { name: 'Test', header: 'Header Test' },
          userId: session.user._id,
          contentType: 'customHtml',
          subject: 'A title for {{header}}',
        })
      );

      expect(html).to.equal('<div>Test</div>');
      expect(subject).to.equal('A title for Header Test');
    });

    it('should add default novu layout for visual editor templates', async () => {
      const { html, subject } = await useCase.execute(
        CompileEmailTemplateCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          layoutId: null,
          preheader: null,
          content: [
            {
              content: '<div>{{name}}</div>',
              type: EmailBlockTypeEnum.TEXT,
            },
          ],
          payload: { name: 'Test', header: 'Header Test' },
          userId: session.user._id,
          contentType: 'editor',
          subject: 'A title for {{header}}',
        })
      );

      expect(html).to.contain('<!DOCTYPE html');
      expect(html).not.to.contain('{{name}}');
      expect(html).to.contain('<div>Test</div>');

      expect(subject).to.equal('A title for Header Test');
    });
  });

  describe('Escaping', () => {
    it('should escape editor text in double curly braces', async () => {
      const { html } = await useCase.execute(
        CompileEmailTemplateCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          layoutId: null,
          preheader: null,
          content: [
            {
              type: EmailBlockTypeEnum.TEXT,
              content: '<div>{{textUrl}}</div>',
            },
          ],
          payload: {
            textUrl: 'https://example.com?email=text+testing@example.com',
          },
          userId: session.user._id,
          contentType: 'editor',
          subject: 'Editor Text Escape Test',
        })
      );

      expect(html).to.contain('<div>https://example.com?email&#x3D;text+testing@example.com</div>');
    });

    it('should not escape editor text in triple curly braces', async () => {
      const { html } = await useCase.execute(
        CompileEmailTemplateCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          layoutId: null,
          preheader: null,
          content: [
            {
              type: EmailBlockTypeEnum.TEXT,
              content: '<div>{{{textUrl}}}</div>',
            },
          ],
          payload: {
            textUrl: 'https://example.com?email=text+testing@example.com',
          },
          userId: session.user._id,
          contentType: 'editor',
          subject: 'Editor Text No Escape Test',
        })
      );

      expect(html).to.contain('<div>https://example.com?email=text+testing@example.com</div>');
    });

    it('should escape button text in double curly braces', async () => {
      const { html } = await useCase.execute(
        CompileEmailTemplateCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          layoutId: null,
          preheader: null,
          content: [
            {
              type: EmailBlockTypeEnum.BUTTON,
              content: '{{buttonText}}',
              url: 'https://example.com',
            },
          ],
          payload: {
            buttonText: 'https://example.com?email=button+testing@example.com',
          },
          userId: session.user._id,
          contentType: 'editor',
          subject: 'Editor Button Escape Test',
        })
      );

      expect(html).to.contain('https://example.com?email&#x3D;button+testing@example.com');
    });

    it('should not escape button text in triple curly braces', async () => {
      const { html } = await useCase.execute(
        CompileEmailTemplateCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          layoutId: null,
          preheader: null,
          content: [
            {
              type: EmailBlockTypeEnum.BUTTON,
              content: '{{{buttonText}}}',
              url: 'https://example.com',
            },
          ],
          payload: {
            buttonText: 'https://example.com?email=button+testing@example.com',
          },
          userId: session.user._id,
          contentType: 'editor',
          subject: 'Editor Button Escape Test',
        })
      );

      expect(html).to.contain('https://example.com?email=button+testing@example.com');
    });

    it('should escape button url in double curly braces', async () => {
      const { html } = await useCase.execute(
        CompileEmailTemplateCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          layoutId: null,
          preheader: null,
          content: [
            {
              type: EmailBlockTypeEnum.BUTTON,
              content: 'Click Here To Go To Link!',
              url: '{{buttonUrl}}',
            },
          ],
          payload: {
            buttonUrl: 'https://example.com?email=button+testing@example.com',
          },
          userId: session.user._id,
          contentType: 'editor',
          subject: 'Editor Button Escape Test',
        })
      );

      expect(html).to.contain('https://example.com?email&#x3D;button+testing@example.com');
    });

    it('should not escape button url in triple curly braces', async () => {
      const { html } = await useCase.execute(
        CompileEmailTemplateCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          layoutId: null,
          preheader: null,
          content: [
            {
              type: EmailBlockTypeEnum.BUTTON,
              content: 'Click Here To Go To Link!',
              url: '{{{buttonUrl}}}',
            },
          ],
          payload: {
            buttonUrl: 'https://example.com?email=button+testing@example.com',
          },
          userId: session.user._id,
          contentType: 'editor',
          subject: 'Editor Button No Escape Test',
        })
      );

      expect(html).to.contain('https://example.com?email=button+testing@example.com');
    });
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - dalService(new DalService();

describe('Compile E-mail Template', ())
 - layoutRepository(new LayoutRepository();

  beforeEach(async ())
 - moduleRef(await Test.createTestingModule({
      imports: [],
      providers: [
        CompileEmailTemplate,...)
 - useCase(moduleRef.get<CompileEmailTemplate>(CompileEmailTemplate);
  });

  it('should compile a template wi...)
 - email(text+testing@example.com',
          },
          userId: session.user._id,
          contentType: '...)
 - email(text+testing@example.com</div>');
    });

    it('should escape button text in double curly braces'...)
 - email(button+testing@example.com',
          },
          userId: session.user._id,
          contentType:...)
 - email(button+testing@example.com');
    });

    it('should escape button url in double curly braces', asy...)
 - email(button+testing@example.com',
          },
          userId: session.user._id,
          contentType:...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/e2e/mock-http-client.ts
Tamao: 3179 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HTTPClient, HTTPClientOptions } from '@novu/api/lib/http';

export class MockHTTPClient extends HTTPClient {
  private mockResponses: Map<string, Array<{ response: Response; remaining: number }>> = new Map();
  private recordedRequests: Array<{ request: Request; response: Response }> = [];

  constructor(mockConfigs: MockConfig[] = [], options: HTTPClientOptions = {}) {
    super(options);
    this.initializeMockResponses(mockConfigs);
  }

  /**
   * Initializes mock responses from the provided mock configurations.
   * @param mockConfigs An array of mock configuration objects.
   */
  private initializeMockResponses(mockConfigs: MockConfig[]) {
    // biome-ignore lint/complexity/noForEach: refactored later
    mockConfigs.forEach(({ baseUrl, path, method, responseCode, responseJson, times }) => {
      const url = new URL(path, baseUrl).toString();
      const response = new Response(JSON.stringify(responseJson), {
        status: responseCode,
        headers: { 'Content-Type': 'application/json' },
      });

      const parsedUrl = new URL(url);
      const key = parsedUrl.pathname + method; // Use pathname instead of the full URL

      if (!this.mockResponses.has(key)) {
        this.mockResponses.set(key, []);
      }

      this.mockResponses.get(key)!.push({ response, remaining: times });
    });
  }

  /**
   * Overrides the request method to return mock responses.
   * @param request The Request object containing the request details.
   * @returns A Promise that resolves to the mock response or an error if no mocks are available.
   */
  async request(request: Request): Promise<Response> {
    const { url } = request;
    const { method } = request;

    // Parse the URL to get the pathname without query parameters
    const parsedUrl = new URL(url);
    const key = parsedUrl.pathname + method; // Use pathname instead of the full URL

    if (this.mockResponses.has(key)) {
      const responses = this.mockResponses.get(key)!;

      for (let i = 0; i < responses.length; i += 1) {
        const responseConfig = responses[i];
        if (responseConfig.remaining > 0) {
          responseConfig.remaining -= 1;

          this.recordedRequests.push({ request, response: responseConfig.response });

          if (responseConfig.remaining === 0) {
            responses.splice(i, 1);
          }

          if (responses.length === 0) {
            this.mockResponses.delete(key);
          }

          return responseConfig.response.clone();
        }
      }

      this.mockResponses.delete(key);
      throw new Error(`No remaining mock responses for ${parsedUrl.pathname} ${method}`);
    }
    throw new Error(`No remaining mock responses for ${key} Existing: ${Object.keys(this.mockResponses)} `);
  }

  /**
   * Getter to access recorded requests and responses.
   * @returns An array of recorded requests and their corresponding responses.
   */
  getRecordedRequests(): Array<{ request: Request; response: Response }> {
    return this.recordedRequests;
  }
}

export interface MockConfig {
  baseUrl: string;
  path: string;
  method: string;
  responseCode: number;
  responseJson: unknown;
  times: number;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - HTTPClientOptions({}) {
    super(options);
    this.initializeMockResponses(mockConfigs);
  }

  /**
   * Initializes...)
Declaraciones 'export' encontradas:
- export class MockHTTPClient
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/e2e/retry.e2e.ts
Tamao: 8264 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { topicsList } from '@novu/api/funcs/topicsList';
import { expect } from 'chai';
import { expectSdkExceptionGeneric } from '../src/app/shared/helpers/e2e/sdk/e2e-sdk.helper';
import { ErrorDto } from '../src/error-dto';
import { MockHTTPClient } from './mock-http-client';

function getIdempotencyKeys(mockHTTPClient: MockHTTPClient) {
  return mockHTTPClient
    .getRecordedRequests()
    .map((req) => req.request.headers)
    .flatMap((headers) => (headers['Idempotency-Key'] ? [headers['Idempotency-Key']] : []))
    .filter((key) => key !== undefined);
}

describe('Novu Node.js package - Retries and idempotency-key', () => {
  it('should retry trigger and generate idempotency-key only once for request', async () => {
    const mockHTTPClient = new MockHTTPClient([
      {
        baseUrl: BACKEND_URL,
        path: TRIGGER_PATH,
        responseCode: 500,
        responseJson: buildErrorDto(TRIGGER_PATH, 'Server Exception', 500),
        method: 'POST',
        times: 3,
      },
      {
        baseUrl: BACKEND_URL,
        path: TRIGGER_PATH,
        responseCode: 201,
        responseJson: { acknowledged: true, transactionId: '1003', status: 'error' },
        method: 'POST',
        times: 1,
      },
    ]);
    novuClient = new Novu({
      security: {
        secretKey: 'fakeKey',
      },
      serverURL: BACKEND_URL,
      httpClient: mockHTTPClient,
    });

    await novuClient.trigger({
      workflowId: 'fake-workflow',
      to: { subscriberId: '123' },
      payload: {},
    });

    const requestKeys = getIdempotencyRequestKeys(mockHTTPClient);
    expect(hasAllEqual(requestKeys), JSON.stringify(requestKeys)).to.be.eq(true);
  });

  it('should generate different idempotency-key for each request', async () => {
    const httpClient = new MockHTTPClient([
      {
        baseUrl: BACKEND_URL,
        path: TRIGGER_PATH,
        responseCode: 201,
        responseJson: { acknowledged: true, transactionId: '1003', status: 'error' },
        method: 'POST',
        times: 2,
      },
    ]);
    novuClient = new Novu({
      security: {
        secretKey: 'fakeKey',
      },
      serverURL: BACKEND_URL,
      httpClient,
    });
    await novuClient.trigger({ workflowId: 'fake-workflow', to: { subscriberId: '123' }, payload: {} });
    await novuClient.trigger({ workflowId: 'fake-workflow', to: { subscriberId: '123' }, payload: {} });

    const idempotencyRequestKeys = getIdempotencyRequestKeys(httpClient);
    expect(new Set(idempotencyRequestKeys).size, JSON.stringify(idempotencyRequestKeys)).to.be.eq(2);
  });

  it('should retry on status 422 and idempotency-key should be the same for every retry', async () => {
    const mockHTTPClient = new MockHTTPClient([
      {
        baseUrl: BACKEND_URL,
        path: TRIGGER_PATH,
        responseCode: 422,
        responseJson: buildErrorDto(TRIGGER_PATH, 'Unprocessable Content', 422),
        method: 'POST',
        times: 3,
      },
      {
        baseUrl: BACKEND_URL,
        path: TRIGGER_PATH,
        responseCode: 201,
        responseJson: { acknowledged: true, transactionId: '1003', status: 'processed' },
        method: 'POST',
        times: 1,
      },
    ]);
    novuClient = new Novu({
      security: {
        secretKey: 'fakeKey',
      },
      serverURL: BACKEND_URL,
      httpClient: mockHTTPClient,
    });

    await novuClient.trigger({ workflowId: 'fake-workflow', to: { subscriberId: '123' }, payload: {} });
    expect(mockHTTPClient.getRecordedRequests().length).to.eq(4);
    const idempotencyKeys = getIdempotencyKeys(mockHTTPClient);
    expect(hasUniqueOnly(idempotencyKeys)).to.be.eq(true);
  });

  it('should fail after reaching max retries', async () => {
    novuClient = new Novu({
      security: {
        secretKey: 'fakeKey',
      },
      serverURL: BACKEND_URL,
      httpClient: new MockHTTPClient([
        {
          baseUrl: BACKEND_URL,
          path: TOPICS_PATH,
          responseCode: 500,
          responseJson: buildErrorDto(TOPICS_PATH, 'Server Exception', 500),
          method: 'GET',
          times: 4,
        },
        {
          baseUrl: BACKEND_URL,
          path: TOPICS_PATH,
          responseCode: 200,
          responseJson: [{}, {}],
          method: 'GET',
          times: 1,
        },
      ]),
    });

    const { error } = await expectSdkExceptionGeneric(() =>
      novuClient.topics.list(
        {},
        {
          retries: {
            strategy: 'backoff',
            backoff: {
              initialInterval: 30,
              maxInterval: 60,
              exponent: 1,
              maxElapsedTime: 150,
            },
            retryConnectionErrors: true,
          },
        }
      )
    );
    expect(error?.statusCode).to.be.eq(500);
  });

  const NON_RECOVERABLE_ERRORS: Array<[number, string]> = [
    [400, 'Bad Request'],
    [401, 'Unauthorized'],
    [403, 'Forbidden'],
    [404, 'Not Found'],
    [405, 'Method not allowed'],
    [413, 'Payload Too Large'],
    [414, 'URI Too Long'],
    [415, 'Unsupported Media Type'],
  ];
  NON_RECOVERABLE_ERRORS.forEach(([status, message]) => {
    it('should not retry on non-recoverable %i error', async () => {
      novuClient = new Novu({
        security: {
          secretKey: 'fakeKey',
        },
        serverURL: BACKEND_URL,
        httpClient: new MockHTTPClient([
          {
            baseUrl: BACKEND_URL,
            path: TOPICS_PATH,
            responseCode: status,
            responseJson: buildErrorDto(TOPICS_PATH, message, status),
            method: 'GET',
            times: 3,
          },
          {
            baseUrl: BACKEND_URL,
            path: TOPICS_PATH,
            responseCode: 200,
            responseJson: [{}, {}],
            method: 'GET',
            times: 1,
          },
        ]),
      });

      const result = await topicsList(novuClient, {});

      expect(result.ok).to.be.eq(false);
    });
  });

  it('should retry on various errors until it reaches successful response', async () => {
    const mockClient = new MockHTTPClient([
      {
        baseUrl: BACKEND_URL,
        path: TOPICS_PATH,
        responseCode: 429,
        responseJson: buildErrorDto(TOPICS_PATH, 'Too many requests', 429),
        method: 'GET',
        times: 1,
      },
      {
        baseUrl: BACKEND_URL,
        path: TOPICS_PATH,
        responseCode: 408,
        responseJson: buildErrorDto(TOPICS_PATH, 'Request Timeout', 408),
        method: 'GET',
        times: 1,
      },
      {
        baseUrl: BACKEND_URL,
        path: TOPICS_PATH,
        responseCode: 504,
        responseJson: buildErrorDto(TOPICS_PATH, 'Gateway timeout', 504),
        method: 'GET',
        times: 1,
      },
      {
        baseUrl: BACKEND_URL,
        path: TOPICS_PATH,
        responseCode: 422,
        responseJson: buildErrorDto(TOPICS_PATH, 'Unprocessable Content', 422),
        method: 'GET',
        times: 1,
      },
      {
        baseUrl: BACKEND_URL,
        path: TOPICS_PATH,
        responseCode: 200,
        responseJson: { data: [], page: 1, pageSize: 30, totalCount: 0 },
        method: 'GET',
        times: 1,
      },
    ]);

    novuClient = new Novu({
      security: {
        secretKey: 'fakeKey',
      },
      serverURL: BACKEND_URL,
      httpClient: mockClient,
    });

    const { error, ok, value } = await topicsList(novuClient, {});
    expect(ok).to.be.true;
  });
});
const BACKEND_URL = 'http://example.com';
const TOPICS_PATH = '/v1/topics';
const TRIGGER_PATH = '/v1/events/trigger';

const hasAllEqual = (arr: Array<string>) => arr.every((val) => val === arr[0]);
const hasUniqueOnly = (arr: Array<string>) => Array.from(new Set(arr)).length === arr.length;

let novuClient: Novu;

function buildErrorDto(path: string, message: string, status: number): ErrorDto {
  return {
    path,
    timestamp: new Date().toDateString(),
    message,
    statusCode: status,
  };
}

const IDEMPOTENCY_HEADER_KEY = 'idempotency-key';

function getIdempotencyRequestKeys(mockHTTPClient: MockHTTPClient) {
  return mockHTTPClient
    .getRecordedRequests()
    .map((pair) => pair.request.headers.get(IDEMPOTENCY_HEADER_KEY))
    .filter((value) => value != null);
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - getIdempotencyKeys(mockHTTPClient: MockHTTPClient)
 - buildErrorDto(path: string, message: string, status: number)
 - getIdempotencyRequestKeys(mockHTTPClient: MockHTTPClient)
Asignaciones con arrow functions encontradas (posibles funciones):
 - requestKeys(getIdempotencyRequestKeys(mockHTTPClient);
    expect(hasAllEqual(requestKeys), JSON.stringify(reque...)
 - idempotencyRequestKeys(getIdempotencyRequestKeys(httpClient);
    expect(new Set(idempotencyRequestKeys).size, JSON.stringi...)
 - idempotencyKeys(getIdempotencyKeys(mockHTTPClient);
    expect(hasUniqueOnly(idempotencyKeys)).to.be.eq(true);
  });...)
 - result(await topicsList(novuClient, {});

      expect(result.ok).to.be.eq(false);
    });
  });

  it('sho...)
 - hasAllEqual(arr: Array<string>))
 - hasUniqueOnly(arr: Array<string>))
 - IDEMPOTENCY_HEADER_KEY('idempotency-key';

function getIdempotencyRequestKeys(mockHTTPClient: MockHTTPClient) {
  return mo...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/e2e/setup.ts
Tamao: 5865 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ClickHouseClient, ClickHouseService, createClickHouseClient } from '@novu/application-generic';
import { DalService } from '@novu/dal';
import { testServer } from '@novu/testing';
import axios from 'axios';
import chai from 'chai';
import { Connection } from 'mongoose';
import sinon from 'sinon';
import { bootstrap } from '../src/bootstrap';

let databaseConnection: Connection;
let analyticsConnection: ClickHouseClient | undefined;
let clickHouseService: ClickHouseService | undefined;
const dalService = new DalService();

async function getDatabaseConnection(): Promise<Connection> {
  if (!databaseConnection) {
    databaseConnection = await dalService.connect(process.env.MONGO_URL);
  }

  return databaseConnection;
}

async function dropDatabase(): Promise<void> {
  try {
    const conn = await getDatabaseConnection();
    await conn.dropDatabase();
  } catch (error) {
    console.error('Error dropping the database:', error);
  }
}

async function closeDatabaseConnection(): Promise<void> {
  if (databaseConnection) {
    await databaseConnection.close();
  }
}

async function getClickHouseConnection(): Promise<ClickHouseClient | undefined> {
  if (!analyticsConnection) {
    if (!clickHouseService) {
      clickHouseService = new ClickHouseService();
      await clickHouseService.init();
    }
    analyticsConnection = clickHouseService?.client;
  }

  return analyticsConnection;
}

function createClickHouseTestClient(database?: string): ClickHouseClient {
  return createClickHouseClient({
    host: 'http://localhost:8123',
    username: 'default',
    password: '',
    database: database || 'default',
  });
}

async function ensureClickHouseDatabase(databaseName: string): Promise<void> {
  try {
    const client = createClickHouseTestClient('default');
    await client.query({
      query: `CREATE DATABASE IF NOT EXISTS ${databaseName}`,
    });
    console.log(`Database "${databaseName}" ensured.`);
  } catch (error) {
    console.log(`Failed to create database ${databaseName}:`, error.message);
  }
}

async function getClickHouseTables(databaseName: string): Promise<string[]> {
  try {
    const conn = await getClickHouseConnection();
    if (!conn) return [];

    const result = await conn.query({
      query: `SHOW TABLES FROM ${databaseName}`,
      format: 'JSONEachRow',
    });

    const tables = (await result.json()) as Array<{ name: string }>;

    return tables.map((t) => t.name);
  } catch (error) {
    console.log(`Could not query tables in ${databaseName}: ${error.message}`);

    return [];
  }
}

async function truncateClickHouseTable(databaseName: string, tableName: string): Promise<void> {
  try {
    const conn = await getClickHouseConnection();
    if (!conn) return;

    await conn.exec({ query: `TRUNCATE TABLE IF EXISTS ${databaseName}.${tableName}` });
    console.log(`Successfully cleaned table ${tableName}`);
  } catch (error) {
    console.log(`Failed to clean table ${tableName}:`, error.message);
  }
}

async function cleanupClickHouseDatabase(): Promise<void> {
  try {
    const databaseName = process.env.CLICK_HOUSE_DATABASE || 'test_logs';
    console.log(`Cleaning up ClickHouse database: ${databaseName}`);

    await ensureClickHouseDatabase(databaseName);

    const tables = await getClickHouseTables(databaseName);
    if (tables.length > 0) {
      console.log(`Found ${tables.length} tables: ${tables.join(', ')}`);
      await Promise.all(tables.map((table) => truncateClickHouseTable(databaseName, table)));
      console.log(`Cleaned up ${tables.length} tables in ${databaseName}`);
    } else {
      console.log(`No tables to clean up in ${databaseName}`);
    }

    console.log(`ClickHouse database ${databaseName} cleanup completed`);
  } catch (error) {
    console.log('Analytics database cleanup encountered an issue:', error.message);
    console.log('This is acceptable for test environment - continuing with test setup');
  }
}

async function closeClickHouseConnection(): Promise<void> {
  if (analyticsConnection) {
    await analyticsConnection.close();
  }
  if (clickHouseService) {
    await clickHouseService.onModuleDestroy();
  }
}

async function waitForHealthCheck(): Promise<void> {
  const port = process.env.PORT;
  const healthCheckUrl = `http://localhost:${port}/v1/health-check`;
  const maxRetries = 60;
  const retryDelay = 1000;

  console.log(`Waiting for health check at ${healthCheckUrl}...`);

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await axios.get(healthCheckUrl, {
        timeout: 5000,
        validateStatus: (status) => status === 200,
      });

      if (response.status === 200) {
        console.log(`Health check passed on attempt ${attempt}`);

        return;
      }
    } catch (error) {
      const isLastAttempt = attempt === maxRetries;

      if (isLastAttempt) {
        console.error(`Health check failed after ${maxRetries} attempts. Last error:`, error.message);
        throw new Error(`Health check failed after ${maxRetries} attempts`);
      }

      console.log(`Health check attempt ${attempt}/${maxRetries} failed, retrying in ${retryDelay}ms...`);
      await new Promise((resolve) => setTimeout(resolve, retryDelay));
    }
  }
}

before(async () => {
  /**
   * disable truncating for better error messages - https://www.chaijs.com/guide/styles/#configtruncatethreshold
   */
  chai.config.truncateThreshold = 0;

  await dropDatabase();
  await cleanupClickHouseDatabase();
  const bootstrapped = await bootstrap();
  await testServer.create(bootstrapped.app);

  await waitForHealthCheck();
});

after(async () => {
  await testServer.teardown();
  await dropDatabase();
  await cleanupClickHouseDatabase();
  await closeDatabaseConnection();
  await closeClickHouseConnection();
});

afterEach(async () => {
  sinon.restore();
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - getDatabaseConnection()
 - dropDatabase()
 - closeDatabaseConnection()
 - getClickHouseConnection()
 - createClickHouseTestClient(database?: string)
 - ensureClickHouseDatabase(databaseName: string)
 - getClickHouseTables(databaseName: string)
 - truncateClickHouseTable(databaseName: string, tableName: string)
 - cleanupClickHouseDatabase()
 - closeClickHouseConnection()
 - waitForHealthCheck()
Asignaciones con arrow functions encontradas (posibles funciones):
 - tables(await result.json()) as Array<{ name: string }>;

    return tables.map((t))
 - tables(await getClickHouseTables(databaseName);
    if (tables.length > 0) {
      console.log(`Found ${tab...)
 - response(await axios.get(healthCheckUrl, {
        timeout: 5000,
        validateStatus: (status))
 - bootstrapped(await bootstrap();
  await testServer.create(bootstrapped.app);

  await waitForHealthCheck();
});

...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/e2e/test-bridge-server.ts
Tamao: 2967 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import http from 'node:http';
import { Client, serve } from '@novu/framework/express';
import express from 'express';

export class TestBridgeServer {
  private server: express.Express;
  private app: http.Server;
  private port: number;
  public client = new Client({ strictAuthentication: false });
  private isServerRunning = false;

  constructor(port = 49999) {
    this.port = port;
  }

  private log(level: 'info' | 'error' | 'warn', message: string, ...args: any[]) {
    // console[level](`[BridgeServer] ${message}`, ...args);
  }

  get serverPath() {
    return `http://0.0.0.0:${this.port}`;
  }

  async start(options) {
    if (this.isServerRunning) {
      await this.stop();
    }

    // Check if port is in use
    try {
      await new Promise((resolve, reject) => {
        const testServer = http.createServer();
        testServer.once('error', (err: NodeJS.ErrnoException) => {
          if (err.code === 'EADDRINUSE') {
            reject(new Error(`Port ${this.port} is already in use`));
          } else {
            reject(err);
          }
        });
        testServer.once('listening', () => {
          testServer.close();
          resolve(true);
        });
        testServer.listen(this.port);
      });
    } catch (error) {
      this.log('error', error.message);
      throw error;
    }

    this.server = express();
    this.server.use(express.json());

    // Logging middleware
    this.server.use((req: express.Request, res: express.Response, next: express.NextFunction) => {
      this.log('info', `${req.method} ${req.path}`);

      return next();
    });

    // Error handling middleware
    this.server.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
      this.log('error', 'Unexpected error:', err);
      res.status(500).json({
        error: 'Internal Server Error',
        message: err.message,
        stack: err.stack,
      });
    });

    // Serve Novu workflows
    this.server.use(serve({ client: this.client, workflows: options.workflows }));

    return new Promise<void>((resolve, reject) => {
      this.app = this.server.listen(this.port, () => {
        this.isServerRunning = true;
        this.log('info', `Server started on port ${this.port}`);
        resolve();
      });

      // Handle initial connection errors
      this.app.on('error', (error: Error) => {
        this.isServerRunning = false;
        this.log('error', 'Server failed to start:', error);
        reject(error);
      });

      this.app.on('close', () => {
        this.isServerRunning = false;
        this.log('warn', 'Server closed');
      });
    });
  }

  async stop() {
    if (this.app && this.isServerRunning) {
      this.log('warn', 'Server Stopping');

      return new Promise<void>((resolve) => {
        this.app.close(() => {
          this.isServerRunning = false;
          resolve();
        });
      });
    }

    return Promise.resolve();
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - port(port;
  }

  private log(level: 'info' | 'error' | 'warn', message: string, ...args: any[]) {
    //...)
 - testServer(http.createServer();
        testServer.once('error', (err: NodeJS.ErrnoException))
 - server(express();
    this.server.use(express.json());

    // Logging middleware
    this.server.use((req:...)
 - app(this.server.listen(this.port, ())
 - isServerRunning(true;
        this.log('info', `Server started on port ${this.port}`);
        resolve();
      });
...)
 - isServerRunning(false;
        this.log('error', 'Server failed to start:', error);
        reject(error);
      });...)
 - isServerRunning(false;
        this.log('warn', 'Server closed');
      });
    });
  }

  async stop() {
    if (th...)
Declaraciones 'export' encontradas:
- export class TestBridgeServer

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/e2e/enterprise/inbound-webhook/process-inbound-webhook.e2e.ts
Tamao: 6392 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { QueryBuilder, Trace, TraceLogRepository } from '@novu/application-generic';
import {
  IntegrationEntity,
  IntegrationRepository,
  MessageEntity,
  MessageRepository,
  NotificationTemplateEntity,
  SubscriberRepository,
} from '@novu/dal';
import { ChannelTypeEnum, PushProviderIdEnum, StepTypeEnum } from '@novu/shared';
import { PushEventStatusEnum } from '@novu/stateless';
import { NotificationTemplateService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../../src/app/shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Process Inbound Webhook E2E #novu-v2', () => {
  let session: UserSession;
  let integrationRepository: IntegrationRepository;
  let messageRepository: MessageRepository;
  let subscriberRepository: SubscriberRepository;
  let traceLogRepository: TraceLogRepository;
  let integration: IntegrationEntity;
  let message: MessageEntity;
  let template: NotificationTemplateEntity;
  let novuClient: Novu;

  before(() => {
    (process.env as any).IS_TRACE_LOGS_ENABLED = 'true';
  });

  after(() => {
    delete (process.env as any).IS_TRACE_LOGS_ENABLED;
  });

  const mockWebhookBody = {
    eventId: 'A0E2DB50-21D8-4F99-93C9-2BC0A4D32228',
    eventType: 'clicked',
    app_version: '1.0.0',
    appState: 'active',
    content: {
      body: 'Test notification body',
      title: 'Test title',
    },
    device_id: '531E306C-A900-4164-AACF-91948F9B4CCE',
    expoPushToken: 'ExponentPushToken[Dy4R0HK8GkSD8NDlqMzM9w]',
    notificationId: 'A0E2DB50-21D8-4F99-93C9-2BC0A4D32228',
    platform: 'ios',
    timestamp: '2025-09-21T20:02:35.103Z',
  };

  const mockHeaders = {
    'content-type': 'application/json',
  };

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    integrationRepository = session.testServer?.getService(IntegrationRepository);
    messageRepository = session.testServer?.getService(MessageRepository);
    traceLogRepository = session.testServer?.getService(TraceLogRepository);
    subscriberRepository = session.testServer?.getService(SubscriberRepository);

    const notificationTemplateService = new NotificationTemplateService(
      session.user._id,
      session.organization._id,
      session.environment._id
    );

    template = await notificationTemplateService.createTemplate({
      steps: [
        {
          type: StepTypeEnum.PUSH,
          content: 'Test push notification: {{title}}',
          title: 'Push Title: {{title}}',
        },
      ],
    });

    novuClient = initNovuClassSdk(session);

    // Disable the default FCM integration to avoid multiple push providers
    await integrationRepository.update(
      {
        _environmentId: session.environment._id,
        providerId: PushProviderIdEnum.FCM,
      },
      { active: false }
    );

    integration = await integrationRepository.create({
      name: 'Test Expo Integration',
      identifier: 'expo-test',
      providerId: PushProviderIdEnum.EXPO,
      channel: ChannelTypeEnum.PUSH,
      credentials: {
        apiKey: 'test-access-token',
      },
      configurations: {
        inboundWebhookEnabled: true,
      },
      active: true,
      primary: true,
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    await novuClient.subscribers.credentials.update(
      {
        providerId: PushProviderIdEnum.EXPO,
        credentials: {
          deviceTokens: ['ExponentPushToken[Dy4RN4K8GkSD8NDlqMzM9w]'],
        },
      },
      session.subscriberId
    );

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [
        {
          subscriberId: session.subscriberId,
        },
      ],
      payload: {
        title: 'Test notification body',
      },
    });

    await session.waitForJobCompletion(template._id);

    const subscriber = await subscriberRepository.findOne({
      _organizationId: session.organization._id,
      subscriberId: session.subscriberId,
    });

    if (!subscriber) {
      throw new Error('Subscriber not found');
    }

    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      providerId: PushProviderIdEnum.EXPO,
    });

    expect(messages.length, 'triggered messages length should be 1').to.equal(1);
    message = messages[0];
  });

  describe('POST /v2/inbound-webhooks/delivery-providers/:environmentId/:integrationId', () => {
    it('should successfully process a push webhook with clicked event', async () => {
      const eventPayload = { ...mockWebhookBody, eventId: message?.identifier };
      const response = await novuClient.activity.track({
        environmentId: session.environment._id,
        integrationId: integration._id,
        requestBody: eventPayload,
      });

      expect(response).to.have.length(1);
      expect(response[0]).to.have.property('id', eventPayload.eventId);
      expect(response[0].event).to.have.property('status', PushEventStatusEnum.CLICKED);
      const parsedRow = JSON.parse((response[0].event as any).row);
      expect(parsedRow).to.deep.equal(eventPayload);

      const updatedMessage = await messageRepository.findOne({
        _id: message._id,
        _environmentId: session.environment._id,
      });

      expect(updatedMessage?.seen).to.be.true;
      expect(updatedMessage?.lastSeenDate).to.be.a('string');

      const traceQueryBuilder = new QueryBuilder<Trace>({
        environmentId: session.environment._id,
      });
      traceQueryBuilder.whereEquals('organization_id', session.organization._id);
      traceQueryBuilder.whereEquals('entity_type', 'step_run');
      traceQueryBuilder.whereEquals('entity_id', message._jobId || '');
      traceQueryBuilder.whereEquals('external_subscriber_id', session.subscriberId || '');
      traceQueryBuilder.whereEquals('event_type', 'message_clicked');

      const traceResult = await traceLogRepository.find({
        where: traceQueryBuilder.build(),
        select: '*',
        limit: 10,
      });

      expect(traceResult.data).to.have.length(1);
      expect(
        traceResult.data.some((trace) => trace.event_type === 'message_clicked'),
        'message_clicked trace should be present'
      ).to.be.true;
    });
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - IS_TRACE_LOGS_ENABLED('true';
  });

  after(())
 - mockHeaders({
    'content-type': 'application/json',
  };

  beforeEach(async ())
 - message(messages[0];
  });

  describe('POST /v2/inbound-webhooks/delivery-providers/:environmentId/:integra...)
 - traceResult(await traceLogRepository.find({
        where: traceQueryBuilder.build(),
        select: '*',
     ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/changes-migration.ts
Tamao: 8098 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import '../src/config';
import { NestFactory } from '@nestjs/core';
import { CreateChange, CreateChangeCommand } from '@novu/application-generic';
import {
  ChangeRepository,
  EnvironmentRepository,
  MemberRepository,
  MessageTemplateRepository,
  NotificationGroupRepository,
  NotificationTemplateRepository,
  OrganizationRepository,
} from '@novu/dal';
import { ChangeEntityTypeEnum, MemberRoleEnum } from '@novu/shared';
import { ApplyChangeCommand } from '../src/app/change/usecases/apply-change/apply-change.command';
import { ApplyChange } from '../src/app/change/usecases/apply-change/apply-change.usecase';
import { CreateEnvironmentCommand } from '../src/app/environments-v1/usecases/create-environment/create-environment.command';
import { CreateEnvironment } from '../src/app/environments-v1/usecases/create-environment/create-environment.usecase';
import { AppModule } from '../src/app.module';

export async function run(): Promise<void> {
  console.log('Script started');
  console.log('');
  const app = await NestFactory.create(AppModule, {
    logger: false,
  });
  console.log('');
  console.log('App created');

  const memberRepository = app.get(MemberRepository);
  const organizationRepository = app.get(OrganizationRepository);
  const notificationTemplateRepository = app.get(NotificationTemplateRepository);
  const messageTemplateRepository = app.get(MessageTemplateRepository);
  const notificationGroupRepository = app.get(NotificationGroupRepository);
  const environmentRepository = app.get(EnvironmentRepository);
  const createChangeUseCase = app.get(CreateChange);
  const createEnvironment = app.get(CreateEnvironment);
  const applyChange = app.get(ApplyChange);
  console.log('Repositories and usecases created');

  const orgs = await organizationRepository.find({});
  console.log(`${orgs.length} Orgs found`);
  for (const org of orgs) {
    console.log(`Migrating org ${org._id}`);
    const member = await memberRepository.findOne({
      roles: MemberRoleEnum.OSS_ADMIN,
      _organizationId: org._id,
    });

    console.log(`Using user ${member._id} to migrate org ${org._id}`);
    console.log('');
    const environments = await environmentRepository.findOrganizationEnvironments(org._id);
    console.log(`Found ${environments.length} environments`);

    if (environments.length === 2) {
      console.log(`Connects Production environment to Development environment`);
      const prod = environments.reduce((prev, current) => {
        return current.name === 'Production' ? current : prev;
      }, environments[1]);
      const dev = environments.reduce((prev, current) => {
        return current.name !== prod.name ? current : prev;
      }, environments[0]);

      await environmentRepository.update(
        {
          _id: prod._id,
        },
        {
          $set: {
            _parentId: dev._id,
          },
        }
      );
    }

    if (environments.length === 1) {
      console.log(`Creating Production environment`);
      const environment = environments[0];
      await createEnvironment.execute(
        CreateEnvironmentCommand.create({
          name: 'Production',
          organizationId: org._id,
          userId: member._id,
          parentEnvironmentId: environment._id,
        })
      );
      console.log(`Production environment created`);
    }

    console.log('');
    const groups = await notificationGroupRepository.find({
      _organizationId: org._id,
      _parentId: { $exists: false, $eq: null },
    });
    let change;
    console.log(`Found ${groups.length} notification groups`);
    for (const group of groups) {
      const found = await notificationGroupRepository.findOne({
        _parentId: group._id,
        _environmentId: group._environmentId,
      });
      if (!found) {
        console.log(`Migrating group ${group._id}`);
        change = await createChangeUseCase.execute(
          CreateChangeCommand.create({
            item: group,
            type: ChangeEntityTypeEnum.NOTIFICATION_GROUP,
            changeId: ChangeRepository.createObjectId(),
            environmentId: group._environmentId,
            organizationId: group._organizationId,
            userId: member._userId,
          })
        );
        console.log(`Change for group ${group._id} created`);
        await applyChange.execute(
          ApplyChangeCommand.create({
            changeId: change._id,
            environmentId: group._environmentId,
            organizationId: group._organizationId,
            userId: member._userId,
          })
        );
        console.log(`Change for group ${group._id} applied`);
      } else {
        console.log(`Migration for group ${group._id} was already done`);
      }
      console.log('');
    }

    const messageTemplates = await messageTemplateRepository.find({
      _organizationId: org._id,
      _parentId: { $exists: false, $eq: null },
    });
    console.log(`Found ${messageTemplates.length} message templates`);
    for (const messageTemplate of messageTemplates) {
      const found = await messageTemplateRepository.findOne({
        _parentId: messageTemplate._id,
        _environmentId: messageTemplate._environmentId,
      });
      if (!found) {
        console.log(`Migrating message template ${messageTemplate._id}`);
        change = await createChangeUseCase.execute(
          CreateChangeCommand.create({
            item: messageTemplate,
            type: ChangeEntityTypeEnum.MESSAGE_TEMPLATE,
            changeId: ChangeRepository.createObjectId(),
            environmentId: messageTemplate._environmentId,
            organizationId: messageTemplate._organizationId,
            userId: member._userId,
          })
        );
        console.log(`Change for message template ${messageTemplate._id} created`);
        await applyChange.execute(
          ApplyChangeCommand.create({
            changeId: change._id,
            environmentId: messageTemplate._environmentId,
            organizationId: messageTemplate._organizationId,
            userId: member._userId,
          })
        );
        console.log(`Change for message template ${messageTemplate._id} applied`);
      } else {
        console.log(`Migration for message template ${messageTemplate._id} was already done`);
      }
      console.log('');
    }

    const notificationTemplates = await notificationTemplateRepository.find({
      _organizationId: org._id,
      _parentId: { $exists: false, $eq: null },
    });
    console.log(`Found ${notificationTemplates.length} notification templates`);
    for (const notificationTemplate of notificationTemplates) {
      const found = await notificationTemplateRepository.findOne({
        _parentId: notificationTemplate._id,
        _environmentId: notificationTemplate._environmentId,
      });
      if (!found) {
        console.log(`Migrating notification template ${notificationTemplate._id}`);
        change = await createChangeUseCase.execute(
          CreateChangeCommand.create({
            item: notificationTemplate,
            type: ChangeEntityTypeEnum.NOTIFICATION_TEMPLATE,
            changeId: ChangeRepository.createObjectId(),
            environmentId: notificationTemplate._environmentId,
            organizationId: notificationTemplate._organizationId,
            userId: member._userId,
          })
        );
        console.log(`Change for notification template ${notificationTemplate._id} created`);
        await applyChange.execute(
          ApplyChangeCommand.create({
            changeId: change._id,
            environmentId: notificationTemplate._environmentId,
            organizationId: notificationTemplate._organizationId,
            userId: member._userId,
          })
        );
        console.log(`Change for notification template ${notificationTemplate._id} applied`);
      } else {
        console.log(`Migration for notification template ${notificationTemplate._id} was already done`);
      }
      console.log('');
    }
    console.log('');
  }

  await app.close();
  console.log('Migration done...');
}

run();


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - run()
Asignaciones con arrow functions encontradas (posibles funciones):
 - prod(environments.reduce((prev, current))
 - dev(environments.reduce((prev, current))
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/add-layout-id-to-email-controls/add-layout-id-to-email-controls-migration.spec.ts
Tamao: 4659 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MessageTemplateRepository } from '@novu/dal';
import { StepTypeEnum, UiComponentEnum, WorkflowCreationSourceEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { run } from './add-layout-id-to-email-controls-migration';

describe('Add Layout ID to Email Controls Migration #novu-v2', () => {
  let session: UserSession;
  const messageTemplateRepository = new MessageTemplateRepository();
  const workflows = ['test', 'test2'];

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should add layoutId to email templates without it', async () => {
    for (const workflow of workflows) {
      const response = await session.testAgent.post(`/v2/workflows`).send({
        __source: WorkflowCreationSourceEnum.DASHBOARD,
        name: workflow,
        workflowId: workflow,
        steps: [
          {
            name: 'email',
            type: StepTypeEnum.EMAIL,
            controlValues: {
              body: '',
              subject: '',
            },
          },
        ],
      });
      const steps = response.body.data.steps;
      await messageTemplateRepository.update(
        { _id: steps[0]._id, _environmentId: session.environment._id, _organizationId: session.organization._id },
        {
          $unset: {
            'controls.schema.properties.layoutId': '',
            'controls.uiSchema.properties.layoutId': '',
          },
        }
      );
      const messageTemplate = await messageTemplateRepository.findOne({
        _id: steps[0]._id,
        _environmentId: session.environment._id,
        _organizationId: session.organization._id,
      });
      expect(messageTemplate?.controls?.schema?.properties?.layoutId).not.to.exist;
      expect(messageTemplate?.controls?.uiSchema?.properties?.layoutId).not.to.exist;
    }

    await run();

    for (const workflow of workflows) {
      const response = await session.testAgent.get(`/v2/workflows/${workflow}`);
      const workflow1 = response.body.data;

      expect(workflow1.steps[0].controls?.dataSchema?.properties?.layoutId).to.exist;
      expect(workflow1.steps[0].controls?.dataSchema?.properties?.layoutId?.type).to.deep.equal(['string', 'null']);
      expect(workflow1.steps[0].controls?.dataSchema?.properties?.body).to.exist;
      expect(workflow1.steps[0].controls?.dataSchema?.properties?.subject).to.exist;
      expect(workflow1.steps[0].controls?.dataSchema?.properties?.editorType).to.exist;

      expect(workflow1.steps[0].controls?.uiSchema?.properties?.layoutId).to.exist;
      expect(workflow1.steps[0].controls?.uiSchema?.properties?.layoutId?.component).to.equal(
        UiComponentEnum.LAYOUT_SELECT
      );
      expect(workflow1.steps[0].controls?.uiSchema?.properties?.body).to.exist;
      expect(workflow1.steps[0].controls?.uiSchema?.properties?.subject).to.exist;
      expect(workflow1.steps[0].controls?.uiSchema?.properties?.editorType).to.exist;
    }
  });

  it('should skip templates that already have layoutId', async () => {
    for (const workflow of workflows) {
      await session.testAgent.post(`/v2/workflows`).send({
        __source: WorkflowCreationSourceEnum.DASHBOARD,
        name: workflow,
        workflowId: workflow,
        steps: [
          {
            name: 'email',
            type: StepTypeEnum.EMAIL,
            controlValues: {
              body: '',
              subject: '',
            },
          },
        ],
      });
    }

    await run();

    for (const workflow of workflows) {
      const response = await session.testAgent.get(`/v2/workflows/${workflow}`);
      const workflow1 = response.body.data;

      expect(workflow1.steps[0].controls?.dataSchema?.properties?.layoutId).to.exist;
      expect(workflow1.steps[0].controls?.dataSchema?.properties?.layoutId?.type).to.deep.equal(['string', 'null']);
      expect(workflow1.steps[0].controls?.dataSchema?.properties?.body).to.exist;
      expect(workflow1.steps[0].controls?.dataSchema?.properties?.subject).to.exist;
      expect(workflow1.steps[0].controls?.dataSchema?.properties?.editorType).to.exist;

      expect(workflow1.steps[0].controls?.uiSchema?.properties?.layoutId).to.exist;
      expect(workflow1.steps[0].controls?.uiSchema?.properties?.layoutId?.component).to.equal(
        UiComponentEnum.LAYOUT_SELECT
      );
      expect(workflow1.steps[0].controls?.uiSchema?.properties?.body).to.exist;
      expect(workflow1.steps[0].controls?.uiSchema?.properties?.subject).to.exist;
      expect(workflow1.steps[0].controls?.uiSchema?.properties?.editorType).to.exist;
    }
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflows(['test', 'test2'];

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should add layoutId to email templat...)
 - workflow1(response.body.data;

      expect(workflow1.steps[0].controls?.dataSchema?.properties?.layoutId).to....)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/add-layout-id-to-email-controls/add-layout-id-to-email-controls-migration.ts
Tamao: 2652 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import '../../src/config';

import { NestFactory } from '@nestjs/core';
import { PinoLogger } from '@novu/application-generic';
import { MessageTemplateRepository, OrganizationRepository } from '@novu/dal';
import { StepTypeEnum, UiComponentEnum } from '@novu/shared';

import { AppModule } from '../../src/app.module';

export async function run() {
  const app = await NestFactory.create(AppModule, {
    logger: false,
  });

  const logger = await app.resolve(PinoLogger);
  logger.setContext('AddLayoutIdToEmailControlsMigration');

  logger.info('start migration - add layoutId to email controls schema');

  const organizationRepository = app.get(OrganizationRepository);
  const messageTemplateRepository = app.get(MessageTemplateRepository);

  const organizations = await organizationRepository.find({});

  logger.info(`Found ${organizations.length} organizations`);

  for (const organization of organizations) {
    // Find all email message templates that have controls but don't have layoutId in the schema
    const emailTemplates = await messageTemplateRepository.find({
      _organizationId: organization._id,
      type: StepTypeEnum.EMAIL,
      'controls.schema': { $exists: true },
      'controls.uiSchema': { $exists: true },
      'controls.schema.properties.layoutId': { $exists: false },
      'controls.uiSchema.properties.layoutId': { $exists: false },
      deleted: false,
    });

    logger.info(
      `Found ${emailTemplates.length} email message templates to migrate for organization ${organization.name}`
    );

    for (const template of emailTemplates) {
      logger.info(`Migrating template ${template._id}`);

      try {
        // Add layoutId to the schema properties
        const updatePayload = {
          $set: {
            'controls.schema.properties.layoutId': {
              type: ['string', 'null'],
            },
            'controls.uiSchema.properties.layoutId': {
              component: UiComponentEnum.LAYOUT_SELECT,
            },
          },
        };

        await messageTemplateRepository.update(
          {
            _id: template._id,
            _organizationId: organization._id,
          },
          updatePayload
        );

        logger.info(`Template ${template._id} - layoutId field added to controls schema`);
      } catch (error) {
        logger.error(`Failed to migrate template ${template._id}`, error);
      }
    }
  }

  logger.info('end migration');
  await app.close();
}

run()
  .then(() => {
    console.log('Migration completed successfully');
    process.exit(0);
  })
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - run()
Asignaciones con arrow functions encontradas (posibles funciones):
 - updatePayload({
          $set: {
            'controls.schema.properties.layoutId': {
              type: ['strin...)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/deleteLogs/dropLogsCollection.ts
Tamao: 456 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { DalService } from '@novu/dal';

(async function dropLogsCollection() {
  const dalService = new DalService();
  try {
    const connection = await dalService.connect(process.env.MONGO_URL);
    await connection.db.collection('logs').drop();
    console.log('Collection "logs" was dropped successfully.');
  } catch (error) {
    console.error('Error dropping "logs" collection:', error);
  } finally {
    await dalService.disconnect();
  }
})();


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - dropLogsCollection()

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/email-step-ui-schema-html-editor/email-step-ui-schema-html-editor-migration.spec.ts
Tamao: 2318 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { StepTypeEnum, UiComponentEnum, UiSchemaGroupEnum, WorkflowCreationSourceEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { run } from './email-step-ui-schema-html-editor-migration';

describe('Update email step ui schema migration test #novu-v2', () => {
  let session: UserSession;
  let novuClient: Novu;
  const workflows = ['test', 'test2'];

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    for (const workflow of workflows) {
      await session.testAgent.post(`/v2/workflows`).send({
        __source: WorkflowCreationSourceEnum.DASHBOARD,
        name: workflow,
        workflowId: workflow,
        steps: [
          {
            name: 'email',
            type: StepTypeEnum.EMAIL,
            controlValues: {
              body: '',
              subject: '',
            },
          },
        ],
      });
    }
  });

  it('should update email step ui schema to html editor', async () => {
    // run the migration
    await run();

    for (const workflow of workflows) {
      const response = await session.testAgent.get(`/v2/workflows/${workflow}`);
      const workflow1 = response.body.data;

      expect(workflow1.steps[0].controls?.uiSchema?.group).to.equal(UiSchemaGroupEnum.EMAIL);
      expect(workflow1.steps[0].controls?.uiSchema?.properties?.body?.component).to.equal(UiComponentEnum.EMAIL_BODY);
      expect(workflow1.steps[0].controls?.uiSchema?.properties?.subject?.component).to.equal(
        UiComponentEnum.TEXT_INLINE_LABEL
      );
      expect(workflow1.steps[0].controls?.uiSchema?.properties?.skip?.component).to.equal(UiComponentEnum.QUERY_EDITOR);
      expect(workflow1.steps[0].controls?.uiSchema?.properties?.editorType?.component).to.equal(
        UiComponentEnum.EMAIL_EDITOR_SELECT
      );
      expect(workflow1.steps[0].controls?.uiSchema?.properties?.editorType?.placeholder).to.equal('block');
      expect(workflow1.steps[0].controls?.uiSchema?.properties?.disableOutputSanitization?.component).to.equal(
        UiComponentEnum.DISABLE_SANITIZATION_SWITCH
      );
      expect(workflow1.steps[0].controls?.uiSchema?.properties?.disableOutputSanitization?.placeholder).to.equal(false);
    }
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflows(['test', 'test2'];

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();

    for (const workflow of workflows) {
      aw...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/email-step-ui-schema-html-editor/email-step-ui-schema-html-editor-migration.ts
Tamao: 1920 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import '../../src/config';
import { NestFactory } from '@nestjs/core';
import { PinoLogger } from '@novu/application-generic';
import { MessageTemplateRepository, OrganizationRepository } from '@novu/dal';
import { UiComponentEnum } from '@novu/shared';
import { AppModule } from '../../src/app.module';

export async function run() {
  const app = await NestFactory.create(AppModule, {
    logger: false,
  });
  const logger = await app.resolve(PinoLogger);
  logger.setContext('EmailStepUiSchemaHtmlEditorMigration');

  logger.info('Start migration - update email step ui schema to html editor');

  const organizationRepository = app.get(OrganizationRepository);
  const messageTemplateRepository = app.get(MessageTemplateRepository);

  const organizations = await organizationRepository.find({});

  for (const organization of organizations) {
    const messageTemplates = await messageTemplateRepository.find({
      _organizationId: organization._id,
      type: 'email',
      'controls.uiSchema': { $exists: true },
    });

    logger.info(`Found ${messageTemplates.length} notification templates, for organization ${organization.name}`);

    for (const notificationTemplate of messageTemplates) {
      logger.info(`Update notification template ${notificationTemplate._id}`);
      await messageTemplateRepository.update(
        { _id: notificationTemplate._id, _organizationId: organization._id },
        {
          $set: {
            'controls.uiSchema.properties.body': {
              component: UiComponentEnum.EMAIL_BODY,
            },
            'controls.uiSchema.properties.editorType': {
              component: UiComponentEnum.EMAIL_EDITOR_SELECT,
              placeholder: 'block',
            },
          },
        }
      );
      logger.info(`Updated notification template ${notificationTemplate._id}`);
    }
  }

  logger.info('End migration.\n');
  await app.close();
}

run();


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - run()
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/encrypt-api-keys/encrypt-api-keys-migration.spec.ts
Tamao: 4681 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { faker } from '@faker-js/faker';
import { decryptApiKey } from '@novu/application-generic';
import { EnvironmentRepository } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/stateless';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { createHash } from 'crypto';

import { encryptApiKeysMigration } from './encrypt-api-keys-migration';

async function pruneIntegration({ environmentRepository }: { environmentRepository: EnvironmentRepository }) {
  const old = await environmentRepository.find({});

  for (const oldKey of old) {
    await environmentRepository.delete({ _id: oldKey._id });
  }
}

describe('Encrypt Old api keys', () => {
  let session: UserSession;
  const environmentRepository = new EnvironmentRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should decrypt all old api keys', async () => {
    await pruneIntegration({ environmentRepository });

    for (let i = 0; i < 2; i += 1) {
      await environmentRepository.create({
        identifier: 'identifier' + i,
        name: faker.name.jobTitle(),
        _organizationId: session.organization._id,
        apiKeys: [
          {
            key: 'not-encrypted-secret-key',
            _userId: session.user._id,
          },
        ],
      });
    }

    const newEnvironments = await environmentRepository.find({});

    expect(newEnvironments.length).to.equal(2);

    for (const environment of newEnvironments) {
      expect(environment.identifier).to.contains('identifier');
      expect(environment.name).to.exist;
      expect(environment._organizationId).to.equal(session.organization._id);
      expect(environment.apiKeys[0].key).to.equal('not-encrypted-secret-key');
      expect(environment.apiKeys[0].hash).to.not.exist;
      expect(environment.apiKeys[0]._userId).to.equal(session.user._id);
    }

    await encryptApiKeysMigration();

    const encryptEnvironments = await environmentRepository.find({});

    for (const environment of encryptEnvironments) {
      const decryptedApiKey = decryptApiKey(environment.apiKeys[0].key);
      const hashedApiKey = createHash('sha256').update(decryptedApiKey).digest('hex');

      expect(environment.identifier).to.contains('identifier');
      expect(environment.name).to.exist;
      expect(environment._organizationId).to.equal(session.organization._id);
      expect(environment.apiKeys[0].key).to.contains('nvsk.');
      expect(environment.apiKeys[0].hash).to.equal(hashedApiKey);
      expect(environment.apiKeys[0]._userId).to.equal(session.user._id);
    }
  });

  it('should validate migration idempotence', async () => {
    await pruneIntegration({ environmentRepository });

    const data = {
      providerId: 'sendgrid',
      channel: ChannelTypeEnum.EMAIL,
      active: false,
    };

    for (let i = 0; i < 2; i += 1) {
      await environmentRepository.create({
        identifier: 'identifier' + i,
        name: faker.name.jobTitle(),
        _organizationId: session.organization._id,
        apiKeys: [
          {
            key: 'not-encrypted-secret-key',
            _userId: session.user._id,
          },
        ],
      });
    }

    await encryptApiKeysMigration();
    const firstMigrationExecution = await environmentRepository.find({});

    await encryptApiKeysMigration();
    const secondMigrationExecution = await environmentRepository.find({});

    expect(firstMigrationExecution[0].identifier).to.contains(secondMigrationExecution[0].identifier);
    expect(firstMigrationExecution[0].name).to.exist;
    expect(firstMigrationExecution[0]._organizationId).to.equal(secondMigrationExecution[0]._organizationId);
    expect(firstMigrationExecution[0].apiKeys[0].key).to.contains(secondMigrationExecution[0].apiKeys[0].key);
    expect(firstMigrationExecution[0].apiKeys[0].hash).to.contains(secondMigrationExecution[0].apiKeys[0].hash);
    expect(firstMigrationExecution[0].apiKeys[0]._userId).to.equal(secondMigrationExecution[0].apiKeys[0]._userId);

    expect(firstMigrationExecution[1].identifier).to.contains(secondMigrationExecution[1].identifier);
    expect(firstMigrationExecution[1].name).to.exist;
    expect(firstMigrationExecution[1]._organizationId).to.equal(secondMigrationExecution[1]._organizationId);
    expect(firstMigrationExecution[1].apiKeys[0].key).to.contains(secondMigrationExecution[1].apiKeys[0].key);
    expect(firstMigrationExecution[1].apiKeys[0].hash).to.contains(secondMigrationExecution[1].apiKeys[0].hash);
    expect(firstMigrationExecution[1].apiKeys[0]._userId).to.equal(secondMigrationExecution[1].apiKeys[0]._userId);
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - pruneIntegration({ environmentRepository }: { environmentRepository: EnvironmentRepository })
Asignaciones con arrow functions encontradas (posibles funciones):
 - old(await environmentRepository.find({});

  for (const oldKey of old) {
    await environmentRepository...)
 - environmentRepository(new EnvironmentRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should decrypt all old api keys', as...)
 - hashedApiKey(createHash('sha256').update(decryptedApiKey).digest('hex');

      expect(environment.identifier).to...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/encrypt-api-keys/encrypt-api-keys-migration.ts
Tamao: 2223 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import '../../src/config';

import { NestFactory } from '@nestjs/core';
import { encryptSecret, PinoLogger } from '@novu/application-generic';
import { EnvironmentRepository, IApiKey } from '@novu/dal';
import { EncryptedSecret } from '@novu/shared';
import { createHash } from 'crypto';

import { AppModule } from '../../src/app.module';

export async function encryptApiKeysMigration() {
  const app = await NestFactory.create(AppModule, {
    logger: false,
  });

  const logger = await app.resolve(PinoLogger);
  logger.setContext('EncryptApiKeysMigration');

  logger.info('start migration - encrypt api keys');

  const environmentRepository = app.get(EnvironmentRepository);
  const environments = await environmentRepository.find({});

  for (const environment of environments) {
    logger.info(`environment ${environment._id}`);

    if (!environment.apiKeys) {
      logger.info(`environment ${environment._id} - is not contains api keys, skipping..`);
      continue;
    }

    if (
      environment.apiKeys.every((key) => {
        return isEncrypted(key.key);
      })
    ) {
      logger.info(`environment ${environment._id} - api keys are already encrypted, skipping..`);
      continue;
    }

    const updatePayload: IEncryptedApiKey[] = encryptApiKeysWithGuard(environment.apiKeys);

    await environmentRepository.update(
      { _id: environment._id },
      {
        $set: { apiKeys: updatePayload },
      }
    );

    logger.info(`environment ${environment._id} - api keys updated`);
  }

  logger.info('end migration');
}

export function encryptApiKeysWithGuard(apiKeys: IApiKey[]): IEncryptedApiKey[] {
  return apiKeys.map((apiKey: IApiKey) => {
    const hashedApiKey = createHash('sha256').update(apiKey.key).digest('hex');

    const encryptedApiKey: IEncryptedApiKey = {
      hash: apiKey?.hash ? apiKey?.hash : hashedApiKey,
      key: isEncrypted(apiKey.key) ? apiKey.key : encryptSecret(apiKey.key),
      _userId: apiKey._userId,
    };

    return encryptedApiKey;
  });
}

function isEncrypted(apiKey: string): apiKey is EncryptedSecret {
  return apiKey.startsWith('nvsk.');
}

export interface IEncryptedApiKey {
  key: EncryptedSecret;
  _userId: string;
  hash: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - encryptApiKeysMigration()
 - encryptApiKeysWithGuard(apiKeys: IApiKey[])
 - isEncrypted(apiKey: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - environments(await environmentRepository.find({});

  for (const environment of environments) {
    logger.info(`...)
Declaraciones 'export' encontradas:
- export  async
- export function encryptApiKeysWithGuard
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/encrypt-credentials/encrypt-credentials-migration.spec.ts
Tamao: 3278 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IntegrationRepository } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/stateless';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { encryptOldCredentialsMigration } from './encrypt-credentials-migration';

describe('Encrypt Old Credentials', () => {
  let session: UserSession;
  const integrationRepository = new IntegrationRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should decrypt all old credentials', async () => {
    await pruneIntegration(integrationRepository);

    const data = {
      providerId: 'sendgrid',
      channel: ChannelTypeEnum.EMAIL,
      active: false,
    };

    for (let i = 0; i < 2; i += 1) {
      await integrationRepository.create({
        _environmentId: session.environment._id,
        _organizationId: session.organization._id,
        providerId: data.providerId + i,
        channel: data.channel,
        credentials: {
          apiKey: '123',
          user: `smith${i}`,
          secretKey: '123',
          domain: 'domain',
          password: '123',
          host: 'host',
          port: 'port',
          secure: true,
          region: 'region',
          accountSid: 'accountSid',
          messageProfileId: 'messageProfileId',
          token: '123',
          from: 'from',
          senderName: 'senderName',
          applicationId: 'applicationId',
          clientId: 'clientId',
          projectName: 'projectName',
        },
        active: data.active,
      });
    }

    const newIntegration = await integrationRepository.find({} as any);

    expect(newIntegration.length).to.equal(2);

    await encryptOldCredentialsMigration();

    const encryptIntegration = await integrationRepository.find({} as any);

    for (const integrationKey in encryptIntegration) {
      const integration = encryptIntegration[integrationKey];

      expect(integration.credentials.apiKey).to.contains('nvsk.');
      expect(integration.credentials.user).to.equal(`smith${integrationKey}`);
      expect(integration.credentials.secretKey).to.contains('nvsk.');
      expect(integration.credentials.domain).to.equal('domain');
      expect(integration.credentials.password).to.contains('nvsk.');
      expect(integration.credentials.host).to.equal('host');
      expect(integration.credentials.secure).to.contains('nvsk.');
      expect(integration.credentials.region).to.equal('region');
      expect(integration.credentials.accountSid).to.equal('accountSid');
      expect(integration.credentials.messageProfileId).to.equal('messageProfileId');
      expect(integration.credentials.token).to.contains('nvsk.');
      expect(integration.credentials.from).to.equal('from');
      expect(integration.credentials.senderName).to.equal('senderName');
      expect(integration.credentials.applicationId).to.equal('applicationId');
      expect(integration.credentials.clientId).to.equal('clientId');
      expect(integration.credentials.projectName).to.equal('projectName');
    }
  });
});

async function pruneIntegration(integrationRepository) {
  const old = await integrationRepository.find({});

  for (const oldKey in old) {
    await integrationRepository.delete({ _id: old[oldKey] });
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - pruneIntegration(integrationRepository)
Asignaciones con arrow functions encontradas (posibles funciones):
 - integrationRepository(new IntegrationRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should decrypt all old credentials',...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/encrypt-credentials/encrypt-credentials-migration.ts
Tamao: 2469 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NestFactory } from '@nestjs/core';
import { encryptSecret, PinoLogger } from '@novu/application-generic';
import { IntegrationEntity, IntegrationRepository } from '@novu/dal';
import { ICredentialsDto, secureCredentials } from '@novu/shared';
import { AppModule } from '../../src/app.module';

export async function encryptOldCredentialsMigration() {
  const app = await NestFactory.create(AppModule, {
    logger: false,
  });

  const logger = await app.resolve(PinoLogger);
  logger.setContext('EncryptCredentialsMigration');

  logger.info('start migration - encrypt credentials');

  const integrationRepository = new IntegrationRepository();
  const integrations = await integrationRepository.find({} as any);

  for (const integration of integrations) {
    logger.info(`integration ${integration._id}`);

    const updatePayload: Partial<IntegrationEntity> = {};

    if (!integration.credentials) {
      logger.info(`integration ${integration._id} - is not contains credentials, skipping..`);
      continue;
    }

    updatePayload.credentials = encryptCredentialsWithGuard(integration);

    await integrationRepository.update(
      { _id: integration._id, _environmentId: integration._environmentId },
      {
        $set: updatePayload,
      }
    );
    logger.info(`integration ${integration._id} - credentials updated`);
  }
  logger.info('end migration');
}

export function encryptCredentialsWithGuard(integration: IntegrationEntity): ICredentialsDto {
  const encryptedCredentials: ICredentialsDto = {};
  const { credentials } = integration;

  for (const key in credentials) {
    const credential = credentials[key];

    if (needEncryption(key, credential, integration)) {
      encryptedCredentials[key] = encryptSecret(credential);
    } else {
      encryptedCredentials[key] = credential;
    }
  }

  return encryptedCredentials;
}

function needEncryption(key: string, credential: string, integration: IntegrationEntity) {
  return secureKey(key) && !alreadyEncrypted(credential, integration, key);
}

function secureKey(key: string): boolean {
  return secureCredentials.some((secureCred) => secureCred === key);
}

function alreadyEncrypted(credential: string, integration: IntegrationEntity, credentialKey: string): boolean {
  const encrypted = credential.includes('nvsk.');

  if (encrypted) {
    logger.info(`integration ${integration._id} - credential ${credentialKey} is already updated`);
  }

  return encrypted;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - encryptOldCredentialsMigration()
 - encryptCredentialsWithGuard(integration: IntegrationEntity)
 - needEncryption(key: string, credential: string, integration: IntegrationEntity)
 - secureKey(key: string)
 - alreadyEncrypted(credential: string, integration: IntegrationEntity, credentialKey: string)
Declaraciones 'export' encontradas:
- export  async
- export function encryptCredentialsWithGuard

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/expire-at/expire-at-delay.migration.spec.ts
Tamao: 4990 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  ExecutionDetailsRepository,
  JobRepository,
  MessageRepository,
  NotificationRepository,
  NotificationTemplateEntity,
  SubscriberRepository,
} from '@novu/dal';
import { DelayTypeEnum, DigestUnitEnum, StepTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { sendTrigger } from '../../src/app/events/e2e/trigger-event.e2e';
import { notificationExpireAt } from './expire-at.migration';

describe('Create expireAt - TTL support - with pending jobs', () => {
  const messageRepository = new MessageRepository();
  const notificationRepository = new NotificationRepository();
  const jobRepository = new JobRepository();
  const executionDetailsRepository = new ExecutionDetailsRepository();

  let session: UserSession;
  let digestTemplate: NotificationTemplateEntity;
  let delayTemplate: NotificationTemplateEntity;
  let query;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    digestTemplate = await createDigestTemplate(session);
    delayTemplate = await createDelayTemplate(session);
    query = {
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      expireAt: { $exists: false },
    };

    for (let i = 0; i < 5; i += 1) {
      const newSubscriberIdInAppNotification = SubscriberRepository.createObjectId();
      await sendTrigger(session, digestTemplate, newSubscriberIdInAppNotification);
      await sendTrigger(session, delayTemplate, newSubscriberIdInAppNotification);
      await new Promise((r) => setTimeout(r, 1000));
      await sendTrigger(session, digestTemplate, newSubscriberIdInAppNotification);
    }
    await new Promise((r) => setTimeout(r, 1000));

    await messageRepository.update({ _environmentId: session.environment._id }, { $unset: { expireAt: 1 } });
    await notificationRepository.update({ _environmentId: session.environment._id }, { $unset: { expireAt: 1 } });
    await jobRepository.update({ _environmentId: session.environment._id }, { $unset: { expireAt: 1 } });
    await executionDetailsRepository.update({ _environmentId: session.environment._id }, { $unset: { expireAt: 1 } });
  });

  it('should not add expireAt for a pending execution', async () => {
    await notificationExpireAt(query);

    const notifications = await notificationRepository.find({
      _environmentId: session.environment._id,
      _templateId: delayTemplate?._id,
    });
    const jobs = await jobRepository.find({ _environmentId: session.environment._id, _templateId: delayTemplate?._id });
    const executionDetails = await executionDetailsRepository.find({
      _environmentId: session.environment._id,
      _notificationTemplateId: delayTemplate?._id,
    });

    notifications.forEach((msg) => {
      expect(msg.expireAt).to.not.exist;
    });
    jobs.forEach((msg) => {
      expect(msg.expireAt).to.not.exist;
    });
    executionDetails.forEach((msg) => {
      expect(msg.expireAt).to.not.exist;
    });
  });

  it('should add expireAt to pending events that were digested', async () => {
    await session.waitForJobCompletion();

    await notificationExpireAt(query);

    const notifications = await notificationRepository.find({
      _environmentId: session.environment._id,
      _templateId: digestTemplate?._id,
    });
    const jobs = await jobRepository.find({
      _environmentId: session.environment._id,
      _templateId: digestTemplate?._id,
    });
    const executionDetails = await executionDetailsRepository.find({
      _environmentId: session.environment._id,
      _notificationTemplateId: digestTemplate?._id,
    });

    notifications.forEach((msg) => {
      expect(msg.expireAt).to.exist;
    });
    jobs.forEach((msg) => {
      expect(msg.expireAt).to.exist;
    });
    executionDetails.forEach((msg) => {
      expect(msg.expireAt).to.exist;
    });
  });
});

async function createDelayTemplate(session) {
  return await session.createTemplate({
    steps: [
      {
        type: StepTypeEnum.IN_APP,
        content: 'Hello {{subscriber.lastName}}, Welcome to {{organizationName}}' as string,
      },
      {
        type: StepTypeEnum.DELAY,
        content: '',
        metadata: {
          unit: DigestUnitEnum.MINUTES,
          amount: 2,
          type: DelayTypeEnum.REGULAR,
        },
      },
      {
        type: StepTypeEnum.IN_APP,
        content: 'Hello {{subscriber.lastName}}, Welcome to {{organizationName}}' as string,
      },
    ],
  });
}
async function createDigestTemplate(session) {
  return await session.createTemplate({
    steps: [
      {
        type: StepTypeEnum.DIGEST,
        content: '',
        metadata: {
          unit: DigestUnitEnum.SECONDS,
          amount: 2,
          type: DelayTypeEnum.REGULAR,
        },
      },
      {
        type: StepTypeEnum.IN_APP,
        content: 'Hello {{step.events.length}}, Welcome to {{organizationName}}' as string,
      },
    ],
  });
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - createDelayTemplate(session)
 - createDigestTemplate(session)
Asignaciones con arrow functions encontradas (posibles funciones):
 - executionDetailsRepository(new ExecutionDetailsRepository();

  let session: UserSession;
  let digestTemplate: NotificationTem...)
 - newSubscriberIdInAppNotification(SubscriberRepository.createObjectId();
      await sendTrigger(session, digestTemplate, newSubscribe...)
 - executionDetails(await executionDetailsRepository.find({
      _environmentId: session.environment._id,
      _notifi...)
 - executionDetails(await executionDetailsRepository.find({
      _environmentId: session.environment._id,
      _notifi...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/expire-at/expire-at.migration.spec.ts
Tamao: 3636 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  ExecutionDetailsRepository,
  JobRepository,
  MessageRepository,
  NotificationRepository,
  NotificationTemplateEntity,
  SubscriberRepository,
} from '@novu/dal';
import { StepTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { sendTrigger } from '../../src/app/events/e2e/trigger-event.e2e';
import { createExpireAt, messagesSetExpireAt } from './expire-at.migration';

describe('Create expireAt - TTL support', () => {
  const messageRepository = new MessageRepository();
  const notificationRepository = new NotificationRepository();
  const jobRepository = new JobRepository();
  const executionDetailsRepository = new ExecutionDetailsRepository();

  let session: UserSession;
  let template: NotificationTemplateEntity;
  let query;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    template = await createTemplate(session);
    query = {
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      expireAt: { $exists: false },
    };

    for (let i = 0; i < 5; i += 1) {
      const newSubscriberIdInAppNotification = SubscriberRepository.createObjectId();
      await sendTrigger(session, template, newSubscriberIdInAppNotification);
    }
    await new Promise((r) => setTimeout(r, 1000));

    await messageRepository.update({ _environmentId: session.environment._id }, { $unset: { expireAt: 1 } });
    await notificationRepository.update({ _environmentId: session.environment._id }, { $unset: { expireAt: 1 } });
    await jobRepository.update({ _environmentId: session.environment._id }, { $unset: { expireAt: 1 } });
    await executionDetailsRepository.update({ _environmentId: session.environment._id }, { $unset: { expireAt: 1 } });

    for (let i = 0; i < 5; i += 1) {
      const newSubscriberIdInAppNotification = SubscriberRepository.createObjectId();
      await sendTrigger(session, template, newSubscriberIdInAppNotification);
    }
    await new Promise((r) => setTimeout(r, 1000));
  });

  it('should set expireAt for messages', async () => {
    await messagesSetExpireAt(query);

    const messages = await messageRepository.find({ _environmentId: session.environment._id });

    messages.forEach((msg) => {
      expect(msg.expireAt).to.exist;
    });
  });

  it('should set expireAt for notification and its jobs and execution details', async () => {
    await createExpireAt();
    const notifications = await notificationRepository.find({ _environmentId: session.environment._id });
    const jobs = await jobRepository.find({ _environmentId: session.environment._id });
    const executionDetails = await executionDetailsRepository.find({ _environmentId: session.environment._id });

    notifications.forEach((msg) => {
      expect(msg.expireAt).to.exist;
    });
    jobs.forEach((msg) => {
      expect(msg.expireAt).to.exist;
    });
    executionDetails.forEach((msg) => {
      expect(msg.expireAt).to.exist;
    });
  });
});

async function createTemplate(session) {
  return await session.createTemplate({
    steps: [
      {
        type: StepTypeEnum.SMS,
        content: 'Welcome to {{organizationName}}' as string,
      },
      {
        type: StepTypeEnum.IN_APP,
        content: 'Hello {{subscriber.lastName}}, Welcome to {{organizationName}}' as string,
      },
      {
        type: StepTypeEnum.EMAIL,
        content: [
          {
            type: 'text',
            content: 'Hello {{subscriber.lastName}}, Welcome to {{organizationName}}' as string,
          },
        ],
      },
    ],
  });
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - createTemplate(session)
Asignaciones con arrow functions encontradas (posibles funciones):
 - executionDetailsRepository(new ExecutionDetailsRepository();

  let session: UserSession;
  let template: NotificationTemplateE...)
 - newSubscriberIdInAppNotification(SubscriberRepository.createObjectId();
      await sendTrigger(session, template, newSubscriberIdInA...)
 - newSubscriberIdInAppNotification(SubscriberRepository.createObjectId();
      await sendTrigger(session, template, newSubscriberIdInA...)
 - messages(await messageRepository.find({ _environmentId: session.environment._id });

    messages.forEach((ms...)
 - executionDetails(await executionDetailsRepository.find({ _environmentId: session.environment._id });

    notificatio...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/expire-at/expire-at.migration.ts
Tamao: 3593 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import '../../src/config';
import { NestFactory } from '@nestjs/core';
import {
  EnvironmentRepository,
  ExecutionDetailsRepository,
  JobRepository,
  JobStatusEnum,
  MessageRepository,
  NotificationRepository,
  OrganizationRepository,
} from '@novu/dal';
import { addDays, addMinutes } from 'date-fns';
import { AppModule } from '../../src/app.module';

const messageRepository = new MessageRepository();
const notificationRepository = new NotificationRepository();
const jobRepository = new JobRepository();
const executionDetailsRepository = new ExecutionDetailsRepository();
const organizationRepository = new OrganizationRepository();
const environmentRepository = new EnvironmentRepository();
const now = Date.now();
let expireAtOneMonth = addDays(now, 30);
let expireAtOneYear = addDays(now, 365);

export async function createExpireAt() {
  const app = await NestFactory.create(AppModule, {
    logger: false,
  });

  console.log('start migration - add expireAt field');

  console.log('get organizations and its environments');

  const organizations = await organizationRepository.find({});
  const totalOrganizations = organizations.length;
  let currentOrganization = 0;
  for (const organization of organizations) {
    currentOrganization += 1;
    console.log(`organization ${currentOrganization} of ${totalOrganizations}`);

    const environments = await environmentRepository.findOrganizationEnvironments(organization._id);
    for (const environment of environments) {
      const query = {
        _organizationId: organization._id,
        _environmentId: environment._id,
        expireAt: { $exists: false },
      };
      expireAtOneMonth = addMinutes(expireAtOneMonth, Math.floor(Math.random() * 4320));
      expireAtOneYear = addMinutes(expireAtOneYear, Math.floor(Math.random() * 4320));

      console.log('Setting messages');
      await messagesSetExpireAt(query);
      console.log('Setting notifications');
      await notificationExpireAt(query);
    }

    console.log('Prococessed organization' + organization._id);
  }

  console.log('end migration');
}

export async function messagesSetExpireAt(query) {
  await messageRepository.update(
    {
      ...query,
      channel: { $ne: 'in_app' },
    },
    { $set: { expireAt: expireAtOneMonth } }
  );

  await messageRepository.update(
    {
      ...query,
      channel: 'in_app',
    },
    { $set: { expireAt: expireAtOneYear } }
  );
}

export async function notificationExpireAt(query) {
  const excludedIds = await getExcludedNotificationIds(query);

  await notificationRepository.update(
    { ...query, _id: { $nin: excludedIds } },
    { $set: { expireAt: expireAtOneMonth } }
  );

  await jobRepository.update(
    { ...query, _notificationId: { $nin: excludedIds } },
    { $set: { expireAt: expireAtOneMonth } }
  );

  await executionDetailsRepository.update(
    { ...query, _notificationId: { $nin: excludedIds } },
    { $set: { expireAt: expireAtOneMonth } }
  );
}

export async function getExcludedNotificationIds(query) {
  const pendingNotifications = await jobRepository._model
    .distinct('_notificationId', {
      ...query,
      status: JobStatusEnum.PENDING,
    })
    .read('secondaryPreferred');

  // digested events stays pending, leaving the notification and deleting the actually digested could cause errors
  return await notificationRepository._model
    .distinct('_id', {
      ...query,
      _id: { $in: pendingNotifications },
      _digestedNotificationId: { $exists: false, $eq: null },
    })
    .read('secondaryPreferred');
}

createExpireAt();


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - createExpireAt()
 - messagesSetExpireAt(query)
 - notificationExpireAt(query)
 - getExcludedNotificationIds(query)
Declaraciones 'export' encontradas:
- export  async
- export  async
- export  async
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/fcm-credentials/fcm-credentials-migration.spec.ts
Tamao: 2111 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IntegrationRepository } from '@novu/dal';
import { PushProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum } from '@novu/stateless';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { updateFcmCredentials } from './fcm-credentials-migration';

describe('Update fcm credential type', () => {
  const integrationRepository = new IntegrationRepository();

  it('should update fcm credential user type', async () => {
    const data = {
      providerId: 'fcm',
      channel: ChannelTypeEnum.PUSH,
      active: false,
    };

    for (let i = 0; i < 3; i += 1) {
      const session = new UserSession();
      await session.initialize();

      await pruneIntegration(integrationRepository, session);

      await integrationRepository.create({
        _environmentId: session.environment._id,
        _organizationId: session.organization._id,
        providerId: data.providerId,
        channel: data.channel,
        credentials: { user: '{ name : john, secret: 123 }' },
        active: data.active,
      });
    }

    const integrations = await integrationRepository.find({ credentials: { user: 'fcm' } });

    for (const integrationKey in integrations) {
      const integration = integrations[integrationKey];

      expect(integration.credentials.user).to.contains('{ name : john, secret: 123 }');
    }

    await updateFcmCredentials();

    const integrationsUpdated = await integrationRepository.find({ providerId: 'fcm' });

    for (const integration of integrationsUpdated) {
      expect(integration.credentials.user).to.eq(undefined);
      expect(integration.credentials.serviceAccount).to.contains('{ name : john, secret: 123 }');
    }
  });
});

async function pruneIntegration(integrationRepository: IntegrationRepository, session: UserSession) {
  const old = await integrationRepository.find({
    _environmentId: session.environment._id,
    _organizationId: session.organization._id,
    providerId: PushProviderIdEnum.FCM,
  });

  for (const oldKey in old) {
    await integrationRepository.delete({ _id: old[oldKey] });
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - pruneIntegration(integrationRepository: IntegrationRepository, session: UserSession)
Asignaciones con arrow functions encontradas (posibles funciones):
 - integrationRepository(new IntegrationRepository();

  it('should update fcm credential user type', async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/fcm-credentials/fcm-credentials-migration.ts
Tamao: 666 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IntegrationRepository } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/stateless';

export async function updateFcmCredentials() {
  console.log('start migration - update fcm credentials (user to serviceAccount)');

  const integrationRepository = new IntegrationRepository();

  console.log('rename all credentials.user credentials.serviceAccount - channel push, provider fcm');

  await integrationRepository.update(
    {
      provider: 'fcm',
      channel: ChannelTypeEnum.PUSH,
      'credentials.user': { $exists: true },
    },
    { $rename: { 'credentials.user': 'credentials.serviceAccount' } }
  );

  console.log('end migration');
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - updateFcmCredentials()
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/in-app-integration/in-app-integration.migration.ts
Tamao: 2196 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import '../../src/config';
import { NestFactory } from '@nestjs/core';
import { encryptCredentials } from '@novu/application-generic';
import { ChannelTypeEnum, EnvironmentRepository, IntegrationRepository, OrganizationRepository } from '@novu/dal';
import { InAppProviderIdEnum } from '@novu/shared';
import { AppModule } from '../../src/app.module';

const organizationRepository = new OrganizationRepository();
const environmentRepository = new EnvironmentRepository();
const integrationRepository = new IntegrationRepository();

export async function createInAppIntegration() {
  // Init the mongodb connection
  const app = await NestFactory.create(AppModule, {
    logger: false,
  });

  console.log('start migration - in app integration');

  console.log('get organizations and its environments');

  const organizations = await organizationRepository.find({});
  const totalOrganizations = organizations.length;
  let currentOrganization = 0;
  for (const organization of organizations) {
    currentOrganization += 1;
    console.log(`organization ${currentOrganization} of ${totalOrganizations}`);

    const environments = await environmentRepository.findOrganizationEnvironments(organization._id);
    for (const environment of environments) {
      const count = await integrationRepository.count({
        _environmentId: environment._id,
        _organizationId: organization._id,
        providerId: InAppProviderIdEnum.Novu,
        channel: ChannelTypeEnum.IN_APP,
      });

      if (count === 0) {
        const response = await integrationRepository.create({
          _environmentId: environment._id,
          _organizationId: organization._id,
          providerId: InAppProviderIdEnum.Novu,
          channel: ChannelTypeEnum.IN_APP,
          credentials: encryptCredentials({
            hmac: environment.widget?.notificationCenterEncryption,
          }),
          active: true,
        });

        console.log(`Created Integration ${response._id}`);
      }

      console.log(`Prococessed environment ${environment._id}`);
    }

    console.log(`Prococessed organization ${organization._id}`);
  }

  console.log('end migration');
}

createInAppIntegration();


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - createInAppIntegration()
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/integration-scheme-update/add-integration-identifier-migration.spec.ts
Tamao: 4554 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentRepository, IntegrationRepository } from '@novu/dal';
import { ChannelTypeEnum, EmailProviderIdEnum, InAppProviderIdEnum, SmsProviderIdEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

import {
  addIntegrationIdentifierMigration,
  addIntegrationIdentifierMigrationBatched,
  genIntegrationIdentificationDetails,
} from './add-integration-identifier-migration';

describe('Add default identifier and name to integration entity', () => {
  let session: UserSession;
  const integrationRepository = new IntegrationRepository();
  const environmentRepository = new EnvironmentRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    await pruneIntegration(integrationRepository);
  });

  it('should identifier and name to integration entity', async () => {
    await integrationRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      channel: ChannelTypeEnum.EMAIL,
      providerId: EmailProviderIdEnum.SendGrid,
      active: true,
    });

    await integrationRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      channel: ChannelTypeEnum.SMS,
      providerId: SmsProviderIdEnum.SNS,
      active: true,
    });

    await integrationRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      channel: ChannelTypeEnum.IN_APP,
      providerId: InAppProviderIdEnum.Novu,
      active: true,
    });

    const createdIntegrations = await integrationRepository.find({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    } as any);

    expect(createdIntegrations.length).to.equal(3);

    for (const integration of createdIntegrations) {
      expect(integration.name).to.not.exist;
      expect(integration.identifier).to.not.exist;
    }

    await addIntegrationIdentifierMigration();

    const updatedIntegration = await integrationRepository.find({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    } as any);

    for (const integration of updatedIntegration) {
      const { name, identifier } = genIntegrationIdentificationDetails({ providerId: integration.providerId });

      expect(integration.name).to.equal(name);
      expect(integration.identifier).to.contain(identifier.split('-')[0]);
    }
  });

  it('should identifier and name to integration entity (batched)', async () => {
    await integrationRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      channel: ChannelTypeEnum.EMAIL,
      providerId: EmailProviderIdEnum.SendGrid,
      active: true,
    });

    await integrationRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      channel: ChannelTypeEnum.SMS,
      providerId: SmsProviderIdEnum.SNS,
      active: true,
    });

    await integrationRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      channel: ChannelTypeEnum.IN_APP,
      providerId: InAppProviderIdEnum.Novu,
      active: true,
    });

    const createdIntegrations = await integrationRepository.find({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    } as any);

    expect(createdIntegrations.length).to.equal(3);

    for (const integration of createdIntegrations) {
      expect(integration.name).to.not.exist;
      expect(integration.identifier).to.not.exist;
    }

    await addIntegrationIdentifierMigrationBatched();

    const updatedIntegration = await integrationRepository.find({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    } as any);

    for (const integration of updatedIntegration) {
      const { name, identifier } = genIntegrationIdentificationDetails({ providerId: integration.providerId });

      expect(integration.name).to.equal(name);
      expect(integration.identifier).to.contain(identifier.split('-')[0]);
    }
  });
});

async function pruneIntegration(integrationRepository) {
  const old = await integrationRepository.find({});

  for (const integration of old) {
    await integrationRepository.delete({ _id: integration._id, _environmentId: integration._environmentId });
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - pruneIntegration(integrationRepository)
Asignaciones con arrow functions encontradas (posibles funciones):
 - environmentRepository(new EnvironmentRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
    await pruneIntegration(integrationRepository)...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/integration-scheme-update/add-integration-identifier-migration.ts
Tamao: 3079 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

// June 27th, 2023

import { EnvironmentRepository, IntegrationEntity, IntegrationRepository } from '@novu/dal';
import { providers, slugify } from '@novu/shared';
import shortid from 'shortid';

export const ENVIRONMENT_NAME_TO_SHORT_NAME = { Development: 'dev', Production: 'prod', undefined: '' };

export async function addIntegrationIdentifierMigrationBatched() {
  console.log('start migration - add integration identifier migration');

  const integrationRepository = new IntegrationRepository();
  const environmentRepository = new EnvironmentRepository();
  const batchSize = 500;

  for await (const integration of integrationRepository.findBatch({} as any, '', {}, batchSize)) {
    console.log(`integration ${integration._id}`);

    const updatePayload = await getUpdatePayload(integration, environmentRepository);

    await integrationRepository.update(
      {
        _id: integration._id,
        _environmentId: integration._environmentId,
        _organizationId: integration._organizationId,
      },
      {
        $set: updatePayload,
      }
    );
    console.log(`integration ${integration._id} - name & identifier updated`);
  }
  console.log('end migration');
}

export async function addIntegrationIdentifierMigration() {
  console.log('start migration - add integration identifier migration');

  const integrationRepository = new IntegrationRepository();
  const environmentRepository = new EnvironmentRepository();

  const integrations = await integrationRepository.find({} as any);

  for (const integration of integrations) {
    console.log(`integration ${integration._id}`);

    const updatePayload = await getUpdatePayload(integration, environmentRepository);

    await integrationRepository.update(
      {
        _id: integration._id,
        _environmentId: integration._environmentId,
        _organizationId: integration._organizationId,
      },
      {
        $set: updatePayload,
      }
    );
    console.log(`integration ${integration._id} - name & identifier updated`);
  }
  console.log('end migration');
}

async function getUpdatePayload(integration: IntegrationEntity, environmentRepo: EnvironmentRepository) {
  const updatePayload: Partial<IntegrationEntity> = {};
  const { name, identifier } = genIntegrationIdentificationDetails({ providerId: integration.providerId });

  if (!integration.name) {
    updatePayload.name = name;
  }

  if (!integration.identifier) {
    updatePayload.identifier = identifier;
  }

  return updatePayload;
}

export function genIntegrationIdentificationDetails({
  providerId,
  name: existingName,
  identifier: existingIdentifier,
}: {
  providerId: string;
  name?: string;
  identifier?: string;
}) {
  const providerIdCapitalized = `${providerId.charAt(0).toUpperCase()}${providerId.slice(1)}`;
  const defaultName = providers.find((provider) => provider.id === providerId)?.displayName ?? providerIdCapitalized;

  const name = existingName ?? defaultName;
  const identifier = existingIdentifier ?? `${slugify(name)}-${shortid.generate()}`;

  return { name, identifier };
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - addIntegrationIdentifierMigrationBatched()
 - addIntegrationIdentifierMigration()
 - getUpdatePayload(integration: IntegrationEntity, environmentRepo: EnvironmentRepository)
 - genIntegrationIdentificationDetails({
  providerId,
  name: existingName,
  identifier: existingIdentifier,
}: {
  providerId: string;
  name?: string;
  identifier?: string;
})
Asignaciones con arrow functions encontradas (posibles funciones):
 - defaultName(providers.find((provider))
Declaraciones 'export' encontradas:
- export  const
- export  async
- export  async
- export function genIntegrationIdentificationDetails

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/integration-scheme-update/add-primary-priority-migration.ts
Tamao: 4531 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

// July 29th, 2023

import '../../src/config';

import { NestFactory } from '@nestjs/core';
import { EnvironmentRepository, IntegrationRepository, OrganizationRepository } from '@novu/dal';
import { CHANNELS_WITH_PRIMARY, ChannelTypeEnum } from '@novu/shared';

import { AppModule } from '../../src/app.module';

export async function run() {
  console.log('Migration for primary and priority fields in the integration entity\n');

  const app = await NestFactory.create(AppModule, {
    logger: false,
  });
  const organizationRepository = app.get(OrganizationRepository);
  const environmentRepository = app.get(EnvironmentRepository);
  const integrationRepository = app.get(IntegrationRepository);

  const environments = await environmentRepository.find({});

  for (const environment of environments) {
    const organization = await organizationRepository.findById(environment._organizationId);
    if (!organization) {
      console.log(
        `Organization ${environment._organizationId} is not found for environment ${environment.name}, id: ${environment._id}`
      );
      continue;
    }

    console.log('\n------------------------------------------');
    console.log(
      `Migrating integrations for the "${organization.name}" organization in the ${environment.name} environment:`
    );

    for (const channel of CHANNELS_WITH_PRIMARY) {
      const integrations = await integrationRepository.find(
        {
          _organizationId: organization._id,
          _environmentId: environment._id,
          channel,
          active: true,
        },
        undefined,
        { sort: { createdAt: -1 } }
      );
      console.log('------');
      console.log(`Found ${integrations.length} active integrations for the ${channel} channel`);

      for (let i = 0; i < integrations.length; i += 1) {
        const integration = integrations[i];
        const payload = {
          primary: i === 0,
          priority: integrations.length - i,
        };
        console.log(`${i + 1}. Updating integration "${integration.name}" with: `, payload);
        await integrationRepository.update(
          {
            _id: integration._id,
            _environmentId: integration._environmentId,
            _organizationId: integration._organizationId,
          },
          {
            $set: payload,
          }
        );
      }

      const inactiveIntegrations = await integrationRepository.find({
        _organizationId: organization._id,
        _environmentId: environment._id,
        channel,
        active: false,
      });
      console.log('------');
      console.log(`Found ${inactiveIntegrations.length} inactive integrations for the ${channel} channel`);

      for (let i = 0; i < inactiveIntegrations.length; i += 1) {
        const integration = inactiveIntegrations[i];
        const payload = {
          primary: false,
          priority: 0,
        };
        console.log(`${i + 1}. Updating inactive integration "${integration.name}" with: `, payload);
        await integrationRepository.update(
          {
            _id: integration._id,
            _environmentId: integration._environmentId,
            _organizationId: integration._organizationId,
          },
          {
            $set: payload,
          }
        );
      }
    }

    for (const channel of [ChannelTypeEnum.IN_APP, ChannelTypeEnum.PUSH, ChannelTypeEnum.CHAT]) {
      const integrations = await integrationRepository.find({
        _organizationId: organization._id,
        _environmentId: environment._id,
        channel,
      });
      console.log('------');
      console.log(`Found ${integrations.length} integrations for the ${channel} channel`);

      for (let i = 0; i < integrations.length; i += 1) {
        const integration = integrations[i];
        const payload = {
          primary: false,
          priority: 0,
        };
        console.log(`${i + 1}. Updating integration "${integration.name}" with: `, payload);
        await integrationRepository.update(
          {
            _id: integration._id,
            _environmentId: integration._environmentId,
            _organizationId: integration._organizationId,
          },
          {
            $set: payload,
          }
        );
      }
    }

    console.log(
      `Finished migrating integrations for the "${organization.name}" organization in the ${environment.name} environment:`
    );
    console.log('------------------------------------------\n');
  }

  app.close();
  process.exit(0);
}

run();


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - run()
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/integration-scheme-update/update-primary-for-disabled-novu-integrations.ts
Tamao: 2485 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

// Aug 29th, 2023

import '../../src/config';

import { NestFactory } from '@nestjs/core';
import { EnvironmentRepository, IntegrationRepository, OrganizationRepository } from '@novu/dal';
import { EmailProviderIdEnum, SmsProviderIdEnum } from '@novu/shared';

import { AppModule } from '../../src/app.module';

export async function run() {
  console.log('Update the primary and priority fields for inactive Novu integrations\n');

  const app = await NestFactory.create(AppModule, {
    logger: false,
  });
  const organizationRepository = app.get(OrganizationRepository);
  const environmentRepository = app.get(EnvironmentRepository);
  const integrationRepository = app.get(IntegrationRepository);

  const environments = await environmentRepository.find({});

  for (const environment of environments) {
    const organization = await organizationRepository.findById(environment._organizationId);
    if (!organization) {
      console.log(
        `Organization ${environment._organizationId} is not found for environment ${environment.name}, id: ${environment._id}`
      );
      continue;
    }

    console.log('\n------------------------------------------');
    console.log(
      `Updating integrations for the "${organization.name}" organization in the ${environment.name} environment`
    );

    const integrations = await integrationRepository.find(
      {
        _organizationId: organization._id,
        _environmentId: environment._id,
        active: false,
        primary: true,
        providerId: {
          $in: [EmailProviderIdEnum.Novu, SmsProviderIdEnum.Novu],
        },
      },
      undefined,
      { sort: { createdAt: -1 } }
    );

    console.log(
      `Found ${integrations.length} inactive and primary Novu integrations ` +
        `for the "${organization.name}" organization in the ${environment.name} environment`
    );

    const ids = integrations.map((integration) => integration._id);
    if (ids.length > 0) {
      console.log(`Updating Novu integrations with: `, { primary: false, priority: 0 });

      await integrationRepository._model.updateMany(
        {
          _id: { $in: ids },
        },
        { $set: { primary: false, priority: 0 } }
      );
    }

    console.log(
      `Finished updating integrations for the "${organization.name}" organization in the ${environment.name} environment`
    );
    console.log('------------------------------------------\n');
  }

  app.close();
  process.exit(0);
}

run();


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - run()
Asignaciones con arrow functions encontradas (posibles funciones):
 - ids(integrations.map((integration))
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/layout-identifier-update/add-layout-identifier-migration.spec.ts
Tamao: 3657 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentRepository, LayoutRepository } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

import { addLayoutIdentifierMigration } from './add-layout-identifier-migration';

describe('Add identifier to layout entity', () => {
  let session: UserSession;
  const layoutRepository = new LayoutRepository();
  const environmentRepository = new EnvironmentRepository();

  const createLayout = async (withProd = false) => {
    const layout = await layoutRepository.create({
      name: 'Test Layout',
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _creatorId: session.user._id as string,
      content: '<div>An layout wrapper <div>{{{body}}}</div></div>',
      isDefault: true,
      deleted: false,
      channel: ChannelTypeEnum.EMAIL,
    });
    if (withProd) {
      const prodEnv = await environmentRepository.findOne({
        _parentId: session.environment._id,
      });
      await layoutRepository.create({
        name: 'Test Layout',
        _environmentId: prodEnv?._id,
        _organizationId: session.organization._id,
        _parentId: layout._id,
        _creatorId: session.user._id as string,
        content: '<div>An layout wrapper <div>{{{body}}}</div></div>',
        isDefault: true,
        deleted: false,
        channel: ChannelTypeEnum.EMAIL,
      });
    }

    return layout;
  };

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should add identifier to layout entity and same identifier for a layout in different environments ', async () => {
    await pruneLayouts(layoutRepository);
    const devLayout = await createLayout(true);
    await createLayout();
    await createLayout();

    const createdLayouts = await layoutRepository.find({
      _organizationId: session.organization._id,
    } as any);

    expect(createdLayouts.length).to.equal(4);

    for (const layout of createdLayouts) {
      expect(layout.identifier).to.not.exist;
    }

    await addLayoutIdentifierMigration();

    const updatedLayouts = await layoutRepository.find({
      _organizationId: session.organization._id,
    } as any);

    for (const layout of updatedLayouts) {
      expect(layout.identifier).to.exist;
    }

    const temp = updatedLayouts.filter((layout) => layout._id === devLayout._id || layout._parentId === devLayout._id);
    expect(temp.length).to.equal(2);
    expect(temp[0].identifier).to.equal(temp[1].identifier);
  });

  it('should not change identifier for layout with existing identifier', async () => {
    const existingLayout = await layoutRepository.find({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });
    await createLayout();

    await addLayoutIdentifierMigration();

    const updatedLayouts = await layoutRepository.find({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    } as any);
    updatedLayouts.forEach((layout) => {
      expect(layout.identifier).to.exist;
    });
    const existingLayoutAfterMigration = await layoutRepository.find({
      _id: existingLayout[0]._id,
      _organizationId: session.organization._id,
    });
    expect(existingLayout[0].identifier).to.equal(existingLayoutAfterMigration[0].identifier);
  });
});

async function pruneLayouts(layoutRepository) {
  const old = await layoutRepository.find({});

  for (const layout of old) {
    await layoutRepository.delete({ _id: layout._id, _environmentId: layout._environmentId });
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - pruneLayouts(layoutRepository)
Asignaciones con arrow functions encontradas (posibles funciones):
 - withProd(false))
 - prodEnv(await environmentRepository.findOne({
        _parentId: session.environment._id,
      });
      aw...)
 - session(new UserSession();
    await session.initialize();
  });

  it('should add identifier to layout enti...)
 - temp(updatedLayouts.filter((layout))
 - updatedLayouts(await layoutRepository.find({
      _environmentId: session.environment._id,
      _organizationId: ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/layout-identifier-update/add-layout-identifier-migration.ts
Tamao: 1671 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

// August 14th, 2023

import { LayoutRepository, OrganizationRepository } from '@novu/dal';
import { slugify } from '@novu/shared';
import shortid from 'shortid';

export async function addLayoutIdentifierMigration() {
  console.log('start migration - add layout identifier migration');

  const organizationRepository = new OrganizationRepository();
  const layoutRepository = new LayoutRepository();

  const organizations = await organizationRepository.find({});

  for (const organization of organizations) {
    console.log(`organization ${organization._id}`);

    const layouts = await layoutRepository.find({
      _organizationId: organization._id,
      _parentId: { $exists: false, $eq: null },
      identifier: { $exists: false, $eq: null },
    });

    const bulkWriteOps = layouts.flatMap((layout) => {
      const { _id, name } = layout;
      const identifier = `${slugify(name)}-${shortid.generate()}`;

      return [
        {
          updateOne: {
            filter: { _id, _organizationId: organization._id },
            update: { $set: { identifier } },
          },
        },
        {
          updateOne: {
            filter: { _parentId: _id, _organizationId: organization._id },
            update: { $set: { identifier } },
          },
        },
      ];
    });

    let bulkResponse;
    try {
      bulkResponse = await layoutRepository.bulkWrite(bulkWriteOps);
    } catch (e) {
      bulkResponse = e.result;
    }
    console.log(
      `${bulkResponse.result.nMatched} matched, ${
        bulkResponse.result.nModified
      } modified, ${bulkResponse.getWriteErrorCount()} errors`
    );
  }
  console.log('end migration');
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - addLayoutIdentifierMigration()
Asignaciones con arrow functions encontradas (posibles funciones):
 - bulkWriteOps(layouts.flatMap((layout))
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/normalize-message-template-cta-action/normalize-message-cta-action-migration.ts
Tamao: 776 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MessageRepository, MessageTemplateRepository } from '@novu/dal';

export async function normalizeMessageCtaAction() {
  console.log('start migration - normalize message cta action');

  const messageRepository = new MessageRepository();
  const messages = await messageRepository._model
    .find({ 'cta.action': '' } as any)
    .read('secondaryPreferred')
    .lean();

  for (const message of messages) {
    console.log(`message ${message._id}`);

    await messageRepository.update(
      { _id: message._id, _organizationId: message._organizationId, _environmentId: message._environmentId } as any,
      {
        $set: { 'cta.action': {} },
      }
    );
    console.log(`message ${message._id} - cta action updated`);
  }

  console.log('end migration');
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - normalizeMessageCtaAction()
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/normalize-message-template-cta-action/normalize-message-template-cta-action-migration.spec.ts
Tamao: 3330 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { faker } from '@faker-js/faker';
import { MessageRepository, MessageTemplateRepository } from '@novu/dal';
import { StepTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { normalizeMessageCtaAction } from './normalize-message-cta-action-migration';
import { normalizeMessageTemplateCtaAction } from './normalize-message-template-cta-action-migration';

describe('Normalize cta action', () => {
  let session: UserSession;
  const messageTemplateRepository = new MessageTemplateRepository();
  const messageRepository = new MessageRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('normalize message template cta action', async () => {
    await messageTemplateRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      _creatorId: session.user._id,
      type: StepTypeEnum.IN_APP,
      content: 'noise',
      cta: {
        action: {
          buttons: [
            {
              title: faker.lorem.words(3),
              url: faker.internet.url(),
            },
          ],
        },
      },
    });

    await messageTemplateRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      _creatorId: session.user._id,
      type: StepTypeEnum.IN_APP,
      content: 'invalid action state',
      cta: {
        action: '',
      },
    });

    const messages = await messageTemplateRepository.find({ 'cta.action': '' } as any);

    expect(messages.length).to.equal(1);
    expect(messages[0]?.cta?.action).to.equal('');
    expect(messages[0]?.content).to.equal('invalid action state');

    await normalizeMessageTemplateCtaAction();

    const normalizedMessages = await messageTemplateRepository.find({ 'cta.action': '' } as any);

    expect(normalizedMessages.length).to.equal(0);
  });

  it('normalize message cta action', async () => {
    await messageRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      content: 'noise',
      cta: {
        action: {
          buttons: [
            {
              title: faker.lorem.words(3),
              url: faker.internet.url(),
            },
          ],
        },
      },
    });

    const createdMessage = await messageRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      content: 'invalid action state',
      cta: {
        action: '',
      },
    });
    await messageRepository.update(
      {
        _id: createdMessage._id,
        _organizationId: createdMessage._organizationId,
        _environmentId: createdMessage._environmentId,
      } as any,
      {
        $set: { 'cta.action': '' },
      }
    );

    const messages = await messageRepository.find({ 'cta.action': '' } as any);

    expect(messages.length).to.equal(1);
    expect(messages[0]?.cta?.action).to.equal('');
    expect(messages[0]?.content).to.equal('invalid action state');

    await normalizeMessageCtaAction();

    const normalizedMessages = await messageRepository.find({ 'cta.action': '' } as any);

    expect(normalizedMessages.length).to.equal(0);
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - messageRepository(new MessageRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('normalize message template cta actio...)
 - normalizedMessages(await messageTemplateRepository.find({ 'cta.action': '' } as any);

    expect(normalizedMessages.le...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/normalize-message-template-cta-action/normalize-message-template-cta-action-migration.ts
Tamao: 810 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MessageTemplateRepository } from '@novu/dal';

export async function normalizeMessageTemplateCtaAction() {
  console.log('start migration - normalize message template cta action');

  const messageTemplateRepository = new MessageTemplateRepository();
  const messageTemplates = await messageTemplateRepository._model
    .find({ 'cta.action': '' } as any)
    .read('secondaryPreferred');

  for (const message of messageTemplates) {
    console.log(`message ${message._id}`);

    await messageTemplateRepository.update(
      { _id: message._id, _organizationId: message._organizationId, _environmentId: message._environmentId } as any,
      {
        $set: { 'cta.action': {} },
      }
    );
    console.log(`message ${message._id} - cta action updated`);
  }

  console.log('end migration');
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - normalizeMessageTemplateCtaAction()
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/normalize-users-email/normalize-users-email.migration.ts
Tamao: 2499 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import '../../src/config';

import { NestFactory } from '@nestjs/core';
import { MemberRepository, SubscriberRepository, UserRepository } from '@novu/dal';

import { normalizeEmail } from '@novu/shared';
import { AppModule } from '../../src/app.module';

export async function run() {
  console.log('Migration Normalize Users Email\n');

  const app = await NestFactory.create(AppModule, {
    logger: false,
  });
  const userRepository = app.get(UserRepository);
  const subscriberRepository = app.get(SubscriberRepository);
  const memberRepository = app.get(MemberRepository);
  const users = await userRepository.find({});
  const sameEmailUsersIds: string[] = [];
  let normalizedEmailsCount = 0;
  let sameEmailUsersCount = 0;

  for (const user of users) {
    const beforeEmail = user.email;
    if (beforeEmail) {
      const normalizedEmail = normalizeEmail(beforeEmail);

      // if the email was normalized
      if (normalizedEmail !== beforeEmail) {
        console.log(
          `For the user: ${user._id} the email was "${beforeEmail}" now is normalized to "${normalizedEmail}"`
        );

        const sameEmailUser = await userRepository.findByEmail(normalizedEmail);
        if (sameEmailUser) {
          console.log(`--> Found the user ${sameEmailUser._id} with the same email "${sameEmailUser.email}"`);
          sameEmailUsersCount += 1;
          sameEmailUsersIds.push(sameEmailUser._id);
        }

        await userRepository.update(
          {
            _id: user._id,
          },
          {
            $set: {
              email: normalizedEmail,
            },
          }
        );

        normalizedEmailsCount += 1;
      }
    }
  }

  console.log('\n---------------------');
  console.log('Summary:');
  console.log(`Normalized user emails count: ${normalizedEmailsCount}`);
  console.log(`Users with the same emails count: ${sameEmailUsersCount}`);
  console.log(`Their ids: ${JSON.stringify(sameEmailUsersIds)}`);
  console.log('---------------------\n');

  for (const userId of sameEmailUsersIds) {
    const members = await memberRepository.findUserActiveMembers(userId);

    if (members.length > 1) {
      console.log(`User ${userId} has more than one active member`);
    } else {
      const subscribersCount = await subscriberRepository.count({
        _organizationId: members[0]._organizationId,
      });

      console.log(`User ${userId} has ${subscribersCount} subscribers`);
    }
  }

  app.close();
  process.exit(0);
}

run();


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - run()
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/novu-integrations/novu-integrations.migration.ts
Tamao: 2691 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import '../../src/config';
import { NestFactory } from '@nestjs/core';
import {
  ChannelTypeEnum,
  EnvironmentEntity,
  EnvironmentRepository,
  IntegrationRepository,
  OrganizationRepository,
} from '@novu/dal';
import { EmailProviderIdEnum, SmsProviderIdEnum, slugify } from '@novu/shared';
import shortid from 'shortid';
import { AppModule } from '../../src/app.module';

const organizationRepository = new OrganizationRepository();
const environmentRepository = new EnvironmentRepository();
const integrationRepository = new IntegrationRepository();

const createNovuIntegration = async (
  environment: EnvironmentEntity,
  channel: ChannelTypeEnum.EMAIL | ChannelTypeEnum.SMS
) => {
  const providerId = channel === ChannelTypeEnum.SMS ? SmsProviderIdEnum.Novu : EmailProviderIdEnum.Novu;
  const name = channel === ChannelTypeEnum.SMS ? 'Novu SMS' : 'Novu Email';

  const count = await integrationRepository.count({
    _environmentId: environment._id,
    _organizationId: environment._organizationId,
    providerId,
    channel,
  });

  if (count > 0) {
    return;
  }

  const countChannelIntegrations = await integrationRepository.count({
    _environmentId: environment._id,
    _organizationId: environment._organizationId,
    channel,
    active: true,
  });

  const response = await integrationRepository.create({
    _environmentId: environment._id,
    _organizationId: environment._organizationId,
    providerId,
    channel,
    name,
    identifier: `${slugify(name)}-${shortid.generate()}`,
    active: countChannelIntegrations === 0,
  });

  console.log(`Created Integration${response._id}`);
};

export async function createNovuIntegrations() {
  // Init the mongodb connection
  const app = await NestFactory.create(AppModule, {
    logger: false,
  });

  console.log('start migration - novu integrations');

  console.log('get organizations and its environments');

  const organizations = await organizationRepository.find({});
  const totalOrganizations = organizations.length;
  let currentOrganization = 0;
  for (const organization of organizations) {
    currentOrganization += 1;
    console.log(`organization ${currentOrganization} of ${totalOrganizations}`);

    const environments = await environmentRepository.findOrganizationEnvironments(organization._id);
    for (const environment of environments) {
      await createNovuIntegration(environment, ChannelTypeEnum.SMS);
      await createNovuIntegration(environment, ChannelTypeEnum.EMAIL);

      console.log(`Processed environment${environment._id}`);
    }

    console.log(`Processed organization${organization._id}`);
  }

  console.log('end migration');
}

createNovuIntegrations();


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - createNovuIntegrations()
Asignaciones con arrow functions encontradas (posibles funciones):
 - createNovuIntegration(async (
  environment: EnvironmentEntity,
  channel: ChannelTypeEnum.EMAIL | ChannelTypeEnum.SMS
))
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/preference-centralization/preference-centralization-migration.spec.ts
Tamao: 301 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

describe('Preference Centralization Migration', () => {
  /**
   * IMPORTANT: This migration depends on SubscriberPreferencesRepository which is now removed.
   * Please checkout the `v2.1.0` tag and run the migration from there.
   * @see https://github.com/novuhq/novu/releases/tag/v2.1.0
   */
});


### ANALISIS AUTOMATICO (ESPAOL) ###

No se detectaron funciones/exportaciones con heurstica JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/preference-centralization/preference-centralization-migration.ts
Tamao: 1410 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/**
 * Migration to centralize workflow and subscriber preferences.
 * Preferences are migrated in the following order:
 *
 * - workflow preferences
 *   -> preferences with workflow-resource type
 *   -> preferences with user-workflow type
 * - subscriber global preference
 *    -> preferences with subscriber global type
 * - subscriber workflow preferences
 *    -> preferences with subscriber workflow type
 *
 * Subscriber workflow preferences must be migrated after global preferences because
 * the upsert subscriber global preferences will delete the subscriber workflow preferences
 * with a matching channel.
 *
 * Depending on the size of your dataset, the following additional indexes will help with of the
 * Subscriber Preference Migration:
 * - { level: 1 }
 * - { level: 1, _id: 1 }
 */
export async function preferenceCentralization() {
  /**
   * IMPORTANT: This migration depends on SubscriberPreferencesRepository which is now removed.
   * Please checkout the `v2.1.0` tag and run the migration from there.
   * @see https://github.com/novuhq/novu/releases/tag/v2.1.0
   */
  console.error('This migration depends on SubscriberPreferencesRepository which is now removed.');
  console.error('Please checkout the `v2.1.0` tag and run the migration from there.');
  console.error('@see https://github.com/novuhq/novu/releases/tag/v2.1.0');

  process.exit(1);
}

preferenceCentralization();


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - preferenceCentralization()
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/preferences-uniqueness/preferences-uniqueness-migration.spec.ts
Tamao: 19852 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PreferencesRepository, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum, PreferencesTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { run } from './preferences-uniqueness-migration';

describe('Preferences Uniqueness Migration #novu-v2', () => {
  let session: UserSession;
  const preferencesRepository = new PreferencesRepository();
  const subscriberRepository = new SubscriberRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    await cleanupPreferences();
    await cleanupSubscribers();
  });

  async function cleanupPreferences() {
    await preferencesRepository._model.deleteMany({});
  }

  async function cleanupSubscribers() {
    await subscriberRepository._model.deleteMany({});
  }

  it('should remove duplicate subscriber global preferences and keep the oldest', async () => {
    const subscriber = await subscriberRepository.create({
      subscriberId: '123',
      firstName: 'first_subscriber',
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    const oldestDate = new Date('2024-01-01');
    const middleDate = new Date('2024-01-02');
    const newestDate = new Date('2024-01-03');

    const oldest = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: true },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(oldest._id, { updatedAt: oldestDate });

    const duplicate1 = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: false },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(duplicate1._id, { updatedAt: middleDate });

    const duplicate2 = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
      preferences: {
        channels: {
          [ChannelTypeEnum.SMS]: { enabled: true },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(duplicate2._id, { updatedAt: newestDate });

    const beforeCount = await preferencesRepository.count({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
    });

    expect(beforeCount).to.equal(3);

    await run();

    const afterCount = await preferencesRepository.count({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
    });

    expect(afterCount).to.equal(1);

    const remaining = await preferencesRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
    });

    expect(remaining?._id).to.equal(oldest._id);
  });

  it('should remove duplicate subscriber workflow preferences and keep the oldest', async () => {
    const subscriber = await subscriberRepository.create({
      subscriberId: '123',
      firstName: 'first_subscriber',
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });
    const workflow = await session.createTemplate();

    await preferencesRepository._model.deleteMany({
      _templateId: workflow._id,
    });

    const oldestDate = new Date('2024-01-01');
    const newestDate = new Date('2024-01-03');

    const oldest = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber._id,
      _templateId: workflow._id,
      type: PreferencesTypeEnum.SUBSCRIBER_WORKFLOW,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: true },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(oldest._id, { updatedAt: oldestDate });

    const duplicate = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber._id,
      _templateId: workflow._id,
      type: PreferencesTypeEnum.SUBSCRIBER_WORKFLOW,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: false },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(duplicate._id, { updatedAt: newestDate });

    const beforeCount = await preferencesRepository.count({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      _templateId: workflow._id,
      type: PreferencesTypeEnum.SUBSCRIBER_WORKFLOW,
    });

    expect(beforeCount).to.equal(2);

    await run();

    const afterCount = await preferencesRepository.count({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      _templateId: workflow._id,
      type: PreferencesTypeEnum.SUBSCRIBER_WORKFLOW,
    });

    expect(afterCount).to.equal(1);

    const remaining = await preferencesRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      _templateId: workflow._id,
      type: PreferencesTypeEnum.SUBSCRIBER_WORKFLOW,
    });

    expect(remaining?._id).to.equal(oldest._id);
  });

  it('should remove duplicate user workflow preferences and keep the oldest', async () => {
    const workflow = await session.createTemplate();

    await preferencesRepository._model.deleteMany({
      _templateId: workflow._id,
    });

    const oldestDate = new Date('2024-01-01');
    const newestDate = new Date('2024-01-03');

    const oldest = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _userId: session.user._id,
      _templateId: workflow._id,
      type: PreferencesTypeEnum.USER_WORKFLOW,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: true },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(oldest._id, { updatedAt: oldestDate });

    const duplicate = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _userId: session.user._id,
      _templateId: workflow._id,
      type: PreferencesTypeEnum.USER_WORKFLOW,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: false },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(duplicate._id, { updatedAt: newestDate });

    const beforeCount = await preferencesRepository.count({
      _environmentId: session.environment._id,
      _templateId: workflow._id,
      type: PreferencesTypeEnum.USER_WORKFLOW,
    });

    expect(beforeCount).to.equal(2);

    await run();

    const afterCount = await preferencesRepository.count({
      _environmentId: session.environment._id,
      _templateId: workflow._id,
      type: PreferencesTypeEnum.USER_WORKFLOW,
    });

    expect(afterCount).to.equal(1);

    const remaining = await preferencesRepository.findOne({
      _environmentId: session.environment._id,
      _templateId: workflow._id,
      type: PreferencesTypeEnum.USER_WORKFLOW,
    });

    expect(remaining?._id).to.equal(oldest._id);
  });

  it('should remove duplicate workflow resource preferences and keep the oldest', async () => {
    const workflow = await session.createTemplate();

    await preferencesRepository._model.deleteMany({
      _templateId: workflow._id,
    });

    const oldestDate = new Date('2024-01-01');
    const newestDate = new Date('2024-01-03');

    const oldest = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _templateId: workflow._id,
      type: PreferencesTypeEnum.WORKFLOW_RESOURCE,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: true },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(oldest._id, { updatedAt: oldestDate });

    const duplicate = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _templateId: workflow._id,
      type: PreferencesTypeEnum.WORKFLOW_RESOURCE,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: false },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(duplicate._id, { updatedAt: newestDate });

    const beforeCount = await preferencesRepository.count({
      _environmentId: session.environment._id,
      _templateId: workflow._id,
      type: PreferencesTypeEnum.WORKFLOW_RESOURCE,
    });

    expect(beforeCount).to.equal(2);

    await run();

    const afterCount = await preferencesRepository.count({
      _environmentId: session.environment._id,
      _templateId: workflow._id,
      type: PreferencesTypeEnum.WORKFLOW_RESOURCE,
    });

    expect(afterCount).to.equal(1);

    const remaining = await preferencesRepository.findOne({
      _environmentId: session.environment._id,
      _templateId: workflow._id,
      type: PreferencesTypeEnum.WORKFLOW_RESOURCE,
    });

    expect(remaining?._id).to.equal(oldest._id);
  });

  it('should not affect unique preferences without duplicates', async () => {
    const subscriber1 = await subscriberRepository.create({
      subscriberId: '123',
      firstName: 'first_subscriber',
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });
    const subscriber2 = await subscriberRepository.create({
      subscriberId: '345',
      firstName: 'second_subscriber',
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });
    const workflow = await session.createTemplate();

    await preferencesRepository._model.deleteMany({
      _templateId: workflow._id,
    });

    await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber1._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: true },
        },
      },
    });

    await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber2._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: true },
        },
      },
    });

    await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber1._id,
      _templateId: workflow._id,
      type: PreferencesTypeEnum.SUBSCRIBER_WORKFLOW,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: true },
        },
      },
    });

    const beforeCount = await preferencesRepository.count({
      _environmentId: session.environment._id,
    });

    expect(beforeCount).to.equal(3);

    await run();

    const afterCount = await preferencesRepository.count({
      _environmentId: session.environment._id,
    });

    expect(afterCount).to.equal(3);
  });

  it('should handle multiple duplicate groups independently', async () => {
    const subscriber1 = await subscriberRepository.create({
      subscriberId: '123',
      firstName: 'first_subscriber',
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });
    const subscriber2 = await subscriberRepository.create({
      subscriberId: '345',
      firstName: 'second_subscriber',
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    const oldestDate1 = new Date('2024-01-01');
    const newestDate1 = new Date('2024-01-03');
    const oldestDate2 = new Date('2024-02-01');
    const newestDate2 = new Date('2024-02-03');

    const oldest1 = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber1._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: true },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(oldest1._id, { updatedAt: oldestDate1 });

    const duplicate1 = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber1._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: false },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(duplicate1._id, { updatedAt: newestDate1 });

    const oldest2 = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber2._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
      preferences: {
        channels: {
          [ChannelTypeEnum.SMS]: { enabled: true },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(oldest2._id, { updatedAt: oldestDate2 });

    const duplicate2 = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber2._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
      preferences: {
        channels: {
          [ChannelTypeEnum.SMS]: { enabled: false },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(duplicate2._id, { updatedAt: newestDate2 });

    const beforeCount = await preferencesRepository.count({
      _environmentId: session.environment._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
    });

    expect(beforeCount).to.equal(4);

    await run();

    const afterCount = await preferencesRepository.count({
      _environmentId: session.environment._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
    });

    expect(afterCount).to.equal(2);

    const remaining1 = await preferencesRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber1._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
    });

    expect(remaining1?._id).to.equal(oldest1._id);

    const remaining2 = await preferencesRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber2._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
    });

    expect(remaining2?._id).to.equal(oldest2._id);
  });

  it('should handle mixed scenarios with duplicates across different preference types', async () => {
    const subscriber = await subscriberRepository.create({
      subscriberId: '123',
      firstName: 'first_subscriber',
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });
    const workflow1 = await session.createTemplate();
    const workflow2 = await session.createTemplate();

    await preferencesRepository._model.deleteMany({
      _templateId: { $in: [workflow1._id, workflow2._id] },
    });

    const oldestDate = new Date('2024-01-01');
    const newestDate = new Date('2024-01-03');

    const globalOldest = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: true },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(globalOldest._id, { updatedAt: oldestDate });

    const globalDuplicate = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: false },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(globalDuplicate._id, { updatedAt: newestDate });

    const workflowOldest = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber._id,
      _templateId: workflow1._id,
      type: PreferencesTypeEnum.SUBSCRIBER_WORKFLOW,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: true },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(workflowOldest._id, { updatedAt: oldestDate });

    const workflowDuplicate = await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber._id,
      _templateId: workflow1._id,
      type: PreferencesTypeEnum.SUBSCRIBER_WORKFLOW,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: false },
        },
      },
    });

    await preferencesRepository._model.findByIdAndUpdate(workflowDuplicate._id, { updatedAt: newestDate });

    await preferencesRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      _subscriberId: subscriber._id,
      _templateId: workflow2._id,
      type: PreferencesTypeEnum.SUBSCRIBER_WORKFLOW,
      preferences: {
        channels: {
          [ChannelTypeEnum.EMAIL]: { enabled: true },
        },
      },
    });

    const beforeCount = await preferencesRepository.count({
      _environmentId: session.environment._id,
    });

    expect(beforeCount).to.equal(5);

    await run();

    const afterCount = await preferencesRepository.count({
      _environmentId: session.environment._id,
    });

    expect(afterCount).to.equal(3);

    const globalRemaining = await preferencesRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
    });

    expect(globalRemaining?._id).to.equal(globalOldest._id);

    const workflowRemaining = await preferencesRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      _templateId: workflow1._id,
      type: PreferencesTypeEnum.SUBSCRIBER_WORKFLOW,
    });

    expect(workflowRemaining?._id).to.equal(workflowOldest._id);

    const workflow2Count = await preferencesRepository.count({
      _environmentId: session.environment._id,
      _subscriberId: subscriber._id,
      _templateId: workflow2._id,
      type: PreferencesTypeEnum.SUBSCRIBER_WORKFLOW,
    });

    expect(workflow2Count).to.equal(1);
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - cleanupPreferences()
 - cleanupSubscribers()
Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberRepository(new SubscriberRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
    await cleanupPreferences();
    await cleanup...)
 - remaining(await preferencesRepository.findOne({
      _environmentId: session.environment._id,
      _subscrib...)
 - remaining(await preferencesRepository.findOne({
      _environmentId: session.environment._id,
      _subscrib...)
 - remaining(await preferencesRepository.findOne({
      _environmentId: session.environment._id,
      _template...)
 - remaining(await preferencesRepository.findOne({
      _environmentId: session.environment._id,
      _template...)
 - afterCount(await preferencesRepository.count({
      _environmentId: session.environment._id,
    });

    expe...)
 - remaining2(await preferencesRepository.findOne({
      _environmentId: session.environment._id,
      _subscrib...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/preferences-uniqueness/preferences-uniqueness-migration.ts
Tamao: 4247 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import '../../src/config';

import { NestFactory } from '@nestjs/core';
import { PinoLogger } from '@novu/application-generic';
import { PreferencesRepository } from '@novu/dal';
import { PreferencesTypeEnum } from '@novu/shared';
import { Expression } from 'mongoose';
import { AppModule } from '../../src/app.module';

export async function run() {
  const app = await NestFactory.create(AppModule, {
    logger: false,
  });

  const logger = await app.resolve(PinoLogger);
  logger.setContext('PreferencesUniquenessMigration');
  const preferencesRepository = app.get(PreferencesRepository);

  logger.info('start migration - preferences uniqueness');

  const promiseTypes = [
    PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
    PreferencesTypeEnum.SUBSCRIBER_WORKFLOW,
    PreferencesTypeEnum.USER_WORKFLOW,
    PreferencesTypeEnum.WORKFLOW_RESOURCE,
  ];

  const promises: Promise<void>[] = [];
  // Subscriber global preferences
  promises.push(
    deletePreferenceDuplicates({
      preferencesRepository,
      logger,
      type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
      sort: { _environmentId: 1, _subscriberId: 1 },
      groupId: { _environmentId: '$_environmentId', _subscriberId: '$_subscriberId' },
    })
  );

  // Subscriber workflow preferences
  promises.push(
    deletePreferenceDuplicates({
      preferencesRepository,
      logger,
      type: PreferencesTypeEnum.SUBSCRIBER_WORKFLOW,
      sort: { _environmentId: 1, _subscriberId: 1, _templateId: 1 },
      groupId: { _environmentId: '$_environmentId', _subscriberId: '$_subscriberId', _templateId: '$_templateId' },
    })
  );

  // User workflow preferences
  promises.push(
    deletePreferenceDuplicates({
      preferencesRepository,
      logger,
      type: PreferencesTypeEnum.USER_WORKFLOW,
      sort: { _environmentId: 1, _templateId: 1 },
      groupId: { _environmentId: '$_environmentId', _templateId: '$_templateId' },
    })
  );

  // Workflow resource preferences
  promises.push(
    deletePreferenceDuplicates({
      preferencesRepository,
      logger,
      type: PreferencesTypeEnum.WORKFLOW_RESOURCE,
      sort: { _environmentId: 1, _templateId: 1 },
      groupId: { _environmentId: '$_environmentId', _templateId: '$_templateId' },
    })
  );

  await Promise.allSettled(promises).then((results) => {
    for (const result of results) {
      if (result.status === 'rejected') {
        const index = results.indexOf(result);
        const promiseType = promiseTypes[index];

        logger.error('error deleting %s preferences duplicates: %s', promiseType, result.reason);
      }
    }
  });

  logger.info('end migration');
  await app.close();
}

async function deletePreferenceDuplicates({
  preferencesRepository,
  logger,
  type,
  sort,
  groupId,
}: {
  preferencesRepository: PreferencesRepository;
  logger: PinoLogger;
  type: PreferencesTypeEnum;
  sort: Record<string, 1 | Expression.Meta | -1>;
  groupId: Record<string, string>;
}) {
  logger.info('deleting %s preferences duplicates', type);

  const cursor = await preferencesRepository._model.aggregate<{
    ids: { id: string; updatedAt: Date; _environmentId: string }[];
  }>(
    [
      { $match: { type } },
      { $sort: sort },
      {
        $group: {
          _id: groupId,
          ids: { $push: { id: '$_id', updatedAt: '$updatedAt', _environmentId: '$_environmentId' } },
          count: { $sum: 1 },
        },
      },
      { $match: { count: { $gt: 1 } } },
    ],
    { maxTimeMS: 600000, allowDiskUse: true }
  );

  logger.info('found %s %s preferences duplicates', cursor.length, type);

  for (const doc of cursor) {
    // sort by updatedAt ascending
    const sorted = doc.ids.sort((a, b) => a.updatedAt.getTime() - b.updatedAt.getTime());
    const _idToKeep = sorted.shift(); // keep the oldest
    const toDelete = sorted.map((d) => d.id);

    await preferencesRepository.delete({
      _id: { $in: toDelete },
      _environmentId: doc.ids[0]._environmentId,
    });
  }

  logger.info('deleted %s %s preferences duplicates', cursor.length, type);
}

/* run()
  .then(() => {
    console.log('Migration completed successfully');
    process.exit(0);
  })
  .catch((error) => {
    console.error(error);
    process.exit(1);
  }); */


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - run()
 - deletePreferenceDuplicates({
  preferencesRepository,
  logger,
  type,
  sort,
  groupId,
}: {
  preferencesRepository: PreferencesRepository;
  logger: PinoLogger;
  type: PreferencesTypeEnum;
  sort: Record<string, 1 | Expression.Meta | -1>;
  groupId: Record<string, string>;
})
Asignaciones con arrow functions encontradas (posibles funciones):
 - sorted(doc.ids.sort((a, b))
 - toDelete(sorted.map((d))
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/secure-to-boolean/secure-to-boolean-migration.spec.ts
Tamao: 2350 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IntegrationRepository } from '@novu/dal';
import { expect } from 'chai';
import { beforeEach } from 'mocha';
import { updateFalseValues, updateTrueValues } from './secure-to-boolean-migration';

const integrationRepository = new IntegrationRepository();

const STR_FALSE_AMOUNT = 10;
const FALSE_AMOUNT = 12;

const STR_TRUE_AMOUNT = 15;
const TRUE_AMOUNT = 10;

describe('Update integration credentials.secure type from string to boolean', () => {
  beforeEach(async () => {
    await clearIntegrationCollection();
    await seedIntegrationCollection('false', STR_FALSE_AMOUNT);
    await seedIntegrationCollection(false, FALSE_AMOUNT);
    await seedIntegrationCollection('true', STR_TRUE_AMOUNT);
    await seedIntegrationCollection(true, TRUE_AMOUNT);
    // secure is optional so it's good to ensure if migration queries don't affect other integrations
    await seedIntegrationCollection(undefined, 10);
  });

  it('should update credentials.secure from "false" to false', async () => {
    const result = await updateFalseValues();
    expect(result.modifiedCount).to.equal(STR_FALSE_AMOUNT);

    const afterChange = await countAfterChange(false);
    expect(afterChange).to.equal(STR_FALSE_AMOUNT + FALSE_AMOUNT);
  });

  it('should update credentials.secure from "true" to true', async () => {
    const result = await updateTrueValues();
    expect(result.modifiedCount).to.equal(STR_TRUE_AMOUNT);

    const afterChange = await countAfterChange(true);
    expect(afterChange).to.equal(STR_TRUE_AMOUNT + TRUE_AMOUNT);
  });
});

async function clearIntegrationCollection() {
  return integrationRepository._model.collection.deleteMany({});
}

async function seedIntegrationCollection(secureValue: any, amount: number) {
  for (let i = 0; i < amount; i += 1) {
    await integrationRepository._model.collection.insertOne({
      providerId: 'apns',
      channel: 'push',
      credentials: {
        secure: secureValue,
        apiKey: `nvsk.12345667891011121314151617181920212223`,
        secretKey: `nvsk.12345667891011121314151617181920212223`,
      },
      active: false,
      deleted: false,
      createdAt: new Date(),
      updatedAt: new Date(),
    });
  }
}

async function countAfterChange(secureValue: boolean) {
  return integrationRepository._model.collection.count({ 'credentials.secure': secureValue });
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - clearIntegrationCollection()
 - seedIntegrationCollection(secureValue: any, amount: number)
 - countAfterChange(secureValue: boolean)
Asignaciones con arrow functions encontradas (posibles funciones):
 - TRUE_AMOUNT(10;

describe('Update integration credentials.secure type from string to boolean', ())
 - afterChange(await countAfterChange(false);
    expect(afterChange).to.equal(STR_FALSE_AMOUNT + FALSE_AMOUNT);
  ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/secure-to-boolean/secure-to-boolean-migration.ts
Tamao: 1585 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import '../../src/config';
import { NestFactory } from '@nestjs/core';
import { PinoLogger } from '@novu/application-generic';
import { IntegrationRepository } from '@novu/dal';
import { AppModule } from '../../src/app.module';

const integrationRepository = new IntegrationRepository();

export async function run() {
  const app = await NestFactory.create(AppModule, {
    logger: false,
  });
  const logger = await app.resolve(PinoLogger);
  logger.setContext('SecureToBooleanMigration');

  logger.info('Start migration - update credentials.secure from string to boolean');

  logger.info('Updating from "true" to true...');
  const resultTrue = await updateTrueValues();
  logger.info(`Matched: ${resultTrue.matchedCount}  Modified: ${resultTrue.modifiedCount} \n`);

  logger.info('Updating from "false" to false...');
  const resultFalse = await updateFalseValues();
  logger.info(`Matched: ${resultFalse.matchedCount}  Modified: ${resultFalse.modifiedCount} \n`);

  logger.info('End migration.\n');
  await app.close();
}

type UpdateResult = { matchedCount: number; modifiedCount: number };

export function updateTrueValues() {
  return integrationRepository._model.collection.updateMany(
    {
      'credentials.secure': 'true',
    },
    {
      $set: { 'credentials.secure': true },
    }
  ) as Promise<UpdateResult>;
}

export function updateFalseValues() {
  return integrationRepository._model.collection.updateMany(
    {
      'credentials.secure': 'false',
    },
    {
      $set: { 'credentials.secure': false },
    }
  ) as Promise<UpdateResult>;
}

run();


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - run()
 - updateTrueValues()
 - updateFalseValues()
Declaraciones 'export' encontradas:
- export  async
- export function updateTrueValues
- export function updateFalseValues

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/seen-read-support/seen-read-support.migration.spec.ts
Tamao: 2399 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MessageRepository, NotificationTemplateEntity, SubscriberRepository } from '@novu/dal';
import { StepTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { sendTrigger } from '../../src/app/events/e2e/trigger-event.e2e';
import { inAppAsSeen, notInAppAsUnseen, seenToRead } from './seen-read-support.migration';

describe('Update seen/read', () => {
  const messageRepository = new MessageRepository();
  let session: UserSession;
  let template: NotificationTemplateEntity;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    template = await createTemplate(session);

    for (let i = 0; i < 7; i += 1) {
      const newSubscriberIdInAppNotification = SubscriberRepository.createObjectId();
      await sendTrigger(session, template, newSubscriberIdInAppNotification);
    }
    await new Promise((r) => setTimeout(r, 1000));

    await messageRepository.update({}, { $unset: { read: 1 } });

    for (let i = 0; i < 3; i += 1) {
      const newSubscriberIdInAppNotification = SubscriberRepository.createObjectId();
      await sendTrigger(session, template, newSubscriberIdInAppNotification);
    }
    await new Promise((r) => setTimeout(r, 1000));
  });

  it('should update all seen to read', async () => {
    await seenToRead();

    const messages = await messageRepository.find({});

    messages.forEach((msg) => {
      expect(msg.read).to.exist;
    });
  });

  it('should add not in app seen as false', async () => {
    await seenToRead();

    await inAppAsSeen();

    await notInAppAsUnseen();

    const messages = await messageRepository.find({ channel: { $ne: 'in_app' } });

    messages.forEach((msg) => {
      expect(msg.seen).to.equal(false);
    });
  });
});

async function createTemplate(session) {
  return await session.createTemplate({
    steps: [
      {
        type: StepTypeEnum.SMS,
        content: 'Welcome to {{organizationName}}' as string,
      },
      {
        type: StepTypeEnum.IN_APP,
        content: 'Hello {{subscriber.lastName}}, Welcome to {{organizationName}}' as string,
      },
      {
        type: StepTypeEnum.EMAIL,
        content: [
          {
            type: 'text',
            content: 'Hello {{subscriber.lastName}}, Welcome to {{organizationName}}' as string,
          },
        ],
      },
    ],
  });
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - createTemplate(session)
Asignaciones con arrow functions encontradas (posibles funciones):
 - messageRepository(new MessageRepository();
  let session: UserSession;
  let template: NotificationTemplateEntity;

  ...)
 - newSubscriberIdInAppNotification(SubscriberRepository.createObjectId();
      await sendTrigger(session, template, newSubscriberIdInA...)
 - newSubscriberIdInAppNotification(SubscriberRepository.createObjectId();
      await sendTrigger(session, template, newSubscriberIdInA...)
 - messages(await messageRepository.find({});

    messages.forEach((msg))
 - messages(await messageRepository.find({ channel: { $ne: 'in_app' } });

    messages.forEach((msg))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/seen-read-support/seen-read-support.migration.ts
Tamao: 1031 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MessageRepository } from '@novu/dal';

const messageRepository = new MessageRepository();

export async function updateSeenRead() {
  console.log('start migration - update seen to read & add seen-true');

  console.log('rename all seen to read');

  await seenToRead();

  console.log('add in_app messages as seen');

  await inAppAsSeen();

  console.log('add not in_app messages as unseen (due the missing feature seen/unseen on other channels)');

  await notInAppAsUnseen();

  console.log('end migration');
}

export async function seenToRead() {
  await messageRepository.update({ read: { $exists: false } }, { $rename: { seen: 'read' } });
}

export async function inAppAsSeen() {
  await messageRepository.update(
    {
      channel: 'in_app',
      seen: { $exists: false },
    },
    { $set: { seen: true } }
  );
}

export async function notInAppAsUnseen() {
  await messageRepository.update(
    {
      channel: { $ne: 'in_app' },
      seen: { $exists: false },
    },
    { $set: { seen: false } }
  );
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - updateSeenRead()
 - seenToRead()
 - inAppAsSeen()
 - notInAppAsUnseen()
Declaraciones 'export' encontradas:
- export  async
- export  async
- export  async
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/subscribers/remove-duplicated-subscribers/remove-duplicated-subscribers.migration.spec.ts
Tamao: 17593 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SubscriberRepository } from '@novu/dal';
import { ChatProviderIdEnum, IChannelSettings, ISubscriber } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { removeDuplicatedSubscribers } from './remove-duplicated-subscribers.migration';

describe('Migration: Remove Duplicated Subscribers', () => {
  let session: UserSession;
  let subscriberService: SubscribersService;
  const subscriberRepository = new SubscriberRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
  });

  it('should remove duplicated subscribers', async () => {
    const duplicatedSubscriberId = '123';

    await subscriberRepository.create({
      subscriberId: duplicatedSubscriberId,
      firstName: 'first_subscriber',
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    await subscriberRepository.create({
      subscriberId: duplicatedSubscriberId,
      firstName: 'mid_subscriber',
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    await subscriberRepository.create({
      subscriberId: duplicatedSubscriberId,
      firstName: 'last_subscriber',
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    const duplicates = await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: session.environment._id,
    });

    expect(duplicates.length).to.equal(3);

    await removeDuplicatedSubscribers();

    const remainingDuplicates = await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: session.environment._id,
    });

    expect(remainingDuplicates.length).to.equal(1);
    expect(remainingDuplicates[0].firstName).to.equal('last_subscriber');
  });

  it('should always keep one subscriber per environment', async () => {
    const duplicatedSubscriberId = '123';
    const firstEnvironmentId = session.environment._id;

    await subscriberRepository.create({
      subscriberId: duplicatedSubscriberId,
      firstName: 'env_1',
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
    });
    await subscriberRepository.create({
      subscriberId: duplicatedSubscriberId,
      firstName: 'env_1',
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
    });

    const secondEnvironmentId = session.organization._id;

    await subscriberRepository.create({
      subscriberId: duplicatedSubscriberId,
      firstName: 'env_2',
      _environmentId: secondEnvironmentId,
      _organizationId: session.organization._id,
    });
    await subscriberRepository.create({
      subscriberId: duplicatedSubscriberId,
      firstName: 'env_2',
      _environmentId: secondEnvironmentId,
      _organizationId: session.organization._id,
    });

    const duplicates = await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: session.environment._id,
    });
    expect(duplicates.length).to.equal(2);

    const duplicates2 = await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: session.environment._id,
    });
    expect(duplicates2.length).to.equal(2);

    await removeDuplicatedSubscribers();

    const remainingDuplicates = await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: session.environment._id,
    });
    expect(remainingDuplicates.length).to.equal(1);
    expect(remainingDuplicates[0].firstName).to.equal('env_1');

    const remainingDuplicates2 = await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: secondEnvironmentId,
    });
    expect(remainingDuplicates2.length).to.equal(1);
    expect(remainingDuplicates2[0].firstName).to.equal('env_2');
  });

  it('should merge the metadata across duplicated subscribers', async () => {
    const duplicatedSubscriberId = '123';
    const firstEnvironmentId = session.environment._id;

    await subscriberRepository.create({
      subscriberId: duplicatedSubscriberId,
      firstName: 'first_name',
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
    });
    await subscriberRepository.create({
      subscriberId: duplicatedSubscriberId,
      lastName: 'last_name',
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
    });

    const duplicates = await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: session.environment._id,
    });
    expect(duplicates.length).to.equal(2);

    await removeDuplicatedSubscribers();

    const remainingDuplicates = await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: session.environment._id,
    });
    expect(remainingDuplicates.length).to.equal(1);
    expect(remainingDuplicates[0].firstName).to.equal('first_name');
    expect(remainingDuplicates[0].lastName).to.equal('last_name');
  });

  it('should merge the metadata across duplicated subscribers by latest created subscriber', async () => {
    const duplicatedSubscriberId = '123';
    const firstEnvironmentId = session.environment._id;

    const firstCreatedSubscriber = await subscriberRepository.create({
      subscriberId: duplicatedSubscriberId,
      firstName: 'first_name_1',
      lastName: 'last_name_1',
      email: 'email_1',
      phone: 'phone_1',
      avatar: 'avatar_1',
      locale: 'locale_1',
      data: { key: 'value_1' },
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
    });

    await subscriberRepository.create({
      subscriberId: duplicatedSubscriberId,
      firstName: 'first_name_2',
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
    });

    await subscriberRepository.create({
      subscriberId: duplicatedSubscriberId,
      email: 'email_3',
      phone: 'phone_3',
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
    });

    await subscriberRepository.create({
      subscriberId: duplicatedSubscriberId,
      avatar: 'avatar_4',
      data: { newStuff: 'value_4' },
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
    });

    await subscriberRepository.create({
      subscriberId: duplicatedSubscriberId,
      firstName: 'first_name_5',
      locale: 'locale_5',
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
    });

    const duplicates = await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: session.environment._id,
    });
    expect(duplicates.length).to.equal(5);

    await removeDuplicatedSubscribers();

    const remainingDuplicates = await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: session.environment._id,
    });
    expect(remainingDuplicates.length).to.equal(1);
    expect(remainingDuplicates[0]._id).to.equal(firstCreatedSubscriber._id);
    expect(remainingDuplicates[0]._organizationId).to.equal(firstCreatedSubscriber._organizationId);
    expect(remainingDuplicates[0]._environmentId).to.equal(firstCreatedSubscriber._environmentId);
    expect(remainingDuplicates[0].__v).to.equal(firstCreatedSubscriber.__v);

    expect(remainingDuplicates[0].firstName).to.equal('first_name_5');
    expect(remainingDuplicates[0].lastName).to.equal('last_name_1');
    expect(remainingDuplicates[0].email).to.equal('email_3');
    expect(remainingDuplicates[0].phone).to.equal('phone_3');
    expect(remainingDuplicates[0].avatar).to.equal('avatar_4');
    expect(remainingDuplicates[0].locale).to.equal('locale_5');
    expect(remainingDuplicates[0].data?.key).to.be.undefined;
    expect(remainingDuplicates[0].data?.newStuff).to.equal('value_4');
  });

  it('should merge 2 channel integration', async () => {
    const duplicatedSubscriberId = '123';
    const firstEnvironmentId = session.environment._id;

    const subscriber1: ISubscriber = {
      email: 'email_1',
      subscriberId: duplicatedSubscriberId,
      firstName: 'first_name_1',
      lastName: 'last_name_1',
      channels: [{ _integrationId: '1', providerId: ChatProviderIdEnum.Slack, credentials: { webhookUrl: 'url_1' } }],
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
      deleted: false,
      createdAt: '2021-01-01T00:00:00.000Z',
      updatedAt: '2021-01-01T00:00:00.000Z',
    };
    const firstCreatedSubscriber = await subscriberRepository.create(subscriber1);

    const subscriber2: ISubscriber = {
      email: 'email_1',
      subscriberId: duplicatedSubscriberId,
      firstName: 'first_name_1',
      lastName: 'last_name_1',
      channels: [
        {
          _integrationId: '2',
          providerId: ChatProviderIdEnum.Discord,
          credentials: { deviceTokens: ['token_123', 'token_123'] },
        },
      ],
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
      deleted: false,
      createdAt: '2021-01-01T00:00:00.000Z',
      updatedAt: '2021-01-01T00:00:00.000Z',
    };
    await subscriberRepository.create(subscriber2);

    await removeDuplicatedSubscribers();

    const remainingDuplicates = await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: session.environment._id,
    });
    expect(remainingDuplicates.length).to.equal(1);
    expect(remainingDuplicates[0]._id).to.equal(firstCreatedSubscriber._id);
    expect(remainingDuplicates[0]._organizationId).to.equal(firstCreatedSubscriber._organizationId);
    expect(remainingDuplicates[0]._environmentId).to.equal(firstCreatedSubscriber._environmentId);
    expect(remainingDuplicates[0].email).to.equal('email_1');
    expect(remainingDuplicates[0].firstName).to.equal('first_name_1');
    expect(remainingDuplicates[0].lastName).to.equal('last_name_1');
    expect(remainingDuplicates[0].createdAt).to.equal('2021-01-01T00:00:00.000Z');

    const firstChannel: IChannelSettings | undefined = remainingDuplicates[0].channels?.find(
      (channel) => channel._integrationId === '1'
    );
    expect(firstChannel?._integrationId).to.equal('1');
    expect(firstChannel?.providerId).to.equal(ChatProviderIdEnum.Slack);
    expect(firstChannel?.credentials.webhookUrl).to.equal('url_1');

    const secondChannel: IChannelSettings | undefined = remainingDuplicates[0].channels?.find(
      (channel) => channel._integrationId === '2'
    );
    expect(secondChannel?._integrationId).to.equal('2');
    expect(secondChannel?.providerId).to.equal(ChatProviderIdEnum.Discord);
    expect(secondChannel?.credentials.deviceTokens).to.deep.equal(['token_123']);
  });

  it('should merge 2 channel same integration', async () => {
    const duplicatedSubscriberId = '123';
    const firstEnvironmentId = session.environment._id;

    const subscriber1: ISubscriber = {
      email: 'email_1',
      subscriberId: duplicatedSubscriberId,
      firstName: 'first_name_1',
      lastName: 'last_name_1',
      channels: [
        {
          _integrationId: '1',
          providerId: ChatProviderIdEnum.Discord,
          credentials: { deviceTokens: ['token_1', 'token_2'] },
        },
      ],
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
      deleted: false,
      createdAt: '2021-01-01T00:00:00.000Z',
      updatedAt: '2021-01-01T00:00:00.000Z',
    };
    const firstCreatedSubscriber = await subscriberRepository.create(subscriber1);

    const subscriber2: ISubscriber = {
      email: 'email_1',
      subscriberId: duplicatedSubscriberId,
      firstName: 'first_name_1',
      lastName: 'last_name_1',
      channels: [
        {
          _integrationId: '1',
          providerId: ChatProviderIdEnum.Discord,
          credentials: { deviceTokens: ['token_2', 'token_3', 'token_3'] },
        },
      ],
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
      deleted: false,
      createdAt: '2021-01-01T00:00:00.000Z',
      updatedAt: '2021-01-01T00:00:00.000Z',
    };
    await subscriberRepository.create(subscriber2);

    await removeDuplicatedSubscribers();

    const remainingDuplicates = await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: session.environment._id,
    });
    expect(remainingDuplicates.length).to.equal(1);
    expect(remainingDuplicates[0]._id).to.equal(firstCreatedSubscriber._id);
    expect(remainingDuplicates[0]._organizationId).to.equal(firstCreatedSubscriber._organizationId);
    expect(remainingDuplicates[0]._environmentId).to.equal(firstCreatedSubscriber._environmentId);
    expect(remainingDuplicates[0].email).to.equal('email_1');
    expect(remainingDuplicates[0].firstName).to.equal('first_name_1');
    expect(remainingDuplicates[0].lastName).to.equal('last_name_1');
    expect(remainingDuplicates[0].createdAt).to.equal('2021-01-01T00:00:00.000Z');

    const firstChannel: IChannelSettings | undefined = remainingDuplicates[0].channels?.find(
      (channel) => channel._integrationId === '1'
    );
    expect(firstChannel?._integrationId).to.equal('1');
    expect(firstChannel?.providerId).to.equal(ChatProviderIdEnum.Discord);
    expect(firstChannel?.credentials.deviceTokens).to.deep.equal(['token_1', 'token_2', 'token_3']);
  });

  it('should merge 2 channel same integration', async () => {
    const duplicatedSubscriberId = '123';
    const firstEnvironmentId = session.environment._id;

    const subscriber1: ISubscriber = {
      email: 'email_1',
      subscriberId: duplicatedSubscriberId,
      firstName: 'first_name_1',
      lastName: 'last_name_1',
      channels: [
        {
          _integrationId: '1',
          providerId: ChatProviderIdEnum.Slack,
          credentials: { webhookUrl: 'old_url_1' },
        },
      ],
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
      deleted: false,
      createdAt: '2021-01-01T00:00:00.000Z',
      updatedAt: '2021-01-01T00:00:00.000Z',
    };
    const firstCreatedSubscriber = await subscriberRepository.create(subscriber1);

    const subscriber2: ISubscriber = {
      email: 'email_1',
      subscriberId: duplicatedSubscriberId,
      firstName: 'first_name_1',
      lastName: 'last_name_1',
      channels: [
        {
          _integrationId: '1',
          providerId: ChatProviderIdEnum.Slack,
          credentials: { webhookUrl: 'new_url_1' },
        },
      ],
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
      deleted: false,
      createdAt: '2021-01-01T00:00:00.000Z',
      updatedAt: '2021-01-01T00:00:00.000Z',
    };
    await subscriberRepository.create(subscriber2);

    await removeDuplicatedSubscribers();

    const remainingDuplicates = await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: session.environment._id,
    });
    expect(remainingDuplicates.length).to.equal(1);
    expect(remainingDuplicates[0]._id).to.equal(firstCreatedSubscriber._id);
    expect(remainingDuplicates[0]._organizationId).to.equal(firstCreatedSubscriber._organizationId);
    expect(remainingDuplicates[0]._environmentId).to.equal(firstCreatedSubscriber._environmentId);
    expect(remainingDuplicates[0].email).to.equal('email_1');
    expect(remainingDuplicates[0].firstName).to.equal('first_name_1');
    expect(remainingDuplicates[0].lastName).to.equal('last_name_1');
    expect(remainingDuplicates[0].createdAt).to.equal('2021-01-01T00:00:00.000Z');

    const firstChannel: IChannelSettings | undefined = remainingDuplicates[0].channels?.find(
      (channel) => channel._integrationId === '1'
    );
    expect(firstChannel?._integrationId).to.equal('1');
    expect(firstChannel?.providerId).to.equal(ChatProviderIdEnum.Slack);
    expect(firstChannel?.credentials.webhookUrl).to.be.equal('new_url_1');
  });

  it('should keep the first created subscriber after merge', async () => {
    const duplicatedSubscriberId = '123';
    const firstEnvironmentId = session.environment._id;

    const firstCreatedSubscriber = await subscriberRepository.create({
      subscriberId: duplicatedSubscriberId,
      firstName: 'first_name',
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
    });
    await subscriberRepository.create({
      subscriberId: duplicatedSubscriberId,
      firstName: 'first_name_2',
      _environmentId: firstEnvironmentId,
      _organizationId: session.organization._id,
    });

    const duplicates = await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: session.environment._id,
    });
    expect(duplicates.length).to.equal(2);

    await removeDuplicatedSubscribers();

    const remainingDuplicates = await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: session.environment._id,
    });

    expect(remainingDuplicates.length).to.equal(1);
    expect(remainingDuplicates[0]._id).to.equal(firstCreatedSubscriber._id);
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberRepository(new SubscriberRepository();

  beforeEach(async ())
 - subscriberService(new SubscribersService(session.organization._id, session.environment._id);
  });

  it('should remov...)
 - remainingDuplicates(await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: ...)
 - remainingDuplicates2(await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: ...)
 - remainingDuplicates(await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: ...)
 - remainingDuplicates(await subscriberRepository.find({
      subscriberId: duplicatedSubscriberId,
      _environmentId: ...)
 - undefined(remainingDuplicates[0].channels?.find(
      (channel))
 - undefined(remainingDuplicates[0].channels?.find(
      (channel))
 - undefined(remainingDuplicates[0].channels?.find(
      (channel))
 - undefined(remainingDuplicates[0].channels?.find(
      (channel))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/subscribers/remove-duplicated-subscribers/remove-duplicated-subscribers.migration.ts
Tamao: 5614 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import '../../../src/config';
import { NestFactory } from '@nestjs/core';
import { SubscriberRepository } from '@novu/dal';
import { IChannelSettings, ISubscriber } from '@novu/shared';
import { AppModule } from '../../../src/app.module';

export async function removeDuplicatedSubscribers() {
  console.log('start migration - remove duplicated subscribers');

  const app = await NestFactory.create(AppModule, {
    logger: false,
  });

  const batchSize = 1000;
  const subscriberRepository = app.get(SubscriberRepository);

  const pipeline = [
    // Group by subscriberId and _environmentId
    {
      $group: {
        _id: { subscriberId: '$subscriberId', environmentId: '$_environmentId' },
        count: { $sum: 1 },
        subscribers: { $push: '$$ROOT' }, // Store all documents of each group
      },
    },
    // Filter groups having more than one document (duplicates)
    {
      $match: {
        count: { $gt: 1 },
      },
    },
  ];

  const cursor = await subscriberRepository._model.aggregate(pipeline, {
    batchSize: batchSize,
    readPreference: 'secondaryPreferred',
    allowDiskUse: true,
  });

  for (const group of cursor) {
    const { subscriberId, environmentId } = group._id;
    const subscribers = group.subscribers;

    if (subscribers.length <= 1) {
      continue;
    }

    // sort oldest subscriber first
    const sortedSubscribers = subscribers.sort((a, b) => a.updatedAt - b.updatedAt);
    const mergedSubscriber = mergeSubscribers(sortedSubscribers);
    const subscribersToRemove = sortedSubscribers.filter((subscriber) => subscriber._id !== mergedSubscriber._id);

    console.log(
      'Merged subscriber:',
      mergedSubscriber._id.toString(),
      'subscriberId:',
      subscriberId,
      'environmentId:',
      environmentId.toString()
    );

    try {
      await subscriberRepository.update(
        {
          _id: mergedSubscriber._id,
          subscriberId: subscriberId,
          _environmentId: environmentId,
        },
        {
          $set: mergedSubscriber,
        }
      );

      console.log(
        'Remaining subscriber updated with merged data for subscriberId:',
        subscriberId,
        'subscriberId:',
        mergedSubscriber._id.toString(),
        'environmentId:',
        environmentId.toString()
      );
    } catch (err) {
      console.error('Error updating remaining subscribers:', err);
    }

    try {
      // Delete all duplicates except the merged one
      await subscriberRepository.deleteMany({
        _id: { $in: subscribersToRemove.map((subscriber) => subscriber._id) },
        subscriberId: subscriberId,
        _environmentId: environmentId,
      });
      console.log(
        'Duplicates deleted for subscriberId:',
        subscriberId,
        'environmentId:',
        environmentId.toString(),
        'ids:',
        subscribersToRemove.map((subscriber) => subscriber._id).join()
      );
    } catch (err) {
      console.error('Error deleting duplicates:', err);
    }
  }

  console.log('end migration - remove duplicated subscribers');

  app.close();
}

// Function to merge subscriber information
function mergeSubscribers(subscribers) {
  const mergedSubscriber = { ...subscribers[0] }; // Start with the first subscriber

  // Initialize a map to store merged channels
  const mergedChannelsMap = new Map();

  // Merge information from other subscribers
  for (const subscriber of subscribers) {
    const currentSubscriber = subscriber;
    for (const key in currentSubscriber) {
      // Skip internal and irrelevant fields
      if (
        [
          '_id',
          '_organizationId',
          '_environmentId',
          'deleted',
          'createdAt',
          'updatedAt',
          '__v',
          'isOnline',
          'lastOnlineAt',
        ].includes(key)
      ) {
        continue;
      }

      // Update with non-null/undefined values from subsequent subscribers
      if (currentSubscriber[key] !== null && currentSubscriber[key] !== undefined) {
        if (key === 'channels') {
          mergeSubscriberChannels(currentSubscriber, mergedChannelsMap);
        } else {
          // For other keys, update directly
          mergedSubscriber[key] = currentSubscriber[key];
        }
      }
    }
  }

  // Convert merged channels map back to array
  mergedSubscriber.channels = [...mergedChannelsMap.values()];

  return mergedSubscriber;
}

function mergeChannels(existingChannel: IChannelSettings, newChannel: IChannelSettings) {
  const result = { ...existingChannel };

  // Merge deviceTokens
  const allTokens = [
    ...(existingChannel?.credentials?.deviceTokens || []),
    ...(newChannel?.credentials?.deviceTokens || []),
  ];
  result.credentials.deviceTokens = [...new Set(allTokens)];

  if (newChannel.credentials.webhookUrl) {
    existingChannel.credentials.webhookUrl = newChannel.credentials.webhookUrl;
  }

  return existingChannel;
}

function mergeSubscriberChannels(subscriber: ISubscriber, mergedChannelsMap) {
  for (const channel of subscriber.channels || []) {
    const integrationId = channel._integrationId;
    if (!mergedChannelsMap.has(integrationId)) {
      // merging the same channel as a workaround just to make sure we always remove token duplications
      mergedChannelsMap.set(integrationId, mergeChannels(channel, channel));
    } else {
      // If the integration ID exists, merge device tokens
      const existingChannel = mergedChannelsMap.get(integrationId);
      mergedChannelsMap.set(integrationId, mergeChannels(existingChannel, channel));
    }
  }
}

removeDuplicatedSubscribers();


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - removeDuplicatedSubscribers()
 - mergeSubscribers(subscribers)
 - mergeChannels(existingChannel: IChannelSettings, newChannel: IChannelSettings)
 - mergeSubscriberChannels(subscriber: ISubscriber, mergedChannelsMap)
Asignaciones con arrow functions encontradas (posibles funciones):
 - sortedSubscribers(subscribers.sort((a, b))
 - subscribersToRemove(sortedSubscribers.filter((subscriber))
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/topic-subscriber-normalize/topic-subscriber-normalize.migration.spec.ts
Tamao: 4499 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SubscriberEntity, SubscriberRepository, TopicSubscribersRepository } from '@novu/dal';
import { ExternalSubscriberId, TopicId, TopicKey, TopicName } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { beforeEach } from 'mocha';

import { topicSubscriberNormalize } from './topic-subscriber-normalize.migration';

const axiosInstance = axios.create();
const TOPIC_PATH = '/v1/topics';

describe('Remove all the stale topic subscriber relations', () => {
  let session: UserSession;
  let subscriberService: SubscribersService;
  const subscriberRepository = new SubscriberRepository();
  const topicSubscribersRepository = new TopicSubscribersRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
  });

  it('should remove topic subscriber relation record on removed subscribers', async () => {
    const subscriberId = '123';
    const createdSubscriber = await subscriberService.createSubscriber({ subscriberId: subscriberId });
    const firstTopicKey = `topic-key-1-trigger-event`;
    const firstTopicName = `topic-name-1-trigger-event`;
    const newTopic = await createTopic(session, firstTopicKey, firstTopicName);
    await addSubscribersToTopic(session, { _id: newTopic._id, key: newTopic.key }, [createdSubscriber]);

    // create subscriber and its relation to topic
    const subscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);
    const topicSubscriber = await topicSubscribersRepository.findOne({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      externalSubscriberId: subscriberId,
    });

    if (!subscriber) {
      expect(subscriber).to.be.ok;
      throw new Error('Subscriber not found');
    }
    if (!topicSubscriber) {
      expect(topicSubscriber).to.be.ok;
      throw new Error('topicSubscriber not found');
    }

    expect(subscriber.subscriberId).to.be.equal(subscriberId);
    expect(topicSubscriber.externalSubscriberId).to.be.equal(subscriberId);
    // END - create subscriber and its relation to topic

    await subscriberRepository.delete({
      _environmentId: subscriber._environmentId,
      _organizationId: subscriber._organizationId,
      subscriberId: subscriber.subscriberId,
    });

    const subscriberAfterDeletion = await subscriberRepository.findBySubscriberId(
      session.environment._id,
      subscriberId
    );
    const topicSubscriberAfterDeletion = await topicSubscribersRepository.findOne({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      externalSubscriberId: subscriberId,
    });

    expect(subscriberAfterDeletion).to.not.be.ok;
    expect(topicSubscriberAfterDeletion).to.be.ok;

    await topicSubscriberNormalize();

    const topicSubscriberAfterMigration = await topicSubscribersRepository.findOne({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      externalSubscriberId: subscriberId,
    });

    expect(topicSubscriberAfterMigration).to.not.be.ok;
  });
});

const createTopic = async (
  session: UserSession,
  key: TopicKey,
  name: TopicName
): Promise<{ _id: TopicId; key: TopicKey }> => {
  const response = await axiosInstance.post(
    `${session.serverUrl}${TOPIC_PATH}`,
    {
      key,
      name,
    },
    {
      headers: {
        authorization: `ApiKey ${session.apiKey}`,
      },
    }
  );

  expect(response.status).to.eql(201);
  const body = response.data;
  expect(body.data._id).to.exist;
  expect(body.data.key).to.eql(key);

  return body.data;
};

const addSubscribersToTopic = async (
  session: UserSession,
  createdTopicDto: { _id: TopicId; key: TopicKey },
  subscribers: SubscriberEntity[]
) => {
  const subscriberIds: ExternalSubscriberId[] = subscribers.map(
    (subscriber: SubscriberEntity) => subscriber.subscriberId
  );

  const response = await axiosInstance.post(
    `${session.serverUrl}${TOPIC_PATH}/${createdTopicDto.key}/subscribers`,
    {
      subscribers: subscriberIds,
    },
    {
      headers: {
        authorization: `ApiKey ${session.apiKey}`,
      },
    }
  );

  expect(response.status).to.be.eq(200);
  expect(response.data.data).to.be.eql({
    succeeded: subscriberIds,
  });
};


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - TOPIC_PATH('/v1/topics';

describe('Remove all the stale topic subscriber relations', ())
 - topicSubscribersRepository(new TopicSubscribersRepository();

  beforeEach(async ())
 - subscriberService(new SubscribersService(session.organization._id, session.environment._id);
  });

  it('should remov...)
 - createTopic(async (
  session: UserSession,
  key: TopicKey,
  name: TopicName
): Promise<{ _id: TopicId; key: T...)
 - addSubscribersToTopic(async (
  session: UserSession,
  createdTopicDto: { _id: TopicId; key: TopicKey },
  subscribers: S...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/migrations/topic-subscriber-normalize/topic-subscriber-normalize.migration.ts
Tamao: 1529 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import '../../src/config';

import { NestFactory } from '@nestjs/core';
import { SubscriberRepository, TopicSubscribersRepository } from '@novu/dal';

import { AppModule } from '../../src/app.module';

/*
 * topic subscriber normalize - will remove deleted subscribers from topic subscribers
 */
export async function topicSubscriberNormalize() {
  console.log('start migration - topic subscriber normalize - will remove deleted subscribers from topic subscribers');

  const app = await NestFactory.create(AppModule, {
    logger: false,
  });
  const topicSubscribersRepository = app.get(TopicSubscribersRepository);
  const subscriberRepository = app.get(SubscriberRepository);

  const cursor = await topicSubscribersRepository._model
    .find({} as any)
    .batchSize(1000)
    .cursor();

  for await (const topicSubscriber of cursor) {
    const subscriber = await subscriberRepository.findBySubscriberId(
      topicSubscriber._environmentId.toString(),
      topicSubscriber.externalSubscriberId
    );

    if (!subscriber) {
      console.log(
        `remove relation topic subscriber ${topicSubscriber.externalSubscriberId} from topic ${topicSubscriber._topicId}`
      );

      await topicSubscribersRepository.delete({
        _environmentId: topicSubscriber._environmentId.toString(),
        _organizationId: topicSubscriber._organizationId,
        externalSubscriberId: topicSubscriber.externalSubscriberId,
      });
    }
  }

  console.log('end migration- topic subscriber normalize');

  app.close();
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - topicSubscriberNormalize()
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/scripts/generate-metadata.ts
Tamao: 1284 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/**
 * This file is responsible for generating Nest.js metadata for the API.
 * Metadata generation is required when using SWC with Nest.js due to SWC
 * not natively supporting Typescript, which is required to use the `reflect-metadata`
 * API and in turn, resolve types for the OpenAPI specification.
 *
 * @see https://docs.nestjs.com/recipes/swc#monorepo-and-cli-plugins
 */
import fs from 'node:fs';
import path from 'node:path';
import { PluginMetadataGenerator } from '@nestjs/cli/lib/compiler/plugins';
import { ReadonlyVisitor } from '@nestjs/swagger/dist/plugin';

const tsconfigPath = 'tsconfig.build.json';
const srcPath = path.join(__dirname, '..', 'src');
const metadataPath = path.join(srcPath, 'metadata.ts');

/*
 * We create an empty metadata file to ensure that files importing `metadata.ts`
 * will compile successfully before the metadata generation occurs.
 */
const defaultContent = `export default async () => { return {}; };`;

fs.writeFileSync(metadataPath, defaultContent, 'utf8');
console.log('metadata.ts file has been generated with default content.');

const generator = new PluginMetadataGenerator();
generator.generate({
  visitors: [new ReadonlyVisitor({ introspectComments: true, pathToSource: srcPath })],
  outputDir: srcPath,
  tsconfigPath,
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - defaultContent(`export default async ())
Declaraciones 'export' encontradas:
- export default  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/.env.development
Tamao: 2418 bytes
Lenguaje detectado: DEVELOPMENT

### CONTENIDO ORIGINAL ###

NODE_ENV=dev
PORT=3000
API_ROOT_URL=https://api.novu-staging.co
FRONT_BASE_URL=https://dashboard.novu-staging.co
GLOBAL_CONTEXT_PATH=
API_CONTEXT_PATH=
DISABLE_USER_REGISTRATION=false

CLIENT_SUCCESS_AUTH_REDIRECT=https://dashboard.novu-staging.co/auth/login

REDIS_PORT=6379
REDIS_HOST=localhost
REDIS_PREFIX=
REDIS_DB_INDEX=2

REDIS_CACHE_SERVICE_HOST=localhost
REDIS_CACHE_SERVICE_PORT=6379
REDIS_CACHE_DB_INDEX=
REDIS_CACHE_TTL=
REDIS_CACHE_PASSWORD=
REDIS_CACHE_CONNECTION_TIMEOUT=
REDIS_CACHE_KEEP_ALIVE=
REDIS_CACHE_FAMILY=
REDIS_CACHE_KEY_PREFIX=
REDIS_CACHE_ENABLE_AUTOPIPELINING=true

IS_IN_MEMORY_CLUSTER_MODE_ENABLED=false
ELASTICACHE_CLUSTER_SERVICE_HOST=
ELASTICACHE_CLUSTER_SERVICE_PORT=
REDIS_CLUSTER_SERVICE_HOST=localhost
REDIS_CLUSTER_SERVICE_PORTS=[7000,7001,7002,7003,7004,7005]
REDIS_CLUSTER_DB_INDEX=
REDIS_CLUSTER_TTL=
REDIS_CLUSTER_PASSWORD=
REDIS_CLUSTER_CONNECTION_TIMEOUT=
REDIS_CLUSTER_KEEP_ALIVE=
REDIS_CLUSTER_FAMILY=
REDIS_CLUSTER_KEY_PREFIX=

NEW_RELIC_ENABLED=true
NEW_RELIC_APP_NAME="[DEV] - api"
NEW_RELIC_APPLICATION_LOGGING_FORWARDING_ENABLED=true
LOG_LEVEL=info

VERCEL_REDIRECT_URI=https://dashboard.novu-staging.co/auth/login
VERCEL_BASE_URL=https://api.vercel.com

MAIL_SERVER_DOMAIN=

MAX_NOVU_INTEGRATION_MAIL_REQUESTS=300
NOVU_EMAIL_INTEGRATION_API_KEY=

MAX_NOVU_INTEGRATION_SMS_REQUESTS=20
NOVU_SMS_INTEGRATION_ACCOUNT_SID=
NOVU_SMS_INTEGRATION_TOKEN=
NOVU_SMS_INTEGRATION_SENDER=

NOVU_SLACK_INTEGRATION_CLIENT_ID=
NOVU_SLACK_INTEGRATION_CLIENT_SECRET=

INTERCOM_IDENTITY_VERIFICATION_SECRET_KEY=

LAUNCH_DARKLY_SDK_KEY=

IS_API_IDEMPOTENCY_ENABLED=false
MONGO_AUTO_CREATE_INDEXES=true

IS_API_RATE_LIMITING_ENABLED=false
API_RATE_LIMIT_COST_SINGLE=
API_RATE_LIMIT_COST_BULK=
API_RATE_LIMIT_ALGORITHM_BURST_ALLOWANCE=
API_RATE_LIMIT_ALGORITHM_WINDOW_DURATION=
API_RATE_LIMIT_MAXIMUM_BUSINESS_TRIGGER=
API_RATE_LIMIT_MAXIMUM_BUSINESS_CONFIGURATION=
API_RATE_LIMIT_MAXIMUM_BUSINESS_GLOBAL=
API_RATE_LIMIT_MAXIMUM_FREE_TRIGGER=
API_RATE_LIMIT_MAXIMUM_FREE_CONFIGURATION=
API_RATE_LIMIT_MAXIMUM_FREE_GLOBAL=
API_RATE_LIMIT_MAXIMUM_UNLIMITED_TRIGGER=
API_RATE_LIMIT_MAXIMUM_UNLIMITED_CONFIGURATION=
API_RATE_LIMIT_MAXIMUM_UNLIMITED_GLOBAL=

HUBSPOT_INVITE_NUDGE_EMAIL_USER_LIST_ID=
HUBSPOT_PRIVATE_APP_ACCESS_TOKEN=

CLERK_ISSUER_URL=
CLERK_WEBHOOK_SECRET=
PLAIN_SUPPORT_KEY='PLAIN_SUPPORT_KEY'
PLAIN_IDENTITY_VERIFICATION_SECRET_KEY='PLAIN_IDENTITY_VERIFICATION_SECRET_KEY'


### ANALISIS AUTOMATICO (ESPAOL) ###

NODE_ENV=dev
PORT=3000
API_ROOT_URL=https://api.novu-staging.co
FRONT_BASE_URL=https://dashboard.novu-staging.co
GLOBAL_CONTEXT_PATH=
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Aade un README describiendo qu hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/apps/api/src/.env.production
Tamao: 2128 bytes
Lenguaje detectado: PRODUCTION

### CONTENIDO ORIGINAL ###

NODE_ENV=production
PORT=3000
API_ROOT_URL=https://api.novu.co
FRONT_BASE_URL=https://dashboard.novu.co
GLOBAL_CONTEXT_PATH=
API_CONTEXT_PATH=
DISABLE_USER_REGISTRATION=false

WIDGET_BASE_URL=https://widget.novu.co

REDIS_PORT=6379
REDIS_PREFIX=
REDIS_DB_INDEX=2

IS_IN_MEMORY_CLUSTER_MODE_ENABLED=false
ELASTICACHE_CLUSTER_SERVICE_HOST=
ELASTICACHE_CLUSTER_SERVICE_PORT=
REDIS_CLUSTER_SERVICE_HOST=
REDIS_CLUSTER_SERVICE_PORT=
REDIS_CLUSTER_DB_INDEX=
REDIS_CLUSTER_TTL=
REDIS_CLUSTER_PASSWORD=
REDIS_CLUSTER_CONNECTION_TIMEOUT=
REDIS_CLUSTER_KEEP_ALIVE=
REDIS_CLUSTER_FAMILY=
REDIS_CLUSTER_KEY_PREFIX=

NEW_RELIC_ENABLED=true
NEW_RELIC_APPLICATION_LOGGING_FORWARDING_ENABLED=true
LOG_LEVEL=info

VERCEL_REDIRECT_URI=https://dashboard.novu.co/auth/login
VERCEL_BASE_URL=https://api.vercel.com

MAIL_SERVER_DOMAIN=

MAX_NOVU_INTEGRATION_MAIL_REQUESTS=300
NOVU_EMAIL_INTEGRATION_API_KEY=

MONGO_MIN_POOL_SIZE=50

MAX_NOVU_INTEGRATION_SMS_REQUESTS=20
NOVU_SMS_INTEGRATION_ACCOUNT_SID=
NOVU_SMS_INTEGRATION_TOKEN=
NOVU_SMS_INTEGRATION_SENDER=

NOVU_SLACK_INTEGRATION_CLIENT_ID=
NOVU_SLACK_INTEGRATION_CLIENT_SECRET=

INTERCOM_IDENTITY_VERIFICATION_SECRET_KEY=

LAUNCH_DARKLY_SDK_KEY=

IS_API_IDEMPOTENCY_ENABLED=false
## This value should be set to true if it is the first time you are running the with the database
MONGO_AUTO_CREATE_INDEXES=false

IS_API_RATE_LIMITING_ENABLED=false
API_RATE_LIMIT_COST_SINGLE=
API_RATE_LIMIT_COST_BULK=
API_RATE_LIMIT_ALGORITHM_BURST_ALLOWANCE=
API_RATE_LIMIT_ALGORITHM_WINDOW_DURATION=
API_RATE_LIMIT_MAXIMUM_BUSINESS_TRIGGER=
API_RATE_LIMIT_MAXIMUM_BUSINESS_CONFIGURATION=
API_RATE_LIMIT_MAXIMUM_BUSINESS_GLOBAL=
API_RATE_LIMIT_MAXIMUM_FREE_TRIGGER=
API_RATE_LIMIT_MAXIMUM_FREE_CONFIGURATION=
API_RATE_LIMIT_MAXIMUM_FREE_GLOBAL=
API_RATE_LIMIT_MAXIMUM_UNLIMITED_TRIGGER=
API_RATE_LIMIT_MAXIMUM_UNLIMITED_CONFIGURATION=
API_RATE_LIMIT_MAXIMUM_UNLIMITED_GLOBAL=

HUBSPOT_INVITE_NUDGE_EMAIL_USER_LIST_ID=
HUBSPOT_PRIVATE_APP_ACCESS_TOKEN=

CLERK_ISSUER_URL=
CLERK_WEBHOOK_SECRET=
PLAIN_SUPPORT_KEY='PLAIN_SUPPORT_KEY'
PLAIN_IDENTITY_VERIFICATION_SECRET_KEY='PLAIN_IDENTITY_VERIFICATION_SECRET_KEY'


### ANALISIS AUTOMATICO (ESPAOL) ###

NODE_ENV=production
PORT=3000
API_ROOT_URL=https://api.novu.co
FRONT_BASE_URL=https://dashboard.novu.co
GLOBAL_CONTEXT_PATH=
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Aade un README describiendo qu hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/apps/api/src/.env.test
Tamao: 6937 bytes
Lenguaje detectado: TEST

### CONTENIDO ORIGINAL ###

STORE_ENCRYPTION_KEY="<ENCRYPTION_KEY_MUST_BE_32_LONG>"
BLUEPRINT_CREATOR=66507de8e76834a745c98f93
CLIENT_SUCCESS_AUTH_REDIRECT=http://127.0.0.1:4200/auth/login
MONGO_URL=mongodb://127.0.0.1:27017/novu-test
REDIS_PORT=6379
REDIS_HOST=localhost
REDIS_PREFIX=
REDIS_DB_INDEX=1

REDIS_CACHE_SERVICE_HOST=localhost
REDIS_CACHE_SERVICE_PORT=6379
REDIS_CACHE_DB_INDEX=
REDIS_CACHE_TTL=
REDIS_CACHE_PASSWORD=
REDIS_CACHE_CONNECTION_TIMEOUT=
REDIS_CACHE_KEEP_ALIVE=
REDIS_CACHE_FAMILY=
REDIS_CACHE_KEY_PREFIX=
REDIS_CACHE_ENABLE_AUTOPIPELINING=false
NEW_RELIC_APP_NAME=[TEST] - API
IS_IN_MEMORY_CLUSTER_MODE_ENABLED=false
ELASTICACHE_CLUSTER_SERVICE_HOST=
ELASTICACHE_CLUSTER_SERVICE_PORT=
REDIS_CLUSTER_SERVICE_HOST=localhost
REDIS_CLUSTER_SERVICE_PORTS=[7000,7001,7002,7003,7004,7005]
REDIS_CLUSTER_DB_INDEX=
REDIS_CLUSTER_TTL=
REDIS_CLUSTER_PASSWORD=
REDIS_CLUSTER_CONNECTION_TIMEOUT=
REDIS_CLUSTER_KEEP_ALIVE=
REDIS_CLUSTER_FAMILY=
REDIS_CLUSTER_KEY_PREFIX=

SYNC_PATH=http://127.0.0.1:3001
API_ROOT_URL=http://127.0.0.1:3000
DISABLE_USER_REGISTRATION=false
PORT=1336
JWT_SECRET=ASD#asda23DFEFSFHG%fg
NODE_ENV=test
SENDGRID_API_KEY=SG.123123
S3_ACCESS_KEY=
S3_SECRET=
REDIS_ARENA_PORT=4568
FRONT_BASE_URL='^https?://([a-zA-Z-_0-9]+.)?(dashboard(-v[0-9]+)?.novu(-staging)?.co)$'
RELEASLY_MAIL=support@starter.co
BACK_OFFICE_URL=http://127.0.0.1:5200
INTERCOM_API_KEY=
GLOBAL_CONTEXT_PATH=
API_CONTEXT_PATH=

S3_LOCAL_STACK=http://127.0.0.1:4566
S3_BUCKET_NAME=novu-test
S3_REGION=us-east-1
GCS_BUCKET_NAME=novu-test
AZURE_ACCOUNT_NAME=novu
AZURE_ACCOUNT_KEY=123456
AZURE_HOST_NAME=https://novu.blob.core.windows.net
AZURE_CONTAINER_NAME=novu-test
AWS_ACCESS_KEY_ID=test
AWS_SECRET_ACCESS_KEY=test
NEW_RELIC_ENABLED=false
NOVU_API_KEY=test

MAIL_SERVER_DOMAIN=

VERCEL_CLIENT_ID=
VERCEL_CLIENT_SECRET=
VERCEL_REDIRECT_URI=http://127.0.0.1:4200/auth/login
VERCEL_BASE_URL=https://api.vercel.com

STORE_NOTIFICATION_CONTENT=true

MAX_NOVU_INTEGRATION_MAIL_REQUESTS=300
INTERCOM_IDENTITY_VERIFICATION_SECRET_KEY=
NOVU_EMAIL_INTEGRATION_API_KEY=test

LOG_LEVEL=error

LAUNCH_DARKLY_SDK_KEY=

MAX_NOVU_INTEGRATION_SMS_REQUESTS=20
NOVU_SMS_INTEGRATION_ACCOUNT_SID=test
NOVU_SMS_INTEGRATION_TOKEN=test
NOVU_SMS_INTEGRATION_SENDER=1234567890

NOVU_SLACK_INTEGRATION_CLIENT_ID=
NOVU_SLACK_INTEGRATION_CLIENT_SECRET=

IS_API_IDEMPOTENCY_ENABLED=true
MONGO_AUTO_CREATE_INDEXES=true

IS_API_RATE_LIMITING_ENABLED=false
API_RATE_LIMIT_COST_SINGLE=
API_RATE_LIMIT_COST_BULK=
API_RATE_LIMIT_ALGORITHM_BURST_ALLOWANCE=
API_RATE_LIMIT_ALGORITHM_WINDOW_DURATION=
API_RATE_LIMIT_MAXIMUM_BUSINESS_TRIGGER=
API_RATE_LIMIT_MAXIMUM_BUSINESS_CONFIGURATION=
API_RATE_LIMIT_MAXIMUM_BUSINESS_GLOBAL=
API_RATE_LIMIT_MAXIMUM_FREE_TRIGGER=
API_RATE_LIMIT_MAXIMUM_FREE_CONFIGURATION=
API_RATE_LIMIT_MAXIMUM_FREE_GLOBAL=
API_RATE_LIMIT_MAXIMUM_UNLIMITED_TRIGGER=
API_RATE_LIMIT_MAXIMUM_UNLIMITED_CONFIGURATION=
API_RATE_LIMIT_MAXIMUM_UNLIMITED_GLOBAL=
IS_USE_MERGED_DIGEST_ID_ENABLED=true

HUBSPOT_INVITE_NUDGE_EMAIL_USER_LIST_ID=
HUBSPOT_PRIVATE_APP_ACCESS_TOKEN=

CLERK_ISSUER_URL=
CLERK_LONG_LIVED_TOKEN=eyJhbGciOiJSUzI1NiIsImNhdCI6ImNsX0I3ZDRQRDIyMkFBQSIsInR5cCI6IkpXVCJ9.eyJfaWQiOiJ1c2VyXzJqeTRBOUNvandYcnNNaHlHVmxPYkNNNldITiIsImF6cCI6Imh0dHBzOi8vZmlyc3QtYmFib29uLTUwLmFjY291bnRzLmRldiIsImVtYWlsIjoic29rcmF0aXMudmlkcm9zQGdtYWlsLmNvbSIsImVudmlyb25tZW50SWQiOm51bGwsImV4cCI6MTg4NTgyOTU0MCwiZXh0ZXJuYWxJZCI6IjY2YThlOTg0YjhhNjcyZDllZWYxMThiZiIsImV4dGVybmFsT3JnSWQiOm51bGwsImZpcnN0TmFtZSI6IlNva3JhdGlzIiwiaWF0IjoxNzI4MDQ0NzgwLCJpc3MiOiJodHRwczovL2ZpcnN0LWJhYm9vbi01MC5jbGVyay5hY2NvdW50cy5kZXYiLCJqdGkiOiI0MTc1N2UxMjEzNDZlYTdlMmRkOSIsImxhc3ROYW1lIjoiVmlkcm9zIiwibmJmIjoxNzI4MDQ0Nzc1LCJvcmdfcm9sZSI6Im9yZzphZG1pbiIsInByb2ZpbGVQaWN0dXJlIjoiaHR0cHM6Ly9pbWcuY2xlcmsuY29tL2V5SjBlWEJsSWpvaWNISnZlSGtpTENKemNtTWlPaUpvZEhSd2N6b3ZMMmx0WVdkbGN5NWpiR1Z5YXk1a1pYWXZiMkYxZEdoZloybDBhSFZpTDJsdFoxOHlhbmswUVVSS1RIWkJiVVpST1VoeWNqSm5lVFp5TWt0d1RVY2lmUSIsInN1YiI6InVzZXJfMmp5NEE5Q29qd1hyc01oeUdWbE9iQ002V0hOIn0.QtsA2vG5kN9NC8kPmzGi2ZUxGU9Y-aEoSPK0GIGuIhhSwkKMj0Bt7mhgH4Z5JFpumj0J6SiTyQ1XZVTz5x_WE4qUSGHeXOQupc-eOvcO2r0tm8g-BKevBBJ1S_d8XbbFPrNQKCcARbpQlZIMXbFtHOhfhVw_43ZyilQ72BoYlIJysP5eR3fHAanmuG6mF5Rq9AkPAqVYNGA-DEs4sl5sZuVxa899pvDp5KObziQDOSz-l-BFAD3S_YYps4Kyo33fEvXgDL_wa08W7A6_bbQwCddvvGHcw-inZ6DXBzqcPZipdchk2Tpn1_EkFws0P5lh4dmLfDJqYfqAlZgIijrJ8A

CLERK_MOCK_JWT_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCooLFH2KgQFKBY
0IrMIMSYoYq4TrZZOxga6ywWa/IP9efQqKMyCGha9MSZWndpoETN/4ZPrDzdZ9hi
Ws7u99LJbstITBhKpnW+feAeFl2GBIhkJGT1ymHCT2fFuXFLL2SnbL+mu8ikZdnd
JupCAJ2/aBX7S9twb1i74D/jJrFGiVpSLJQczQ8uo3U0xanmBOuO6oqj+BCwIbPm
IEaoVP16mpVHnWJtGbquebauaH08AiCS2MBWjxW019njq4vasmvBAokLU6QYcGHg
jWUpGWOwEjrqcp9hNQiEkMfQuPz0Lgx8QFmXka+4cYg0zDr4v4TCin9EcA3caWy/
RDCi5rNnAgMBAAECggEAF6da1tIsWP0btPmjzph2G1blp47bA09HxVbhu09vCBAd
cWaGZdlKEiAth7lp8LYbkK3cQEbPztrnPnywdFLtDXZuK3kJG0eYUp1Dl9TZT5hJ
LYrxYoz+A4yx6Mlne/1s6BNYGuJSdcUXt27jA1kkx5mpI7PzVyU3VDtTmuBtk5As
YuXao6PQBGyaimh8MUmYoP5GZdjxbp5OfVlG8gznhy762ExJpvlAfAjsU2qMYhMK
8mlfGivsEsoJo3clMdWXsNq5Axsc8tj+U544Nco114osNfz98955BH92iiIiVyaK
NVaSfPV0gJIfAtvCMQ8aHifw9xJ2MAmf73s1Iq3dqQKBgQDdplj0o/t6EJo6JYWV
MfFd7NNvbs/iGjHz07fgG+sux1AgAq7iBCTVHHBPA2GbUGLj7dcJmzyMOC/mb30+
kibLmEQruwfgOVCspUsQqxyw6a5vhbhxStUIGYkRhpKX8Whaa79WNgGNm5+XfScn
oy37kqr6yevuOXBcf+Uuvy0IuwKBgQDCwsQf+S6aGGvlAtuJFWFxxPxOalX0giwX
oiJUId+yWXD/d7GLmOmM1081QUtWMXqd/GkRje5AkB5DHGJp4hLIG4hREMz5lw6F
dNUBpW9bF0IF0ARlCLCtqCQ6BLxd5t9je5xWEp4ZiO8GRY+al/K+7NCzCfIOsQp/
Ieeb41z7RQKBgAR8DyS0BKyNlXFDvRYtsoKB/i0tAsvCV+xlBj1kkzeZFMfxBfTQ
vKYLM0KGAP2RfM67yzQIjgsQP/fbnZ8ceeh4pjh0Sk6BGl7D4Wbu71+s+riK7hZs
uy60xY8zN9gXLFNYBsEJyrJAydPY1mf45z9F0mvMlhd11g4pEEwH1jNtAoGBAL/z
Ezbr8Nkgvp373gDSWLK3UW+7b7HG5cv5GNpQdFcjvbGa9xo9f9k2jzNOggCWTWIN
1kPd3XY2VA0SmY//p0EfmY9D/rDzBvXTOugfc4uUdZai+OHW2cKdV+7yoe/uTjaP
KnrOaJGEGwfUYP8dSLqRTfNXFwERzeWUtd83C3n9AoGBANPfxc11gBm7e+/TkbBS
6igcylNg3GE7EcsPYPmIbu3fSAsDMlisBwV/oZVDXPVpnyBPV+3QAWKlwQPQ6zia
iqf/Ts8OTFQEAIMCtaokNbNKdof+yO2uECvDKz/lAYTrvVe+DRiQMkFXcGOdKHoK
0toWx5mpGfmyeqoDQDiUKHSS
-----END PRIVATE KEY-----"
CLERK_MOCK_JWT_PUBLIC_KEY="-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqKCxR9ioEBSgWNCKzCDE
mKGKuE62WTsYGussFmvyD/Xn0KijMghoWvTEmVp3aaBEzf+GT6w83WfYYlrO7vfS
yW7LSEwYSqZ1vn3gHhZdhgSIZCRk9cphwk9nxblxSy9kp2y/prvIpGXZ3SbqQgCd
v2gV+0vbcG9Yu+A/4yaxRolaUiyUHM0PLqN1NMWp5gTrjuqKo/gQsCGz5iBGqFT9
epqVR51ibRm6rnm2rmh9PAIgktjAVo8VtNfZ46uL2rJrwQKJC1OkGHBh4I1lKRlj
sBI66nKfYTUIhJDH0Lj89C4MfEBZl5GvuHGINMw6+L+Ewop/RHAN3Glsv0Qwouaz
ZwIDAQAB
-----END PUBLIC KEY-----"

TUNNEL_BASE_ADDRESS=example.com
API_ROOT_URL=http://localhost:1336
PLAIN_SUPPORT_KEY='PLAIN_SUPPORT_KEY'
PLAIN_IDENTITY_VERIFICATION_SECRET_KEY='PLAIN_IDENTITY_VERIFICATION_SECRET_KEY'
NOVU_INTERNAL_SECRET_KEY=test
KEYLESS_ORGANIZATION_ID=67b89421f8bd757ea40f39ab
KEYLESS_USER_EMAIL=67b89421f8bd757ea40f39ab


CLICK_HOUSE_URL=http://localhost:8123
CLICK_HOUSE_USER=default
CLICK_HOUSE_PASSWORD=
CLICK_HOUSE_DATABASE=test_logs


### ANALISIS AUTOMATICO (ESPAOL) ###

STORE_ENCRYPTION_KEY="<ENCRYPTION_KEY_MUST_BE_32_LONG>"
BLUEPRINT_CREATOR=66507de8e76834a745c98f93
CLIENT_SUCCESS_AUTH_REDIRECT=http://127.0.0.1:4200/auth/login
MONGO_URL=mongodb://127.0.0.1:27017/novu-test
REDIS_PORT=6379
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Aade un README describiendo qu hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/apps/api/src/.example.env
Tamao: 2683 bytes
Lenguaje detectado: ENV

### CONTENIDO ORIGINAL ###

NODE_ENV=local
PORT=3000
API_ROOT_URL=http://127.0.0.1:3000
# URL for the Self-Hosted or the URL regexp for the Novu Dashboard
FRONT_BASE_URL=http://127.0.0.1:4200
STORE_ENCRYPTION_KEY="<ENCRYPTION_KEY_MUST_BE_32_LONG>"
DISABLE_USER_REGISTRATION=false

MONGO_URL=mongodb://127.0.0.1:27017/novu-db
MONGO_MAX_POOL_SIZE=500
REDIS_PORT=6379
REDIS_PREFIX=
REDIS_HOST=localhost
REDIS_DB_INDEX=2

REDIS_CACHE_SERVICE_HOST=
REDIS_CACHE_SERVICE_PORT=6379
REDIS_CACHE_DB_INDEX=
REDIS_CACHE_TTL=
REDIS_CACHE_PASSWORD=
REDIS_CACHE_CONNECTION_TIMEOUT=
REDIS_CACHE_KEEP_ALIVE=
REDIS_CACHE_FAMILY=
REDIS_CACHE_KEY_PREFIX=
REDIS_CACHE_ENABLE_AUTOPIPELINING=

IS_IN_MEMORY_CLUSTER_MODE_ENABLED=false
REDIS_CLUSTER_SERVICE_HOST=
REDIS_CLUSTER_SERVICE_PORT=
REDIS_CLUSTER_DB_INDEX=
REDIS_CLUSTER_TTL=
REDIS_CLUSTER_PASSWORD=
REDIS_CLUSTER_CONNECTION_TIMEOUT=
REDIS_CLUSTER_KEEP_ALIVE=
REDIS_CLUSTER_FAMILY=
REDIS_CLUSTER_KEY_PREFIX=


JWT_SECRET=LOCAL_ONLY_CHANGE_ME

S3_LOCAL_STACK=http://127.0.0.1:4566
S3_BUCKET_NAME=novu-local
S3_REGION=us-east-1
AWS_ACCESS_KEY_ID=test
AWS_SECRET_ACCESS_KEY=test
NEW_RELIC_ENABLED=false
CDN_URL=

MAIL_SERVER_DOMAIN=

GLOBAL_CONTEXT_PATH=
API_CONTEXT_PATH=
VERCEL_CLIENT_ID=
VERCEL_CLIENT_SECRET=
VERCEL_REDIRECT_URI=http://127.0.0.1:4200/auth/login
VERCEL_BASE_URL=https://api.vercel.com

STORE_NOTIFICATION_CONTENT=true

INTERCOM_IDENTITY_VERIFICATION_SECRET_KEY=
LOG_LEVEL=info

LAUNCH_DARKLY_SDK_KEY=

IS_API_RATE_LIMITING_ENABLED=false
API_RATE_LIMIT_COST_SINGLE=
API_RATE_LIMIT_COST_BULK=
API_RATE_LIMIT_ALGORITHM_BURST_ALLOWANCE=
API_RATE_LIMIT_ALGORITHM_WINDOW_DURATION=
API_RATE_LIMIT_MAXIMUM_BUSINESS_TRIGGER=
API_RATE_LIMIT_MAXIMUM_BUSINESS_CONFIGURATION=
API_RATE_LIMIT_MAXIMUM_BUSINESS_GLOBAL=
API_RATE_LIMIT_MAXIMUM_FREE_TRIGGER=
API_RATE_LIMIT_MAXIMUM_FREE_CONFIGURATION=
API_RATE_LIMIT_MAXIMUM_FREE_GLOBAL=
API_RATE_LIMIT_MAXIMUM_UNLIMITED_TRIGGER=
API_RATE_LIMIT_MAXIMUM_UNLIMITED_CONFIGURATION=
API_RATE_LIMIT_MAXIMUM_UNLIMITED_GLOBAL=

HUBSPOT_INVITE_NUDGE_EMAIL_USER_LIST_ID=
HUBSPOT_PRIVATE_APP_ACCESS_TOKEN=

CLERK_ISSUER_URL=
CLERK_LONG_LIVED_TOKEN=

TUNNEL_BASE_ADDRESS=
PLAIN_SUPPORT_KEY='PLAIN_SUPPORT_KEY'
PLAIN_IDENTITY_VERIFICATION_SECRET_KEY='PLAIN_IDENTITY_VERIFICATION_SECRET_KEY'
PLAIN_CARDS_HMAC_SECRET_KEY='PLAIN_CARDS_HMAC_SECRET_KEY'

NOVU_INTERNAL_SECRET_KEY=
NOVU_SECRET_KEY='NOVU_SECRET_KEY'

# expressed in seconds or a string describing a time span [zeit/ms](https://github.com/zeit/ms.js).  Eg: 60, "2 days", "10h", "7d"
SUBSCRIBER_WIDGET_JWT_EXPIRATION_TIME='15 days'

# ClickHouse connection variables
CLICK_HOUSE_URL=http://127.0.0.1:8123
CLICK_HOUSE_USER=default
CLICK_HOUSE_PASSWORD=
CLICK_HOUSE_DATABASE=novu-local


### ANALISIS AUTOMATICO (ESPAOL) ###

NODE_ENV=local
PORT=3000
API_ROOT_URL=http://127.0.0.1:3000
# URL for the Self-Hosted or the URL regexp for the Novu Dashboard
FRONT_BASE_URL=http://127.0.0.1:4200
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Aade un README describiendo qu hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/apps/api/src/app.module.ts
Tamao: 7760 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { DynamicModule, Module, Provider } from '@nestjs/common';
import { ForwardReference } from '@nestjs/common/interfaces/modules/forward-reference.interface';
import { Type } from '@nestjs/common/interfaces/type.interface';
import { APP_GUARD, APP_INTERCEPTOR } from '@nestjs/core';
import { ApiExcludeController } from '@nestjs/swagger';
import { cacheService, TracingModule } from '@novu/application-generic';
import { Client, NovuModule } from '@novu/framework/nest';
import { usageLimitsWorkflow } from '@novu/notifications';
import { isClerkEnabled } from '@novu/shared';
import { SentryModule } from '@sentry/nestjs/setup';
import packageJson from '../package.json';
import { ActivityModule } from './app/activity/activity.module';
import { AnalyticsModule } from './app/analytics/analytics.module';
import { AuthModule } from './app/auth/auth.module';
import { BlueprintModule } from './app/blueprint/blueprint.module';
import { BridgeModule } from './app/bridge/bridge.module';
import { ChangeModule } from './app/change/change.module';
import { ContentTemplatesModule } from './app/content-templates/content-templates.module';
import { ContextsModule } from './app/contexts/contexts.module';
import { EnvironmentsModuleV1 } from './app/environments-v1/environments-v1.module';
import { EnvironmentsModule } from './app/environments-v2/environments.module';
import { EventsModule } from './app/events/events.module';
import { ExecutionDetailsModule } from './app/execution-details/execution-details.module';
import { FeedsModule } from './app/feeds/feeds.module';
import { HealthModule } from './app/health/health.module';
import { InboundParseModule } from './app/inbound-parse/inbound-parse.module';
import { InboxModule } from './app/inbox/inbox.module';
import { IntegrationModule } from './app/integrations/integrations.module';
import { InternalModule } from './app/internal/internal.module';
import { InvitesModule } from './app/invites/invites.module';
import { LayoutsV1Module } from './app/layouts-v1/layouts-v1.module';
import { LayoutsV2Module } from './app/layouts-v2/layouts.module';
import { MessagesModule } from './app/messages/messages.module';
import { NotificationGroupsModule } from './app/notification-groups/notification-groups.module';
import { NotificationModule } from './app/notifications/notification.module';
import { OrganizationModule } from './app/organization/organization.module';
import { OutboundWebhooksModule } from './app/outbound-webhooks/outbound-webhooks.module';
import { PartnerIntegrationsModule } from './app/partner-integrations/partner-integrations.module';
import { PreferencesModule } from './app/preferences';
import { ApiRateLimitInterceptor } from './app/rate-limiting/guards';
import { RateLimitingModule } from './app/rate-limiting/rate-limiting.module';
import { AnalyticsLogsGuard } from './app/shared/framework/analytics-logs.guard';
import { AnalyticsLogsInterceptor } from './app/shared/framework/analytics-logs.interceptor';
import { IdempotencyInterceptor } from './app/shared/framework/idempotency.interceptor';
import { ProductFeatureInterceptor } from './app/shared/interceptors/product-feature.interceptor';
import { SharedModule } from './app/shared/shared.module';
import { StorageModule } from './app/storage/storage.module';
import { SubscribersV1Module } from './app/subscribers/subscribersV1.module';
import { SubscribersModule } from './app/subscribers-v2/subscribers.module';
import { SupportModule } from './app/support/support.module';
import { TenantModule } from './app/tenant/tenant.module';
import { TestingModule } from './app/testing/testing.module';
import { TopicsV1Module } from './app/topics-v1/topics-v1.module';
import { TopicsV2Module } from './app/topics-v2/topics-v2.module';
import { UserModule } from './app/user/user.module';
import { WidgetsModule } from './app/widgets/widgets.module';
import { WorkflowOverridesModule } from './app/workflow-overrides/workflow-overrides.module';
import { WorkflowModuleV1 } from './app/workflows-v1/workflow-v1.module';
import { WorkflowModule } from './app/workflows-v2/workflow.module';

const enterpriseImports = (): Array<Type | DynamicModule | Promise<DynamicModule> | ForwardReference> => {
  const modules: Array<Type | DynamicModule | Promise<DynamicModule> | ForwardReference> = [];
  if (process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true') {
    if (require('@novu/ee-translation')?.EnterpriseTranslationModule) {
      modules.push(require('@novu/ee-translation')?.EnterpriseTranslationModule);
      modules.push(require('@novu/ee-translation')?.TranslationModule);
    }

    if (require('@novu/ee-billing')?.BillingModule) {
      modules.push(require('@novu/ee-billing')?.BillingModule.forRoot());
    }

    if (require('@novu/ee-api')?.InboundWebhooksModule) {
      modules.push(require('@novu/ee-api')?.InboundWebhooksModule);
    }

    modules.push(SupportModule);
    modules.push(OutboundWebhooksModule.forRoot());
  }

  return modules;
};

const enterpriseQuotaThrottlerInterceptor =
  (process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true') &&
  require('@novu/ee-billing')?.QuotaThrottlerInterceptor
    ? [
        {
          provide: APP_INTERCEPTOR,
          useClass: require('@novu/ee-billing')?.QuotaThrottlerInterceptor,
        },
      ]
    : [];

const baseModules: Array<Type | DynamicModule | Promise<DynamicModule> | ForwardReference> = [
  AuthModule,
  InboundParseModule,
  SharedModule,
  HealthModule,
  EnvironmentsModuleV1,
  ExecutionDetailsModule,
  WorkflowModuleV1,
  EventsModule,
  WidgetsModule,
  InboxModule,
  NotificationModule,
  NotificationGroupsModule,
  ContentTemplatesModule,
  OrganizationModule,
  ActivityModule,
  UserModule,
  IntegrationModule,
  InternalModule,
  ChangeModule,
  ContextsModule,
  SubscribersV1Module,
  SubscribersModule,
  FeedsModule,
  LayoutsV1Module,
  LayoutsV2Module,
  MessagesModule,
  PartnerIntegrationsModule,
  TopicsV1Module,
  TopicsV2Module,
  BlueprintModule,
  TenantModule,
  StorageModule,
  WorkflowOverridesModule,
  RateLimitingModule,
  WidgetsModule,
  TracingModule.register(packageJson.name, packageJson.version),
  BridgeModule,
  PreferencesModule,
  WorkflowModule,
  EnvironmentsModule,
  NovuModule,
];

const enterpriseModules = enterpriseImports();

if (!isClerkEnabled()) {
  const communityModules = [InvitesModule];
  baseModules.push(...communityModules);
}

const modules = baseModules.concat(enterpriseModules);

const providers: Provider[] = [
  {
    provide: APP_GUARD,
    useClass: AnalyticsLogsGuard,
  },
  {
    provide: APP_INTERCEPTOR,
    useClass: ApiRateLimitInterceptor,
  },
  {
    provide: APP_INTERCEPTOR,
    useClass: ProductFeatureInterceptor,
  },
  ...enterpriseQuotaThrottlerInterceptor,
  {
    provide: APP_INTERCEPTOR,
    useClass: IdempotencyInterceptor,
  },
  {
    provide: APP_INTERCEPTOR,
    useClass: AnalyticsLogsInterceptor,
  },
  cacheService,
];

if (process.env.SENTRY_DSN) {
  modules.unshift(SentryModule.forRoot());
}

if (process.env.SEGMENT_TOKEN) {
  modules.push(AnalyticsModule);
}

if (process.env.NODE_ENV === 'test') {
  modules.push(TestingModule);
}

modules.push(
  NovuModule.register({
    apiPath: '/bridge/novu',
    client: new Client({
      secretKey: process.env.NOVU_INTERNAL_SECRET_KEY,
      strictAuthentication:
        process.env.NODE_ENV === 'production' ||
        process.env.NODE_ENV === 'dev' ||
        process.env.NOVU_STRICT_AUTHENTICATION_ENABLED === 'true',
    }),
    controllerDecorators: [ApiExcludeController()],
    workflows: [usageLimitsWorkflow],
  })
);

@Module({
  imports: modules,
  controllers: [],
  providers,
})
export class AppModule {}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - enterpriseImports(): Array<Type | DynamicModule | Promise<DynamicModule> | ForwardReference>)
Declaraciones 'export' encontradas:
- export class AppModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/bootstrap.ts
Tamao: 4845 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import './instrument';

import { INestApplication, ValidationPipe, VersioningType } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import {
  BullMqService,
  getErrorInterceptor,
  // biome-ignore lint/style/noRestrictedImports: <explanation> x
  Logger,
  PinoLogger,
  RequestLogRepository,
} from '@novu/application-generic';

import bodyParser from 'body-parser';
import helmet from 'helmet';
import { ResponseInterceptor } from './app/shared/framework/response.interceptor';
import { setupSwagger } from './app/shared/framework/swagger/swagger.controller';

import { RequestIdMiddleware } from './app/shared/middleware/request-id.middleware';

import { AppModule } from './app.module';
import { CONTEXT_PATH, corsOptionsDelegate, validateEnv } from './config';
import { AllExceptionsFilter } from './exception-filter';

const passport = require('passport');
const compression = require('compression');

const extendedBodySizeRoutes = [
  '/v1/events',
  '/v1/notification-templates',
  '/v1/workflows',
  '/v1/layouts',
  '/v1/bridge/sync',
  '/v1/bridge/diff',
  '/v1/environments/:environmentId/bridge',
  '/v2/workflows',
];

// Validate the ENV variables after launching SENTRY, so missing variables will report to sentry.
validateEnv();
class BootstrapOptions {
  internalSdkGeneration?: boolean;
}

export async function bootstrap(
  bootstrapOptions?: BootstrapOptions
): Promise<{ app: INestApplication; document: any }> {
  BullMqService.haveProInstalled();

  let rawBodyBuffer: undefined | ((...args) => void);
  let nestOptions: Record<string, boolean> = {};

  if (process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true') {
    rawBodyBuffer = (_req, _res, buffer, _encoding): void => {
      if (buffer?.length) {
        // eslint-disable-next-line no-param-reassign
        (_req as any).rawBody = Buffer.from(buffer);
      }
    };
    nestOptions = {
      bodyParser: false,
      rawBody: true,
    };
  }

  const app = await NestFactory.create(AppModule, { bufferLogs: true, ...nestOptions });

  app.enableVersioning({
    type: VersioningType.URI,
    prefix: `${CONTEXT_PATH}v`,
    defaultVersion: '1',
  });

  const logger = await app.resolve(PinoLogger);
  logger.setContext('Bootstrap');

  app.useLogger(app.get(Logger));
  app.flushLogs();

  const server = app.getHttpServer();
  logger.trace(`Server timeout: ${server.timeout}`);
  server.keepAliveTimeout = 61 * 1000;
  logger.trace(`Server keepAliveTimeout: ${server.keepAliveTimeout / 1000}s `);
  server.headersTimeout = 65 * 1000;
  logger.trace(`Server headersTimeout: ${server.headersTimeout / 1000}s `);

  app.use(helmet());
  app.enableCors(corsOptionsDelegate);

  app.use(passport.initialize());

  // Apply transaction ID middleware early in the request lifecycle
  const transactionIdMiddleware = new RequestIdMiddleware();
  app.use((req, res, next) => transactionIdMiddleware.use(req, res, next));

  app.useGlobalPipes(
    new ValidationPipe({
      transform: true,
      forbidUnknownValues: false,
    })
  );

  app.useGlobalInterceptors(new ResponseInterceptor());
  app.useGlobalInterceptors(getErrorInterceptor());

  app.use(extendedBodySizeRoutes, bodyParser.json({ limit: '26mb' }));
  app.use(extendedBodySizeRoutes, bodyParser.urlencoded({ limit: '26mb', extended: true }));

  // Add text/plain parser specifically for inbound webhooks (SNS confirmations)
  app.use(
    '/v2/inbound-webhooks/delivery-providers/:environmentId/:integrationId',
    bodyParser.text({ verify: rawBodyBuffer })
  );

  app.use(bodyParser.json({ verify: rawBodyBuffer }));
  app.use(bodyParser.urlencoded({ extended: true, verify: rawBodyBuffer }));

  app.use(compression());

  const document = await setupSwagger(app, bootstrapOptions?.internalSdkGeneration);

  app.useGlobalFilters(new AllExceptionsFilter(app.get(Logger), app.get(RequestLogRepository)));

  /*
   * Handle unhandled promise rejections
   * We explicitly crash the process on unhandled rejections as they indicate the application
   * is in an undefined state. NestJS can't handle these as they occur outside the event lifecycle.
   * According to Node.js docs, it's unsafe to resume normal operation after unhandled rejections.
   * We log these rejections with fatal level to ensure they are properly monitored and tracked.
   * See: https://nodejs.org/api/process.html#process_warning_using_uncaughtexception_correctly
   */
  process.on('unhandledRejection', (reason, promise) => {
    logger.fatal({
      err: reason,
      message: 'Unhandled promise rejection',
      promise,
    });
    process.exit(1);
  });

  await app.listen(process.env.PORT || 3000);

  app.enableShutdownHooks();

  logger.info(`Started application in NODE_ENV=${process.env.NODE_ENV} on port ${process.env.PORT}.`);

  return { app, document };
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - bootstrap(bootstrapOptions?: BootstrapOptions)
Asignaciones con arrow functions encontradas (posibles funciones):
 - extendedBodySizeRoutes([
  '/v1/events',
  '/v1/notification-templates',
  '/v1/workflows',
  '/v1/layouts',
  '/v1/bridge/...)
 - rawBodyBuffer(_req, _res, buffer, _encoding): void)
 - transactionIdMiddleware(new RequestIdMiddleware();
  app.use((req, res, next))
 - document(await setupSwagger(app, bootstrapOptions?.internalSdkGeneration);

  app.useGlobalFilters(new AllExc...)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/error-dto.ts
Tamao: 4715 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiExtraModels, ApiProperty, getSchemaPath } from '@nestjs/swagger'; // Ensure you have the correct import for ApiProperty
import { ConstraintValidation } from '@novu/application-generic';

export class ErrorDto {
  @ApiProperty({
    description: 'HTTP status code of the error response.',
    example: 404,
  })
  statusCode: number;

  @ApiProperty({
    description: 'Timestamp of when the error occurred.',
    example: '2024-12-12T13:00:00Z',
  })
  timestamp: string;

  @ApiProperty({
    description: 'The path where the error occurred.',
    example: '/api/v1/resource',
  })
  path: string;

  @ApiProperty({
    required: false,
    description: 'Value that failed validation',
    oneOf: [
      { type: 'string', nullable: true },
      { type: 'number' },
      { type: 'boolean' },
      { type: 'object', nullable: true },
      {
        type: 'array',
        items: {
          anyOf: [
            { type: 'string', nullable: true },
            { type: 'number' },
            { type: 'boolean' },
            { type: 'object', additionalProperties: true },
          ],
        },
      },
    ],
    example: 'xx xx xx ',
  })
  message?: unknown;

  @ApiProperty({
    description: 'Optional context object for additional error details.',
    type: 'object',
    required: false,
    additionalProperties: true,
    example: {
      workflowId: 'some_wf_id',
      stepId: 'some_wf_id',
    },
  })
  ctx?: object | Object;

  /**
   * Optional unique identifier for the error, useful for tracking using Sentry and New Relic, only available for 500.
   */
  @ApiProperty({
    description: `Optional unique identifier for the error, useful for tracking using Sentry and 
      New Relic, only available for 500.`,
    example: 'abc123',
    required: false,
  })
  errorId?: string;
}

export class PayloadValidationErrorDto {
  @ApiProperty({
    description: 'Field path that failed validation',
    example: 'user.name',
  })
  field: string;

  @ApiProperty({
    description: 'Validation error message',
    example: "must have required property 'name'",
  })
  message: string;

  @ApiProperty({
    description: 'The actual value that failed validation',
    oneOf: [
      { type: 'string', nullable: true },
      { type: 'number' },
      { type: 'boolean' },
      { type: 'object', nullable: true },
      {
        type: 'array',
        items: {
          anyOf: [
            { type: 'string', nullable: true },
            { type: 'number' },
            { type: 'boolean' },
            { type: 'object', additionalProperties: true },
          ],
        },
      },
    ],
    required: false,
    example: { age: 25 },
  })
  value?: any;

  @ApiProperty({
    description: 'JSON Schema path where the validation failed',
    example: '#/required',
    required: false,
  })
  schemaPath?: string;
}

@ApiExtraModels(PayloadValidationErrorDto)
export class PayloadValidationExceptionDto extends ErrorDto {
  @ApiProperty({
    description: 'Type identifier for payload validation errors',
    example: 'PAYLOAD_VALIDATION_ERROR',
  })
  type: string;

  @ApiProperty({
    description: 'Array of detailed validation errors',
    type: [PayloadValidationErrorDto],
    example: [
      {
        field: 'user.name',
        message: "must have required property 'name'",
        value: { age: 25 },
        schemaPath: '#/required',
      },
    ],
  })
  errors: PayloadValidationErrorDto[];

  @ApiProperty({
    description: 'The JSON schema that was used for validation',
    type: 'object',
    required: false,
    example: {
      type: 'object',
      properties: {
        name: { type: 'string' },
        age: { type: 'number' },
      },
      required: ['name'],
    },
  })
  schema?: any;
}

@ApiExtraModels(ConstraintValidation)
export class ValidationErrorDto extends ErrorDto {
  @ApiProperty({
    description: 'A record of validation errors keyed by field name',
    type: 'object',
    additionalProperties: {
      $ref: getSchemaPath(ConstraintValidation),
    },
    example: {
      fieldName1: {
        messages: ['Field is required', 'Must be a valid email address'],
        value: 'invalidEmail',
      },
      fieldName2: {
        messages: ['Must be at least 18 years old'],
        value: 17,
      },
      fieldName3: {
        messages: ['Must be a boolean value'],
        value: true,
      },
      fieldName4: {
        messages: ['Must be a valid object'],
        value: { key: 'value' },
      },
      fieldName5: {
        messages: ['Field is missing'],
        value: null,
      },
      fieldName6: {
        messages: ['Undefined value'],
      },
    },
  })
  errors: Record<string, ConstraintValidation>;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ErrorDto
- export class PayloadValidationErrorDto
- export class PayloadValidationExceptionDto
- export class ValidationErrorDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/exception-filter.ts
Tamao: 8079 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { randomUUID } from 'node:crypto';
import { ArgumentsHost, ExceptionFilter, HttpException, HttpStatus, PayloadTooLargeException } from '@nestjs/common';
import { InternalServerErrorException } from '@nestjs/common/exceptions/internal-server-error.exception';
import { HttpArgumentsHost } from '@nestjs/common/interfaces';
import { CommandValidationException, PinoLogger, RequestLogRepository } from '@novu/application-generic';
import { UserSessionData } from '@novu/shared';
import { captureException } from '@sentry/node';
import { Response } from 'express';
import { ZodError } from 'zod';
import { RequestWithReqId } from './app/shared/middleware/request-id.middleware';
import { buildLog } from './app/shared/utils/mappers';
import { ErrorDto, ValidationErrorDto } from './error-dto';
import { retryWithBackoff } from './utils/payload-sanitizer';

export const ERROR_MSG_500 = `Internal server error, contact support and provide them with the errorId`;

class ValidationPipeError {
  response: { message: string[] | string };
}

export class AllExceptionsFilter implements ExceptionFilter {
  constructor(
    private readonly logger: PinoLogger,
    private readonly requestLogRepository: RequestLogRepository
  ) {}
  async catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<RequestWithReqId>();
    const errorDto = this.buildErrorResponse(exception, request);

    // TODO: In same cases the statusCode is a string. We should investigate why this is happening.
    const statusCode = Number(errorDto.statusCode);
    if (statusCode >= 500) {
      this.logError(errorDto, exception);
    }

    // This is for backwards compatibility for clients waiting for the context elements to appear flat
    const finalResponse = { ...errorDto.ctx, ...errorDto };

    await this.createAnalyticsLog(ctx, request, statusCode, errorDto);

    response.status(statusCode).json(finalResponse);
  }

  private async createAnalyticsLog(
    ctx: HttpArgumentsHost,
    request: RequestWithReqId,
    statusCode: number,
    errorDto: ErrorDto
  ) {
    const shouldRun = await this.shouldRun(ctx);

    if (!shouldRun) return;

    const req = ctx.getRequest();
    const user = req.user as UserSessionData;
    const basicLog = buildLog(request, statusCode, errorDto, user);

    try {
      if (basicLog) {
        this.requestLogRepository.create(basicLog, {
          organizationId: user?.organizationId,
          environmentId: user?.environmentId,
          userId: user?._id,
        });
      }
    } catch (err) {
      this.logger.warn({ err }, 'Failed to log analytics to ClickHouse after retries');
    }
  }

  private async shouldRun(ctx: HttpArgumentsHost): Promise<boolean> {
    const req = ctx.getRequest();

    // Check if the analytics metadata was set by the guard (AnalyticsLogsGuard)
    if (req._shouldLogAnalytics !== true) return false;

    const isEnabled = process.env.IS_ANALYTICS_LOGS_ENABLED === 'true';

    return isEnabled;
  }

  private logError(errorDto: ErrorDto, exception: unknown) {
    this.logger.error({
      /**
       * It's important to use `err` as the key, pino (the logger we use) will
       * log an empty object if the key is not `err`
       *
       * @see https://github.com/pinojs/pino/issues/819#issuecomment-611995074
       */
      err: exception,
      error: errorDto,
    });
  }

  private buildErrorDto(
    request: RequestWithReqId,
    statusCode: number,
    message: string,
    ctx?: Object | object
  ): ErrorDto {
    return {
      statusCode,
      timestamp: new Date().toISOString(),
      path: request.url,
      message,
      ctx,
    };
  }

  private buildErrorResponse(exception: unknown, request: RequestWithReqId): ErrorDto {
    if (exception instanceof HttpException && exception.name === 'ThrottlerException') {
      return this.handlerThrottlerException(request);
    }

    if (exception instanceof ZodError) {
      return this.handleZod(exception, request);
    }
    if (exception instanceof CommandValidationException) {
      return this.handleCommandValidation(exception, request);
    }
    if (this.isBadRequestWithMultipleExceptions(exception)) {
      return this.handleValidationPipeValidation(exception, request);
    }

    if (exception instanceof HttpException && !(exception instanceof InternalServerErrorException)) {
      return this.handleOtherHttpExceptions(exception, request);
    }

    if (this.isPayloadTooLargeError(exception)) {
      return this.handleOtherHttpExceptions(new PayloadTooLargeException(), request);
    }

    return this.buildA5xxError(request, exception);
  }

  private isPayloadTooLargeError(exception: unknown) {
    return exception?.constructor?.name === 'PayloadTooLargeError';
  }

  private isBadRequestWithMultipleExceptions(exception: unknown): exception is ValidationPipeError {
    // noinspection UnnecessaryLocalVariableJS
    const isBadRequestExceptionFromValidationPipe =
      exception instanceof Object &&
      safeHasProperty(exception, 'response') &&
      safeHasProperty((exception as any).response, 'message') &&
      Array.isArray((exception as any).response.message);

    return isBadRequestExceptionFromValidationPipe;
  }
  private buildA5xxError(request: RequestWithReqId, exception: unknown) {
    const errorDto500 = this.buildErrorDto(request, HttpStatus.INTERNAL_SERVER_ERROR, ERROR_MSG_500);

    return {
      ...errorDto500,
      errorId: this.getUuid(exception),
    };
  }

  private handleOtherHttpExceptions(exception: HttpException, request: RequestWithReqId): ErrorDto {
    const status = exception.getStatus();
    const response = exception.getResponse();
    const { innerMsg, tempContext } = this.buildMsgAndContextForHttpError(response, status);

    return this.buildErrorDto(request, status || 500, innerMsg, tempContext);
  }

  private buildMsgAndContextForHttpError(response: string | object | { message: string }, status: number) {
    if (typeof response === 'string') {
      return { innerMsg: response as string };
    }

    if (safeHasProperty(response, 'message')) {
      const { message, ...ctx } = response as { message: string };

      return { innerMsg: message, tempContext: ctx };
    }
    if (typeof response === 'object' && response !== null) {
      return { innerMsg: `Api Exception Raised with status ${status}`, tempContext: response };
    }

    return { innerMsg: `Api Exception Raised with status ${status}` };
  }

  private handleCommandValidation(
    exception: CommandValidationException,
    request: RequestWithReqId
  ): ValidationErrorDto {
    const errorDto = this.buildErrorDto(request, HttpStatus.UNPROCESSABLE_ENTITY, exception.message, {});

    return { ...errorDto, errors: exception.constraintsViolated };
  }

  private getUuid(exception: unknown) {
    if (process.env.SENTRY_DSN) {
      try {
        return captureException(exception);
      } catch (e) {
        return randomUUID();
      }
    } else {
      return randomUUID();
    }
  }
  private handleZod(exception: ZodError, request: RequestWithReqId): ErrorDto {
    const ctx = {
      errors: exception.errors.map((err) => ({
        message: err.message,
        path: err.path,
      })),
    };

    return this.buildErrorDto(request, HttpStatus.BAD_REQUEST, 'Zod Validation Failed', ctx);
  }

  private handleValidationPipeValidation(exception: ValidationPipeError, request: RequestWithReqId) {
    const errorDto = this.buildErrorDto(request, HttpStatus.UNPROCESSABLE_ENTITY, 'Validation Error', {});

    return { ...errorDto, errors: { general: { messages: exception.response.message, value: 'No Value Recorded' } } };
  }

  private handlerThrottlerException(request: RequestWithReqId) {
    return this.buildErrorDto(request, HttpStatus.TOO_MANY_REQUESTS, 'API rate limit exceeded', {});
  }
}

function safeHasProperty(obj: unknown, property: string): boolean {
  return typeof obj === 'object' && obj !== null && property in obj;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - safeHasProperty(obj: unknown, property: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - ctx({
      errors: exception.errors.map((err))
Declaraciones 'export' encontradas:
- export  const
- export class AllExceptionsFilter

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/instrument.ts
Tamao: 335 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import './config/env.config';

require('newrelic');

import { init } from '@sentry/nestjs';
import { version } from '../package.json';

if (process.env.SENTRY_DSN) {
  init({
    dsn: process.env.SENTRY_DSN,
    environment: process.env.NODE_ENV,
    release: `v${version}`,
    ignoreErrors: ['Non-Error exception captured'],
  });
}


### ANALISIS AUTOMATICO (ESPAOL) ###

No se detectaron funciones/exportaciones con heurstica JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/main.ts
Tamao: 55 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { bootstrap } from './bootstrap';

bootstrap();


### ANALISIS AUTOMATICO (ESPAOL) ###

No se detectaron funciones/exportaciones con heurstica JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/newrelic.ts
Tamao: 2210 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/**
 * New Relic agent configuration.
 *
 * See lib/config/default.js in the agent distribution for a more complete
 * description of configuration variables and their potential values.
 */

exports.config = {
  /**
   * Array of application names.
   */
  app_name: [process.env.NEW_RELIC_APP_NAME],
  /**
   * Your New Relic license key.
   */
  license_key: process.env.NEW_RELIC_LICENSE_KEY,
  /**
   * This setting controls distributed tracing.
   * Distributed tracing lets you see the path that a request takes through your
   * distributed system. Enabling distributed tracing changes the behavior of some
   * New Relic features, so carefully consult the transition guide before you enable
   * this feature: https://docs.newrelic.com/docs/transition-guide-distributed-tracing
   * Default is true.
   */
  distributed_tracing: {
    /**
     * Enables/disables distributed tracing.
     *
     * @env NEW_RELIC_DISTRIBUTED_TRACING_ENABLED
     */
    enabled: true,
  },
  application_logging: {
    forwarding: {
      enabled: true,
    },
  },
  logging: {
    /**
     * Level at which to log. 'trace' is most useful to New Relic when diagnosing
     * issues with the agent, 'info' and higher will impose the least overhead on
     * production applications.
     */
    level: 'info',
  },
  /**
   * When true, all request headers except for those listed in attributes.exclude
   * will be captured for all traces, unless otherwise specified in a destination's
   * attributes include/exclude lists.
   */
  allow_all_headers: true,
  attributes: {
    /**
     * Prefix of attributes to exclude from all destinations. Allows * as wildcard
     * at end.
     *
     * NOTE: If excluding headers, they must be in camelCase form to be filtered.
     *
     * @env NEW_RELIC_ATTRIBUTES_EXCLUDE
     */
    exclude: [
      'request.headers.cookie',
      'request.headers.authorization',
      'request.headers.proxyAuthorization',
      'request.headers.setCookie*',
      'request.headers.x*',
      'response.headers.cookie',
      'response.headers.authorization',
      'response.headers.proxyAuthorization',
      'response.headers.setCookie*',
      'response.headers.x*',
    ],
  },
};


### ANALISIS AUTOMATICO (ESPAOL) ###

No se detectaron funciones/exportaciones con heurstica JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/activity.controller.ts
Tamao: 6206 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ClassSerializerInterceptor, Controller, Get, Param, Query, UseInterceptors } from '@nestjs/common';
import { ApiOperation } from '@nestjs/swagger';
import { FeatureFlagsService, RequirePermissions, UserSession } from '@novu/application-generic';
import { FeatureFlagsKeysEnum, PermissionsEnum, UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { SdkGroupName, SdkMethodName } from '../shared/framework/swagger/sdk.decorators';
import { GetChartsRequestDto } from './dtos/get-charts.request.dto';
import { GetChartsResponseDto } from './dtos/get-charts.response.dto';
import { GetRequestResponseDto } from './dtos/get-request.response.dto';
import { GetRequestsDto } from './dtos/get-requests.dto';
import { GetRequestsResponseDto } from './dtos/get-requests.response.dto';
import { GetWorkflowRunResponseDto } from './dtos/workflow-run-response.dto';
import { GetWorkflowRunsRequestDto } from './dtos/workflow-runs-request.dto';
import { GetWorkflowRunsResponseDto } from './dtos/workflow-runs-response.dto';
import { GetChartsCommand } from './usecases/get-charts/get-charts.command';
import { GetCharts } from './usecases/get-charts/get-charts.usecase';
import { GetRequestCommand } from './usecases/get-request/get-request.command';
import { GetRequest } from './usecases/get-request/get-request.usecase';
import { GetRequestsCommand } from './usecases/get-requests/get-requests.command';
import { GetRequests } from './usecases/get-requests/get-requests.usecase';
import { GetWorkflowRunCommand } from './usecases/get-workflow-run/get-workflow-run.command';
import { GetWorkflowRun } from './usecases/get-workflow-run/get-workflow-run.usecase';
import { GetWorkflowRunsCommand } from './usecases/get-workflow-runs/get-workflow-runs.command';
import { GetWorkflowRuns } from './usecases/get-workflow-runs/get-workflow-runs.usecase';

@Controller('/activity')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@SdkGroupName('Activity')
export class ActivityController {
  constructor(
    private getRequestsUsecase: GetRequests,
    private getWorkflowRunsUsecase: GetWorkflowRuns,
    private getWorkflowRunUsecase: GetWorkflowRun,
    private getRequestUsecase: GetRequest,
    private getChartsUsecase: GetCharts,
    private featureFlagsService: FeatureFlagsService
  ) {}

  @Get('requests')
  @RequirePermissions(PermissionsEnum.NOTIFICATION_READ)
  @SdkGroupName('Activity.Requests')
  @SdkMethodName('list')
  @ApiOperation({
    summary: 'List activity requests',
    description: 'Retrieve a list of activity requests with optional filtering and pagination.',
  })
  async getLogs(@UserSession() user: UserSessionData, @Query() query: GetRequestsDto): Promise<GetRequestsResponseDto> {
    return this.getRequestsUsecase.execute(
      GetRequestsCommand.create({
        ...query,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        createdGte: query.createdGte,
      })
    );
  }

  @Get('requests/:requestId')
  @RequirePermissions(PermissionsEnum.NOTIFICATION_READ)
  @SdkGroupName('Activity.Requests')
  @SdkMethodName('retrieve')
  @ApiOperation({
    summary: 'Retrieve activity request',
    description: 'Retrieve detailed traces and information for a specific activity request by ID.',
  })
  async getRequestTraces(@UserSession() user, @Param('requestId') requestId: string): Promise<GetRequestResponseDto> {
    return this.getRequestUsecase.execute(
      GetRequestCommand.create({
        requestId,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
      })
    );
  }

  @Get('workflow-runs')
  @RequirePermissions(PermissionsEnum.NOTIFICATION_READ)
  @SdkGroupName('Activity.WorkflowRuns')
  @SdkMethodName('list')
  @ApiOperation({
    summary: 'List workflow runs',
    description: 'Retrieve a list of workflow runs with optional filtering and pagination.',
  })
  async getWorkflowRuns(
    @UserSession() user: UserSessionData,
    @Query() query: GetWorkflowRunsRequestDto
  ): Promise<GetWorkflowRunsResponseDto> {
    // Check if context search is enabled via feature flag
    const isContextEnabled = await this.featureFlagsService.getFlag({
      key: FeatureFlagsKeysEnum.IS_CONTEXT_ENABLED,
      defaultValue: false,
      organization: { _id: user.organizationId },
      user: { _id: user._id },
      environment: { _id: user.environmentId },
    });

    const contextKeysQuery: string[] | undefined = isContextEnabled ? query.contextKeys : undefined;

    return this.getWorkflowRunsUsecase.execute(
      GetWorkflowRunsCommand.create({
        ...query,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        userId: user._id,
        contextKeys: contextKeysQuery,
      })
    );
  }

  @Get('workflow-runs/:workflowRunId')
  @RequirePermissions(PermissionsEnum.NOTIFICATION_READ)
  @SdkGroupName('Activity.WorkflowRuns')
  @SdkMethodName('retrieve')
  @ApiOperation({
    summary: 'Retrieve workflow run',
    description: 'Retrieve detailed information for a specific workflow run by ID.',
  })
  async getWorkflowRun(
    @UserSession() user: UserSessionData,
    @Param('workflowRunId') workflowRunId: string
  ): Promise<GetWorkflowRunResponseDto> {
    return this.getWorkflowRunUsecase.execute(
      GetWorkflowRunCommand.create({
        workflowRunId,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        userId: user._id,
      })
    );
  }

  @Get('charts')
  @RequirePermissions(PermissionsEnum.NOTIFICATION_READ)
  @SdkGroupName('Activity.Charts')
  @SdkMethodName('retrieve')
  @ApiOperation({
    summary: 'Retrieve activity charts',
    description: 'Retrieve chart data for activity analytics and metrics visualization.',
  })
  async getCharts(
    @UserSession() user: UserSessionData,
    @Query() query: GetChartsRequestDto
  ): Promise<GetChartsResponseDto> {
    return this.getChartsUsecase.execute(
      GetChartsCommand.create({
        ...query,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ActivityController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/activity.module.ts
Tamao: 2828 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { SharedModule } from '../shared/shared.module';
import { ActivityController } from './activity.controller';
import { BuildActiveSubscribersChart } from './usecases/build-active-subscribers-chart/build-active-subscribers-chart.usecase';
import { BuildActiveSubscribersTrendChart } from './usecases/build-active-subscribers-trend-chart/build-active-subscribers-trend-chart.usecase';
import { BuildAvgMessagesPerSubscriberChart } from './usecases/build-avg-messages-per-subscriber-chart/build-avg-messages-per-subscriber-chart.usecase';
import { BuildDeliveryTrendChart } from './usecases/build-delivery-trend-chart/build-delivery-trend-chart.usecase';
import { BuildInteractionTrendChart } from './usecases/build-interaction-trend-chart/build-interaction-trend-chart.usecase';
import { BuildMessagesDeliveredChart } from './usecases/build-messages-delivered-chart/build-messages-delivered-chart.usecase';
import { BuildProviderByVolumeChart } from './usecases/build-provider-by-volume-chart/build-provider-by-volume-chart.usecase';
import { BuildTotalInteractionsChart } from './usecases/build-total-interactions-chart/build-total-interactions-chart.usecase';
import { BuildWorkflowByVolumeChart } from './usecases/build-workflow-by-volume-chart/build-workflow-by-volume-chart.usecase';
import { BuildWorkflowRunsCountChart } from './usecases/build-workflow-runs-count-chart/build-workflow-runs-count-chart.usecase';
import { BuildWorkflowRunsMetricChart } from './usecases/build-workflow-runs-metric-chart/build-workflow-runs-metric-chart.usecase';
import { BuildWorkflowRunsTrendChart } from './usecases/build-workflow-runs-trend-chart/build-workflow-runs-trend-chart.usecase';
import { GetCharts } from './usecases/get-charts/get-charts.usecase';
import { GetRequest } from './usecases/get-request/get-request.usecase';
import { GetRequests } from './usecases/get-requests/get-requests.usecase';
import { GetWorkflowRun } from './usecases/get-workflow-run/get-workflow-run.usecase';
import { GetWorkflowRuns } from './usecases/get-workflow-runs/get-workflow-runs.usecase';
import { WorkflowRunService } from '@novu/application-generic';

const USE_CASES = [
  GetRequests,
  GetWorkflowRuns,
  GetWorkflowRun,
  GetCharts,
  BuildDeliveryTrendChart,
  BuildInteractionTrendChart,
  BuildWorkflowByVolumeChart,
  BuildProviderByVolumeChart,
  BuildMessagesDeliveredChart,
  BuildActiveSubscribersChart,
  BuildActiveSubscribersTrendChart,
  BuildAvgMessagesPerSubscriberChart,
  BuildWorkflowRunsCountChart,
  BuildWorkflowRunsMetricChart,
  BuildTotalInteractionsChart,
  BuildWorkflowRunsTrendChart,
  GetRequest,
  WorkflowRunService,
];

@Module({
  imports: [SharedModule],
  controllers: [ActivityController],
  providers: [...USE_CASES],
})
export class ActivityModule {}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ActivityModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/dtos/get-charts.request.dto.ts
Tamao: 931 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsArray, IsDateString, IsDefined, IsEnum, IsOptional, IsString } from 'class-validator';
import { ReportTypeEnum, WorkflowRunStatusDtoEnum } from './shared.dto';

export class GetChartsRequestDto {
  @IsDateString()
  @IsOptional()
  createdAtGte?: string;

  @IsDateString()
  @IsOptional()
  createdAtLte?: string;

  @IsEnum(ReportTypeEnum, { each: true })
  @IsDefined()
  reportType: ReportTypeEnum[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  workflowIds?: string[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  subscriberIds?: string[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  transactionIds?: string[];

  @IsOptional()
  @IsArray()
  @IsEnum(WorkflowRunStatusDtoEnum, { each: true })
  statuses?: WorkflowRunStatusDtoEnum[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  channels?: string[];

  @IsOptional()
  @IsString()
  topicKey?: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetChartsRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/dtos/get-charts.response.dto.ts
Tamao: 4338 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsNumber, IsString, ValidateNested } from 'class-validator';
import { ReportTypeEnum } from './shared.dto';

export class ChartDataPointDto {
  @ApiProperty({ description: 'Chart data point timestamp' })
  @IsString()
  timestamp: string;

  @ApiProperty({ description: 'In-app (Inbox) delivery count' })
  @IsNumber()
  inApp: number;

  @ApiProperty({ description: 'Email delivery count' })
  @IsNumber()
  email: number;

  @ApiProperty({ description: 'SMS delivery count' })
  @IsNumber()
  sms: number;

  @ApiProperty({ description: 'Chat delivery count' })
  @IsNumber()
  chat: number;

  @ApiProperty({ description: 'Push delivery count' })
  @IsNumber()
  push: number;
}

export class InteractionTrendDataPointDto {
  @ApiProperty({ description: 'Chart data point timestamp' })
  @IsString()
  timestamp: string;

  @ApiProperty({ description: 'Messages seen count' })
  @IsNumber()
  messageSeen: number;

  @ApiProperty({ description: 'Messages read count' })
  @IsNumber()
  messageRead: number;

  @ApiProperty({ description: 'Messages snoozed count' })
  @IsNumber()
  messageSnoozed: number;

  @ApiProperty({ description: 'Messages archived count' })
  @IsNumber()
  messageArchived: number;
}

export class WorkflowVolumeDataPointDto {
  @ApiProperty({ description: 'Workflow name' })
  @IsString()
  workflowName: string;

  @ApiProperty({ description: 'Number of workflow runs' })
  @IsNumber()
  count: number;
}

export class ProviderVolumeDataPointDto {
  @ApiProperty({ description: 'Provider identifier' })
  @IsString()
  providerId: string;

  @ApiProperty({ description: 'Number of step runs' })
  @IsNumber()
  count: number;
}

export class MessagesDeliveredDataPointDto {
  @ApiProperty({ description: 'Current period count' })
  @IsNumber()
  currentPeriod: number;

  @ApiProperty({ description: 'Previous period count' })
  @IsNumber()
  previousPeriod: number;
}

export class ActiveSubscribersDataPointDto {
  @ApiProperty({ description: 'Current period count' })
  @IsNumber()
  currentPeriod: number;

  @ApiProperty({ description: 'Previous period count' })
  @IsNumber()
  previousPeriod: number;
}

export class AvgMessagesPerSubscriberDataPointDto {
  @ApiProperty({ description: 'Current period average' })
  @IsNumber()
  currentPeriod: number;

  @ApiProperty({ description: 'Previous period average' })
  @IsNumber()
  previousPeriod: number;
}

export class WorkflowRunsMetricDataPointDto {
  @ApiProperty({ description: 'Current period count' })
  @IsNumber()
  currentPeriod: number;

  @ApiProperty({ description: 'Previous period count' })
  @IsNumber()
  previousPeriod: number;
}

export class TotalInteractionsDataPointDto {
  @ApiProperty({ description: 'Current period count' })
  @IsNumber()
  currentPeriod: number;

  @ApiProperty({ description: 'Previous period count' })
  @IsNumber()
  previousPeriod: number;
}

export class WorkflowRunsTrendDataPointDto {
  @ApiProperty({ description: 'Chart data point timestamp' })
  @IsString()
  timestamp: string;

  @ApiProperty({ description: 'Processing workflow runs count' })
  @IsNumber()
  processing: number;

  @ApiProperty({ description: 'Completed workflow runs count' })
  @IsNumber()
  completed: number;

  @ApiProperty({ description: 'Failed workflow runs count' })
  @IsNumber()
  error: number;
}

export class ActiveSubscribersTrendDataPointDto {
  @ApiProperty({ description: 'Chart data point timestamp' })
  @IsString()
  timestamp: string;

  @ApiProperty({ description: 'Active subscribers count' })
  @IsNumber()
  count: number;
}

export class WorkflowRunsCountDataPointDto {
  @ApiProperty({ description: 'Workflow runs count' })
  @IsNumber()
  count: number;
}

export class GetChartsResponseDto {
  @ApiProperty({ description: 'Chart sections' })
  @ValidateNested()
  data: Record<
    ReportTypeEnum,
    | ChartDataPointDto[]
    | InteractionTrendDataPointDto[]
    | WorkflowVolumeDataPointDto[]
    | ProviderVolumeDataPointDto[]
    | MessagesDeliveredDataPointDto
    | ActiveSubscribersDataPointDto
    | AvgMessagesPerSubscriberDataPointDto
    | WorkflowRunsMetricDataPointDto
    | TotalInteractionsDataPointDto
    | WorkflowRunsTrendDataPointDto[]
    | ActiveSubscribersTrendDataPointDto[]
    | WorkflowRunsCountDataPointDto
  >;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ChartDataPointDto
- export class InteractionTrendDataPointDto
- export class WorkflowVolumeDataPointDto
- export class ProviderVolumeDataPointDto
- export class MessagesDeliveredDataPointDto
- export class ActiveSubscribersDataPointDto
- export class AvgMessagesPerSubscriberDataPointDto
- export class WorkflowRunsMetricDataPointDto
- export class TotalInteractionsDataPointDto
- export class WorkflowRunsTrendDataPointDto
- export class ActiveSubscribersTrendDataPointDto
- export class WorkflowRunsCountDataPointDto
- export class GetChartsResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/dtos/get-request.request.dto.ts
Tamao: 256 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsString } from 'class-validator';

export class GetRequestRequestDto {
  @ApiProperty({
    description: 'Request identifier',
    example: 'req_123456789',
  })
  @IsString()
  requestId: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetRequestRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/dtos/get-request.response.dto.ts
Tamao: 2182 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsOptional, IsString } from 'class-validator';
import { RequestLogResponseDto } from './get-requests.response.dto';

export class TraceResponseDto {
  @ApiProperty({ description: 'Trace identifier' })
  @IsString()
  id: string;

  @ApiProperty({ description: 'Creation timestamp' })
  @IsString()
  createdAt: string;

  @ApiProperty({ description: 'Event type (e.g., request_received, workflow_execution_started)' })
  @IsString()
  eventType: string;

  @ApiProperty({ description: 'Human readable title/message' })
  @IsString()
  title: string;

  @ApiProperty({ description: 'Detailed message', nullable: true })
  @IsOptional()
  @IsString()
  message?: string | null;

  @ApiProperty({ description: 'Raw data associated with trace', nullable: true })
  @IsOptional()
  @IsString()
  rawData?: string | null;

  @ApiProperty({ description: 'Trace status (success, error, warning, pending)' })
  @IsString()
  status: string;

  @ApiProperty({ description: 'Entity type (request, workflow_run, step_run)' })
  @IsString()
  entityType: string;

  @ApiProperty({ description: 'Entity identifier' })
  @IsString()
  entityId: string;

  @ApiProperty({ description: 'Organization identifier' })
  @IsString()
  organizationId: string;

  @ApiProperty({ description: 'Environment identifier' })
  @IsString()
  environmentId: string;

  @ApiProperty({ description: 'User identifier', nullable: true })
  @IsOptional()
  @IsString()
  userId?: string | null;

  @ApiProperty({ description: 'External subscriber identifier', nullable: true })
  @IsOptional()
  @IsString()
  externalSubscriberId?: string | null;

  @ApiProperty({ description: 'Subscriber identifier', nullable: true })
  @IsOptional()
  @IsString()
  subscriberId?: string | null;
}

export class GetRequestResponseDto {
  @ApiProperty({ description: 'Request details', type: RequestLogResponseDto })
  @Type(() => RequestLogResponseDto)
  request: RequestLogResponseDto;

  @ApiProperty({ description: 'Associated traces', type: [TraceResponseDto] })
  @Type(() => TraceResponseDto)
  traces: TraceResponseDto[];
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class TraceResponseDto
- export class GetRequestResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/dtos/get-requests.dto.ts
Tamao: 2615 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { Transform, Type } from 'class-transformer';
import { IsArray, IsNumber, IsOptional, IsString, Matches, Max, MaxLength, Min } from 'class-validator';

// Custom transformer to convert statusCodes to array of numbers
const StatusCodesTransformer = Transform(({ value }) => {
  if (!value) return undefined;

  // If already an array of numbers, return as is
  if (Array.isArray(value) && value.every((item) => typeof item === 'number')) {
    return value;
  }

  // If array of strings/mixed, convert each to number
  if (Array.isArray(value)) {
    return value.map((item) => parseInt(String(item), 10)).filter((num) => !Number.isNaN(num));
  }

  // If string with comma-separated values
  if (typeof value === 'string' && value.includes(',')) {
    return value
      .split(',')
      .map((item) => parseInt(item.trim(), 10))
      .filter((num) => !Number.isNaN(num));
  }

  // If single string or number
  const num = parseInt(String(value), 10);

  return Number.isNaN(num) ? undefined : [num];
});

export class GetRequestsDto {
  @ApiPropertyOptional({
    description: 'Page number for pagination',
    minimum: 0,
    maximum: 100,
  })
  @IsNumber()
  @IsOptional()
  @Type(() => Number)
  @Min(0)
  @Max(100)
  page?: number;

  @ApiPropertyOptional({
    description: 'Number of items per page',
    minimum: 1,
    maximum: 100,
  })
  @IsNumber()
  @IsOptional()
  @Type(() => Number)
  @Min(1)
  @Max(100)
  limit?: number;

  @ApiPropertyOptional({
    description: 'Filter by HTTP status codes',
    type: [Number],
    example: [200, 404, 500],
  })
  @IsOptional()
  @StatusCodesTransformer
  @IsArray()
  @IsNumber({}, { each: true })
  @Min(100, { each: true })
  @Max(599, { each: true })
  statusCodes?: number[];

  @ApiPropertyOptional({
    description: 'Filter by URL pattern',
    maxLength: 500,
  })
  @IsString()
  @IsOptional()
  @MaxLength(500)
  @Matches(/^[a-zA-Z0-9\-._~:/?#[\]@!$&"()*+,;=%]*$/, {
    message: 'URL pattern contains invalid characters',
  })
  urlPattern?: string;

  @ApiPropertyOptional({
    description: 'Filter by transaction identifier',
    maxLength: 100,
  })
  @IsString()
  @IsOptional()
  @MaxLength(100)
  transactionId?: string;

  @ApiPropertyOptional({
    description: 'Filter requests created after this timestamp (Unix timestamp)',
    minimum: 0,
    example: 1640995200,
  })
  @IsOptional()
  @Type(() => Number)
  @IsNumber({}, { message: 'createdGte must be a valid timestamp' })
  @Min(0, { message: 'createdGte must be a positive timestamp' })
  createdGte?: number;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - StatusCodesTransformer(Transform(({ value }))
 - num(parseInt(String(value), 10);

  return Number.isNaN(num) ? undefined : [num];
});

export class GetR...)
Declaraciones 'export' encontradas:
- export class GetRequestsDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/dtos/get-requests.response.dto.ts
Tamao: 2428 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsNumber, IsOptional, IsString } from 'class-validator';

export class RequestLogResponseDto {
  @ApiProperty({ description: 'Request log identifier' })
  @IsString()
  id: string;

  @ApiProperty({ description: 'Creation timestamp' })
  @IsString()
  createdAt: string;

  @ApiProperty({ description: 'Request URL' })
  @IsString()
  url: string;

  @ApiProperty({ description: 'URL pattern' })
  @IsString()
  urlPattern: string;

  @ApiProperty({ description: 'HTTP method' })
  @IsString()
  method: string;

  @ApiProperty({ description: 'HTTP status code' })
  @IsNumber()
  statusCode: number;

  @ApiProperty({ description: 'Request path' })
  @IsString()
  path: string;

  @ApiProperty({ description: 'Request hostname' })
  @IsString()
  hostname: string;

  @ApiPropertyOptional({ description: 'Transaction identifier', nullable: true })
  @IsOptional()
  @IsString()
  transactionId: string | null;

  @ApiProperty({ description: 'Client IP address' })
  @IsString()
  ip: string;

  @ApiProperty({ description: 'User agent string' })
  @IsString()
  userAgent: string;

  @ApiProperty({ description: 'Request body' })
  @IsString()
  requestBody: string;

  @ApiProperty({ description: 'Response body' })
  @IsString()
  responseBody: string;

  @ApiProperty({ description: 'User identifier' })
  @IsString()
  userId: string;

  @ApiProperty({ description: 'Organization identifier' })
  @IsString()
  organizationId: string;

  @ApiProperty({ description: 'Environment identifier' })
  @IsString()
  environmentId: string;

  @ApiProperty({ description: 'Authentication type' })
  @IsString()
  authType: string;

  @ApiProperty({ description: 'Request duration in milliseconds' })
  @IsNumber()
  durationMs: number;
}

export class GetRequestsResponseDto {
  @ApiProperty({ description: 'Request log data', type: [RequestLogResponseDto] })
  @Type(() => RequestLogResponseDto)
  data: RequestLogResponseDto[]; // todo not reuse the get request response dto, instead make it leaner

  @ApiProperty({ description: 'Total number of requests' })
  @IsNumber()
  total: number;

  @ApiPropertyOptional({ description: 'Page size' })
  @IsOptional()
  @IsNumber()
  pageSize?: number;

  @ApiPropertyOptional({ description: 'Current page number' })
  @IsOptional()
  @IsNumber()
  page?: number;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class RequestLogResponseDto
- export class GetRequestsResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/dtos/shared.dto.ts
Tamao: 2903 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { DeliveryLifecycleStatusEnum, SeverityLevelEnum } from '@novu/shared';
import { IsArray, IsBoolean, IsEnum, IsIn, IsOptional, IsString } from 'class-validator';

export enum WorkflowRunStatusDtoEnum {
  PROCESSING = 'processing',
  COMPLETED = 'completed',
  ERROR = 'error',
}

export class GetWorkflowRunResponseBaseDto {
  @ApiProperty({ description: 'Workflow run id' })
  @IsString()
  id: string;

  @ApiProperty({ description: 'Workflow identifier' })
  @IsString()
  workflowId: string;

  @ApiProperty({ description: 'Workflow name' })
  @IsString()
  workflowName: string;

  @ApiProperty({ description: 'Organization identifier' })
  @IsString()
  organizationId: string;

  @ApiProperty({ description: 'Environment identifier' })
  @IsString()
  environmentId: string;

  @ApiProperty({ description: 'Internal subscriber identifier' })
  @IsString()
  internalSubscriberId: string;

  @ApiPropertyOptional({ description: 'External subscriber identifier' })
  @IsOptional()
  @IsString()
  subscriberId?: string;

  @ApiProperty({
    description: 'Workflow run status',
    enum: WorkflowRunStatusDtoEnum,
  })
  @IsIn(Object.values(WorkflowRunStatusDtoEnum))
  status: WorkflowRunStatusDtoEnum;

  @ApiProperty({
    description: 'Workflow run delivery lifecycle status',
    enum: DeliveryLifecycleStatusEnum,
  })
  @IsIn(Object.values(DeliveryLifecycleStatusEnum))
  deliveryLifecycleStatus: DeliveryLifecycleStatusEnum;

  @ApiProperty({ description: 'Trigger identifier' })
  @IsString()
  triggerIdentifier: string;

  @ApiProperty({ description: 'Transaction identifier' })
  @IsString()
  transactionId: string;

  @ApiProperty({ description: 'Creation timestamp' })
  @IsString()
  createdAt: string;

  @ApiProperty({ description: 'Update timestamp' })
  @IsString()
  updatedAt: string;

  @ApiProperty({ description: 'Severity', enum: SeverityLevelEnum })
  @IsEnum(SeverityLevelEnum)
  severity: SeverityLevelEnum;

  @ApiProperty({ description: 'Critical flag' })
  @IsBoolean()
  critical: boolean;

  @ApiPropertyOptional({ description: 'Contexts (keys) in which the workflow run was executed', type: [String] })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  contextKeys?: string[];
}

export enum ReportTypeEnum {
  DELIVERY_TREND = 'delivery-trend',
  INTERACTION_TREND = 'interaction-trend',
  WORKFLOW_BY_VOLUME = 'workflow-by-volume',
  PROVIDER_BY_VOLUME = 'provider-by-volume',
  MESSAGES_DELIVERED = 'messages-delivered',
  ACTIVE_SUBSCRIBERS = 'active-subscribers',
  AVG_MESSAGES_PER_SUBSCRIBER = 'avg-messages-per-subscriber',
  WORKFLOW_RUNS_METRIC = 'workflow-runs-metric',
  TOTAL_INTERACTIONS = 'total-interactions',
  WORKFLOW_RUNS_TREND = 'workflow-runs-trend',
  ACTIVE_SUBSCRIBERS_TREND = 'active-subscribers-trend',
  WORKFLOW_RUNS_COUNT = 'workflow-runs-count',
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export class GetWorkflowRunResponseBaseDto
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/dtos/workflow-run-response.dto.ts
Tamao: 3124 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { StepRunStatus } from '@novu/application-generic';
import { ExecutionDetailsStatusEnum } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsDate, IsEnum, IsIn, IsObject, IsOptional, IsString } from 'class-validator';
import { DigestMetadataDto } from '../../notifications/dtos/activities-response.dto';

import { GetWorkflowRunResponseBaseDto } from './shared.dto';

export class StepExecutionDetailDto {
  @ApiProperty({ description: 'Unique identifier of the execution detail' })
  @IsString()
  _id: string;

  @ApiPropertyOptional({ description: 'Creation time of the execution detail' })
  @IsOptional()
  @IsString()
  createdAt?: string;

  @ApiProperty({
    enum: [...Object.values(ExecutionDetailsStatusEnum)],
    enumName: 'ExecutionDetailsStatusEnum',
    description: 'Status of the execution detail',
  })
  @IsEnum(ExecutionDetailsStatusEnum)
  status: ExecutionDetailsStatusEnum;

  @ApiProperty({ description: 'Detailed information about the execution' })
  @IsString()
  detail: string;

  @ApiPropertyOptional({ description: 'Provider identifier' })
  @IsOptional()
  @IsString()
  providerId?: string;

  @ApiPropertyOptional({ description: 'Raw data of the execution' })
  @IsOptional()
  @IsString()
  raw?: string | null;
}

export class StepRunDto {
  @ApiProperty({ description: 'Step run identifier' })
  @IsString()
  stepRunId: string;

  @ApiProperty({ description: 'Step identifier' })
  @IsString()
  stepId: string;

  @ApiProperty({ description: 'Step type' })
  @IsString()
  stepType: string;

  @ApiPropertyOptional({ description: 'Provider identifier' })
  @IsOptional()
  @IsString()
  providerId?: string;

  @ApiProperty({
    description: 'Step status',
    enum: ['pending', 'queued', 'running', 'completed', 'failed', 'delayed', 'canceled', 'merged', 'skipped'],
  })
  @IsIn([
    'pending',
    'queued',
    'running',
    'completed',
    'failed',
    'delayed',
    'canceled',
    'merged',
    'skipped',
  ] satisfies StepRunStatus[])
  status: StepRunStatus;

  @ApiProperty({ description: 'Creation timestamp' })
  @IsDate()
  createdAt: Date;

  @ApiProperty({ description: 'Update timestamp' })
  @IsDate()
  updatedAt: Date;

  @ApiProperty({ description: 'Execution details', type: [StepExecutionDetailDto] })
  @Type(() => StepExecutionDetailDto)
  executionDetails: StepExecutionDetailDto[];

  @ApiPropertyOptional({
    description: 'Optional digest for the job, including metadata and events',
    type: DigestMetadataDto,
  })
  digest?: DigestMetadataDto;

  @ApiPropertyOptional({
    description: 'The number of times the digest/delay job has been extended to align with the subscribers schedule',
    type: Number,
  })
  scheduleExtensionsCount?: number;
}

export class GetWorkflowRunResponseDto extends GetWorkflowRunResponseBaseDto {
  @ApiProperty({ description: 'Step runs', type: [StepRunDto] })
  @Type(() => StepRunDto)
  steps: StepRunDto[];

  @ApiProperty({ description: 'Trigger payload' })
  @IsObject()
  payload: Record<string, unknown>;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class StepExecutionDetailDto
- export class StepRunDto
- export class GetWorkflowRunResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/dtos/workflow-runs-request.dto.ts
Tamao: 1834 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SeverityLevelEnum } from '@novu/shared';
import { Transform, Type } from 'class-transformer';
import { IsArray, IsIn, IsInt, IsISO8601, IsOptional, IsString, Max, Min } from 'class-validator';
import { WorkflowRunStatusDtoEnum } from './shared.dto';

export class GetWorkflowRunsRequestDto {
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  @Max(100)
  limit: number = 10;

  @IsOptional()
  @IsString()
  cursor?: string;

  @IsOptional()
  @Transform(({ value }) => (Array.isArray(value) ? value : [value]))
  @IsArray()
  @IsString({ each: true })
  workflowIds?: string[];

  @IsOptional()
  @Transform(({ value }) => (Array.isArray(value) ? value : [value]))
  @IsArray()
  @IsString({ each: true })
  subscriberIds?: string[];

  @IsOptional()
  @Transform(({ value }) => (Array.isArray(value) ? value : [value]))
  @IsArray()
  @IsString({ each: true })
  transactionIds?: string[];

  @IsOptional()
  @Transform(({ value }) => (Array.isArray(value) ? value : [value]))
  @IsArray()
  @IsString({ each: true })
  @IsIn(Object.values(WorkflowRunStatusDtoEnum), { each: true })
  statuses?: WorkflowRunStatusDtoEnum[];

  @IsOptional()
  @Transform(({ value }) => (Array.isArray(value) ? value : [value]))
  @IsArray()
  @IsString({ each: true })
  channels?: string[];

  @IsOptional()
  @IsString()
  topicKey?: string;

  @IsOptional()
  @IsISO8601()
  createdGte?: string;

  @IsOptional()
  @IsISO8601()
  createdLte?: string;

  @IsOptional()
  @Transform(({ value }) => (Array.isArray(value) ? value : [value]))
  @IsArray()
  @IsString({ each: true })
  @IsIn(Object.values(SeverityLevelEnum), { each: true })
  severity?: SeverityLevelEnum[];

  @IsOptional()
  @Transform(({ value }) => (Array.isArray(value) ? value : [value]))
  @IsArray()
  @IsString({ each: true })
  contextKeys?: string[];
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - number(10;

  @IsOptional()
  @IsString()
  cursor?: string;

  @IsOptional()
  @Transform(({ value }))
Declaraciones 'export' encontradas:
- export class GetWorkflowRunsRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/dtos/workflow-runs-response.dto.ts
Tamao: 1658 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { StepRunStatus } from '@novu/application-generic';
import { Type } from 'class-transformer';
import { IsIn, IsObject, IsOptional, IsString } from 'class-validator';
import { GetWorkflowRunResponseBaseDto } from './shared.dto';

export class WorkflowRunStepsDetailsDto {
  @ApiProperty({ description: 'Step run identifier' })
  @IsString()
  id: string;

  @ApiProperty({ description: 'Step identifier' })
  @IsString()
  stepRunId: string;

  @ApiProperty({ description: 'Step type' })
  @IsString()
  stepType: string;

  @ApiProperty({
    description: 'Step status',
    enum: ['pending', 'queued', 'running', 'completed', 'failed', 'delayed', 'canceled', 'merged', 'skipped'],
  })
  @IsIn([
    'pending',
    'queued',
    'running',
    'completed',
    'failed',
    'delayed',
    'canceled',
    'merged',
    'skipped',
  ] satisfies StepRunStatus[])
  status: StepRunStatus;
}

export class GetWorkflowRunsDto extends GetWorkflowRunResponseBaseDto {
  @ApiProperty({ description: 'Workflow run steps', type: [WorkflowRunStepsDetailsDto] })
  @Type(() => WorkflowRunStepsDetailsDto)
  steps: WorkflowRunStepsDetailsDto[];
}

export class GetWorkflowRunsResponseDto {
  @ApiProperty({ description: 'Workflow runs data', type: [GetWorkflowRunsDto] })
  @Type(() => GetWorkflowRunsDto)
  data: GetWorkflowRunsDto[];

  @ApiPropertyOptional({ description: 'Next cursor for pagination' })
  @IsOptional()
  @IsString()
  next: string | null;

  @ApiPropertyOptional({ description: 'Previous cursor for pagination' })
  @IsOptional()
  @IsString()
  previous: string | null;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowRunStepsDetailsDto
- export class GetWorkflowRunsDto
- export class GetWorkflowRunsResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/e2e/get-requests.e2e.ts
Tamao: 8560 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { LogRepository, RequestLog, RequestLogRepository } from '@novu/application-generic';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { format, isAfter, subHours } from 'date-fns';
import { generateTransactionId } from '../../shared/helpers';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';
import { RequestLogResponseDto } from '../dtos/get-requests.response.dto';

describe('Activity - /activity/requests (GET) #novu-v2', () => {
  let session: UserSession;
  let novuClient: Novu;
  let requestLogRepository: RequestLogRepository;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);
    requestLogRepository = session.testServer?.getService(RequestLogRepository);
  });

  it('should return a list of http logs', async () => {
    const requestLog: Omit<RequestLog, 'id' | 'expires_at'> = {
      user_id: session.user._id,
      environment_id: session.environment._id,
      organization_id: session.organization._id,
      transaction_id: generateTransactionId(),
      status_code: 200,
      created_at: format(new Date(), 'yyyy-MM-dd HH:mm:ss') as any,
      path: '/test-path',
      url: '/test-url',
      url_pattern: '/test-url-pattern/:id',
      hostname: 'localhost',
      method: 'GET',
      ip: '127.0.0.1',
      user_agent: 'test-agent',
      request_body: '{}',
      response_body: '{}',
      auth_type: 'ApiKey',
      duration_ms: 42,
    };

    await requestLogRepository.createMany([requestLog, requestLog], {
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      userId: session.user._id,
    });

    const { body } = await session.testAgent.get('/v1/activity/requests').expect(200);

    expect(body.data.length).to.be.equal(2);
    expect(body.total).to.be.equal(2);
    expect(body.pageSize).to.be.equal(10);

    const expectedLog = normalizeRequestLogForTesting({
      id: 'req_123',
      createdAt: new Date(`${requestLog.created_at} UTC`).toISOString(),
      method: requestLog.method,
      path: requestLog.path,
      transactionId: requestLog.transaction_id,
      requestBody: requestLog.request_body,
      responseBody: requestLog.response_body,
      url: requestLog.url,
      urlPattern: requestLog.url_pattern,
      hostname: requestLog.hostname,
      ip: requestLog.ip,
      userAgent: requestLog.user_agent,
      authType: requestLog.auth_type,
      durationMs: requestLog.duration_ms,
      userId: requestLog.user_id,
      organizationId: requestLog.organization_id,
      environmentId: requestLog.environment_id,
      statusCode: requestLog.status_code,
    });
    const responseLog = normalizeRequestLogForTesting(body.data[0]);
    expect(responseLog).to.deep.equal(expectedLog);
  });

  it('should filter http logs by url, transaction id, and created time', async () => {
    const baseRequestLog: Omit<RequestLog, 'id' | 'expires_at' | 'status_code' | 'url'> = {
      user_id: session.user._id,
      environment_id: session.environment._id,
      organization_id: session.organization._id,
      transaction_id: generateTransactionId(),
      created_at: format(new Date(), 'yyyy-MM-dd HH:mm:ss') as any,
      path: '/test-path',
      url_pattern: '/test-url-pattern/:id',
      hostname: 'localhost',
      method: 'GET',
      ip: '127.0.0.1',
      user_agent: 'test-agent',
      request_body: '{}',
      response_body: '{}',
      auth_type: 'ApiKey',
      duration_ms: 42,
    };

    // Create logs with different status codes, URLs, transaction IDs, and timestamps
    const transactionId1 = generateTransactionId();
    const transactionId2 = generateTransactionId();
    const currentTime = new Date();
    const threeHoursAgo = subHours(currentTime, 3);

    const log200Api = {
      ...baseRequestLog,
      status_code: 200,
      url: '/api/workflows',
      transaction_id: transactionId1,
      created_at: LogRepository.formatDateTime64(currentTime) as any,
    };
    const log404Api = {
      ...baseRequestLog,
      status_code: 404,
      url: '/api/notifications',
      transaction_id: transactionId1,
      created_at: LogRepository.formatDateTime64(currentTime) as any,
    };
    const log500Api = {
      ...baseRequestLog,
      status_code: 500,
      url: '/api/users',
      transaction_id: transactionId2,
      created_at: LogRepository.formatDateTime64(threeHoursAgo) as any,
    };
    const log200Auth = {
      ...baseRequestLog,
      status_code: 200,
      url: '/auth/login',
      transaction_id: transactionId2,
      created_at: LogRepository.formatDateTime64(threeHoursAgo) as any,
    };

    await requestLogRepository.createMany([log200Api, log404Api, log500Api, log200Auth], {
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      userId: session.user._id,
    });

    // Test 1: Filter by status codes 200 and 404
    const statusFilterResponse = await session.testAgent
      .get('/v1/activity/requests')
      .query({ statusCodes: [200, 404] })
      .expect(200);

    expect(statusFilterResponse.body.data.length, 'statusFilterResponse.body.data.length').to.be.equal(3);
    expect(statusFilterResponse.body.total, 'statusFilterResponse.body.total').to.be.equal(3);

    const statusCodes = statusFilterResponse.body.data.map((log: RequestLogResponseDto) => log.statusCode);
    expect(statusCodes.length, 'statusCodes.length').to.be.equal(3);
    expect(statusCodes, 'statusCodes').to.include.members([200, 404]);

    // Test 2: Filter by URL containing 'api'
    const urlFilterResponse = await session.testAgent.get('/v1/activity/requests').query({ url: 'api' }).expect(200);

    expect(urlFilterResponse.body.data.length, 'urlFilterResponse.body.data.length').to.be.equal(3);
    expect(urlFilterResponse.body.total, 'urlFilterResponse.body.total').to.be.equal(3);

    const urls = urlFilterResponse.body.data.map((log: RequestLogResponseDto) => log.url);
    urls.forEach((url: string) => {
      expect(url).to.include('api');
    });

    // Test 3: Combine filters - status codes 200,404 AND URL containing 'workflows'
    const combinedFilterResponse = await session.testAgent
      .get('/v1/activity/requests')
      .query({ statusCodes: [200, 404], url: 'workflows' })
      .expect(200);

    expect(combinedFilterResponse.body.data.length).to.be.equal(1);
    expect(combinedFilterResponse.body.total).to.be.equal(1);

    const combinedResult = combinedFilterResponse.body.data[0];
    expect(combinedResult.statusCode).to.be.equal(200);
    expect(combinedResult.url).to.include('workflows');

    // Test 4: Filter by transaction ID
    const transactionFilterResponse = await session.testAgent
      .get('/v1/activity/requests')
      .query({ transactionId: transactionId1 })
      .expect(200);

    expect(transactionFilterResponse.body.data.length).to.be.equal(2);
    expect(transactionFilterResponse.body.total).to.be.equal(2);

    const transactionIds = transactionFilterResponse.body.data.map((log: RequestLogResponseDto) => log.transactionId);
    transactionIds.forEach((txId: string) => {
      expect(txId).to.be.equal(transactionId1);
    });

    // Verify the correct logs are returned for transactionId1
    const returnedStatusCodes = transactionFilterResponse.body.data.map((log: RequestLogResponseDto) => log.statusCode);
    expect(returnedStatusCodes).to.include.members([200, 404]);

    // Test 5: Filter by createdGte (last 2 hours) - should only return recent logs
    const twoHoursAgoTimestamp = subHours(currentTime, 2).getTime();
    const createdFilterResponse = await session.testAgent
      .get('/v1/activity/requests')
      .query({ createdGte: twoHoursAgoTimestamp })
      .expect(200);

    expect(createdFilterResponse.body.data.length).to.be.equal(2);
    expect(createdFilterResponse.body.total).to.be.equal(2);

    // Verify only recent logs (within last 2 hours) are returned
    const recentCreatedAt = createdFilterResponse.body.data.map(
      (log: RequestLogResponseDto) => new Date(log.createdAt)
    );
    const twoHoursAgo = subHours(currentTime, 2);
    expect(isAfter(recentCreatedAt[0], twoHoursAgo)).to.be.true;
    expect(isAfter(recentCreatedAt[1], twoHoursAgo)).to.be.true;
  });
});

function normalizeRequestLogForTesting(requestLog: RequestLogResponseDto): Omit<RequestLogResponseDto, 'id'> {
  const { id, ...rest } = requestLog;

  return rest;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - normalizeRequestLogForTesting(requestLog: RequestLogResponseDto)
Asignaciones con arrow functions encontradas (posibles funciones):
 - requestLogRepository(session.testServer?.getService(RequestLogRepository);
  });

  it('should return a list of http logs...)
 - responseLog(normalizeRequestLogForTesting(body.data[0]);
    expect(responseLog).to.deep.equal(expectedLog);
  }...)
 - statusCodes(statusFilterResponse.body.data.map((log: RequestLogResponseDto))
 - urls(urlFilterResponse.body.data.map((log: RequestLogResponseDto))
 - transactionIds(transactionFilterResponse.body.data.map((log: RequestLogResponseDto))
 - returnedStatusCodes(transactionFilterResponse.body.data.map((log: RequestLogResponseDto))
 - recentCreatedAt(createdFilterResponse.body.data.map(
      (log: RequestLogResponseDto))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/e2e/get-workflow-run.e2e.ts
Tamao: 3536 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { WorkflowRunRepository } from '@novu/application-generic';
import { NotificationTemplateEntity, SubscriberEntity } from '@novu/dal';
import { EmailBlockTypeEnum, StepTypeEnum } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Workflow Run - GET /v1/activity/workflow-runs/:workflowRunId #novu-v2', () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;
  let novuClient: Novu;
  let workflowRunRepository: WorkflowRunRepository;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
    novuClient = initNovuClassSdk(session);
    workflowRunRepository = session.testServer?.getService(WorkflowRunRepository);

    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.EMAIL,
          subject: 'Test subject',
          content: [{ type: EmailBlockTypeEnum.TEXT, content: 'Hello {{firstName}}' }],
        },
        {
          type: StepTypeEnum.IN_APP,
          content: 'In-app notification for {{firstName}}',
        },
      ],
    });
  });

  it('should return workflow run details by ID', async () => {
    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [subscriber.subscriberId, '123'],
      payload: { firstName: 'John' },
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    const workflowRun = await workflowRunRepository.findOne({
      where: {
        enforced: { environmentId: session.environment._id },
        conditions: [
          { field: 'organization_id', operator: '=', value: session.organization._id },
          { field: 'subscriber_id', operator: '=', value: subscriber._id },
        ],
      },
      select: '*',
    });

    const workflowRunId = workflowRun?.data?.workflow_run_id;

    const { body } = await session.testAgent.get(`/v1/activity/workflow-runs/${workflowRunId}`).expect(200);
    const { data } = body;

    expect(data.id, 'response workflow run id').to.equal(workflowRunId);
    expect(data.subscriberId, 'response subscriber id').to.equal(subscriber.subscriberId);
    expect(data.organizationId, 'response organization id').to.equal(session.organization._id);
    expect(data.environmentId, 'response environment id').to.equal(session.environment._id);
    expect(data.steps.length, 'response steps count').to.be.greaterThan(0);

    const triggerSteps = data.steps.filter((step: any) => step.stepType === 'trigger');
    expect(triggerSteps.length, 'should have exactly one trigger step').to.equal(1);

    const triggerStepRunTraces = data.steps[0].executionDetails;
    expect(triggerStepRunTraces.length, 'response step execution details count').to.be.greaterThan(0);
    expect(triggerStepRunTraces[0].detail, 'response step execution details status').to.equal('Step queued');
  });

  it('should return 404 for non-existent workflow run', async () => {
    const nonExistentId = 'non-existent-workflow-run-id';

    await session.testAgent.get(`/v1/activity/workflow-runs/${nonExistentId}`).expect(404);
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - template(await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.EMAIL,
        ...)
 - triggerSteps(data.steps.filter((step: any))
 - triggerStepRunTraces(data.steps[0].executionDetails;
    expect(triggerStepRunTraces.length, 'response step execution det...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/e2e/get-workflow-runs.e2e.ts
Tamao: 24412 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { ClickHouseService, WorkflowRunRepository, WorkflowRunStatusEnum } from '@novu/application-generic';
import { NotificationEntity, NotificationRepository, NotificationTemplateEntity, SubscriberEntity } from '@novu/dal';
import { EmailBlockTypeEnum, StepTypeEnum } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { sleep } from '../../events/e2e/utils/sleep.util';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';
import { GetWorkflowRunsResponseDto } from '../dtos/workflow-runs-response.dto';
import { WorkflowRunStatusDtoEnum } from '../dtos/shared.dto';

describe('Workflow Runs Filtering & Pagination - GET /v1/activity/workflow-runs #novu-v2', () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let inAppWorkflow: NotificationTemplateEntity;
  let emailTemplate: NotificationTemplateEntity;
  let inAppTemplate: NotificationTemplateEntity;
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;
  let novuClient: Novu;
  let workflowRunRepository: WorkflowRunRepository;
  const clickHouseService = new ClickHouseService();

  // Helper function to create multiple workflow triggers with 5ms delay between each
  async function createMultipleWorkflowRuns(options: {
    count: number;
    workflowId: string;
    subscriberId: string[];
    payloadTemplate?: (index: number) => Record<string, any>;
    transactionId?: string;
  }) {
    const { count, workflowId, subscriberId, payloadTemplate, transactionId } = options;

    for (let i = 1; i < count + 1; i += 1) {
      await novuClient.trigger({
        workflowId,
        to: subscriberId,
        payload: payloadTemplate ? payloadTemplate(i) : { runNumber: i },
        ...(transactionId && { transactionId: `${transactionId}-${i}` }),
      });

      await sleep(5);
    }
  }

  async function createMultipleWorkflowRunsByDb(options: {
    count: number;
    subscriberId: string[];
    payloadTemplate?: (index: number) => Record<string, any>;
    transactionId?: string;
    status?: WorkflowRunStatusEnum;
    channels?: StepTypeEnum[];
  }) {
    const {
      count,
      subscriberId,
      payloadTemplate,
      transactionId,
      status = WorkflowRunStatusEnum.COMPLETED,
      channels = [StepTypeEnum.EMAIL],
    } = options;

    const promises: Promise<void>[] = [];

    for (let i = 1; i < count + 1; i += 1) {
      const payload = payloadTemplate ? payloadTemplate(i) : { runNumber: i };

      // Create a mock NotificationEntity
      const mockNotification: NotificationEntity = {
        _id: NotificationRepository.createObjectId(),
        _templateId: template._id,
        _environmentId: session.environment._id,
        _organizationId: session.organization._id,
        _subscriberId: subscriber._id,
        topics: [],
        transactionId: transactionId ? `${transactionId}-${i}` : `txn_${Date.now()}_${i}`,
        channels,
        to: subscriberId[0],
        payload,
        controls: undefined,
        tags: [],
        createdAt: new Date().toISOString(),
      };

      promises.push(
        workflowRunRepository.create(mockNotification, template, {
          status,
          userId: session.user._id,
          externalSubscriberId: subscriberId[0],
        })
      );
    }

    await Promise.all(promises);
  }

  beforeEach(async () => {
    await clickHouseService.init();

    // Enable workflow run logs writing for testing
    (process.env as any).IS_WORKFLOW_RUN_LOGS_WRITE_ENABLED = 'true';

    session = new UserSession();
    await session.initialize();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
    novuClient = initNovuClassSdk(session);
    workflowRunRepository = session.testServer?.getService(WorkflowRunRepository);

    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.EMAIL,
          subject: 'Test subject',
          content: [{ type: EmailBlockTypeEnum.TEXT, content: 'Hello {{firstName}}' }],
        },
      ],
    });

    inAppWorkflow = await session.createTemplate({
      name: 'In App Workflow',
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'In-app notification content {{firstName}}',
        },
      ],
    });

    emailTemplate = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.EMAIL,
          subject: 'Email workflow subject',
          content: [{ type: EmailBlockTypeEnum.TEXT, content: 'Email workflow content {{firstName}}' }],
        },
      ],
    });

    inAppTemplate = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'In-app notification content {{firstName}}',
        },
      ],
    });
  });

  afterEach(() => {
    // Clean up environment variable after each test
    delete (process.env as any).IS_WORKFLOW_RUN_LOGS_WRITE_ENABLED;
  });

  it('should return paginated results with default limit', async () => {
    // will generate 6 workflow runs with 2 subscribers, total of 12 workflow runs
    await createMultipleWorkflowRuns({
      count: 6,
      workflowId: template.triggers[0].identifier,
      subscriberId: [subscriber.subscriberId, '123'],
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    // Force ClickHouse merge to deduplicate workflow runs
    const databaseName = process.env.CLICK_HOUSE_DATABASE || 'test_logs';
    await clickHouseService.exec({
      query: `OPTIMIZE TABLE ${databaseName}.workflow_runs FINAL`,
    });

    const { body: firstPage }: { body: GetWorkflowRunsResponseDto } = await session.testAgent
      .get('/v1/activity/workflow-runs')
      .expect(200);

    expect(firstPage.next, 'firstPage next').to.be.not.null;
    expect(firstPage.previous, 'firstPage previous').to.be.null;
    expect(firstPage.data.length, 'firstPage dataLength').to.be.equal(10);

    const { body: secondPage }: { body: GetWorkflowRunsResponseDto } = await session.testAgent
      .get('/v1/activity/workflow-runs')
      .query({ cursor: firstPage.next })
      .expect(200);

    expect(secondPage.next, 'secondPage next').to.be.null;
    expect(secondPage.previous, 'secondPage previous').to.be.not.null;
    expect(secondPage.data.length, 'secondPage dataLength').to.be.equal(2);

    const secondPageWorkflowRun = await workflowRunRepository.findOne({
      where: {
        enforced: { environmentId: session.environment._id },
        conditions: [{ field: 'workflow_run_id', operator: '=', value: secondPage.data[0].id }],
      },
      select: '*',
    });
    expect(secondPageWorkflowRun, 'secondPageWorkflowRun should exist').to.not.be.null;
    expect(secondPageWorkflowRun.data, 'secondPageWorkflowRun.data should exist').to.not.be.undefined;
    expect(JSON.parse(secondPageWorkflowRun.data.payload || '{}')?.runNumber, 'secondPage runNumber').to.be.equal(1);

    expect(firstPage.data[0].steps, 'workflow run should have steps').to.be.an('array');
    if (firstPage.data[0].steps.length > 0) {
      const step = firstPage.data[0].steps[0];
      expect(step.id.startsWith('sr_'), 'step id should start with sr_').to.be.true;
      expect(step.stepType, 'step should have step type').to.be.equal('trigger');
      expect(step.status, 'step should have status').to.be.equal('completed');
    }
  });

  it('should validate cursor-based pagination collision handling', async () => {
    await createMultipleWorkflowRunsByDb({
      count: 11,
      subscriberId: [subscriber.subscriberId],
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    const fetchedRunNumbers = new Set<number>();
    const forwardPages: Array<{
      pageNumber: number;
      orderedIds: string[];
      transactionIds: string[];
      next: string | null;
      previous: string | null;
    }> = [];
    let cursor: string | null = null;
    let totalFetched = 0;
    let pageCount = 0;

    // Go forward through all pages and store detailed page information
    do {
      const query: any = { limit: 2 };
      if (cursor) {
        query.cursor = cursor;
      }

      const { body } = await session.testAgent.get('/v1/activity/workflow-runs').query(query).expect(200);

      pageCount += 1;
      const currentPageNumber = pageCount;

      // Store page data with ordered IDs for later comparison
      const orderedIds = body.data.map((item: any) => item.id);
      const transactionIds = body.data.map((item: any) => item.transactionId);
      forwardPages.push({
        pageNumber: currentPageNumber,
        orderedIds,
        transactionIds,
        next: body.next,
        previous: body.previous,
      });

      expect(body.data).to.be.an('array');
      expect(body.data.length).to.be.at.least(1);
      expect(body.data.length).to.be.at.most(2);

      // Check for duplicates and collect runNumbers
      for (const workflowRun of body.data) {
        const workflowRunEntity = await workflowRunRepository.findOne({
          where: {
            enforced: { environmentId: session.environment._id },
            conditions: [{ field: 'workflow_run_id', operator: '=', value: workflowRun.id }],
          },
          select: '*',
        });
        expect(workflowRunEntity, 'workflowRunEntity should exist').to.not.be.null;
        expect(workflowRunEntity.data, 'workflowRunEntity.data should exist').to.not.be.undefined;
        const runNumber = JSON.parse(workflowRunEntity.data.payload || '{}')?.runNumber;
        expect(fetchedRunNumbers.has(runNumber), `Duplicate runNumber ${runNumber} found on page ${currentPageNumber}`)
          .to.be.false;
        fetchedRunNumbers.add(runNumber);
      }

      totalFetched += body.data.length;
      cursor = body.next;

      // Validate cursor logic - next indicates if there are more results
      if (cursor) {
        expect(cursor, `next should be a valid string when there are more results on page ${pageCount}`).to.be.a(
          'string'
        );
      } else {
        expect(cursor, `next should be null when there are no more results on page ${pageCount}`).to.be.null;
      }
    } while (cursor);

    // Validate we fetched all 11 workflow runs
    expect(totalFetched, 'Total fetched workflow runs').to.equal(11);
    expect(fetchedRunNumbers.size, 'Unique runNumbers fetched').to.equal(11);

    // Validate we have runNumbers 1 through 11
    for (let i = 1; i <= 11; i += 1) {
      expect(fetchedRunNumbers.has(i), `runNumber ${i} should be present`).to.be.true;
    }

    // Test bidirectional pagination: Navigate backwards through ALL pages
    const lastPage = forwardPages[forwardPages.length - 1];
    expect(lastPage.previous, 'Last page should have previous').to.be.not.null;

    // Navigate backwards through all pages and validate they match forward pages exactly
    let backwardCursor = lastPage.previous;
    let backwardPageIndex = forwardPages.length - 2; // Start from second-to-last page

    while (backwardCursor && backwardPageIndex >= 0) {
      const { body: backwardPageResult } = await session.testAgent
        .get('/v1/activity/workflow-runs')
        .query({ cursor: backwardCursor, limit: 2 })
        .expect(200);

      const correspondingForwardPage = forwardPages[backwardPageIndex];
      const backwardOrderedIds = backwardPageResult.data.map((item: any) => item.id);

      // Validate exact same items in exact same order
      expect(backwardPageResult.data.length, `Backward page ${backwardPageIndex + 1} should have same length`).to.equal(
        correspondingForwardPage.orderedIds.length
      );

      expect(
        backwardOrderedIds,
        `Backward page ${backwardPageIndex + 1} IDs should match forward page exactly`
      ).to.deep.equal(correspondingForwardPage.orderedIds);

      // Validate runNumbers match in exact order (no sorting, preserve original order)
      const backwardRunNumbers = backwardPageResult.data.map((item: any) => item.transactionId);
      const forwardRunNumbers = correspondingForwardPage.transactionIds;

      expect(
        backwardRunNumbers,
        `Backward page ${backwardPageIndex + 1} runNumbers should match forward page order`
      ).to.deep.equal(forwardRunNumbers);

      // Validate cursor properties
      if (backwardPageIndex > 0) {
        expect(backwardPageResult.previous, `Backward page ${backwardPageIndex + 1} should have previous`).to.be.not
          .null;
      } else {
        expect(backwardPageResult.previous, `First page (backward) should have null previous`).to.be.null;
      }

      expect(backwardPageResult.next, `Backward page ${backwardPageIndex + 1} should have next`).to.be.not.null;

      // Move to previous page
      backwardCursor = backwardPageResult.previous;
      backwardPageIndex -= 1;
    }

    // Validate we reached the beginning (first page should have null previous)
    expect(backwardPageIndex, 'Should have navigated through all pages backwards').to.equal(-1);

    /*
     * Test that we can navigate forward again from any backward page
     * Test from the middle page for comprehensive validation
     */
    const middlePageIndex = Math.floor(forwardPages.length / 2);
    const middlePage = forwardPages[middlePageIndex];

    if (middlePage.next) {
      const { body: forwardFromMiddleResult } = await session.testAgent
        .get('/v1/activity/workflow-runs')
        .query({ cursor: middlePage.next, limit: 2 })
        .expect(200);

      const nextPageFromMiddle = forwardPages[middlePageIndex + 1];
      const forwardFromMiddleIds = forwardFromMiddleResult.data.map((item: any) => item.id);

      expect(forwardFromMiddleIds, 'Forward navigation from middle should match original forward page').to.deep.equal(
        nextPageFromMiddle.orderedIds
      );
    }
  });

  it('should filter results by single workflowId', async () => {
    const secondTemplate = await session.createTemplate({
      steps: [{ type: StepTypeEnum.IN_APP, content: 'Test in-app message' }],
    });

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: subscriber.subscriberId,
      payload: { firstName: 'John' },
    });

    await novuClient.trigger({
      workflowId: secondTemplate.triggers[0].identifier,
      to: subscriber.subscriberId,
      payload: { firstName: 'Jane' },
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    const { body } = await session.testAgent
      .get('/v1/activity/workflow-runs')
      .query({ workflowIds: [template._id] })
      .expect(200);

    expect(body.data).to.be.an('array');

    for (const workflowRun of body.data) {
      expect(workflowRun.workflowId).to.equal(template._id);
      expect(workflowRun.steps, 'workflow run should have steps').to.be.an('array');
    }
  });

  it('should filter results by multiple workflowIds', async () => {
    const secondTemplate = await session.createTemplate({
      steps: [{ type: StepTypeEnum.IN_APP, content: 'Test in-app message' }],
    });

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: subscriber.subscriberId,
      payload: { firstName: 'John' },
    });

    await novuClient.trigger({
      workflowId: secondTemplate.triggers[0].identifier,
      to: subscriber.subscriberId,
      payload: { firstName: 'Jane' },
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    const { body } = await session.testAgent
      .get('/v1/activity/workflow-runs')
      .query({ workflowIds: [template._id, secondTemplate._id] })
      .expect(200);

    expect(body.data).to.be.an('array');

    const allowedIds = [template._id, secondTemplate._id];
    for (const workflowRun of body.data) {
      expect(allowedIds).to.include(workflowRun.workflowId);
    }
  });

  it('should filter results by single subscriberId', async () => {
    const secondSubscriber = await subscriberService.createSubscriber();

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: subscriber.subscriberId,
      payload: { firstName: 'John' },
    });

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: secondSubscriber.subscriberId,
      payload: { firstName: 'Jane' },
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    const { body } = await session.testAgent
      .get('/v1/activity/workflow-runs')
      .query({ subscriberIds: [subscriber.subscriberId] })
      .expect(200);

    expect(body.data).to.be.an('array');

    for (const workflowRun of body.data) {
      expect(workflowRun.subscriberId).to.equal(subscriber.subscriberId);
    }
  });

  it('should filter results by transactionId', async () => {
    const customTransactionId = `test-transaction-${Date.now()}`;

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: subscriber.subscriberId,
      payload: { firstName: 'John' },
      transactionId: customTransactionId,
    });

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: subscriber.subscriberId,
      payload: { firstName: 'Jane' },
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    const { body } = await session.testAgent
      .get('/v1/activity/workflow-runs')
      .query({ transactionIds: [customTransactionId] })
      .expect(200);

    expect(body.data).to.be.an('array');

    for (const workflowRun of body.data) {
      expect(workflowRun.transactionId).to.equal(customTransactionId);
    }
  });

  it('should filter results by status', async () => {
    await createMultipleWorkflowRunsByDb({
      count: 2,
      subscriberId: [subscriber.subscriberId],
      status: WorkflowRunStatusEnum.COMPLETED,
    });
    await createMultipleWorkflowRunsByDb({
      count: 1,
      subscriberId: [subscriber.subscriberId],
      status: WorkflowRunStatusEnum.ERROR,
    });

    const { body } = await session.testAgent
      .get('/v1/activity/workflow-runs')
      .query({ statuses: [WorkflowRunStatusDtoEnum.COMPLETED] })
      .expect(200);

    expect(body.data.length).to.be.equal(2);

    for (const workflowRun of body.data) {
      expect(workflowRun.status).to.equal(WorkflowRunStatusDtoEnum.COMPLETED);
    }
  });

  it('should filter results by date range', async () => {
    await createMultipleWorkflowRuns({
      count: 2,
      workflowId: template.triggers[0].identifier,
      subscriberId: [subscriber.subscriberId],
      payloadTemplate: (index) => ({ testText: `first trigger ${index}` }),
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    const beforeTrigger = new Date();

    await createMultipleWorkflowRuns({
      count: 2,
      workflowId: template.triggers[0].identifier,
      subscriberId: [subscriber.subscriberId],
      payloadTemplate: (index) => ({ testText: `second trigger ${index}` }),
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    const afterTrigger = new Date();

    await createMultipleWorkflowRuns({
      count: 2,
      workflowId: template.triggers[0].identifier,
      subscriberId: [subscriber.subscriberId],
      payloadTemplate: (index) => ({ testText: `third trigger ${index}` }),
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    const { body } = await session.testAgent
      .get('/v1/activity/workflow-runs')
      .query({
        createdGte: beforeTrigger.toISOString(),
        createdLte: afterTrigger.toISOString(),
      })
      .expect(200);

    expect(body.data).to.be.an('array');
    expect(body.data.length, 'body.data.length').to.be.greaterThan(0);

    for (const workflowRun of body.data) {
      const workflowRunEntity = await workflowRunRepository.findOne({
        where: {
          enforced: { environmentId: session.environment._id },
          conditions: [{ field: 'workflow_run_id', operator: '=', value: workflowRun.id }],
        },
        select: '*',
      });
      expect(workflowRunEntity, 'workflowRunEntity should exist').to.not.be.null;
      expect(workflowRunEntity.data, 'workflowRunEntity.data should exist').to.not.be.undefined;
      expect(JSON.parse(workflowRunEntity.data.payload || '{}')?.testText).to.contain('second trigger');
    }
  });

  it('should support combining multiple filters', async () => {
    await novuClient.trigger({
      workflowId: inAppWorkflow.triggers[0].identifier,
      to: subscriber.subscriberId,
      payload: { firstName: 'John' },
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    const { body } = await session.testAgent
      .get('/v1/activity/workflow-runs')
      .query({
        workflowIds: [inAppWorkflow._id],
        subscriberIds: subscriber.subscriberId,
        statuses: [WorkflowRunStatusDtoEnum.COMPLETED],
        limit: 10,
      })
      .expect(200);

    expect(body.data.length, 'expected body.data.length to be greater than 0').to.be.greaterThan(0);

    for (const workflowRun of body.data) {
      expect(workflowRun.workflowId).to.equal(inAppWorkflow._id);
      expect(workflowRun.subscriberId).to.equal(subscriber.subscriberId);
      expect(workflowRun.status).to.equal(WorkflowRunStatusDtoEnum.COMPLETED);
    }
  });

  it('should filter results by channels', async () => {
    // Trigger email workflow runs
    await createMultipleWorkflowRuns({
      count: 2,
      workflowId: emailTemplate.triggers[0].identifier,
      subscriberId: [subscriber.subscriberId],
    });

    // Trigger in-app workflow runs
    await createMultipleWorkflowRuns({
      count: 2,
      workflowId: inAppTemplate.triggers[0].identifier,
      subscriberId: [subscriber.subscriberId],
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();

    // Filter by EMAIL channel only
    const { body: bodyEmailFiltered } = (await session.testAgent
      .get('/v1/activity/workflow-runs')
      .query({ channels: [StepTypeEnum.EMAIL] })
      .expect(200)) as { body: GetWorkflowRunsResponseDto };

    expect(bodyEmailFiltered.data.length, 'bodyEmailFiltered.data.length').to.be.greaterThan(0);

    for (const workflowRun of bodyEmailFiltered.data) {
      const stepsTypes = workflowRun.steps.map((step: any) => step.stepType);
      expect(stepsTypes.length).to.be.greaterThan(0);
      for (const stepType of stepsTypes) {
        expect([StepTypeEnum.TRIGGER, StepTypeEnum.EMAIL], 'stepType should be EMAIL').to.include(stepType);
      }
    }

    // Filter by EMAIL and IN_APP channels
    const { body: bodyEmailAndInAppFiltered } = (await session.testAgent
      .get('/v1/activity/workflow-runs')
      .query({ channels: [StepTypeEnum.EMAIL, StepTypeEnum.IN_APP] })
      .expect(200)) as { body: GetWorkflowRunsResponseDto };

    expect(bodyEmailAndInAppFiltered.data.length, 'bodyEmailAndInAppFiltered.data.length').to.be.greaterThan(0);

    for (const workflowRun of bodyEmailAndInAppFiltered.data) {
      const stepsTypes = workflowRun.steps.map((step: any) => step.stepType);
      expect(stepsTypes.length).to.be.greaterThan(0);
      for (const stepType of stepsTypes) {
        expect(
          [StepTypeEnum.TRIGGER, StepTypeEnum.EMAIL, StepTypeEnum.IN_APP],
          'stepType should be EMAIL or IN_APP'
        ).to.include(stepType);
      }
    }
  });

  it('should handle empty results gracefully', async () => {
    const { body } = await session.testAgent
      .get('/v1/activity/workflow-runs')
      .query({ workflowIds: ['non-existent-id'] })
      .expect(200);

    expect(body.data).to.be.an('array');
    expect(body.data.length).to.equal(0);
    expect(body.next).to.equal(null);
    expect(body.previous).to.equal(null);
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - createMultipleWorkflowRuns(options: {
    count: number;
    workflowId: string;
    subscriberId: string[];
    payloadTemplate?: (index: number)
 - createMultipleWorkflowRunsByDb(options: {
    count: number;
    subscriberId: string[];
    payloadTemplate?: (index: number)
Asignaciones con arrow functions encontradas (posibles funciones):
 - clickHouseService(new ClickHouseService();

  // Helper function to create multiple workflow triggers with 5ms delay b...)
 - NotificationEntity({
        _id: NotificationRepository.createObjectId(),
        _templateId: template._id,
        _...)
 - inAppTemplate(await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.IN_APP,
       ...)
 - step(firstPage.data[0].steps[0];
      expect(step.id.startsWith('sr_'), 'step id should start with sr_')...)
 - orderedIds(body.data.map((item: any))
 - transactionIds(body.data.map((item: any))
 - backwardOrderedIds(backwardPageResult.data.map((item: any))
 - backwardRunNumbers(backwardPageResult.data.map((item: any))
 - forwardFromMiddleIds(forwardFromMiddleResult.data.map((item: any))
 - allowedIds([template._id, secondTemplate._id];
    for (const workflowRun of body.data) {
      expect(allowedI...)
 - beforeTrigger(new Date();

    await createMultipleWorkflowRuns({
      count: 2,
      workflowId: template.trigg...)
 - afterTrigger(new Date();

    await createMultipleWorkflowRuns({
      count: 2,
      workflowId: template.trigg...)
 - stepsTypes(workflowRun.steps.map((step: any))
 - stepsTypes(workflowRun.steps.map((step: any))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/shared/mappers.ts
Tamao: 2694 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Trace, TraceStatus, WorkflowRunStatusEnum } from '@novu/application-generic';
import { ExecutionDetailsStatusEnum } from '@novu/shared';
import { TraceResponseDto } from '../dtos/get-request.response.dto';
import { RequestLogResponseDto } from '../dtos/get-requests.response.dto';
import { WorkflowRunStatusDtoEnum } from '../dtos/shared.dto';
import { StepExecutionDetailDto } from '../dtos/workflow-run-response.dto';

export function mapWorkflowRunStatusToDto(workflowRunStatus: WorkflowRunStatusEnum): WorkflowRunStatusDtoEnum {
  switch (workflowRunStatus) {
    case WorkflowRunStatusEnum.COMPLETED:
    case WorkflowRunStatusEnum.SUCCESS:
      return WorkflowRunStatusDtoEnum.COMPLETED;
    case WorkflowRunStatusEnum.ERROR:
      return WorkflowRunStatusDtoEnum.ERROR;
    case WorkflowRunStatusEnum.PENDING:
    case WorkflowRunStatusEnum.PROCESSING:
      return WorkflowRunStatusDtoEnum.PROCESSING;
    default:
      return WorkflowRunStatusDtoEnum.PROCESSING;
  }
}

export function mapTraceToResponseDto({
  id,
  createdAt,
  eventType,
  title,
  message,
  rawData,
  status,
  entityType,
  entityId,
  organizationId,
  environmentId,
  userId,
  externalSubscriberId,
  subscriberId,
}: {
  id: string;
  createdAt: Date;
  eventType: string;
  title: string;
  message: string;
  rawData: string;
  status: string;
  entityType: string;
  entityId: string;
  organizationId: string;
  environmentId: string;
  userId: string;
  externalSubscriberId: string;
  subscriberId: string;
}): TraceResponseDto {
  return {
    id,
    createdAt: new Date(`${createdAt} UTC`).toISOString(),
    eventType,
    title,
    message,
    rawData,
    status,
    entityType,
    entityId,
    organizationId,
    environmentId,
    userId,
    externalSubscriberId,
    subscriberId,
  };
}

export function mapTraceToExecutionDetailDto(
  traces: Pick<Trace, 'entity_id' | 'id' | 'status' | 'title' | 'raw_data' | 'created_at'>[]
): StepExecutionDetailDto[] {
  return traces.map((trace) => ({
    _id: trace.id,
    createdAt: new Date(`${trace.created_at} UTC`).toISOString(),
    status: mapTraceStatusToExecutionDetailsStatus(trace.status),
    detail: trace.title,
    raw: trace.raw_data,
  }));
}

function mapTraceStatusToExecutionDetailsStatus(traceStatus: TraceStatus): ExecutionDetailsStatusEnum {
  switch (traceStatus) {
    case 'success':
      return ExecutionDetailsStatusEnum.SUCCESS;
    case 'error':
      return ExecutionDetailsStatusEnum.FAILED;
    case 'warning':
      return ExecutionDetailsStatusEnum.WARNING;
    case 'pending':
      return ExecutionDetailsStatusEnum.PENDING;
    default:
      return ExecutionDetailsStatusEnum.FAILED;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - mapWorkflowRunStatusToDto(workflowRunStatus: WorkflowRunStatusEnum)
 - mapTraceToResponseDto({
  id,
  createdAt,
  eventType,
  title,
  message,
  rawData,
  status,
  entityType,
  entityId,
  organizationId,
  environmentId,
  userId,
  externalSubscriberId,
  subscriberId,
}: {
  id: string;
  createdAt: Date;
  eventType: string;
  title: string;
  message: string;
  rawData: string;
  status: string;
  entityType: string;
  entityId: string;
  organizationId: string;
  environmentId: string;
  userId: string;
  externalSubscriberId: string;
  subscriberId: string;
})
 - mapTraceToExecutionDetailDto(traces: Pick<Trace, 'entity_id' | 'id' | 'status' | 'title' | 'raw_data' | 'created_at'>[])
 - mapTraceStatusToExecutionDetailsStatus(traceStatus: TraceStatus)
Declaraciones 'export' encontradas:
- export function mapWorkflowRunStatusToDto
- export function mapTraceToResponseDto
- export function mapTraceToExecutionDetailDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/shared/select.const.ts
Tamao: 848 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { RequestLog, Trace } from '@novu/application-generic';

export const traceSelectColumns = [
  'id',
  'created_at',
  'event_type',
  'title',
  'message',
  'raw_data',
  'status',
  'entity_type',
  'entity_id',
  'organization_id',
  'environment_id',
  'user_id',
  'external_subscriber_id',
  'subscriber_id',
] as const;
type GetTraceFetchResult = Pick<Trace, (typeof traceSelectColumns)[number]>;

export const requestLogSelectColumns = [
  'id',
  'created_at',
  'method',
  'path',
  'status_code',
  'transaction_id',
  'request_body',
  'response_body',
  'url',
  'url_pattern',
  'hostname',
  'ip',
  'user_agent',
  'auth_type',
  'duration_ms',
  'user_id',
  'organization_id',
  'environment_id',
  'transaction_id',
] as const;
type GetRequestLogFetchResult = Pick<RequestLog, (typeof requestLogSelectColumns)[number]>;


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-active-subscribers-chart/build-active-subscribers-chart.command.ts
Tamao: 288 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsDate, IsDefined } from 'class-validator';

export class BuildActiveSubscribersChartCommand extends EnvironmentCommand {
  @IsDate()
  @IsDefined()
  startDate: Date;

  @IsDate()
  @IsDefined()
  endDate: Date;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildActiveSubscribersChartCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-active-subscribers-chart/build-active-subscribers-chart.usecase.ts
Tamao: 1336 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase, PinoLogger, WorkflowRunRepository } from '@novu/application-generic';
import { ActiveSubscribersDataPointDto } from '../../dtos/get-charts.response.dto';
import { BuildActiveSubscribersChartCommand } from './build-active-subscribers-chart.command';

@Injectable()
export class BuildActiveSubscribersChart {
  constructor(
    private workflowRunRepository: WorkflowRunRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(BuildActiveSubscribersChart.name);
  }

  @InstrumentUsecase()
  async execute(command: BuildActiveSubscribersChartCommand): Promise<ActiveSubscribersDataPointDto> {
    const { environmentId, organizationId, startDate, endDate } = command;

    // Calculate previous period dates
    const periodDuration = endDate.getTime() - startDate.getTime();
    const previousEndDate = new Date(startDate.getTime() - 1);
    const previousStartDate = new Date(previousEndDate.getTime() - periodDuration);

    const result = await this.workflowRunRepository.getActiveSubscribersData(
      environmentId,
      organizationId,
      startDate,
      endDate,
      previousStartDate,
      previousEndDate
    );

    return {
      currentPeriod: result.currentPeriod,
      previousPeriod: result.previousPeriod,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildActiveSubscribersChart

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-active-subscribers-chart/index.ts
Tamao: 183 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { BuildActiveSubscribersChartCommand } from './build-active-subscribers-chart.command';
export { BuildActiveSubscribersChart } from './build-active-subscribers-chart.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-active-subscribers-trend-chart/build-active-subscribers-trend-chart.command.ts
Tamao: 293 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsDate, IsDefined } from 'class-validator';

export class BuildActiveSubscribersTrendChartCommand extends EnvironmentCommand {
  @IsDate()
  @IsDefined()
  startDate: Date;

  @IsDate()
  @IsDefined()
  endDate: Date;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildActiveSubscribersTrendChartCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-active-subscribers-trend-chart/build-active-subscribers-trend-chart.usecase.ts
Tamao: 1641 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase, PinoLogger, WorkflowRunRepository } from '@novu/application-generic';
import { ActiveSubscribersTrendDataPointDto } from '../../dtos/get-charts.response.dto';
import { BuildActiveSubscribersTrendChartCommand } from './build-active-subscribers-trend-chart.command';

@Injectable()
export class BuildActiveSubscribersTrendChart {
  constructor(
    private workflowRunRepository: WorkflowRunRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(BuildActiveSubscribersTrendChart.name);
  }

  @InstrumentUsecase()
  async execute(command: BuildActiveSubscribersTrendChartCommand): Promise<ActiveSubscribersTrendDataPointDto[]> {
    const { environmentId, organizationId, startDate, endDate } = command;

    const activeSubscribers = await this.workflowRunRepository.getActiveSubscribersTrendData(
      environmentId,
      organizationId,
      startDate,
      endDate
    );

    const chartDataMap = new Map<string, number>();

    const currentDate = new Date(startDate);
    while (currentDate <= endDate) {
      const dateKey = currentDate.toISOString().split('T')[0];
      chartDataMap.set(dateKey, 0);
      currentDate.setDate(currentDate.getDate() + 1);
    }

    for (const dataPoint of activeSubscribers) {
      const date = dataPoint.date;
      chartDataMap.set(date, parseInt(dataPoint.count, 10));
    }

    const chartData: ActiveSubscribersTrendDataPointDto[] = [];

    for (const [date, count] of chartDataMap) {
      chartData.push({
        timestamp: date,
        count,
      });
    }

    return chartData;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildActiveSubscribersTrendChart

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-active-subscribers-trend-chart/index.ts
Tamao: 205 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { BuildActiveSubscribersTrendChartCommand } from './build-active-subscribers-trend-chart.command';
export { BuildActiveSubscribersTrendChart } from './build-active-subscribers-trend-chart.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-avg-messages-per-subscriber-chart/build-avg-messages-per-subscriber-chart.command.ts
Tamao: 295 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsDate, IsDefined } from 'class-validator';

export class BuildAvgMessagesPerSubscriberChartCommand extends EnvironmentCommand {
  @IsDate()
  @IsDefined()
  startDate: Date;

  @IsDate()
  @IsDefined()
  endDate: Date;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildAvgMessagesPerSubscriberChartCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-avg-messages-per-subscriber-chart/build-avg-messages-per-subscriber-chart.usecase.ts
Tamao: 1378 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase, PinoLogger, StepRunRepository } from '@novu/application-generic';
import { AvgMessagesPerSubscriberDataPointDto } from '../../dtos/get-charts.response.dto';
import { BuildAvgMessagesPerSubscriberChartCommand } from './build-avg-messages-per-subscriber-chart.command';

@Injectable()
export class BuildAvgMessagesPerSubscriberChart {
  constructor(
    private stepRunRepository: StepRunRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(BuildAvgMessagesPerSubscriberChart.name);
  }

  @InstrumentUsecase()
  async execute(command: BuildAvgMessagesPerSubscriberChartCommand): Promise<AvgMessagesPerSubscriberDataPointDto> {
    const { environmentId, organizationId, startDate, endDate } = command;

    // Calculate previous period dates
    const periodDuration = endDate.getTime() - startDate.getTime();
    const previousEndDate = new Date(startDate.getTime() - 1);
    const previousStartDate = new Date(previousEndDate.getTime() - periodDuration);

    const result = await this.stepRunRepository.getAvgMessagesPerSubscriberData(
      environmentId,
      organizationId,
      startDate,
      endDate,
      previousStartDate,
      previousEndDate
    );

    return {
      currentPeriod: result.currentPeriod,
      previousPeriod: result.previousPeriod,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildAvgMessagesPerSubscriberChart

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-avg-messages-per-subscriber-chart/index.ts
Tamao: 215 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { BuildAvgMessagesPerSubscriberChartCommand } from './build-avg-messages-per-subscriber-chart.command';
export { BuildAvgMessagesPerSubscriberChart } from './build-avg-messages-per-subscriber-chart.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-delivery-trend-chart/build-delivery-trend-chart.command.ts
Tamao: 284 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsDate, IsDefined } from 'class-validator';

export class BuildDeliveryTrendChartCommand extends EnvironmentCommand {
  @IsDate()
  @IsDefined()
  startDate: Date;

  @IsDate()
  @IsDefined()
  endDate: Date;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildDeliveryTrendChartCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-delivery-trend-chart/build-delivery-trend-chart.usecase.ts
Tamao: 2108 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase, PinoLogger, StepRunRepository } from '@novu/application-generic';
import { ChartDataPointDto } from '../../dtos/get-charts.response.dto';
import { BuildDeliveryTrendChartCommand } from './build-delivery-trend-chart.command';

@Injectable()
export class BuildDeliveryTrendChart {
  constructor(
    private stepRunRepository: StepRunRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(BuildDeliveryTrendChart.name);
  }

  @InstrumentUsecase()
  async execute(command: BuildDeliveryTrendChartCommand): Promise<ChartDataPointDto[]> {
    const { environmentId, organizationId, startDate, endDate } = command;

    const stepRuns = await this.stepRunRepository.getDeliveryTrendData(
      environmentId,
      organizationId,
      startDate,
      endDate
    );

    const chartDataMap = new Map<string, Map<string, number>>();

    const currentDate = new Date(startDate);
    while (currentDate <= endDate) {
      const dateKey = currentDate.toISOString().split('T')[0];
      chartDataMap.set(
        dateKey,
        new Map([
          ['in_app', 0],
          ['email', 0],
          ['sms', 0],
          ['chat', 0],
          ['push', 0],
        ])
      );
      currentDate.setDate(currentDate.getDate() + 1);
    }

    for (const stepRun of stepRuns) {
      const date = stepRun.date;
      const channel = stepRun.step_type;

      const channelMap = chartDataMap.get(date);
      if (channelMap?.has(channel)) {
        const currentCount = channelMap.get(channel) || 0;
        channelMap.set(channel, currentCount + parseInt(stepRun.count, 10));
      }
    }

    const chartData: ChartDataPointDto[] = [];

    for (const [date, channelCounts] of chartDataMap) {
      chartData.push({
        timestamp: date,
        inApp: channelCounts.get('in_app') || 0,
        email: channelCounts.get('email') || 0,
        sms: channelCounts.get('sms') || 0,
        chat: channelCounts.get('chat') || 0,
        push: channelCounts.get('push') || 0,
      });
    }

    return chartData;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildDeliveryTrendChart

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-delivery-trend-chart/index.ts
Tamao: 167 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { BuildDeliveryTrendChartCommand } from './build-delivery-trend-chart.command';
export { BuildDeliveryTrendChart } from './build-delivery-trend-chart.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-interaction-trend-chart/build-interaction-trend-chart.command.ts
Tamao: 287 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsDate, IsDefined } from 'class-validator';

export class BuildInteractionTrendChartCommand extends EnvironmentCommand {
  @IsDate()
  @IsDefined()
  startDate: Date;

  @IsDate()
  @IsDefined()
  endDate: Date;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildInteractionTrendChartCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-interaction-trend-chart/build-interaction-trend-chart.usecase.ts
Tamao: 2181 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase, PinoLogger, TraceLogRepository } from '@novu/application-generic';
import { InteractionTrendDataPointDto } from '../../dtos/get-charts.response.dto';
import { BuildInteractionTrendChartCommand } from './build-interaction-trend-chart.command';

@Injectable()
export class BuildInteractionTrendChart {
  constructor(
    private traceLogRepository: TraceLogRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(BuildInteractionTrendChart.name);
  }

  @InstrumentUsecase()
  async execute(command: BuildInteractionTrendChartCommand): Promise<InteractionTrendDataPointDto[]> {
    const { environmentId, organizationId, startDate, endDate } = command;

    const traces = await this.traceLogRepository.getInteractionTrendData(
      environmentId,
      organizationId,
      startDate,
      endDate
    );

    const chartDataMap = new Map<string, Map<string, number>>();

    const currentDate = new Date(startDate);
    while (currentDate <= endDate) {
      const dateKey = currentDate.toISOString().split('T')[0];
      chartDataMap.set(
        dateKey,
        new Map([
          ['message_seen', 0],
          ['message_read', 0],
          ['message_snoozed', 0],
          ['message_archived', 0],
        ])
      );
      currentDate.setDate(currentDate.getDate() + 1);
    }

    for (const trace of traces) {
      const date = trace.date;
      const eventType = trace.event_type;

      const eventMap = chartDataMap.get(date);
      if (eventMap?.has(eventType)) {
        const currentCount = eventMap.get(eventType) || 0;
        eventMap.set(eventType, currentCount + parseInt(trace.count, 10));
      }
    }

    const chartData: InteractionTrendDataPointDto[] = [];

    for (const [date, eventCounts] of chartDataMap) {
      chartData.push({
        timestamp: date,
        messageSeen: eventCounts.get('message_seen') || 0,
        messageRead: eventCounts.get('message_read') || 0,
        messageSnoozed: eventCounts.get('message_snoozed') || 0,
        messageArchived: eventCounts.get('message_archived') || 0,
      });
    }

    return chartData;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildInteractionTrendChart

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-interaction-trend-chart/index.ts
Tamao: 179 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { BuildInteractionTrendChartCommand } from './build-interaction-trend-chart.command';
export { BuildInteractionTrendChart } from './build-interaction-trend-chart.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-messages-delivered-chart/build-messages-delivered-chart.command.ts
Tamao: 288 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsDate, IsDefined } from 'class-validator';

export class BuildMessagesDeliveredChartCommand extends EnvironmentCommand {
  @IsDate()
  @IsDefined()
  startDate: Date;

  @IsDate()
  @IsDefined()
  endDate: Date;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildMessagesDeliveredChartCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-messages-delivered-chart/build-messages-delivered-chart.usecase.ts
Tamao: 1345 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase, PinoLogger, StepRunRepository } from '@novu/application-generic';
import { MessagesDeliveredDataPointDto } from '../../dtos/get-charts.response.dto';
import { BuildMessagesDeliveredChartCommand } from './build-messages-delivered-chart.command';

@Injectable()
export class BuildMessagesDeliveredChart {
  constructor(
    private stepRunRepository: StepRunRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(BuildMessagesDeliveredChart.name);
  }

  @InstrumentUsecase()
  async execute(command: BuildMessagesDeliveredChartCommand): Promise<MessagesDeliveredDataPointDto> {
    const { environmentId, organizationId, startDate, endDate } = command;

    // Calculate previous period dates
    const periodDuration = endDate.getTime() - startDate.getTime();
    const previousEndDate = new Date(startDate.getTime() - 1); // Day before start date
    const previousStartDate = new Date(previousEndDate.getTime() - periodDuration);

    const result = await this.stepRunRepository.getMessagesDeliveredData(
      environmentId,
      organizationId,
      startDate,
      endDate,
      previousStartDate,
      previousEndDate
    );

    return {
      currentPeriod: result.currentPeriod,
      previousPeriod: result.previousPeriod,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildMessagesDeliveredChart

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-messages-delivered-chart/index.ts
Tamao: 183 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { BuildMessagesDeliveredChartCommand } from './build-messages-delivered-chart.command';
export { BuildMessagesDeliveredChart } from './build-messages-delivered-chart.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-provider-by-volume-chart/build-provider-by-volume-chart.command.ts
Tamao: 287 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsDate, IsDefined } from 'class-validator';

export class BuildProviderByVolumeChartCommand extends EnvironmentCommand {
  @IsDate()
  @IsDefined()
  startDate: Date;

  @IsDate()
  @IsDefined()
  endDate: Date;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildProviderByVolumeChartCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-provider-by-volume-chart/build-provider-by-volume-chart.usecase.ts
Tamao: 1044 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase, PinoLogger, StepRunRepository } from '@novu/application-generic';
import { ProviderVolumeDataPointDto } from '../../dtos/get-charts.response.dto';
import { BuildProviderByVolumeChartCommand } from './build-provider-by-volume-chart.command';

@Injectable()
export class BuildProviderByVolumeChart {
  constructor(
    private stepRunRepository: StepRunRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(BuildProviderByVolumeChart.name);
  }

  @InstrumentUsecase()
  async execute(command: BuildProviderByVolumeChartCommand): Promise<ProviderVolumeDataPointDto[]> {
    const { environmentId, organizationId, startDate, endDate } = command;

    const providerData = await this.stepRunRepository.getProviderVolumeData(
      environmentId,
      organizationId,
      startDate,
      endDate
    );

    return providerData.map((dataPoint) => ({
      providerId: dataPoint.provider_id,
      count: parseInt(dataPoint.count, 10),
    }));
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - providerData(await this.stepRunRepository.getProviderVolumeData(
      environmentId,
      organizationId,
     ...)
Declaraciones 'export' encontradas:
- export class BuildProviderByVolumeChart

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-provider-by-volume-chart/index.ts
Tamao: 181 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { BuildProviderByVolumeChartCommand } from './build-provider-by-volume-chart.command';
export { BuildProviderByVolumeChart } from './build-provider-by-volume-chart.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-total-interactions-chart/build-total-interactions-chart.command.ts
Tamao: 288 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsDate, IsDefined } from 'class-validator';

export class BuildTotalInteractionsChartCommand extends EnvironmentCommand {
  @IsDate()
  @IsDefined()
  startDate: Date;

  @IsDate()
  @IsDefined()
  endDate: Date;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildTotalInteractionsChartCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-total-interactions-chart/build-total-interactions-chart.usecase.ts
Tamao: 1324 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase, PinoLogger, TraceLogRepository } from '@novu/application-generic';
import { TotalInteractionsDataPointDto } from '../../dtos/get-charts.response.dto';
import { BuildTotalInteractionsChartCommand } from './build-total-interactions-chart.command';

@Injectable()
export class BuildTotalInteractionsChart {
  constructor(
    private traceLogRepository: TraceLogRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(BuildTotalInteractionsChart.name);
  }

  @InstrumentUsecase()
  async execute(command: BuildTotalInteractionsChartCommand): Promise<TotalInteractionsDataPointDto> {
    const { environmentId, organizationId, startDate, endDate } = command;

    // Calculate previous period dates
    const periodDuration = endDate.getTime() - startDate.getTime();
    const previousEndDate = new Date(startDate.getTime() - 1);
    const previousStartDate = new Date(previousEndDate.getTime() - periodDuration);

    const result = await this.traceLogRepository.getTotalInteractionsData(
      environmentId,
      organizationId,
      startDate,
      endDate,
      previousStartDate,
      previousEndDate
    );

    return {
      currentPeriod: result.currentPeriod,
      previousPeriod: result.previousPeriod,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildTotalInteractionsChart

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-total-interactions-chart/index.ts
Tamao: 116 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './build-total-interactions-chart.command';
export * from './build-total-interactions-chart.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-workflow-by-volume-chart/build-workflow-by-volume-chart.command.ts
Tamao: 287 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsDate, IsDefined } from 'class-validator';

export class BuildWorkflowByVolumeChartCommand extends EnvironmentCommand {
  @IsDate()
  @IsDefined()
  startDate: Date;

  @IsDate()
  @IsDefined()
  endDate: Date;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildWorkflowByVolumeChartCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-workflow-by-volume-chart/build-workflow-by-volume-chart.usecase.ts
Tamao: 1134 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase, PinoLogger, WorkflowRunRepository } from '@novu/application-generic';
import { WorkflowVolumeDataPointDto } from '../../dtos/get-charts.response.dto';
import { BuildWorkflowByVolumeChartCommand } from './build-workflow-by-volume-chart.command';

@Injectable()
export class BuildWorkflowByVolumeChart {
  constructor(
    private workflowRunRepository: WorkflowRunRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(BuildWorkflowByVolumeChart.name);
  }

  @InstrumentUsecase()
  async execute(command: BuildWorkflowByVolumeChartCommand): Promise<WorkflowVolumeDataPointDto[]> {
    const { environmentId, organizationId, startDate, endDate } = command;

    const workflowRuns = await this.workflowRunRepository.getWorkflowVolumeData(
      environmentId,
      organizationId,
      startDate,
      endDate
    );

    const chartData: WorkflowVolumeDataPointDto[] = workflowRuns.map((workflowRun) => ({
      workflowName: workflowRun.workflow_name,
      count: parseInt(workflowRun.count, 10),
    }));

    return chartData;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildWorkflowByVolumeChart

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-workflow-by-volume-chart/index.ts
Tamao: 116 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './build-workflow-by-volume-chart.command';
export * from './build-workflow-by-volume-chart.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-workflow-runs-count-chart/build-workflow-runs-count-chart.command.ts
Tamao: 975 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand, WorkflowRunStatusEnum } from '@novu/application-generic';
import { IsArray, IsDate, IsDefined, IsIn, IsOptional, IsString } from 'class-validator';
import { WorkflowRunStatusDtoEnum } from '../../dtos/shared.dto';

export class BuildWorkflowRunsCountChartCommand extends EnvironmentCommand {
  @IsDate()
  @IsDefined()
  startDate: Date;

  @IsDate()
  @IsDefined()
  endDate: Date;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  workflowIds?: string[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  subscriberIds?: string[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  transactionIds?: string[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  @IsIn(Object.values(WorkflowRunStatusDtoEnum), {
    each: true,
  })
  statuses?: WorkflowRunStatusDtoEnum[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  channels?: string[];

  @IsOptional()
  @IsString()
  topicKey?: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildWorkflowRunsCountChartCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-workflow-runs-count-chart/build-workflow-runs-count-chart.usecase.ts
Tamao: 3342 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import {
  InstrumentUsecase,
  PinoLogger,
  QueryBuilder,
  WorkflowRun,
  WorkflowRunRepository,
  WorkflowRunStatusEnum,
} from '@novu/application-generic';
import { WorkflowRunsCountDataPointDto } from '../../dtos/get-charts.response.dto';
import { BuildWorkflowRunsCountChartCommand } from './build-workflow-runs-count-chart.command';
import { WorkflowRunStatusDtoEnum } from '../../dtos/shared.dto';
 
@Injectable()
export class BuildWorkflowRunsCountChart {
  constructor(
    private workflowRunRepository: WorkflowRunRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(BuildWorkflowRunsCountChart.name);
  }

  @InstrumentUsecase()
  async execute(command: BuildWorkflowRunsCountChartCommand): Promise<WorkflowRunsCountDataPointDto> {
    const {
      environmentId,
      startDate,
      endDate,
      workflowIds,
      subscriberIds,
      transactionIds,
      statuses,
      channels,
      topicKey,
    } = command;

    this.logger.debug('Getting workflow runs count for chart', {
      organizationId: command.organizationId,
      environmentId: command.environmentId,
    });

    try {
      const queryBuilder = new QueryBuilder<WorkflowRun>({
        environmentId,
      });

      // Add date range filters
      queryBuilder.whereGreaterThanOrEqual('created_at', startDate);
      queryBuilder.whereLessThanOrEqual('created_at', endDate);

      // Add optional filters
      if (workflowIds?.length) {
        queryBuilder.whereIn('workflow_id', workflowIds);
      }

      if (subscriberIds?.length) {
        queryBuilder.whereIn('external_subscriber_id', subscriberIds);
      }

      if (transactionIds?.length) {
        queryBuilder.whereIn('transaction_id', transactionIds);
      }

      if (statuses?.length) {
        const mappedStatuses = statuses.map((status) => { //backward compatibility: if new statuses are used, append old status until renewed in the database, nv-6562
          if (status === WorkflowRunStatusDtoEnum.PROCESSING) {
            return [WorkflowRunStatusEnum.PENDING, WorkflowRunStatusEnum.PROCESSING];
          }
          if (status === WorkflowRunStatusDtoEnum.COMPLETED) {
            return [WorkflowRunStatusEnum.SUCCESS, WorkflowRunStatusEnum.COMPLETED];
          }
          if (status === WorkflowRunStatusDtoEnum.ERROR) {
            return [WorkflowRunStatusEnum.ERROR];
          }
          return status;
        });

        queryBuilder.whereIn('status', mappedStatuses.flat());
      }

      if (channels?.length) {
        queryBuilder.orWhere(
          channels.map((channel) => ({
            field: 'channels',
            operator: 'LIKE',
            value: `%"${channel}"%`,
          }))
        );
      }

      if (topicKey) {
        queryBuilder.whereLike('topics', `%${topicKey}%`);
      }

      const safeWhere = queryBuilder.build();

      const result = await this.workflowRunRepository.count({
        where: safeWhere,
        useFinal: true,
      });

      return {
        count: result,
      };
    } catch (error) {
      this.logger.error('Failed to get workflow runs count for chart', {
        error: error.message,
        organizationId: command.organizationId,
        environmentId: command.environmentId,
      });
      throw error;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mappedStatuses(statuses.map((status))
Declaraciones 'export' encontradas:
- export class BuildWorkflowRunsCountChart

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-workflow-runs-count-chart/index.ts
Tamao: 185 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { BuildWorkflowRunsCountChartCommand } from './build-workflow-runs-count-chart.command';
export { BuildWorkflowRunsCountChart } from './build-workflow-runs-count-chart.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-workflow-runs-metric-chart/build-workflow-runs-metric-chart.command.ts
Tamao: 289 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsDate, IsDefined } from 'class-validator';

export class BuildWorkflowRunsMetricChartCommand extends EnvironmentCommand {
  @IsDate()
  @IsDefined()
  startDate: Date;

  @IsDate()
  @IsDefined()
  endDate: Date;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildWorkflowRunsMetricChartCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-workflow-runs-metric-chart/build-workflow-runs-metric-chart.usecase.ts
Tamao: 1370 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase, PinoLogger, WorkflowRunRepository } from '@novu/application-generic';
import { WorkflowRunsMetricDataPointDto } from '../../dtos/get-charts.response.dto';
import { BuildWorkflowRunsMetricChartCommand } from './build-workflow-runs-metric-chart.command';

@Injectable()
export class BuildWorkflowRunsMetricChart {
  constructor(
    private workflowRunRepository: WorkflowRunRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(BuildWorkflowRunsMetricChart.name);
  }

  @InstrumentUsecase()
  async execute(command: BuildWorkflowRunsMetricChartCommand): Promise<WorkflowRunsMetricDataPointDto> {
    const { environmentId, organizationId, startDate, endDate } = command;

    // Calculate previous period dates
    const periodDuration = endDate.getTime() - startDate.getTime();
    const previousEndDate = new Date(startDate.getTime() - 1); // Day before start date
    const previousStartDate = new Date(previousEndDate.getTime() - periodDuration);

    const result = await this.workflowRunRepository.getWorkflowRunsMetricData(
      environmentId,
      organizationId,
      startDate,
      endDate,
      previousStartDate,
      previousEndDate
    );

    return {
      currentPeriod: result.currentPeriod,
      previousPeriod: result.previousPeriod,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildWorkflowRunsMetricChart

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-workflow-runs-metric-chart/index.ts
Tamao: 189 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { BuildWorkflowRunsMetricChartCommand } from './build-workflow-runs-metric-chart.command';
export { BuildWorkflowRunsMetricChart } from './build-workflow-runs-metric-chart.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-workflow-runs-trend-chart/build-workflow-runs-trend-chart.command.ts
Tamao: 288 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsDate, IsDefined } from 'class-validator';

export class BuildWorkflowRunsTrendChartCommand extends EnvironmentCommand {
  @IsDate()
  @IsDefined()
  startDate: Date;

  @IsDate()
  @IsDefined()
  endDate: Date;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildWorkflowRunsTrendChartCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-workflow-runs-trend-chart/build-workflow-runs-trend-chart.usecase.ts
Tamao: 2460 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase, PinoLogger, WorkflowRunRepository } from '@novu/application-generic';
import { WorkflowRunsTrendDataPointDto } from '../../dtos/get-charts.response.dto';
import { BuildWorkflowRunsTrendChartCommand } from './build-workflow-runs-trend-chart.command';

@Injectable()
export class BuildWorkflowRunsTrendChart {
  constructor(
    private workflowRunRepository: WorkflowRunRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(BuildWorkflowRunsTrendChart.name);
  }

  @InstrumentUsecase()
  async execute(command: BuildWorkflowRunsTrendChartCommand): Promise<WorkflowRunsTrendDataPointDto[]> {
    const { environmentId, organizationId, startDate, endDate } = command;

    const workflowRuns = await this.workflowRunRepository.getWorkflowRunsTrendData(
      environmentId,
      organizationId,
      startDate,
      endDate
    );

    const chartDataMap = new Map<string, Map<string, number>>();

    const currentDate = new Date(startDate);
    while (currentDate <= endDate) {
      const dateKey = currentDate.toISOString().split('T')[0];
      chartDataMap.set(
        dateKey,
        new Map([
          ['pending', 0], // remove backward compatibility after data renews nv-6562
          ['processing', 0], 
          ['success', 0], // remove backward compatibility after data renews nv-6562
          ['completed', 0],
          ['error', 0],
        ])
      );
      currentDate.setDate(currentDate.getDate() + 1);
    }

    for (const workflowRun of workflowRuns) {
      const date = workflowRun.date;
      const status = workflowRun.status;

      const statusMap = chartDataMap.get(date);
      if (statusMap?.has(status)) {
        const currentCount = statusMap.get(status) || 0;
        statusMap.set(status, currentCount + parseInt(workflowRun.count, 10));      
      }
    }

    const chartData: WorkflowRunsTrendDataPointDto[] = [];

    for (const [date, statusCounts] of chartDataMap) {
      chartData.push({
        timestamp: date,
        processing: (statusCounts.get('pending') || 0) + (statusCounts.get('processing') || 0), // remove backward compatibility after data renews nv-6562
        completed: (statusCounts.get('success') || 0) + (statusCounts.get('completed') || 0), // remove backward compatibility after data renews nv-6562
        error: statusCounts.get('error') || 0,
      });
    }

    return chartData;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BuildWorkflowRunsTrendChart

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/build-workflow-runs-trend-chart/index.ts
Tamao: 118 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './build-workflow-runs-trend-chart.command';
export * from './build-workflow-runs-trend-chart.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/get-charts/get-charts.command.ts
Tamao: 1041 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsArray, IsDateString, IsDefined, IsEnum, IsOptional, IsString } from 'class-validator';
import { ReportTypeEnum, WorkflowRunStatusDtoEnum } from '../../dtos/shared.dto';

export class GetChartsCommand extends EnvironmentCommand {
  @IsDateString()
  @IsOptional()
  createdAtGte?: string;

  @IsDateString()
  @IsOptional()
  createdAtLte?: string;

  @IsEnum(ReportTypeEnum, { each: true })
  @IsDefined()
  @IsArray()
  reportType: ReportTypeEnum[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  workflowIds?: string[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  subscriberIds?: string[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  transactionIds?: string[];

  @IsOptional()
  @IsArray()
  @IsEnum(WorkflowRunStatusDtoEnum, { each: true })
  statuses?: WorkflowRunStatusDtoEnum[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  channels?: string[];

  @IsOptional()
  @IsString()
  topicKey?: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetChartsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/get-charts/get-charts.usecase.ts
Tamao: 13628 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpException, HttpStatus, Injectable } from '@nestjs/common';
import { PinoLogger } from '@novu/application-generic';
import { CommunityOrganizationRepository, OrganizationEntity } from '@novu/dal';
import { ApiServiceLevelEnum, FeatureNameEnum, getFeatureForTierAsNumber } from '@novu/shared';
import {
  ActiveSubscribersDataPointDto,
  ActiveSubscribersTrendDataPointDto,
  AvgMessagesPerSubscriberDataPointDto,
  ChartDataPointDto,
  GetChartsResponseDto,
  InteractionTrendDataPointDto,
  MessagesDeliveredDataPointDto,
  ProviderVolumeDataPointDto,
  TotalInteractionsDataPointDto,
  WorkflowRunsCountDataPointDto,
  WorkflowRunsMetricDataPointDto,
  WorkflowRunsTrendDataPointDto,
  WorkflowVolumeDataPointDto,
} from '../../dtos/get-charts.response.dto';
import { ReportTypeEnum } from '../../dtos/shared.dto';
import { BuildActiveSubscribersChart, BuildActiveSubscribersChartCommand } from '../build-active-subscribers-chart';
import { BuildActiveSubscribersTrendChartCommand } from '../build-active-subscribers-trend-chart/build-active-subscribers-trend-chart.command';
import { BuildActiveSubscribersTrendChart } from '../build-active-subscribers-trend-chart/build-active-subscribers-trend-chart.usecase';
import {
  BuildAvgMessagesPerSubscriberChart,
  BuildAvgMessagesPerSubscriberChartCommand,
} from '../build-avg-messages-per-subscriber-chart';
import { BuildDeliveryTrendChart, BuildDeliveryTrendChartCommand } from '../build-delivery-trend-chart';
import { BuildInteractionTrendChart, BuildInteractionTrendChartCommand } from '../build-interaction-trend-chart';
import { BuildMessagesDeliveredChart, BuildMessagesDeliveredChartCommand } from '../build-messages-delivered-chart';
import { BuildProviderByVolumeChart, BuildProviderByVolumeChartCommand } from '../build-provider-by-volume-chart';
import { BuildTotalInteractionsChart, BuildTotalInteractionsChartCommand } from '../build-total-interactions-chart';
import { BuildWorkflowByVolumeChart, BuildWorkflowByVolumeChartCommand } from '../build-workflow-by-volume-chart';
import { BuildWorkflowRunsCountChart, BuildWorkflowRunsCountChartCommand } from '../build-workflow-runs-count-chart';
import { BuildWorkflowRunsMetricChart, BuildWorkflowRunsMetricChartCommand } from '../build-workflow-runs-metric-chart';
import { BuildWorkflowRunsTrendChart, BuildWorkflowRunsTrendChartCommand } from '../build-workflow-runs-trend-chart';
import { GetChartsCommand } from './get-charts.command';

@Injectable()
export class GetCharts {
  constructor(
    private buildDeliveryTrendChart: BuildDeliveryTrendChart,
    private buildInteractionTrendChart: BuildInteractionTrendChart,
    private buildWorkflowByVolumeChart: BuildWorkflowByVolumeChart,
    private buildProviderByVolumeChart: BuildProviderByVolumeChart,
    private buildMessagesDeliveredChart: BuildMessagesDeliveredChart,
    private buildActiveSubscribersChart: BuildActiveSubscribersChart,
    private buildActiveSubscribersTrendChart: BuildActiveSubscribersTrendChart,
    private buildAvgMessagesPerSubscriberChart: BuildAvgMessagesPerSubscriberChart,
    private buildWorkflowRunsCountChart: BuildWorkflowRunsCountChart,
    private buildWorkflowRunsMetricChart: BuildWorkflowRunsMetricChart,
    private buildTotalInteractionsChart: BuildTotalInteractionsChart,
    private buildWorkflowRunsTrendChart: BuildWorkflowRunsTrendChart,
    private organizationRepository: CommunityOrganizationRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(GetCharts.name);
  }

  async execute(command: GetChartsCommand): Promise<GetChartsResponseDto> {
    const {
      createdAtGte,
      createdAtLte,
      reportType,
      environmentId,
      organizationId,
      workflowIds,
      subscriberIds,
      transactionIds,
      statuses,
      channels,
      topicKey,
    } = command;

    const validatedDates = await this.validateRetentionLimitForTier(organizationId, createdAtGte, createdAtLte);

    const endDate = new Date(validatedDates.before);
    const startDate = new Date(validatedDates.after);
    const data: Record<
      ReportTypeEnum,
      | ChartDataPointDto[]
      | InteractionTrendDataPointDto[]
      | WorkflowVolumeDataPointDto[]
      | ProviderVolumeDataPointDto[]
      | MessagesDeliveredDataPointDto
      | ActiveSubscribersDataPointDto
      | AvgMessagesPerSubscriberDataPointDto
      | WorkflowRunsCountDataPointDto
      | WorkflowRunsMetricDataPointDto
      | TotalInteractionsDataPointDto
      | WorkflowRunsTrendDataPointDto[]
      | ActiveSubscribersTrendDataPointDto[]
    > = {} as Record<
      ReportTypeEnum,
      | ChartDataPointDto[]
      | InteractionTrendDataPointDto[]
      | WorkflowVolumeDataPointDto[]
      | ProviderVolumeDataPointDto[]
      | MessagesDeliveredDataPointDto
      | ActiveSubscribersDataPointDto
      | AvgMessagesPerSubscriberDataPointDto
      | WorkflowRunsCountDataPointDto
      | WorkflowRunsMetricDataPointDto
      | TotalInteractionsDataPointDto
      | WorkflowRunsTrendDataPointDto[]
      | ActiveSubscribersTrendDataPointDto[]
    >;

    const chartPromises: Array<{
      type: ReportTypeEnum;
      promise: Promise<
        | ChartDataPointDto[]
        | InteractionTrendDataPointDto[]
        | WorkflowVolumeDataPointDto[]
        | ProviderVolumeDataPointDto[]
        | MessagesDeliveredDataPointDto
        | ActiveSubscribersDataPointDto
        | AvgMessagesPerSubscriberDataPointDto
        | WorkflowRunsMetricDataPointDto
        | TotalInteractionsDataPointDto
        | WorkflowRunsTrendDataPointDto[]
        | ActiveSubscribersTrendDataPointDto[]
      >;
    }> = [];

    if (reportType.includes(ReportTypeEnum.DELIVERY_TREND)) {
      chartPromises.push({
        type: ReportTypeEnum.DELIVERY_TREND,
        promise: this.buildDeliveryTrendChart.execute(
          BuildDeliveryTrendChartCommand.create({
            environmentId,
            organizationId,
            startDate,
            endDate,
          })
        ),
      });
    }

    if (reportType.includes(ReportTypeEnum.INTERACTION_TREND)) {
      chartPromises.push({
        type: ReportTypeEnum.INTERACTION_TREND,
        promise: this.buildInteractionTrendChart.execute(
          BuildInteractionTrendChartCommand.create({
            environmentId,
            organizationId,
            startDate,
            endDate,
          })
        ),
      });
    }

    if (reportType.includes(ReportTypeEnum.WORKFLOW_BY_VOLUME)) {
      chartPromises.push({
        type: ReportTypeEnum.WORKFLOW_BY_VOLUME,
        promise: this.buildWorkflowByVolumeChart.execute(
          BuildWorkflowByVolumeChartCommand.create({
            environmentId,
            organizationId,
            startDate,
            endDate,
          })
        ),
      });
    }

    if (reportType.includes(ReportTypeEnum.PROVIDER_BY_VOLUME)) {
      chartPromises.push({
        type: ReportTypeEnum.PROVIDER_BY_VOLUME,
        promise: this.buildProviderByVolumeChart.execute(
          BuildProviderByVolumeChartCommand.create({
            environmentId,
            organizationId,
            startDate,
            endDate,
          })
        ),
      });
    }

    if (reportType.includes(ReportTypeEnum.MESSAGES_DELIVERED)) {
      chartPromises.push({
        type: ReportTypeEnum.MESSAGES_DELIVERED,
        promise: this.buildMessagesDeliveredChart.execute(
          Object.assign(new BuildMessagesDeliveredChartCommand(), {
            environmentId,
            organizationId,
            startDate,
            endDate,
          })
        ),
      });
    }

    if (reportType.includes(ReportTypeEnum.ACTIVE_SUBSCRIBERS)) {
      chartPromises.push({
        type: ReportTypeEnum.ACTIVE_SUBSCRIBERS,
        promise: this.buildActiveSubscribersChart.execute(
          Object.assign(new BuildActiveSubscribersChartCommand(), {
            environmentId,
            organizationId,
            startDate,
            endDate,
          })
        ),
      });
    }

    if (reportType.includes(ReportTypeEnum.AVG_MESSAGES_PER_SUBSCRIBER)) {
      chartPromises.push({
        type: ReportTypeEnum.AVG_MESSAGES_PER_SUBSCRIBER,
        promise: this.buildAvgMessagesPerSubscriberChart.execute(
          Object.assign(new BuildAvgMessagesPerSubscriberChartCommand(), {
            environmentId,
            organizationId,
            startDate,
            endDate,
          })
        ),
      });
    }

    if (reportType.includes(ReportTypeEnum.WORKFLOW_RUNS_METRIC)) {
      chartPromises.push({
        type: ReportTypeEnum.WORKFLOW_RUNS_METRIC,
        promise: this.buildWorkflowRunsMetricChart.execute(
          Object.assign(new BuildWorkflowRunsMetricChartCommand(), {
            environmentId,
            organizationId,
            startDate,
            endDate,
          })
        ),
      });
    }

    if (reportType.includes(ReportTypeEnum.WORKFLOW_RUNS_COUNT)) {
      data[ReportTypeEnum.WORKFLOW_RUNS_COUNT] = await this.buildWorkflowRunsCountChart.execute(
        Object.assign(new BuildWorkflowRunsCountChartCommand(), {
          environmentId,
          organizationId,
          startDate,
          endDate,
          workflowIds,
          subscriberIds,
          transactionIds,
          statuses,
          channels,
          topicKey,
        })
      );
    }

    if (reportType.includes(ReportTypeEnum.TOTAL_INTERACTIONS)) {
      chartPromises.push({
        type: ReportTypeEnum.TOTAL_INTERACTIONS,
        promise: this.buildTotalInteractionsChart.execute(
          Object.assign(new BuildTotalInteractionsChartCommand(), {
            environmentId,
            organizationId,
            startDate,
            endDate,
          })
        ),
      });
    }

    if (reportType.includes(ReportTypeEnum.WORKFLOW_RUNS_TREND)) {
      chartPromises.push({
        type: ReportTypeEnum.WORKFLOW_RUNS_TREND,
        promise: this.buildWorkflowRunsTrendChart.execute(
          BuildWorkflowRunsTrendChartCommand.create({
            environmentId,
            organizationId,
            startDate,
            endDate,
          })
        ),
      });
    }

    if (reportType.includes(ReportTypeEnum.ACTIVE_SUBSCRIBERS_TREND)) {
      chartPromises.push({
        type: ReportTypeEnum.ACTIVE_SUBSCRIBERS_TREND,
        promise: this.buildActiveSubscribersTrendChart.execute(
          BuildActiveSubscribersTrendChartCommand.create({
            environmentId,
            organizationId,
            startDate,
            endDate,
          })
        ),
      });
    }

    const results = await Promise.all(chartPromises.map(({ promise }) => promise));

    chartPromises.forEach(({ type }, index) => {
      data[type] = results[index];
    });

    return {
      data,
    };
  }

  private async validateRetentionLimitForTier(organizationId: string, createdAtGte?: string, createdAtLte?: string) {
    const organization = await this.organizationRepository.findById(organizationId);

    if (!organization) {
      throw new HttpException('Organization not found', HttpStatus.INTERNAL_SERVER_ERROR);
    }

    const maxRetentionMs = this.getMaxRetentionPeriodByOrganization(organization);

    const earliestAllowedDate = new Date(Date.now() - maxRetentionMs);

    // If no start date is provided, default to the earliest allowed date
    const effectiveStartDate = createdAtGte ? new Date(createdAtGte) : earliestAllowedDate;
    const effectiveEndDate = createdAtLte ? new Date(createdAtLte) : new Date();

    this.validateDateRange(earliestAllowedDate, effectiveStartDate, effectiveEndDate);

    return {
      after: effectiveStartDate.toISOString(),
      before: effectiveEndDate.toISOString(),
    };
  }

  private validateDateRange(earliestAllowedDate: Date, startDate: Date, endDate: Date) {
    if (startDate > endDate) {
      throw new HttpException(
        'Invalid date range: start date (createdAtGte) must be earlier than end date (createdAtLte)',
        HttpStatus.BAD_REQUEST
      );
    }

    // add buffer to account for time delay in execution
    const buffer = 1 * 60 * 60 * 1000; // 1 hour
    const bufferedEarliestAllowedDate = new Date(earliestAllowedDate.getTime() - buffer);

    if (startDate < bufferedEarliestAllowedDate || endDate < bufferedEarliestAllowedDate) {
      throw new HttpException(
        `Requested date range exceeds your plan's retention period. ` +
          `The earliest accessible date for your plan is ${earliestAllowedDate.toISOString().split('T')[0]}. ` +
          `Please upgrade your plan to access older activities.`,
        HttpStatus.PAYMENT_REQUIRED
      );
    }
  }

  /**
   * Charts data follows the same retention policy as activity feed notifications.
   * Data is automatically deleted after a certain period of time based on the organization's tier.
   */
  private getMaxRetentionPeriodByOrganization(organization: OrganizationEntity) {
    // 1. Self-hosted gets unlimited retention both community and enterprise
    if (process.env.IS_SELF_HOSTED === 'true') {
      return Number.MAX_SAFE_INTEGER;
    }

    const { apiServiceLevel, createdAt } = organization;

    // 2. Special case: Free tier orgs created before Feb 28, 2025 get 30 days
    if (apiServiceLevel === ApiServiceLevelEnum.FREE && new Date(createdAt) < new Date('2025-02-28')) {
      return 30 * 24 * 60 * 60 * 1000;
    }

    // 3. Otherwise, use tier-based retention from feature flags
    return getFeatureForTierAsNumber(
      FeatureNameEnum.PLATFORM_ACTIVITY_FEED_RETENTION,
      apiServiceLevel ?? ApiServiceLevelEnum.FREE,
      true
    );
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - results(await Promise.all(chartPromises.map(({ promise }))
Declaraciones 'export' encontradas:
- export class GetCharts

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/get-request/get-request.command.ts
Tamao: 206 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsString } from 'class-validator';

export class GetRequestCommand extends EnvironmentCommand {
  @IsString()
  requestId: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetRequestCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/get-request/get-request.usecase.ts
Tamao: 3355 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { QueryBuilder, RequestLog, RequestLogRepository, Trace, TraceLogRepository } from '@novu/application-generic';
import { GetRequestResponseDto, TraceResponseDto } from '../../dtos/get-request.response.dto';
import { mapTraceToResponseDto } from '../../shared/mappers';
import { requestLogSelectColumns, traceSelectColumns } from '../../shared/select.const';
import { GetRequestCommand } from './get-request.command';

@Injectable()
export class GetRequest {
  constructor(
    private readonly requestLogRepository: RequestLogRepository,
    private readonly traceLogRepository: TraceLogRepository
  ) {}

  async execute(command: GetRequestCommand): Promise<GetRequestResponseDto> {
    const requestQueryBuilder = new QueryBuilder<RequestLog>({
      environmentId: command.environmentId,
    });
    requestQueryBuilder.whereEquals('id', command.requestId);
    requestQueryBuilder.whereEquals('organization_id', command.organizationId);

    const request = await this.requestLogRepository.findOne({
      where: requestQueryBuilder.build(),
      select: requestLogSelectColumns,
    });

    if (!request?.data) {
      throw new NotFoundException(`Request with requestId ${command.requestId} not found`);
    }

    const traceQueryBuilder = new QueryBuilder<Trace>({
      environmentId: command.environmentId,
    });
    traceQueryBuilder.whereEquals('entity_id', command.requestId);
    traceQueryBuilder.whereEquals('entity_type', 'request');
    traceQueryBuilder.whereEquals('organization_id', command.organizationId);

    const traceResult = await this.traceLogRepository.find({
      where: traceQueryBuilder.build(),
      orderBy: 'created_at',
      orderDirection: 'ASC',
      select: traceSelectColumns,
    });

    const mappedTraces: TraceResponseDto[] = traceResult.data.map((trace) =>
      mapTraceToResponseDto({
        id: trace.id,
        createdAt: trace.created_at,
        eventType: trace.event_type,
        title: trace.title,
        message: trace.message ?? '',
        rawData: trace.raw_data ?? '',
        status: trace.status,
        entityType: trace.entity_type,
        entityId: trace.entity_id,
        organizationId: trace.organization_id,
        environmentId: trace.environment_id,
        userId: trace.user_id ?? '',
        externalSubscriberId: trace.external_subscriber_id ?? '',
        subscriberId: trace.subscriber_id ?? '',
      })
    );

    return {
      request: {
        id: request.data.id,
        createdAt: new Date(`${request.data.created_at} UTC`).toISOString(),
        url: request.data.url,
        urlPattern: request.data.url_pattern,
        method: request.data.method,
        statusCode: request.data.status_code,
        path: request.data.path,
        hostname: request.data.hostname,
        ip: request.data.ip,
        userAgent: request.data.user_agent,
        requestBody: request.data.request_body,
        responseBody: request.data.response_body,
        userId: request.data.user_id,
        organizationId: request.data.organization_id,
        environmentId: request.data.environment_id,
        authType: request.data.auth_type,
        durationMs: request.data.duration_ms,
        transactionId: request.data.transaction_id,
      },
      traces: mappedTraces,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetRequest

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/get-requests/get-requests.command.ts
Tamao: 599 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsArray, IsNumber, IsOptional, IsString } from 'class-validator';

export class GetRequestsCommand extends EnvironmentCommand {
  @IsNumber()
  @IsOptional()
  page?: number;

  @IsNumber()
  @IsOptional()
  limit?: number;

  @IsOptional()
  @IsArray()
  @IsNumber({}, { each: true })
  statusCodes?: number[];

  @IsString()
  @IsOptional()
  url?: string;

  @IsString()
  @IsOptional()
  urlPattern?: string;

  @IsString()
  @IsOptional()
  transactionId?: string;

  @IsOptional()
  @IsNumber()
  createdGte?: number;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetRequestsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/get-requests/get-requests.usecase.ts
Tamao: 2675 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { LogRepository, QueryBuilder, RequestLog, RequestLogRepository } from '@novu/application-generic';
import { GetRequestsResponseDto, RequestLogResponseDto } from '../../dtos/get-requests.response.dto';
import { requestLogSelectColumns } from '../../shared/select.const';
import { GetRequestsCommand } from './get-requests.command';

@Injectable()
export class GetRequests {
  constructor(private readonly requestLogRepository: RequestLogRepository) {}

  async execute(command: GetRequestsCommand): Promise<GetRequestsResponseDto> {
    const limit = command.limit || 10;
    const page = command.page || 0;
    const offset = page * limit;

    const queryBuilder = new QueryBuilder<RequestLog>({
      environmentId: command.environmentId,
    });

    if (command.statusCodes?.length) {
      queryBuilder.whereIn('status_code', command.statusCodes);
    }

    if (command.url) {
      queryBuilder.whereLike('url', `%${command.url}%`);
    }

    if (command.urlPattern) {
      queryBuilder.whereEquals('url_pattern', command.urlPattern);
    }

    if (command.transactionId) {
      queryBuilder.whereLike('transaction_id', `%${command.transactionId}%`);
    }

    if (command.createdGte) {
      queryBuilder.whereGreaterThanOrEqual('created_at', LogRepository.formatDateTime64(new Date(command.createdGte)));
    }

    const safeWhere = queryBuilder.build();

    const [findResult, total] = await Promise.all([
      this.requestLogRepository.find({
        where: safeWhere,
        limit,
        offset,
        orderBy: 'created_at',
        orderDirection: 'DESC',
        select: requestLogSelectColumns,
      }),
      this.requestLogRepository.count({ where: safeWhere }),
    ]);

    const mappedData: RequestLogResponseDto[] = findResult.data.map((request) => {
      return {
        id: request.id,
        createdAt: new Date(`${request.created_at} UTC`).toISOString(),
        method: request.method,
        path: request.path,
        statusCode: request.status_code,
        transactionId: request.transaction_id,
        requestBody: request.request_body,
        responseBody: request.response_body,
        url: request.url,
        urlPattern: request.url_pattern,
        hostname: request.hostname,
        ip: request.ip,
        userAgent: request.user_agent,
        authType: request.auth_type,
        durationMs: request.duration_ms,
        userId: request.user_id,
        organizationId: request.organization_id,
        environmentId: request.environment_id,
      };
    });

    return {
      data: mappedData,
      total,
      pageSize: limit,
      page,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetRequests

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/get-workflow-run/get-workflow-run.command.ts
Tamao: 245 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetWorkflowRunCommand extends EnvironmentWithUserCommand {
  @IsString()
  workflowRunId: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetWorkflowRunCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/get-workflow-run/get-workflow-run.usecase.ts
Tamao: 10018 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import {
  PinoLogger,
  QueryBuilder,
  StepRun,
  StepRunRepository,
  Trace,
  TraceLogRepository,
  WorkflowRun,
  WorkflowRunRepository,
} from '@novu/application-generic';
import { JobEntity, JobRepository } from '@novu/dal';
import { SeverityLevelEnum, StepTypeEnum } from '@novu/shared';
import { GetWorkflowRunResponseDto, StepRunDto } from '../../dtos/workflow-run-response.dto';
import { mapTraceToExecutionDetailDto, mapWorkflowRunStatusToDto } from '../../shared/mappers';
import { GetWorkflowRunCommand } from './get-workflow-run.command';

const workflowRunSelectColumns = [
  'workflow_run_id',
  'workflow_id',
  'workflow_name',
  'organization_id',
  'environment_id',
  'subscriber_id',
  'external_subscriber_id',
  'status',
  'trigger_identifier',
  'transaction_id',
  'channels',
  'subscriber_to',
  'payload',
  'control_values',
  'topics',
  'is_digest',
  'digested_workflow_run_id',
  'created_at',
  'updated_at',
  'delivery_lifecycle_status',
  'severity',
  'critical',
  'context_keys',
] as const;
type WorkflowRunFetchResult = Pick<WorkflowRun, (typeof workflowRunSelectColumns)[number]>;

const stepRunSelectColumns = [
  'step_run_id',
  'step_id',
  'workflow_run_id',
  'subscriber_id',
  'external_subscriber_id',
  'message_id',
  'step_type',
  'step_name',
  'provider_id',
  'status',
  'error_code',
  'error_message',
  'transaction_id',
  'created_at',
  'updated_at',
  'digest',
  'schedule_extensions_count',
] as const;
type StepRunFetchResult = Pick<StepRun, (typeof stepRunSelectColumns)[number]>;

const traceSelectColumns = ['entity_id', 'id', 'status', 'title', 'raw_data', 'created_at'] as const;
type TraceFetchResult = Pick<Trace, (typeof traceSelectColumns)[number]>;

interface IStepRunWithDetails extends StepRunFetchResult {
  executionDetails?: TraceFetchResult[];
}

@Injectable()
export class GetWorkflowRun {
  constructor(
    private workflowRunRepository: WorkflowRunRepository,
    private stepRunRepository: StepRunRepository,
    private traceLogRepository: TraceLogRepository,
    private jobRepository: JobRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  /**
   * BACKWARD COMPATIBILITY: This method fetches digest data from Job entities at runtime
   * for step runs that don't have digest data stored in ClickHouse.
   * TODO: Remove this method as part of task nv-6576 once all step runs have digest data stored
   */
  private async getJobDigestDataByTransactionId(
    transactionId: string,
    command: GetWorkflowRunCommand
  ): Promise<Map<string, string | null>> {
    try {
      const jobs: Pick<JobEntity, '_id' | 'step' | 'digest'>[] = await this.jobRepository.find(
        {
          transactionId,
          _environmentId: command.environmentId,
        },
        '_id step digest'
      );

      const digestDataByStepId = new Map<string, string | null>();

      for (const job of jobs) {
        if (job.digest && job.step?.stepId) {
          digestDataByStepId.set(job._id, JSON.stringify(job.digest));
        }
      }

      return digestDataByStepId;
    } catch (error) {
      this.logger.warn('Failed to get job digest data', {
        error: error.message,
        transactionId,
      });

      return new Map();
    }
  }

  async execute(command: GetWorkflowRunCommand): Promise<GetWorkflowRunResponseDto> {
    this.logger.debug('Getting workflow run from ClickHouse', {
      organizationId: command.organizationId,
      environmentId: command.environmentId,
      workflowRunId: command.workflowRunId,
    });

    try {
      const workflowRunQuery = new QueryBuilder<WorkflowRun>({
        environmentId: command.environmentId,
      })
        .whereEquals('workflow_run_id', command.workflowRunId)
        .build();

      const workflowRunResult = await this.workflowRunRepository.findOne({
        where: workflowRunQuery,
        useFinal: true,
        select: workflowRunSelectColumns,
      });

      if (!workflowRunResult.data) {
        throw new NotFoundException('Workflow run not found', {
          cause: `Workflow run with id ${command.workflowRunId} not found`,
        });
      }

      const workflowRun = workflowRunResult.data;
      const stepRuns = await this.getStepRunsForWorkflowRun(command, workflowRun);
      const workflowRunDto = this.mapWorkflowRunToDto(workflowRun, stepRuns);

      return workflowRunDto;
    } catch (error) {
      this.logger.error('Failed to get workflow run', {
        error: error.message,
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        workflowRunId: command.workflowRunId,
      });
      throw error;
    }
  }

  private async getStepRunsForWorkflowRun(
    command: GetWorkflowRunCommand,
    workflowRun: WorkflowRunFetchResult
  ): Promise<IStepRunWithDetails[]> {
    try {
      const stepRunsQuery = new QueryBuilder<StepRun>({
        environmentId: command.environmentId,
      })
        .whereEquals('transaction_id', workflowRun.transaction_id)
        .whereEquals('workflow_run_id', workflowRun.workflow_run_id)
        .build();

      const stepRunsResult = await this.stepRunRepository.find({
        where: stepRunsQuery,
        orderBy: 'created_at',
        orderDirection: 'ASC',
        useFinal: true,
        select: stepRunSelectColumns,
      });

      if (!stepRunsResult.data || stepRunsResult.data.length === 0) {
        return [];
      }

      const stepRunIds = stepRunsResult.data.map((stepRun) => stepRun.step_run_id);
      const executionDetailsByStepRunId = await this.getExecutionDetailsByEntityId(stepRunIds, command);

      // BACKWARD COMPATIBILITY: Check if any step runs are missing digest data
      // TODO: Remove this logic as part of task nv-6576 once all step runs have digest data stored
      const stepRunsWithoutDigest = stepRunsResult.data.filter(
        (stepRun) => !stepRun.digest && stepRun.step_type === StepTypeEnum.DIGEST
      );
      const digestDataByStepId =
        stepRunsWithoutDigest.length > 0
          ? await this.getJobDigestDataByTransactionId(workflowRun.transaction_id, command)
          : new Map<string, string | null>();

      return stepRunsResult.data.map(
        (stepRun) =>
          ({
            ...stepRun,
            executionDetails: executionDetailsByStepRunId.get(stepRun.step_run_id) || [],
            digest: stepRun.digest ? stepRun.digest : digestDataByStepId.get(stepRun.step_run_id) || null,
          }) satisfies IStepRunWithDetails
      );
    } catch (error) {
      this.logger.warn(
        {
          nv: {
            error: error.message,
            workflowRunId: command.workflowRunId,
            transactionId: workflowRun.transaction_id,
          },
        },
        'Failed to get step runs for workflow run'
      );

      return [];
    }
  }

  private async getExecutionDetailsByEntityId(
    entityIds: string[],
    command: GetWorkflowRunCommand
  ): Promise<Map<string, TraceFetchResult[]>> {
    if (entityIds.length === 0) {
      return new Map();
    }

    try {
      const traceQuery = new QueryBuilder<Trace>({
        environmentId: command.environmentId,
      })
        .whereIn('entity_id', entityIds)
        .whereEquals('entity_type', 'step_run')
        .build();

      const traceResult = await this.traceLogRepository.find({
        where: traceQuery,
        orderBy: 'created_at',
        orderDirection: 'ASC',
        select: traceSelectColumns,
      });

      const executionDetailsByEntityId = new Map<string, TraceFetchResult[]>();

      for (const trace of traceResult.data) {
        if (!executionDetailsByEntityId.has(trace.entity_id)) {
          executionDetailsByEntityId.set(trace.entity_id, []);
        }

        const existingTraces = executionDetailsByEntityId.get(trace.entity_id);
        if (existingTraces) {
          existingTraces.push(trace);
        }
      }

      return executionDetailsByEntityId;
    } catch (error) {
      this.logger.warn('Failed to get execution details from traces', {
        error: error.message,
        entityIds,
      });

      return new Map();
    }
  }

  private mapStepRunToDto(stepRun: IStepRunWithDetails): StepRunDto {
    return {
      stepRunId: stepRun.step_run_id,
      stepId: stepRun.step_id,
      stepType: stepRun.step_type,
      providerId: stepRun.provider_id || undefined,
      status: stepRun.status,
      createdAt: new Date(stepRun.created_at),
      updatedAt: new Date(stepRun.updated_at),
      digest: stepRun.digest ? JSON.parse(stepRun.digest) : undefined,
      executionDetails: mapTraceToExecutionDetailDto(stepRun.executionDetails || []),
      scheduleExtensionsCount: stepRun.schedule_extensions_count,
    };
  }

  private mapWorkflowRunToDto(
    workflowRun: WorkflowRunFetchResult,
    stepRuns: IStepRunWithDetails[]
  ): GetWorkflowRunResponseDto {
    return {
      id: workflowRun.workflow_run_id,
      workflowId: workflowRun.workflow_id,
      workflowName: workflowRun.workflow_name,
      organizationId: workflowRun.organization_id,
      environmentId: workflowRun.environment_id,
      internalSubscriberId: workflowRun.subscriber_id,
      subscriberId: workflowRun.external_subscriber_id || undefined,
      status: mapWorkflowRunStatusToDto(workflowRun.status),
      deliveryLifecycleStatus: workflowRun.delivery_lifecycle_status,
      triggerIdentifier: workflowRun.trigger_identifier,
      transactionId: workflowRun.transaction_id,
      createdAt: new Date(`${workflowRun.created_at} UTC`).toISOString(),
      updatedAt: new Date(`${workflowRun.updated_at} UTC`).toISOString(),
      payload: workflowRun.payload ? JSON.parse(workflowRun.payload) : {},
      steps: stepRuns.map((stepRun) => this.mapStepRunToDto(stepRun)),
      severity: workflowRun.severity,
      critical: workflowRun.critical,
      contextKeys: workflowRun.context_keys,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - stepRunIds(stepRunsResult.data.map((stepRun))
 - stepRunsWithoutDigest(stepRunsResult.data.filter(
        (stepRun))
 - digestDataByStepId(stepRunsWithoutDigest.length > 0
          ? await this.getJobDigestDataByTransactionId(workflowRun....)
 - existingTraces(executionDetailsByEntityId.get(trace.entity_id);
        if (existingTraces) {
          existingTra...)
Declaraciones 'export' encontradas:
- export class GetWorkflowRun

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/get-workflow-runs/get-workflow-runs.command.ts
Tamao: 1311 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SeverityLevelEnum } from '@novu/shared';
import { IsArray, IsIn, IsInt, IsISO8601, IsOptional, IsString, Max, Min } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';
import { WorkflowRunStatusDtoEnum } from '../../dtos/shared.dto';

export class GetWorkflowRunsCommand extends EnvironmentWithUserCommand {
  @IsInt()
  @Min(1)
  @Max(100)
  limit: number;

  @IsOptional()
  @IsString()
  cursor?: string;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  workflowIds?: string[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  subscriberIds?: string[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  transactionIds?: string[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  statuses?: WorkflowRunStatusDtoEnum[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  channels?: string[];

  @IsOptional()
  @IsString()
  topicKey?: string;

  @IsOptional()
  @IsISO8601()
  createdGte?: string;

  @IsOptional()
  @IsISO8601()
  createdLte?: string;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  @IsIn(Object.values(SeverityLevelEnum), { each: true })
  severity?: SeverityLevelEnum[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  contextKeys?: string[];
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetWorkflowRunsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/activity/usecases/get-workflow-runs/get-workflow-runs.usecase.ts
Tamao: 13666 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import {
  ClickhouseOperator,
  FieldCondition,
  PinoLogger,
  QueryBuilder,
  StepRun,
  StepRunRepository,
  Where,
  WorkflowRun,
  WorkflowRunRepository,
  WorkflowRunStatusEnum,
} from '@novu/application-generic';
import { SeverityLevelEnum } from '@novu/shared';
import { WorkflowRunStatusDtoEnum } from '../../dtos/shared.dto';
import { GetWorkflowRunsDto, GetWorkflowRunsResponseDto } from '../../dtos/workflow-runs-response.dto';
import { mapWorkflowRunStatusToDto } from '../../shared/mappers';
import { GetWorkflowRunsCommand } from './get-workflow-runs.command';

type CursorData = {
  created_at: string;
  workflow_run_id: string;
};

const workflowRunSelectColumns = [
  'workflow_run_id',
  'workflow_id',
  'workflow_name',
  'organization_id',
  'environment_id',
  'subscriber_id',
  'external_subscriber_id',
  'status',
  'trigger_identifier',
  'transaction_id',
  'created_at',
  'updated_at',
  'delivery_lifecycle_status',
  'severity',
  'critical',
  'context_keys',
] as const;
type WorkflowRunFetchResult = Pick<WorkflowRun, (typeof workflowRunSelectColumns)[number]>;

const stepRunSelectColumns = [
  'id',
  'step_run_id',
  'step_id',
  'workflow_run_id',
  'subscriber_id',
  'external_subscriber_id',
  'step_type',
  'step_name',
  'provider_id',
  'status',
  'transaction_id',
  'created_at',
  'updated_at',
] as const;
type StepRunFetchResult = Pick<StepRun, (typeof stepRunSelectColumns)[number]>;

@Injectable()
export class GetWorkflowRuns {
  constructor(
    private workflowRunRepository: WorkflowRunRepository,
    private stepRunRepository: StepRunRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(GetWorkflowRuns.name);
  }

  async execute(command: GetWorkflowRunsCommand): Promise<GetWorkflowRunsResponseDto> {
    this.logger.debug('Getting workflow runs with compound cursor-based pagination', {
      organizationId: command.organizationId,
      environmentId: command.environmentId,
      limit: command.limit,
      cursor: command.cursor ? 'present' : 'not-present',
    });

    try {
      const queryBuilder = new QueryBuilder<WorkflowRun>({
        environmentId: command.environmentId,
      });

      if (command.workflowIds?.length) {
        queryBuilder.whereIn('workflow_id', command.workflowIds);
      }

      if (command.subscriberIds?.length) {
        queryBuilder.whereIn('external_subscriber_id', command.subscriberIds);
      }

      if (command.transactionIds?.length) {
        queryBuilder.whereIn('transaction_id', command.transactionIds);
      }

      if (command.statuses?.length) {
        const statuses = command.statuses.map((status) => {
          //backward compatibility: if new statuses are used, append old status until renewed in the database, nv-6562
          if (status === WorkflowRunStatusDtoEnum.PROCESSING) {
            return [WorkflowRunStatusEnum.PENDING, WorkflowRunStatusEnum.PROCESSING];
          }
          if (status === WorkflowRunStatusDtoEnum.COMPLETED) {
            return [WorkflowRunStatusEnum.SUCCESS, WorkflowRunStatusEnum.COMPLETED];
          }
          if (status === WorkflowRunStatusDtoEnum.ERROR) {
            return [WorkflowRunStatusEnum.ERROR];
          }
          return status;
        });
        queryBuilder.whereIn('status', statuses.flat());
      }

      if (command.createdGte) {
        queryBuilder.whereGreaterThanOrEqual('created_at', new Date(command.createdGte));
      }

      if (command.createdLte) {
        queryBuilder.whereLessThanOrEqual('created_at', new Date(command.createdLte));
      }

      if (command.channels?.length) {
        queryBuilder.orWhere(
          command.channels.map((channel) => ({
            field: 'channels',
            operator: 'LIKE',
            value: `%"${channel}"%`,
          }))
        );
      }

      const severity = command.severity ?? [];
      if (severity.length) {
        const orConditions: Array<FieldCondition<WorkflowRun, keyof WorkflowRun, ClickhouseOperator>> = [];
        if (severity.includes(SeverityLevelEnum.NONE)) {
          orConditions.push({
            field: 'severity',
            operator: 'IS NULL',
          });
          orConditions.push({
            field: 'severity',
            operator: '=',
            value: SeverityLevelEnum.NONE,
          });
        }
        const severityWithoutNone = severity.filter((severity) => severity !== SeverityLevelEnum.NONE);
        for (const severity of severityWithoutNone) {
          orConditions.push({
            field: 'severity',
            operator: '=',
            value: severity.toString(),
          });
        }
        queryBuilder.orWhere(orConditions);
      }

      if (command.topicKey) {
        queryBuilder.whereLike('topics', `%${command.topicKey}%`);
      }

      if (command.contextKeys?.length) {
        // This checks if context_keys array contains any of the specified keys
        queryBuilder.whereHasAny('context_keys', command.contextKeys);
      }

      const safeWhere = queryBuilder.build();

      let cursor: CursorData | undefined;
      if (command.cursor) {
        try {
          cursor = this.decodeCursor(command.cursor);
          this.logger.debug('Using compound cursor pagination', {
            timestamp: cursor.created_at,
            workflowRunId: cursor.workflow_run_id,
          });
        } catch (error) {
          throw new BadRequestException('Invalid cursor format');
        }
      }

      const result = (await this.workflowRunRepository.findWithCursor({
        where: safeWhere,
        cursor,
        limit: command.limit + 1, // Get one extra to determine if there are more results
        orderDirection: 'DESC',
        useFinal: true, // Use FINAL for consistent reads in ReplacingMergeTree
        select: workflowRunSelectColumns,
      })) satisfies { data: WorkflowRunFetchResult[] };

      const workflowRuns = result.data;
      const hasMore = workflowRuns.length > command.limit;

      // Remove the extra item if present
      if (hasMore) {
        workflowRuns.pop();
      }

      // Generate next cursor if there are more results
      let nextCursor: string | null = null;
      if (hasMore && workflowRuns.length > 0) {
        const lastRun = workflowRuns[workflowRuns.length - 1];
        nextCursor = this.encodeCursor({
          created_at: this.parseClickHouseTimestamp(lastRun.created_at).toISOString(),
          workflow_run_id: lastRun.workflow_run_id,
        });
      }

      // Generate previous cursor if we're not on the first page
      let previousCursor: string | null = null;
      if (command.cursor && workflowRuns.length > 0) {
        previousCursor = await this.generatePreviousCursor(safeWhere, cursor!, command.limit);
      }

      // Fetch step runs for all workflow runs efficiently
      const stepRunsByCompositeKey = await this.getStepRunsForWorkflowRuns(command, workflowRuns);

      const data = workflowRuns.map((workflowRun) => {
        const compositeKey = `${workflowRun.subscriber_id}:${workflowRun.transaction_id}`;

        return this.mapWorkflowRunToDto(workflowRun, stepRunsByCompositeKey.get(compositeKey) || []);
      });

      return {
        data,
        next: nextCursor,
        previous: previousCursor,
      };
    } catch (error) {
      this.logger.error('Failed to get workflow runs', {
        error: error.message,
        organizationId: command.organizationId,
        environmentId: command.environmentId,
      });
      throw error;
    }
  }

  /**
   * Generates the previous cursor using a simple approach:
   * Query backwards from current cursor and use the last item as the boundary
   */
  private async generatePreviousCursor(
    safeWhere: Where<WorkflowRun>,
    currentCursor: CursorData,
    limit: number
  ): Promise<string | null> {
    const isBoundaryCase = currentCursor?.workflow_run_id === '1'; // first or last item
    // Return empty when at boundary during cursor computation - cannot compute previous page beyond dataset limits
    if (isBoundaryCase) {
      return null;
    }

    try {
      const backwardResult = await this.workflowRunRepository.findWithCursor({
        where: safeWhere,
        cursor: currentCursor,
        limit,
        orderDirection: 'ASC', // Get older items
        useFinal: true,
        select: ['created_at', 'workflow_run_id'],
      });

      const previousPageItems = backwardResult.data as WorkflowRun[];

      if (previousPageItems.length === 0) {
        return null;
      }

      if (previousPageItems.length < limit) {
        return this.encodeCursor({
          created_at: new Date(0).toISOString(), // Unix epoch (1970-01-01)
          workflow_run_id: '1', // Earliest possible workflow_run_id
        });
      }

      /*
       * Use the last item from the previous page as the cursor.
       * When this cursor is used with DESC order, it will exclude this item
       * and everything older, effectively giving us the previous page.
       */
      const lastItemOfPreviousPage = previousPageItems[previousPageItems.length - 1];

      return this.encodeCursor({
        created_at: this.parseClickHouseTimestamp(lastItemOfPreviousPage.created_at).toISOString(),
        workflow_run_id: lastItemOfPreviousPage.workflow_run_id,
      });
    } catch (error) {
      this.logger.error('Failed to generate previous cursor', {
        error: error.message,
        currentCursor,
      });

      return null;
    }
  }

  /**
   * Cursor-based pagination implementation for ClickHouse optimization
   * This approach provides consistent performance regardless of page depth
   */
  private encodeCursor(data: CursorData): string {
    return Buffer.from(JSON.stringify(data)).toString('base64');
  }

  private decodeCursor(cursor: string): CursorData {
    return JSON.parse(Buffer.from(cursor, 'base64').toString('utf-8'));
  }

  /**
   * Parses ClickHouse timestamp format as UTC
   * ClickHouse returns timestamps in format "YYYY-MM-DD HH:mm:ss.SSS" which should be treated as UTC
   * but JavaScript's Date constructor interprets them as local time by default
   */
  private parseClickHouseTimestamp(timestamp: string | Date): Date {
    // If already a Date object, return as-is
    if (timestamp instanceof Date) {
      return timestamp;
    }

    /*
     * ClickHouse format: "2025-07-23 13:52:52.860"
     * Convert to ISO format with explicit UTC: "2025-07-23T13:52:52.860Z"
     */
    const isoFormat = `${timestamp.replace(' ', 'T')}Z`;

    return new Date(isoFormat);
  }

  /**
   * Efficiently fetch step runs for multiple workflow runs using batch query
   * Groups by composite key: subscriber_id:transaction_id
   */
  private async getStepRunsForWorkflowRuns(
    command: GetWorkflowRunsCommand,
    workflowRuns: WorkflowRunFetchResult[]
  ): Promise<Map<string, StepRunFetchResult[]>> {
    if (workflowRuns.length === 0) {
      return new Map();
    }

    try {
      const transactionIds = workflowRuns.map((run) => run.transaction_id);
      const stepRunsQuery = new QueryBuilder<StepRun>({
        environmentId: command.environmentId,
      })
        .whereIn('transaction_id', transactionIds)
        .build();

      const stepRunsResult = await this.stepRunRepository.find({
        where: stepRunsQuery,
        orderBy: 'created_at',
        orderDirection: 'ASC',
        useFinal: true,
        select: stepRunSelectColumns,
      });

      // Group step runs by composite key: subscriber_id:transaction_id
      const stepRunsByCompositeKey = new Map<string, StepRunFetchResult[]>();

      for (const stepRun of stepRunsResult.data) {
        const compositeKey = `${stepRun.subscriber_id}:${stepRun.transaction_id}`;
        if (!stepRunsByCompositeKey.has(compositeKey)) {
          stepRunsByCompositeKey.set(compositeKey, []);
        }
        // biome-ignore lint/style/noNonNullAssertion: <explanation> because we otherwise the if statement would set it to the map
        stepRunsByCompositeKey.get(compositeKey)!.push(stepRun);
      }

      return stepRunsByCompositeKey;
    } catch (error) {
      this.logger.warn('Failed to get step runs for workflow runs', {
        error: error.message,
        transactionIds: workflowRuns.map((run) => run.transaction_id),
        subscriberIds: workflowRuns.map((run) => run.subscriber_id),
      });

      return new Map();
    }
  }

  private mapWorkflowRunToDto(workflowRun: WorkflowRunFetchResult, stepRuns: StepRunFetchResult[]): GetWorkflowRunsDto {
    return {
      id: workflowRun.workflow_run_id,
      workflowId: workflowRun.workflow_id,
      workflowName: workflowRun.workflow_name,
      organizationId: workflowRun.organization_id,
      environmentId: workflowRun.environment_id,
      internalSubscriberId: workflowRun.subscriber_id,
      subscriberId: workflowRun.external_subscriber_id || undefined,
      status: mapWorkflowRunStatusToDto(workflowRun.status),
      deliveryLifecycleStatus: workflowRun.delivery_lifecycle_status,
      triggerIdentifier: workflowRun.trigger_identifier,
      transactionId: workflowRun.transaction_id,
      createdAt: new Date(`${workflowRun.created_at} UTC`).toISOString(),
      updatedAt: new Date(`${workflowRun.updated_at} UTC`).toISOString(),
      steps: stepRuns.map((stepRun) => ({
        id: stepRun.id,
        stepRunId: stepRun.step_run_id,
        stepType: stepRun.step_type,
        status: stepRun.status,
      })),
      severity: workflowRun.severity,
      critical: workflowRun.critical,
      contextKeys: workflowRun.context_keys,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - statuses(command.statuses.map((status))
 - severityWithoutNone(severity.filter((severity))
 - data(workflowRuns.map((workflowRun))
 - transactionIds(workflowRuns.map((run))
 - compositeKey(`${stepRun.subscriber_id}:${stepRun.transaction_id}`;
        if (!stepRunsByCompositeKey.has(compos...)
Declaraciones 'export' encontradas:
- export class GetWorkflowRuns

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/analytics/analytics.controller.ts
Tamao: 2322 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Body, Controller, HttpCode, HttpStatus, Post } from '@nestjs/common';
import { ApiExcludeController } from '@nestjs/swagger';
import { SkipThrottle } from '@nestjs/throttler';
import { AnalyticsService, ExternalApiAccessible, SkipPermissionsCheck, UserSession } from '@novu/application-generic';
import { UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { HubspotIdentifyFormCommand } from './usecases/hubspot-identify-form/hubspot-identify-form.command';
import { HubspotIdentifyFormUsecase } from './usecases/hubspot-identify-form/hubspot-identify-form.usecase';

@Controller({
  path: 'telemetry',
})
@SkipThrottle()
@RequireAuthentication()
@ApiExcludeController()
export class AnalyticsController {
  constructor(
    private analyticsService: AnalyticsService,
    private hubspotIdentifyFormUsecase: HubspotIdentifyFormUsecase
  ) {}

  @Post('/measure')
  @ExternalApiAccessible()
  @SkipPermissionsCheck()
  async trackEvent(@Body('event') event, @Body('data') data = {}, @UserSession() user: UserSessionData): Promise<any> {
    this.analyticsService.track(event, user._id, {
      ...(data || {}),
      _organization: user?.organizationId,
    });

    return {
      success: true,
    };
  }

  @Post('/identify')
  @ExternalApiAccessible()
  @HttpCode(HttpStatus.NO_CONTENT)
  @SkipPermissionsCheck()
  async identifyUser(@Body() body: any, @UserSession() user: UserSessionData) {
    if (body.anonymousId) {
      this.analyticsService.alias(body.anonymousId, user._id);
    }

    this.analyticsService.upsertUser(user, user._id, {
      organizationType: body.organizationType,
      companySize: body.companySize,
      jobTitle: body.jobTitle,
    });

    this.analyticsService.updateGroup(user._id, user.organizationId, {
      organizationType: body.organizationType,
      companySize: body.companySize,
      jobTitle: body.jobTitle,
    });

    await this.hubspotIdentifyFormUsecase.execute(
      HubspotIdentifyFormCommand.create({
        email: user.email as string,
        lastName: user.lastName,
        firstName: user.firstName,
        hubspotContext: body.hubspotContext,
        pageUri: body.pageUri,
        pageName: body.pageName,
        organizationId: user.organizationId,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class AnalyticsController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/analytics/analytics.module.ts
Tamao: 478 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpModule } from '@nestjs/axios';
import { Module } from '@nestjs/common';
import { SharedModule } from '../shared/shared.module';
import { AnalyticsController } from './analytics.controller';
import { HubspotIdentifyFormUsecase } from './usecases/hubspot-identify-form/hubspot-identify-form.usecase';

@Module({
  imports: [SharedModule, HttpModule],
  controllers: [AnalyticsController],
  providers: [HubspotIdentifyFormUsecase],
})
export class AnalyticsModule {}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class AnalyticsModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/analytics/usecases/hubspot-identify-form/hubspot-identify-form.command.ts
Tamao: 557 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsDefined, IsOptional, IsString } from 'class-validator';

export class HubspotIdentifyFormCommand extends BaseCommand {
  @IsDefined()
  @IsString()
  email: string;

  @IsOptional()
  @IsString()
  lastName?: string;

  @IsOptional()
  @IsString()
  firstName?: string;

  @IsOptional()
  @IsString()
  hubspotContext?: string;

  @IsOptional()
  @IsString()
  pageUri?: string;

  @IsOptional()
  @IsString()
  pageName?: string;

  @IsDefined()
  @IsString()
  organizationId: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class HubspotIdentifyFormCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/analytics/usecases/hubspot-identify-form/hubspot-identify-form.usecase.ts
Tamao: 1770 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpService } from '@nestjs/axios';
import { Injectable } from '@nestjs/common';
import { PinoLogger } from '@novu/application-generic';
import { AxiosError } from 'axios';
import { HubspotIdentifyFormCommand } from './hubspot-identify-form.command';

const LOG_CONTEXT = 'HubspotIdentifyFormUsecase';

@Injectable()
export class HubspotIdentifyFormUsecase {
  private readonly hubspotPortalId = '44416662';
  private readonly hubspotFormId = 'fc39aa98-4285-4322-9514-52da978baae8';

  constructor(
    private httpService: HttpService,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: HubspotIdentifyFormCommand) {
    try {
      const hubspotSubmitUrl = `https://api.hsforms.com/submissions/v3/integration/submit/${this.hubspotPortalId}/${this.hubspotFormId}`;

      const hubspotData = {
        fields: [
          { name: 'email', value: command.email },
          { name: 'lastname', value: command.lastName || 'Unknown' },
          { name: 'firstname', value: command.firstName || 'Unknown' },
          { name: 'app_organizationid', value: command.organizationId },
        ],
        context: {
          hutk: command.hubspotContext,
          pageUri: command.pageUri,
          pageName: command.pageName,
        },
      };

      this.httpService.post(hubspotSubmitUrl, hubspotData);
    } catch (error) {
      if (error instanceof AxiosError) {
        this.logger.error(
          `Failed to submit to Hubspot message=${error.message}, status=${error.status}`,
          {
            organizationId: command.organizationId,
            response: error.response?.data,
          },
          LOG_CONTEXT
        );
      } else {
        throw error;
      }
    }
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class HubspotIdentifyFormUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/auth.controller.ts
Tamao: 6801 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  BadRequestException,
  Body,
  ClassSerializerInterceptor,
  Controller,
  Get,
  Header,
  HttpCode,
  HttpStatus,
  NotFoundException,
  Param,
  Post,
  Query,
  Req,
  Res,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { ApiExcludeController, ApiTags } from '@nestjs/swagger';
import { buildOauthRedirectUrl, PinoLogger } from '@novu/application-generic';
import { MemberEntity, MemberRepository, UserRepository } from '@novu/dal';
import { PasswordResetFlowEnum, UserSessionData } from '@novu/shared';
import { ApiCommonResponses } from '../shared/framework/response.decorator';
import { UserSession } from '../shared/framework/user.decorator';
import { LoginBodyDto } from './dtos/login.dto';
import { PasswordResetBodyDto, PasswordResetRequestBodyDto } from './dtos/password-reset.dto';
import { UpdatePasswordBodyDto } from './dtos/update-password.dto';
import { UserRegistrationBodyDto } from './dtos/user-registration.dto';
import { RequireAuthentication } from './framework/auth.decorator';
import { AuthService } from './services/auth.service';
import { LoginCommand } from './usecases/login/login.command';
import { Login } from './usecases/login/login.usecase';
import { PasswordResetCommand } from './usecases/password-reset/password-reset.command';
import { PasswordReset } from './usecases/password-reset/password-reset.usecase';
import { PasswordResetRequestCommand } from './usecases/password-reset-request/password-reset-request.command';
import { PasswordResetRequest } from './usecases/password-reset-request/password-reset-request.usecase';
import { UserRegisterCommand } from './usecases/register/user-register.command';
import { UserRegister } from './usecases/register/user-register.usecase';
import { SwitchOrganizationCommand } from './usecases/switch-organization/switch-organization.command';
import { SwitchOrganization } from './usecases/switch-organization/switch-organization.usecase';
import { UpdatePasswordCommand } from './usecases/update-password/update-password.command';
import { UpdatePassword } from './usecases/update-password/update-password.usecase';

@ApiCommonResponses()
@Controller('/auth')
@UseInterceptors(ClassSerializerInterceptor)
@ApiTags('Auth')
@ApiExcludeController()
export class AuthController {
  constructor(
    private userRepository: UserRepository,
    private authService: AuthService,
    private userRegisterUsecase: UserRegister,
    private loginUsecase: Login,
    private switchOrganizationUsecase: SwitchOrganization,
    private memberRepository: MemberRepository,
    private passwordResetRequestUsecase: PasswordResetRequest,
    private passwordResetUsecase: PasswordReset,
    private updatePasswordUsecase: UpdatePassword,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  @Get('/github')
  githubAuth() {
    this.logger.trace('Checking Github Auth');

    if (!process.env.GITHUB_OAUTH_CLIENT_ID || !process.env.GITHUB_OAUTH_CLIENT_SECRET) {
      throw new BadRequestException(
        'GitHub auth is not configured, please provide GITHUB_OAUTH_CLIENT_ID and GITHUB_OAUTH_CLIENT_SECRET as env variables'
      );
    }

    this.logger.trace('Github Auth has all variables.');

    return {
      success: true,
    };
  }

  @Get('/github/callback')
  @UseGuards(AuthGuard('github'))
  async githubCallback(@Req() request, @Res() response) {
    const url = buildOauthRedirectUrl(request);

    return response.redirect(url);
  }

  @Get('/refresh')
  @RequireAuthentication()
  @Header('Cache-Control', 'no-store')
  refreshToken(@UserSession() user: UserSessionData) {
    if (!user || !user._id) throw new BadRequestException();

    return this.authService.refreshToken(user._id);
  }

  @Post('/register')
  @Header('Cache-Control', 'no-store')
  async userRegistration(@Body() body: UserRegistrationBodyDto) {
    return await this.userRegisterUsecase.execute(
      UserRegisterCommand.create({
        email: body.email,
        password: body.password,
        firstName: body.firstName,
        lastName: body.lastName,
        organizationName: body.organizationName,
        origin: body.origin,
        jobTitle: body.jobTitle,
        domain: body.domain,
        productUseCases: body.productUseCases,
        wasInvited: !!body.invitationToken,
      })
    );
  }

  @Post('/reset/request')
  async forgotPasswordRequest(@Body() body: PasswordResetRequestBodyDto, @Query('src') src?: string) {
    return await this.passwordResetRequestUsecase.execute(
      PasswordResetRequestCommand.create({
        email: body.email,
        src: src as PasswordResetFlowEnum,
      })
    );
  }

  @Post('/reset')
  async passwordReset(@Body() body: PasswordResetBodyDto) {
    return await this.passwordResetUsecase.execute(
      PasswordResetCommand.create({
        password: body.password,
        token: body.token,
      })
    );
  }

  @Post('/login')
  @Header('Cache-Control', 'no-store')
  async userLogin(@Body() body: LoginBodyDto) {
    return await this.loginUsecase.execute(
      LoginCommand.create({
        email: body.email,
        password: body.password,
      })
    );
  }

  @Post('/organizations/:organizationId/switch')
  @RequireAuthentication()
  @HttpCode(200)
  @Header('Cache-Control', 'no-store')
  async organizationSwitch(@UserSession() user: UserSessionData, @Param('organizationId') organizationId: string) {
    const command = SwitchOrganizationCommand.create({
      userId: user._id,
      newOrganizationId: organizationId,
    });

    return this.switchOrganizationUsecase.execute(command);
  }

  @Post('/update-password')
  @Header('Cache-Control', 'no-store')
  @RequireAuthentication()
  @HttpCode(HttpStatus.NO_CONTENT)
  async updatePassword(@UserSession() user: UserSessionData, @Body() body: UpdatePasswordBodyDto) {
    return await this.updatePasswordUsecase.execute(
      UpdatePasswordCommand.create({
        userId: user._id,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        currentPassword: body.currentPassword,
        newPassword: body.newPassword,
        confirmPassword: body.confirmPassword,
      })
    );
  }

  @Get('/test/token/:userId')
  async authenticateTest(@Param('userId') userId: string, @Query('organizationId') organizationId: string) {
    if (process.env.NODE_ENV !== 'test') throw new NotFoundException();

    const user = await this.userRepository.findById(userId);
    if (!user) throw new BadRequestException('No user found');

    const member = organizationId ? await this.memberRepository.findMemberByUserId(organizationId, user._id) : null;

    return await this.authService.getSignedToken(user, organizationId, member as MemberEntity);
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class AuthController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/auth.module.ts
Tamao: 728 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Global, MiddlewareConsumer, Module, ModuleMetadata } from '@nestjs/common';
import { isClerkEnabled } from '@novu/shared';
import { configure as configureCommunity, getCommunityAuthModuleConfig } from './community.auth.module.config';
import { configure as configureEE, getEEModuleConfig } from './ee.auth.module.config';

function getModuleConfig(): ModuleMetadata {
  if (isClerkEnabled()) {
    return getEEModuleConfig();
  } else {
    return getCommunityAuthModuleConfig();
  }
}

@Global()
@Module(getModuleConfig())
export class AuthModule {
  public configure(consumer: MiddlewareConsumer) {
    if (isClerkEnabled()) {
      configureEE(consumer);
    } else {
      configureCommunity(consumer);
    }
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - getModuleConfig()
Declaraciones 'export' encontradas:
- export class AuthModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/community.auth.module.config.ts
Tamao: 2973 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MiddlewareConsumer, ModuleMetadata, Provider, RequestMethod } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { CommunityMemberRepository, CommunityOrganizationRepository, CommunityUserRepository } from '@novu/dal';
import { AuthProviderEnum, PassportStrategyEnum } from '@novu/shared';
import passport from 'passport';
import { EnvironmentsModuleV1 } from '../environments-v1/environments-v1.module';
import { SharedModule } from '../shared/shared.module';
import { UserModule } from '../user/user.module';
import { AuthController } from './auth.controller';
import { RootEnvironmentGuard } from './framework/root-environment-guard.service';
import { AuthService } from './services/auth.service';
import { CommunityAuthService } from './services/community.auth.service';
import { ApiKeyStrategy } from './services/passport/apikey.strategy';
import { GitHubStrategy } from './services/passport/github.strategy';
import { JwtStrategy } from './services/passport/jwt.strategy';
import { JwtSubscriberStrategy } from './services/passport/subscriber-jwt.strategy';
import { USE_CASES } from './usecases';

const AUTH_STRATEGIES: Provider[] = [JwtStrategy, ApiKeyStrategy, JwtSubscriberStrategy];

if (process.env.GITHUB_OAUTH_CLIENT_ID) {
  AUTH_STRATEGIES.push(GitHubStrategy);
}

export function getCommunityAuthModuleConfig(): ModuleMetadata {
  const baseImports = [
    PassportModule.register({
      defaultStrategy: PassportStrategyEnum.JWT,
    }),
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      signOptions: {
        expiresIn: 360000,
      },
    }),
  ];

  const baseProviders = [...AUTH_STRATEGIES, AuthService, RootEnvironmentGuard];

  // Wherever is the string token used, override it with the provider
  const injectableProviders = [
    {
      provide: 'USER_REPOSITORY',
      useClass: CommunityUserRepository,
    },
    {
      provide: 'ORGANIZATION_REPOSITORY',
      useClass: CommunityOrganizationRepository,
    },
    {
      provide: 'MEMBER_REPOSITORY',
      useClass: CommunityMemberRepository,
    },
    {
      provide: 'AUTH_SERVICE',
      useClass: CommunityAuthService,
    },
  ];

  return {
    imports: [...baseImports, EnvironmentsModuleV1, SharedModule, UserModule],
    controllers: [AuthController],
    providers: [...baseProviders, ...injectableProviders, ...USE_CASES],
    exports: [
      RootEnvironmentGuard,
      AuthService,
      'AUTH_SERVICE',
      'USER_REPOSITORY',
      'MEMBER_REPOSITORY',
      'ORGANIZATION_REPOSITORY',
    ],
  };
}

export function configure(consumer: MiddlewareConsumer) {
  if (process.env.GITHUB_OAUTH_CLIENT_ID) {
    consumer
      .apply(
        passport.authenticate(AuthProviderEnum.GITHUB, {
          session: false,
          scope: ['user:email'],
        })
      )
      .forRoutes({
        path: '/auth/github',
        method: RequestMethod.GET,
      });
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - getCommunityAuthModuleConfig()
 - configure(consumer: MiddlewareConsumer)
Declaraciones 'export' encontradas:
- export function getCommunityAuthModuleConfig
- export function configure

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/ee.auth.module.config.ts
Tamao: 1330 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MiddlewareConsumer, ModuleMetadata } from '@nestjs/common';
import { cacheService, PlatformException } from '@novu/application-generic';
import { RootEnvironmentGuard } from './framework/root-environment-guard.service';
import { AuthService } from './services/auth.service';
import { ApiKeyStrategy } from './services/passport/apikey.strategy';
import { JwtSubscriberStrategy } from './services/passport/subscriber-jwt.strategy';

export function getEEModuleConfig(): ModuleMetadata {
  const eeAuthPackage = require('@novu/ee-auth');
  const eeAuthModule = eeAuthPackage?.eeAuthModule;

  if (!eeAuthModule) {
    throw new PlatformException('ee-auth module is not loaded');
  }

  return {
    imports: [...eeAuthModule.imports],
    controllers: [...eeAuthModule.controllers],
    providers: [
      ...eeAuthModule.providers,
      // reused services
      ApiKeyStrategy,
      JwtSubscriberStrategy,
      AuthService,
      cacheService,
      RootEnvironmentGuard,
    ],
    exports: [...eeAuthModule.exports, RootEnvironmentGuard, AuthService],
  };
}

export function configure(consumer: MiddlewareConsumer) {
  const eeAuthPackage = require('@novu/ee-auth');

  if (!eeAuthPackage?.configure) {
    throw new PlatformException('ee-auth configure() is not loaded');
  }

  eeAuthPackage.configure(consumer);
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - getEEModuleConfig()
 - configure(consumer: MiddlewareConsumer)
Declaraciones 'export' encontradas:
- export function getEEModuleConfig
- export function configure

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/dtos/login.dto.ts
Tamao: 190 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsEmail, IsString } from 'class-validator';

export class LoginBodyDto {
  @IsDefined()
  @IsEmail()
  email: string;

  @IsDefined()
  @IsString()
  password: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class LoginBodyDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/dtos/password-reset.dto.ts
Tamao: 721 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { passwordConstraints } from '@novu/shared';
import { IsDefined, IsEmail, IsUUID, Matches, MaxLength, MinLength } from 'class-validator';

export class PasswordResetBodyDto {
  @IsDefined()
  @MinLength(passwordConstraints.minLength)
  @MaxLength(passwordConstraints.maxLength)
  @Matches(passwordConstraints.pattern, {
    message:
      'The password must contain minimum 8 and maximum 64 characters, at least one uppercase letter, one lowercase letter, one number and one special character #?!@$%^&*()-',
  })
  password: string;

  @IsDefined()
  @IsUUID(4, {
    message: 'Bad token provided',
  })
  token: string;
}

export class PasswordResetRequestBodyDto {
  @IsDefined()
  @IsEmail()
  email: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class PasswordResetBodyDto
- export class PasswordResetRequestBodyDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/dtos/update-password.dto.ts
Tamao: 634 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { passwordConstraints } from '@novu/shared';
import { IsNotEmpty, Matches, MaxLength, MinLength } from 'class-validator';

export class UpdatePasswordBodyDto {
  @IsNotEmpty()
  @MinLength(passwordConstraints.minLength)
  @MaxLength(passwordConstraints.maxLength)
  @Matches(passwordConstraints.pattern, {
    message:
      'The new password must contain minimum 8 and maximum 64 characters,' +
      ' at least one uppercase letter, one lowercase letter, one number and one special character #?!@$%^&*()-',
  })
  newPassword: string;

  @IsNotEmpty()
  confirmPassword: string;

  @IsNotEmpty()
  currentPassword: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class UpdatePasswordBodyDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/dtos/user-registration.dto.ts
Tamao: 1130 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { JobTitleEnum, ProductUseCases, passwordConstraints, SignUpOriginEnum } from '@novu/shared';
import { IsDefined, IsEmail, IsEnum, IsOptional, IsString, Matches, MaxLength, MinLength } from 'class-validator';

export class UserRegistrationBodyDto {
  @IsDefined()
  @IsEmail()
  email: string;

  @IsDefined()
  @MinLength(passwordConstraints.minLength)
  @MaxLength(passwordConstraints.maxLength)
  @Matches(passwordConstraints.pattern, {
    message:
      'The password must contain minimum 8 and maximum 64 characters, at least one uppercase letter, one lowercase letter, one number and one special character #?!@$%^&*()-',
  })
  password: string;

  @IsDefined()
  @IsString()
  firstName: string;

  @IsOptional()
  @IsString()
  lastName?: string;

  @IsOptional()
  @IsString()
  organizationName?: string;

  @IsOptional()
  @IsEnum(SignUpOriginEnum)
  origin?: SignUpOriginEnum;

  @IsOptional()
  @IsEnum(JobTitleEnum)
  jobTitle?: JobTitleEnum;

  @IsString()
  @IsOptional()
  domain?: string;

  @IsString()
  @IsOptional()
  invitationToken?: string;

  @IsOptional()
  productUseCases?: ProductUseCases;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class UserRegistrationBodyDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/e2e/clerk.strategy.spec.ts
Tamao: 3607 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UnauthorizedException } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { HttpRequestHeaderKeysEnum } from '@novu/application-generic';
import { EnvironmentRepository } from '@novu/dal';
import { ALL_PERMISSIONS, ApiAuthSchemeEnum, MemberRoleEnum, UserSessionData } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';

describe('ClerkStrategy', () => {
  let eeAuth: any;

  try {
    eeAuth = require('@novu/ee-auth');
  } catch (error) {
    return;
  }

  const { ClerkStrategy, LinkEntitiesService, ClerkJwtPayload } = eeAuth;

  let strategy: typeof ClerkStrategy;
  let mockEnvironmentRepository: { findOne: sinon.SinonStub };
  let mockLinkEntitiesService: { linkInternalExternalEntities: sinon.SinonStub };

  const mockRequest = {
    headers: {
      [HttpRequestHeaderKeysEnum.NOVU_ENVIRONMENT_ID.toLowerCase()]: 'env-123',
    },
  };

  const mockPayload: Partial<typeof ClerkJwtPayload> = {
    _id: 'clerk-user-123',
    org_id: 'clerk-org-123',
    firstName: 'John',
    lastName: 'Doe',
    profilePicture: 'https://example.com/profile.png',
    email: 'john@example.com',
    org_role: MemberRoleEnum.OWNER,
    org_permissions: ALL_PERMISSIONS,
    externalId: undefined,
    externalOrgId: undefined,
  };

  beforeEach(async () => {
    mockEnvironmentRepository = {
      findOne: sinon.stub().resolves({ _id: 'env-123' }),
    };

    mockLinkEntitiesService = {
      linkInternalExternalEntities: sinon.stub().resolves({
        internalUserId: 'internal-user-123',
        internalOrgId: 'internal-org-123',
      }),
    };

    const moduleRef = await Test.createTestingModule({
      providers: [
        ClerkStrategy,
        { provide: EnvironmentRepository, useValue: mockEnvironmentRepository },
        { provide: LinkEntitiesService, useValue: mockLinkEntitiesService },
      ],
    }).compile();

    strategy = moduleRef.get<typeof ClerkStrategy>(ClerkStrategy);
  });

  describe('validate', () => {
    it('should transform Clerk payload into valid user session', async () => {
      const result: UserSessionData = await strategy.validate(mockRequest, mockPayload);

      expect(result).to.deep.include({
        _id: 'internal-user-123',
        firstName: 'John',
        lastName: 'Doe',
        email: 'john@example.com',
        organizationId: 'internal-org-123',
        roles: [MemberRoleEnum.OWNER],
        permissions: ALL_PERMISSIONS,
        environmentId: 'env-123',
        scheme: ApiAuthSchemeEnum.BEARER,
      });
    });

    it('should call linkInternalExternalEntities with correct parameters', async () => {
      await strategy.validate(mockRequest, mockPayload);

      expect(mockLinkEntitiesService.linkInternalExternalEntities.calledOnceWith(mockRequest, mockPayload)).to.be.true;
    });

    it('should verify environment access', async () => {
      await strategy.validate(mockRequest, mockPayload);

      expect(
        mockEnvironmentRepository.findOne.calledOnceWith(
          {
            _id: 'env-123',
            _organizationId: 'internal-org-123',
          },
          '_id'
        )
      ).to.be.true;
    });

    it('should throw UnauthorizedException when environment is not found', async () => {
      mockEnvironmentRepository.findOne.resolves(null);

      try {
        await strategy.validate(mockRequest, mockPayload);
        expect.fail('Should have thrown an error');
      } catch (err) {
        expect(err).to.be.instanceOf(UnauthorizedException);
        expect(err.message).to.equal('Cannot find environment');
      }
    });
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - strategy(moduleRef.get<typeof ClerkStrategy>(ClerkStrategy);
  });

  describe('validate', ())
 - UserSessionData(await strategy.validate(mockRequest, mockPayload);

      expect(result).to.deep.include({
        _...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/e2e/link-entities.service.spec.ts
Tamao: 8892 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import {
  AnalyticsService,
  createNestLoggingModuleOptions,
  FeatureFlagsService,
  LoggerModule,
  PinoLogger,
} from '@novu/application-generic';
import {
  CommunityOrganizationRepository,
  CommunityUserRepository,
  OrganizationRepository,
  UserRepository,
} from '@novu/dal';
import { ResourceOriginEnum, ResourceTypeEnum } from '@novu/shared';
import { CLERK_ORGANIZATION_1, CLERK_USER_1, ClerkClientMock } from '@novu/testing';
import { expect } from 'chai';
import mongoose from 'mongoose';
import sinon from 'sinon';
import { CreateEnvironmentCommand } from '../../environments-v1/usecases/create-environment/create-environment.command';
import { CreateEnvironment } from '../../environments-v1/usecases/create-environment/create-environment.usecase';
import { CreateNovuIntegrationsCommand } from '../../integrations/usecases/create-novu-integrations/create-novu-integrations.command';
import { CreateNovuIntegrations } from '../../integrations/usecases/create-novu-integrations/create-novu-integrations.usecase';
import { UpsertLayout } from '../../layouts-v2/usecases/upsert-layout';
import { SyncExternalOrganization } from '../../organization/usecases/create-organization/sync-external-organization/sync-external-organization.usecase';
import { GetOrganization } from '../../organization/usecases/get-organization/get-organization.usecase';

describe('Link external and internal entities #novu-v2', () => {
  let eeAuth: any;

  try {
    eeAuth = require('@novu/ee-auth');
  } catch (error) {
    return;
  }

  const { LinkEntitiesService, ClerkJwtPayload, SyncExternalUser, EEUserRepository, EEOrganizationRepository } = eeAuth;

  // Test suite variables
  let linkEntitiesService: typeof LinkEntitiesService;
  let communityUserRepository: CommunityUserRepository;
  let communityOrganizationRepository: CommunityOrganizationRepository;

  // Mock services
  const createEnvironment = {
    execute: sinon.stub().resolves({ _id: new mongoose.Types.ObjectId() }),
  };

  const createNovuIntegrations = {
    execute: sinon.stub().resolves({ _id: new mongoose.Types.ObjectId() }),
  };

  const upsertLayout = {
    execute: sinon.stub().resolves({
      _id: new mongoose.Types.ObjectId(),
      layoutId: 'layout-id',
      slug: 'layout-slug',
      name: 'layout-name',
      isDefault: true,
      updatedAt: new Date().toISOString(),
      createdAt: new Date().toISOString(),
      origin: ResourceOriginEnum.NOVU_CLOUD,
      type: ResourceTypeEnum.BRIDGE,
      variables: {},
      controls: {},
    }),
  };

  const featureFlagsService = {
    getFlag: sinon.stub().resolves({ value: true }),
  };

  const analyticsService = {
    upsertUser: sinon.stub(),
    track: sinon.stub(),
    upsertGroup: sinon.stub(),
  };

  // Stub command creation
  sinon.stub(CreateEnvironmentCommand, 'create').returns({});
  sinon.stub(CreateNovuIntegrationsCommand, 'create').returns({});

  // Initialize repositories
  const clerkClientMock = new ClerkClientMock();
  const eeUserRepository = new EEUserRepository(new CommunityUserRepository(), clerkClientMock);
  const eeOrganizationRepository = new EEOrganizationRepository(new CommunityOrganizationRepository(), clerkClientMock);

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [LoggerModule.forRoot(createNestLoggingModuleOptions({ serviceName: 'test', version: '0.0.1' }))],
      providers: [
        LinkEntitiesService,
        CommunityUserRepository,
        CommunityOrganizationRepository,
        SyncExternalUser,
        GetOrganization,
        { provide: 'SyncOrganizationUsecase', useClass: SyncExternalOrganization },
        { provide: EEUserRepository, useValue: eeUserRepository },
        { provide: UserRepository, useValue: eeUserRepository },
        { provide: OrganizationRepository, useValue: eeOrganizationRepository },
        { provide: CreateEnvironment, useValue: createEnvironment },
        { provide: CreateNovuIntegrations, useValue: createNovuIntegrations },
        { provide: UpsertLayout, useValue: upsertLayout },
        { provide: AnalyticsService, useValue: analyticsService },
        { provide: FeatureFlagsService, useValue: featureFlagsService },
      ],
    }).compile();

    linkEntitiesService = moduleRef.get<typeof LinkEntitiesService>(LinkEntitiesService);
    communityUserRepository = moduleRef.get<CommunityUserRepository>(CommunityUserRepository);
    communityOrganizationRepository = moduleRef.get<CommunityOrganizationRepository>(CommunityOrganizationRepository);
  });

  afterEach(async () => {
    await communityUserRepository.delete({ externalId: CLERK_USER_1.id });
    await communityOrganizationRepository.delete({ externalId: CLERK_ORGANIZATION_1.id });
  });

  it.skip('should create new user and organization when no internal entities exist', async () => {
    const mockClerkPayload: Partial<typeof ClerkJwtPayload> = {
      _id: CLERK_USER_1.id,
      email: CLERK_USER_1.primaryEmailAddress?.emailAddress || '',
      lastName: CLERK_USER_1.lastName || '',
      firstName: CLERK_USER_1.firstName || '',
      profilePicture: CLERK_USER_1.imageUrl,
      org_id: CLERK_ORGANIZATION_1.id,
      externalId: undefined,
      externalOrgId: undefined,
    };

    const result = await linkEntitiesService.linkInternalExternalEntities({}, mockClerkPayload);

    expect(result.internalUserId).to.be.a('string');
    expect(result.internalOrgId).to.be.a('string');

    const internalUser = await eeUserRepository.findById(result.internalUserId);
    expect(internalUser?.externalId).to.equal(CLERK_USER_1.id);

    const internalOrg = await eeOrganizationRepository.findById(result.internalOrgId);
    expect(internalOrg?.externalId).to.equal(CLERK_ORGANIZATION_1.id);

    sinon.assert.calledTwice(createEnvironment.execute);
    sinon.assert.calledTwice(createNovuIntegrations.execute);
  });

  it('should update JWT if internal linked entities exist but not present in JWT', async () => {
    const existingInternalUser = await communityUserRepository.create({
      externalId: CLERK_USER_1.id,
    });
    const existingInternalOrg = await communityOrganizationRepository.create({
      externalId: CLERK_ORGANIZATION_1.id,
    });

    const mockClerkPayload: Partial<typeof ClerkJwtPayload> = {
      _id: CLERK_USER_1.id,
      email: CLERK_USER_1.primaryEmailAddress?.emailAddress || '',
      lastName: CLERK_USER_1.lastName || '',
      firstName: CLERK_USER_1.firstName || '',
      profilePicture: CLERK_USER_1.imageUrl,
      org_id: CLERK_ORGANIZATION_1.id,
      externalId: undefined,
      externalOrgId: undefined,
    };

    const result = await linkEntitiesService.linkInternalExternalEntities({}, mockClerkPayload);

    expect(result.internalUserId).to.equal(existingInternalUser._id);
    expect(result.internalOrgId).to.equal(existingInternalOrg._id);
  });

  it('should do no-op if entities are already linked', async () => {
    const existingInternalUser = await communityUserRepository.create({
      externalId: CLERK_USER_1.id,
    });
    const existingInternalOrg = await communityOrganizationRepository.create({
      externalId: CLERK_ORGANIZATION_1.id,
    });

    const createUserSpy = sinon.spy(communityUserRepository, 'create');
    const createOrganizationSpy = sinon.spy(communityOrganizationRepository, 'create');

    const mockClerkPayload: Partial<typeof ClerkJwtPayload> = {
      _id: CLERK_USER_1.id,
      email: CLERK_USER_1.primaryEmailAddress?.emailAddress || '',
      lastName: CLERK_USER_1.lastName || '',
      firstName: CLERK_USER_1.firstName || '',
      profilePicture: CLERK_USER_1.imageUrl,
      org_id: CLERK_ORGANIZATION_1.id,
      externalId: existingInternalUser._id,
      externalOrgId: existingInternalOrg._id,
    };

    const result = await linkEntitiesService.linkInternalExternalEntities({}, mockClerkPayload);

    expect(result.internalUserId).to.equal(existingInternalUser._id);
    expect(result.internalOrgId).to.equal(existingInternalOrg._id);

    sinon.assert.notCalled(createUserSpy);
    sinon.assert.notCalled(createOrganizationSpy);
  });

  it('should fail if external entities are not found', async () => {
    const mockClerkPayload: Partial<typeof ClerkJwtPayload> = {
      _id: 'non-existent-external-id',
      email: CLERK_USER_1.primaryEmailAddress?.emailAddress || '',
      lastName: CLERK_USER_1.lastName || '',
      firstName: CLERK_USER_1.firstName || '',
      profilePicture: CLERK_USER_1.imageUrl,
      org_id: 'non-existent-external-org-id',
      externalId: undefined,
      externalOrgId: undefined,
    };

    try {
      await linkEntitiesService.linkInternalExternalEntities({}, mockClerkPayload);
      throw new Error('Expected error to be thrown');
    } catch (error) {
      expect(error).to.be.an('error');
    }
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - eeOrganizationRepository(new EEOrganizationRepository(new CommunityOrganizationRepository(), clerkClientMock);

  beforeEach(...)
 - communityOrganizationRepository(moduleRef.get<CommunityOrganizationRepository>(CommunityOrganizationRepository);
  });

  afterEach(...)
 - internalOrg(await eeOrganizationRepository.findById(result.internalOrgId);
    expect(internalOrg?.externalId).t...)
 - result(await linkEntitiesService.linkInternalExternalEntities({}, mockClerkPayload);

    expect(result.int...)
 - result(await linkEntitiesService.linkInternalExternalEntities({}, mockClerkPayload);

    expect(result.int...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/e2e/login.e2e.ts
Tamao: 6371 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CommunityUserRepository } from '@novu/dal';
import { UserSessionData } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { subMinutes } from 'date-fns';
import jwt from 'jsonwebtoken';

describe('User login - /auth/login (POST) #novu-v0-os', async () => {
  let session: UserSession;
  const userRepository = new CommunityUserRepository();
  const userCredentials = {
    email: 'Testy.test22@gmail.com',
    password: '123Qwerty@',
  };

  context('with email/password', async () => {
    before(async () => {
      session = new UserSession();
      await session.initialize();

      const { body } = await session.testAgent
        .post('/v1/auth/register')
        .send({
          email: userCredentials.email,
          password: userCredentials.password,
          firstName: 'Test',
          lastName: 'User',
        })
        .expect(201);
    });

    it('should login the user correctly', async () => {
      const { body } = await session.testAgent.post('/v1/auth/login').send({
        email: userCredentials.email,
        password: userCredentials.password,
      });

      const jwtContent = (await jwt.decode(body.data.token)) as UserSessionData;

      expect(jwtContent.firstName).to.equal('test');
      expect(jwtContent.lastName).to.equal('user');
      expect(jwtContent.email).to.equal('testytest22@gmail.com');
    });

    it('should login the user correctly with uppercase email', async () => {
      const { body } = await session.testAgent.post('/v1/auth/login').send({
        email: userCredentials.email.toUpperCase(),
        password: userCredentials.password,
      });

      const jwtContent = (await jwt.decode(body.data.token)) as UserSessionData;

      expect(jwtContent.firstName).to.equal('test');
      expect(jwtContent.lastName).to.equal('user');
      expect(jwtContent.email).to.equal('testytest22@gmail.com');
    });

    it('should throw error on trying to login non-existing user', async () => {
      const { body } = await session.testAgent.post('/v1/auth/login').send({
        email: 'nonExistingUser@email.com',
        password: '123123213123',
      });

      expect(body.statusCode).to.equal(401);
      expect(body.message).to.contain('Incorrect email or password provided.');
    });

    it('should fail on bad password', async () => {
      const { body } = await session.testAgent.post('/v1/auth/login').send({
        email: userCredentials.email,
        password: '123123213123',
      });

      expect(body.statusCode).to.equal(401);
      expect(body.message).to.contain('Incorrect email or password provided.');
    });

    it('should allow user to log in and reset the failed attempts counter after less than 5 failed attempts within 5 minutes', async () => {
      const SAFE_FAILED_LOGIN_ATTEMPTS = 3;

      for (let i = 0; i < SAFE_FAILED_LOGIN_ATTEMPTS; i += 1) {
        await session.testAgent.post('/v1/auth/login').send({
          email: userCredentials.email,
          password: 'wrong-password',
        });
      }

      const { body } = await session.testAgent.post('/v1/auth/login').send({
        email: userCredentials.email,
        password: userCredentials.password,
      });

      const jwtContent = (await jwt.decode(body.data.token)) as UserSessionData;

      expect(jwtContent.firstName).to.equal('test');
      expect(jwtContent.lastName).to.equal('user');
      expect(jwtContent.email).to.equal('testytest22@gmail.com');

      const { body: wrongCredsBody } = await session.testAgent.post('/v1/auth/login').send({
        email: userCredentials.email,
        password: 'wrong-password',
      });

      expect(wrongCredsBody.statusCode).to.equal(401);
      expect(wrongCredsBody.message).to.contain('Incorrect email or password provided.');
    });

    it('should block the user account after 5 unsuccessful attempts within 5 minutes', async () => {
      const MAX_LOGIN_ATTEMPTS = 5;

      for (let i = 0; i < MAX_LOGIN_ATTEMPTS; i += 1) {
        await session.testAgent.post('/v1/auth/login').send({
          email: userCredentials.email,
          password: 'wrong-password',
        });
      }

      const { body } = await session.testAgent.post('/v1/auth/login').send({
        email: userCredentials.email,
        password: userCredentials.password,
      });

      expect(body.statusCode).to.equal(401);
      expect(body.message).to.contain('Account blocked');
    });

    it('should reset the account blocked error after 5 minutes and allow for more 5 failed attempts', async () => {
      const MAX_LOGIN_ATTEMPTS = 5;
      const BLOCKED_PERIOD_IN_MINUTES = 5;

      const lastFailedAttempt = subMinutes(new Date(), BLOCKED_PERIOD_IN_MINUTES);

      const failedLogin = {
        lastFailedAttempt: lastFailedAttempt.toISOString(),
        times: MAX_LOGIN_ATTEMPTS,
      };

      await userRepository.update(
        {
          _id: session.user._id,
        },
        {
          $set: {
            failedLogin,
          },
        }
      );

      for (let i = 0; i < MAX_LOGIN_ATTEMPTS - 1; i += 1) {
        const { body } = await session.testAgent.post('/v1/auth/login').send({
          email: session.user.email,
          password: 'wrong-password',
        });

        expect(body.message).to.contain('Incorrect email or password provided.');
        expect(body.statusCode).to.equal(401);
      }

      const { body } = await session.testAgent.post('/v1/auth/login').send({
        email: userCredentials.email,
        password: userCredentials.password,
      });

      expect(body.statusCode).to.equal(401);
      expect(body.message).to.contain('Account blocked');
    });
  });

  context('with OAuth', async () => {
    const userEmail = 'testoauth@gmail.com';

    before(async () => {
      // Create a mock OAuth user without a password
      await userRepository.create({
        email: userEmail,
        firstName: 'Testy',
        lastName: 'Oauth',
      });
    });

    it('should throw an error informing the user to use OAuth instead', async () => {
      const { body } = await session.testAgent.post('/v1/auth/login').send({
        email: userEmail,
        password: 'whatever',
      });

      expect(body.statusCode).to.equal(400);
      expect(body.message).to.contain('Please sign in using Github.');
    });
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - userCredentials({
    email: 'Testy.test22@gmail.com',
    password: '123Qwerty@',
  };

  context('with email/passw...)
 - jwtContent(await jwt.decode(body.data.token)) as UserSessionData;

      expect(jwtContent.firstName).to.equal(...)
 - jwtContent(await jwt.decode(body.data.token)) as UserSessionData;

      expect(jwtContent.firstName).to.equal(...)
 - userEmail('testoauth@gmail.com';

    before(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/e2e/password-reset.e2e.ts
Tamao: 8975 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CommunityUserRepository } from '@novu/dal';
import { PasswordResetFlowEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { subDays, subMinutes } from 'date-fns';
import { SinonStubbedMember, stub } from 'sinon';
import { v4 as uuidv4 } from 'uuid';

describe('Password reset - /auth/reset (POST) #novu-v0-os', async () => {
  let session: UserSession;
  const userRepository = new CommunityUserRepository();

  const requestResetToken = async (payload) => {
    let plainToken: string;
    /*
     * Wrapper for method to obtain plain reset token before hashing.
     * Stub is created on Prototype because API and tests use different UserRepository instances.
     */
    stub(CommunityUserRepository.prototype, 'updatePasswordResetToken').callsFake((...args) => {
      [, plainToken] = args;
      (
        CommunityUserRepository.prototype.updatePasswordResetToken as SinonStubbedMember<
          typeof CommunityUserRepository.prototype.updatePasswordResetToken
        >
      ).restore();

      return userRepository.updatePasswordResetToken(...args);
    });

    const { body } = await session.testAgent.post('/v1/auth/reset/request').send(payload);

    return { body, plainToken: plainToken! };
  };

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should request a password reset for existing user with no query param', async () => {
    const { body } = await session.testAgent.post('/v1/auth/reset/request').send({
      email: session.user.email,
    });

    expect(body.data.success).to.equal(true);
    const found = await userRepository.findById(session.user._id);

    expect(found?.resetToken).to.be.ok;
  });

  Object.values(PasswordResetFlowEnum)
    .map(String)
    .forEach((src) => {
      it(`should request a password reset for existing user with a src query param specified: ${src}`, async () => {
        const url = `/v1/auth/reset/request?src=${src}`;
        const { body } = await session.testAgent.post(url).send({
          email: session.user.email,
        });

        expect(body.data.success).to.equal(true);
        const found = await userRepository.findById(session.user._id);

        expect(found?.resetToken).to.be.ok;
      });
    });

  it('should request a password reset for existing user with uppercase email', async () => {
    const { body } = await session.testAgent.post('/v1/auth/reset/request').send({
      email: session.user.email.toUpperCase(),
    });

    expect(body.data.success).to.equal(true);
    const found = await userRepository.findById(session.user._id);

    expect(found?.resetToken).to.be.ok;
  });

  it('should change a password after reset', async () => {
    const { body, plainToken } = await requestResetToken({
      email: session.user.email,
    });

    expect(body.data.success).to.equal(true);

    const found = await userRepository.findById(session.user._id);
    expect(plainToken).to.not.equal(found?.resetToken);

    const { body: resetChange } = await session.testAgent.post('/v1/auth/reset').send({
      password: 'ASd3ASD$Fdfdf',
      token: plainToken,
    });

    expect(resetChange.data.token).to.be.ok;

    /**
     * RLD-68
     * A workaround due to a potential race condition between token reset and new password login
     */
    await new Promise((resolve) => {
      setTimeout(resolve, 100);
    });

    const { body: loginBody } = await session.testAgent.post('/v1/auth/login').send({
      email: session.user.email,
      password: 'ASd3ASD$Fdfdf',
    });

    // RLD-68 A debug case to catch the error state message origin
    if (!loginBody || !loginBody.data) {
      console.info(loginBody);
    }

    expect(loginBody.data.token).to.be.ok;

    const foundUserAfterChange = await userRepository.findById(session.user._id);

    expect(foundUserAfterChange?.resetToken).to.not.be.ok;
    expect(foundUserAfterChange?.resetTokenDate).to.not.be.ok;
  });

  it('should fail to change password for bad token', async () => {
    const { body } = await requestResetToken({
      email: session.user.email,
    });

    expect(body.data.success).to.equal(true);

    const { body: resetChange } = await session.testAgent.post('/v1/auth/reset').send({
      password: 'ASd3ASD$Fdfdf',
      token: uuidv4(),
    });

    expect(resetChange.message).to.contain('Bad token provided');
  });

  it('should fail to change password for expired token', async () => {
    const { body, plainToken } = await requestResetToken({
      email: session.user.email,
    });

    expect(body.data.success).to.equal(true);
    await userRepository.update(
      {
        _id: session.user._id,
      },
      {
        $set: {
          resetTokenDate: subDays(new Date(), 20),
        },
      }
    );

    const { body: resetChange } = await session.testAgent.post('/v1/auth/reset').send({
      password: 'ASd3ASD$Fdfdf',
      token: plainToken,
    });

    expect(resetChange.message).to.contain('Token has expired');
  });

  it('should limit password request to 5 requests per minute', async () => {
    const MAX_ATTEMPTS = 5;

    for (let i = 0; i < MAX_ATTEMPTS; i += 1) {
      await session.testAgent.post('/v1/auth/reset/request').send({
        email: session.user.email,
      });
    }

    const { body } = await session.testAgent.post('/v1/auth/reset/request').send({
      email: session.user.email,
    });

    expect(body.statusCode).to.equal(401);
    expect(body.message).to.contain('Too many requests, Try again after a minute.');
  });

  it('should limit password request to 15 requests per day', async () => {
    const MAX_ATTEMPTS = 5;

    for (let i = 0; i < MAX_ATTEMPTS; i += 1) {
      await session.testAgent.post('/v1/auth/reset/request').send({
        email: session.user.email,
      });
    }

    await userRepository.update(
      {
        _id: session.user._id,
      },
      {
        $set: {
          resetTokenCount: {
            reqInMinute: 0,
            reqInDay: 10,
          },
        },
      }
    );

    for (let i = 0; i < MAX_ATTEMPTS; i += 1) {
      await session.testAgent.post('/v1/auth/reset/request').send({
        email: session.user.email,
      });
    }

    const { body } = await session.testAgent.post('/v1/auth/reset/request').send({
      email: session.user.email,
    });

    expect(body.statusCode).to.equal(401);
    expect(body.message).to.contain('Too many requests, Try again after 24 hours.');
  });

  it('should allow user to request password reset after 1 minute block period', async () => {
    const MAX_ATTEMPTS = 5;

    for (let i = 0; i < MAX_ATTEMPTS; i += 1) {
      await session.testAgent.post('/v1/auth/reset/request').send({
        email: session.user.email,
      });
    }

    await userRepository.update(
      {
        _id: session.user._id,
      },
      {
        $set: {
          resetTokenDate: subMinutes(new Date(), 1),
        },
      }
    );

    for (let i = 0; i < MAX_ATTEMPTS; i += 1) {
      const { body } = await session.testAgent.post('/v1/auth/reset/request').send({
        email: session.user.email,
      });

      expect(body.data.success).to.equal(true);
      const found = await userRepository.findById(session.user._id);

      expect(found?.resetToken).to.be.ok;
    }
  });

  it('should allow user to request password reset after 24 hours block period', async () => {
    const MAX_ATTEMPTS = 5;

    await session.testAgent.post('/v1/auth/reset/request').send({
      email: session.user.email,
    });

    await userRepository.update(
      {
        _id: session.user._id,
      },
      {
        $set: {
          resetTokenDate: subDays(new Date(), 1),
          resetTokenCount: {
            reqInMinute: 5,
            reqInDay: 15,
          },
        },
      }
    );

    for (let i = 0; i < MAX_ATTEMPTS; i += 1) {
      const { body } = await session.testAgent.post('/v1/auth/reset/request').send({
        email: session.user.email,
      });

      expect(body.data.success).to.equal(true);
      const found = await userRepository.findById(session.user._id);

      expect(found?.resetToken).to.be.ok;
    }
  });

  it("should throw error when the password doesn't meets the requirements", async () => {
    const { body, plainToken } = await requestResetToken({
      email: session.user.email,
    });

    expect(body.data.success).to.equal(true);

    const foundUser = await userRepository.findById(session.user._id);

    const { body: resetChange } = await session.testAgent.post('/v1/auth/reset').send({
      password: 'password',
      token: plainToken,
    });

    expect(plainToken).to.not.equal(foundUser?.resetToken);
    expect(resetChange.message[0]).to.contain(
      'The password must contain minimum 8 and maximum 64 characters, at least one uppercase letter, one lowercase letter, one number and one special character #?!@$%^&*()-'
    );
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - requestResetToken(async (payload))
 - session(new UserSession();
    await session.initialize();
  });

  it('should request a password reset for ...)
 - found(await userRepository.findById(session.user._id);

    expect(found?.resetToken).to.be.ok;
  });

  O...)
 - found(await userRepository.findById(session.user._id);

        expect(found?.resetToken).to.be.ok;
      ...)
 - found(await userRepository.findById(session.user._id);

    expect(found?.resetToken).to.be.ok;
  });

  i...)
 - foundUserAfterChange(await userRepository.findById(session.user._id);

    expect(foundUserAfterChange?.resetToken).to.no...)
 - found(await userRepository.findById(session.user._id);

      expect(found?.resetToken).to.be.ok;
    }
  ...)
 - found(await userRepository.findById(session.user._id);

      expect(found?.resetToken).to.be.ok;
    }
  ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/e2e/permissions.guard.e2e.ts
Tamao: 5806 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpRequestHeaderKeysEnum } from '@novu/application-generic';
import { ApiAuthSchemeEnum, ApiServiceLevelEnum, PermissionsEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('PermissionsGuard #novu-v2', () => {
  before(() => {
    // @ts-ignore - Setting environment variables
    process.env.IS_RBAC_ENABLED = 'true';
  });

  let session: UserSession;
  const permissionRoutePath = '/v1/test-auth/permission-route';
  const noPermissionRoutePath = '/v1/test-auth/no-permission-route';
  const allPermissionsRoutePath = '/v1/test-auth/all-permissions-route';

  let request: (
    authHeader: string,
    path: string
  ) => Promise<Awaited<ReturnType<typeof UserSession.prototype.testAgent.get>>>;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    // Set organization service level to business tier for default tests
    await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

    request = (authHeader, path) =>
      session.testAgent.get(path).set(HttpRequestHeaderKeysEnum.AUTHORIZATION, authHeader);
  });

  describe('With Bearer authentication (Business tier)', () => {
    it('should return 200 when user has all required permissions', async () => {
      const response = await request(session.token, permissionRoutePath);
      expect(response.statusCode).to.equal(200);
    });

    it('should return 200 for route with no permission requirement', async () => {
      const response = await request(session.token, noPermissionRoutePath);
      expect(response.statusCode).to.equal(200);
    });

    it('should return 403 when user does not have required permission', async () => {
      const noPermissionsSession = new UserSession();
      await noPermissionsSession.initialize();
      await noPermissionsSession.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

      await noPermissionsSession.updateEETokenClaims({
        org_permissions: [
          PermissionsEnum.MESSAGE_READ,
          PermissionsEnum.SUBSCRIBER_READ,
          PermissionsEnum.NOTIFICATION_READ,
        ],
      });

      const response = await noPermissionsSession.testAgent
        .get(permissionRoutePath)
        .set(HttpRequestHeaderKeysEnum.AUTHORIZATION, noPermissionsSession.token);

      expect(response.statusCode).to.equal(403);
      expect(response.body.message).to.include('Insufficient permissions');
    });

    it('should return 403 when user has only one of the required permissions', async () => {
      const partialPermissionsSession = new UserSession();
      await partialPermissionsSession.initialize();
      await partialPermissionsSession.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

      await partialPermissionsSession.updateEETokenClaims({
        org_permissions: [PermissionsEnum.INTEGRATION_READ],
      });

      const response = await partialPermissionsSession.testAgent
        .get(permissionRoutePath)
        .set(HttpRequestHeaderKeysEnum.AUTHORIZATION, partialPermissionsSession.token);

      expect(response.statusCode).to.equal(403);
      expect(response.body.message).to.include('Insufficient permissions');
    });

    it('should return 403 for default route when user has insufficient permissions', async () => {
      const somePermissionsSession = new UserSession();
      await somePermissionsSession.initialize();
      await somePermissionsSession.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

      await somePermissionsSession.updateEETokenClaims({
        org_permissions: [PermissionsEnum.WORKFLOW_READ, PermissionsEnum.MESSAGE_READ],
      });

      const response = await somePermissionsSession.testAgent
        .get(allPermissionsRoutePath)
        .set(HttpRequestHeaderKeysEnum.AUTHORIZATION, somePermissionsSession.token);

      expect(response.statusCode).to.equal(403);
    });
  });

  describe('With Bearer authentication (Free and Pro tiers)', () => {
    it('should return 200 for free tier even with insufficient permissions', async () => {
      const freeSession = new UserSession();
      await freeSession.initialize();
      await freeSession.updateOrganizationServiceLevel(ApiServiceLevelEnum.FREE);

      // Setting insufficient permissions that would fail with business tier
      await freeSession.updateEETokenClaims({
        org_permissions: [PermissionsEnum.MESSAGE_READ],
      });

      const response = await freeSession.testAgent
        .get(permissionRoutePath)
        .set(HttpRequestHeaderKeysEnum.AUTHORIZATION, freeSession.token);

      // Should get 200 because permissions guard is disabled for free tier
      expect(response.statusCode).to.equal(200);
    });

    it('should return 200 for pro tier even with insufficient permissions', async () => {
      const proSession = new UserSession();
      await proSession.initialize();
      await proSession.updateOrganizationServiceLevel(ApiServiceLevelEnum.PRO);

      // Setting insufficient permissions that would fail with business tier
      await proSession.updateEETokenClaims({
        org_permissions: [PermissionsEnum.MESSAGE_READ],
      });

      const response = await proSession.testAgent
        .get(permissionRoutePath)
        .set(HttpRequestHeaderKeysEnum.AUTHORIZATION, proSession.token);

      // Should get 200 because permissions guard is disabled for pro tier
      expect(response.statusCode).to.equal(200);
    });
  });

  describe('With API Key authentication', () => {
    it('should return 200 regardless of permissions and service tier', async () => {
      const response = await request(`${ApiAuthSchemeEnum.API_KEY} ${session.apiKey}`, permissionRoutePath);
      expect(response.statusCode).to.equal(200);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - allPermissionsRoutePath('/v1/test-auth/all-permissions-route';

  let request: (
    authHeader: string,
    path: string
  ...)
 - request(authHeader, path))
 - response(await request(session.token, permissionRoutePath);
      expect(response.statusCode).to.equal(200);
...)
 - response(await request(session.token, noPermissionRoutePath);
      expect(response.statusCode).to.equal(200)...)
 - response(await noPermissionsSession.testAgent
        .get(permissionRoutePath)
        .set(HttpRequestHeade...)
 - response(await partialPermissionsSession.testAgent
        .get(permissionRoutePath)
        .set(HttpRequest...)
 - response(await somePermissionsSession.testAgent
        .get(allPermissionsRoutePath)
        .set(HttpReques...)
 - response(await freeSession.testAgent
        .get(permissionRoutePath)
        .set(HttpRequestHeaderKeysEnum...)
 - response(await proSession.testAgent
        .get(permissionRoutePath)
        .set(HttpRequestHeaderKeysEnum....)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/e2e/switch-organization.e2e.ts
Tamao: 2573 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { OrganizationEntity } from '@novu/dal';
import { MemberRoleEnum, UserSessionData } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import jwt from 'jsonwebtoken';

describe('Switch Organization - /auth/organizations/:id/switch (POST) #novu-v0-os', async () => {
  let session: UserSession;

  describe('no organization for user', () => {
    before(async () => {
      session = new UserSession();
      await session.initialize({
        noOrganization: true,
      });
    });

    it('should fail for not authorized organization', async () => {
      const { body } = await session.testAgent
        .post('/v1/auth/organizations/5c573a9941a86c60689cf63a/switch')
        .expect(401);
    });
  });

  describe('user has single organizations', () => {
    before(async () => {
      session = new UserSession();
      await session.initialize({
        noOrganization: true,
      });
    });

    it('should switch the user current organization', async () => {
      const content = jwt.decode(session.token.split(' ')[1]) as UserSessionData;

      expect(content._id).to.equal(session.user._id);
      const organization = await session.addOrganization();

      const { body } = await session.testAgent.post(`/v1/auth/organizations/${organization._id}/switch`).expect(200);

      const newJwt = jwt.decode(body.data) as UserSessionData;

      expect(newJwt._id).to.equal(session.user._id);
      expect(newJwt.organizationId).to.equal(organization._id);
      expect(newJwt.roles.length).to.equal(1);
      expect(newJwt.roles[0]).to.equal(MemberRoleEnum.OSS_ADMIN);
    });
  });

  describe('user has multiple organizations', () => {
    let secondOrganization: OrganizationEntity;
    let firstOrganization: OrganizationEntity;

    before(async () => {
      session = new UserSession();
      await session.initialize();
      firstOrganization = session.organization;
      secondOrganization = await session.addOrganization();
    });

    it('should switch to second organization', async () => {
      const content = jwt.decode(session.token.split(' ')[1]) as UserSessionData;

      expect(content.organizationId).to.equal(firstOrganization._id);

      const { body } = await session.testAgent
        .post(`/v1/auth/organizations/${secondOrganization._id}/switch`)
        .expect(200);

      const newJwt = jwt.decode(body.data) as UserSessionData;

      expect(newJwt._id).to.equal(session.user._id);
      expect(newJwt.organizationId).to.equal(secondOrganization._id);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
      await session.initialize({
        noOrganization: true,
      });
    });
...)
 - session(new UserSession();
      await session.initialize({
        noOrganization: true,
      });
    });
...)
 - newJwt(jwt.decode(body.data) as UserSessionData;

      expect(newJwt._id).to.equal(session.user._id);
    ...)
 - secondOrganization(await session.addOrganization();
    });

    it('should switch to second organization', async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/e2e/update-password.e2e.ts
Tamao: 4883 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSessionData } from '@novu/shared';
import { TEST_USER_PASSWORD, UserSession } from '@novu/testing';
import { expect } from 'chai';
import jwt from 'jsonwebtoken';

const NEW_PASSWORD = 'newPassword123@';
const PASSWORD_ERROR_MESSAGE =
  'The new password must contain minimum 8 and maximum 64 characters,' +
  ' at least one uppercase letter, one lowercase letter, one number and one special character #?!@$%^&*()-';

describe('User update password - /auth/update-password (POST) #novu-v0-os', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should update password', async () => {
    const { statusCode } = await session.testAgent.post('/v1/auth/update-password').send({
      currentPassword: TEST_USER_PASSWORD,
      newPassword: NEW_PASSWORD,
      confirmPassword: NEW_PASSWORD,
    });

    expect(statusCode).to.equal(204);

    const { body: loginBody } = await session.testAgent.post('/v1/auth/login').send({
      email: session.user.email,
      password: NEW_PASSWORD,
    });

    const jwtContent = (await jwt.decode(loginBody.data.token)) as UserSessionData;

    expect(jwtContent.firstName).to.equal(session.user.firstName);
    expect(jwtContent.lastName).to.equal(session.user.lastName);
    expect(jwtContent.email).to.equal(session.user.email);
  });

  it('should fail on bad current password', async () => {
    const { body } = await session.testAgent.post('/v1/auth/update-password').send({
      currentPassword: '123123213',
      newPassword: NEW_PASSWORD,
      confirmPassword: NEW_PASSWORD,
    });

    expect(body.statusCode).to.equal(401);
    expect(body.message).to.contain('Unauthorized');
  });

  it('should fail on mismatched passwords', async () => {
    const { body } = await session.testAgent.post('/v1/auth/update-password').send({
      currentPassword: TEST_USER_PASSWORD,
      newPassword: NEW_PASSWORD,
      confirmPassword: '123123213',
    });

    expect(body.statusCode).to.equal(400);
    expect(body.message).to.contain('Passwords do not match');
  });

  it('should fail on bad password', async () => {
    const { body: validLengthBody } = await session.testAgent.post('/v1/auth/update-password').send({
      currentPassword: TEST_USER_PASSWORD,
      newPassword: '12345678',
      confirmPassword: '12345678',
    });

    expect(validLengthBody.statusCode).to.equal(400);
    expect(validLengthBody.message[0]).to.equal(PASSWORD_ERROR_MESSAGE);
  });

  it('should fail on password missing upper case letter', async () => {
    const { body } = await session.testAgent.post('/v1/auth/update-password').send({
      currentPassword: TEST_USER_PASSWORD,
      newPassword: 'abcde@12345',
      confirmPassword: 'abcde@12345',
    });

    expect(body.statusCode).to.equal(400);
    expect(body.message[0]).to.equal(PASSWORD_ERROR_MESSAGE);
  });

  it('should fail on password missing lower case letter', async () => {
    const { body } = await session.testAgent.post('/v1/auth/update-password').send({
      currentPassword: TEST_USER_PASSWORD,
      newPassword: 'ABCDE@12345',
      confirmPassword: 'ABCDE@12345',
    });

    expect(body.statusCode).to.equal(400);
    expect(body.message[0]).to.equal(PASSWORD_ERROR_MESSAGE);
  });

  it('should fail on password missing special characters', async () => {
    const { body } = await session.testAgent.post('/v1/auth/update-password').send({
      currentPassword: TEST_USER_PASSWORD,
      newPassword: 'ABCabc12345',
      confirmPassword: 'ABCabc12345',
    });

    expect(body.statusCode).to.equal(400);
    expect(body.message[0]).to.equal(PASSWORD_ERROR_MESSAGE);
  });

  it('should fail on password missing numbers', async () => {
    const { body } = await session.testAgent.post('/v1/auth/update-password').send({
      currentPassword: TEST_USER_PASSWORD,
      newPassword: 'ABCabc@ABCDE',
      confirmPassword: 'ABCabc@ABCDE',
    });

    expect(body.statusCode).to.equal(400);
    expect(body.message[0]).to.equal(PASSWORD_ERROR_MESSAGE);
  });

  it('should fail if password length is less than 8 or more then 64', async () => {
    const { body: minimumLengthBody } = await session.testAgent.post('/v1/auth/update-password').send({
      currentPassword: TEST_USER_PASSWORD,
      newPassword: '123',
      confirmPassword: '123',
    });

    expect(minimumLengthBody.statusCode).to.equal(400);
    expect(minimumLengthBody.message[0]).to.equal(PASSWORD_ERROR_MESSAGE);

    const { body: maxLengthBody } = await session.testAgent.post('/v1/auth/update-password').send({
      currentPassword: TEST_USER_PASSWORD,
      newPassword: 'Ab1@'.repeat(20),
      confirmPassword: 'Ab1@'.repeat(20),
    });

    expect(maxLengthBody.statusCode).to.equal(400);
    expect(maxLengthBody.message[0]).to.equal(PASSWORD_ERROR_MESSAGE);
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - PASSWORD_ERROR_MESSAGE('The new password must contain minimum 8 and maximum 64 characters,' +
  ' at least one uppercase le...)
 - session(new UserSession();
    await session.initialize();
  });

  it('should update password', async ())
 - jwtContent(await jwt.decode(loginBody.data.token)) as UserSessionData;

    expect(jwtContent.firstName).to.equ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/e2e/user-registration.e2e.ts
Tamao: 3803 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CommunityOrganizationRepository, EnvironmentRepository } from '@novu/dal';
import { MemberRoleEnum, UserSessionData } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import jwt from 'jsonwebtoken';

describe('User registration - /auth/register (POST) #novu-v0-os', async () => {
  let session: UserSession;
  const environmentRepository = new EnvironmentRepository();
  const organizationRepository = new CommunityOrganizationRepository();

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should throw validation error for not enough information', async () => {
    const { body } = await session.testAgent.post('/v1/auth/register').send({
      email: '123',
    });

    expect(body.statusCode).to.equal(400);
    expect(body.message.find((i) => i.includes('email'))).to.be.ok;
    expect(body.message.find((i) => i.includes('password'))).to.be.ok;
    expect(body.message.find((i) => i.includes('firstName'))).to.be.ok;
  });

  it('should throw error if user signup is disabled', async () => {
    process.env.DISABLE_USER_REGISTRATION = 'true';

    const { body } = await session.testAgent.post('/v1/auth/register').send({
      email: 'Testy.test@gmail.com',
      firstName: 'Test',
      lastName: 'User',
      password: '123@Qwerty',
    });

    expect(body.statusCode).to.equal(400);
    expect(JSON.stringify(body)).to.include('Account creation is disabled');

    process.env.DISABLE_USER_REGISTRATION = 'false';
  });

  it('should create a new user successfully', async () => {
    const { body } = await session.testAgent.post('/v1/auth/register').send({
      email: 'Testy.test@gmail.com',
      firstName: 'Test',
      lastName: 'User',
      password: '123@Qwerty',
    });

    expect(body.data.token).to.be.ok;

    const jwtContent = (await jwt.decode(body.data.token)) as UserSessionData;

    expect(jwtContent.firstName).to.equal('test');
    expect(jwtContent.lastName).to.equal('user');
    expect(jwtContent.email).to.equal('testytest@gmail.com');
  });

  it('should create a user with organization', async () => {
    const { body } = await session.testAgent.post('/v1/auth/register').send({
      email: 'Testy.test-org@gmail.com',
      firstName: 'Test',
      lastName: 'User',
      password: '123@Qwerty',
      organizationName: 'Sample org',
    });

    expect(body.data.token).to.be.ok;

    const jwtContent = (await jwt.decode(body.data.token)) as UserSessionData;

    expect(jwtContent.firstName).to.equal('test');
    expect(jwtContent.lastName).to.equal('user');

    // Should generate organization
    expect(jwtContent.organizationId).to.be.ok;
    const organization = await organizationRepository.findById(jwtContent.organizationId);

    expect(organization.name).to.equal('Sample org');

    // Should generate two (prod and dev) environments
    const environments = await environmentRepository.findOrganizationEnvironments(organization._id);

    // Check that each environment has a valid apiKey
    environments.forEach((env) => {
      expect(env.apiKeys.length).to.equal(1);
      expect(env.apiKeys[0].key).to.be.ok;
    });

    expect(jwtContent.roles[0]).to.equal(MemberRoleEnum.OSS_ADMIN);
  });

  it("should throw error when the password doesn't meets the requirements", async () => {
    const { body } = await session.testAgent.post('/v1/auth/register').send({
      email: 'Testy.test12345@gmail.com',
      firstName: 'Test',
      lastName: 'User',
      password: 'password',
    });

    expect(body.message[0]).to.contain(
      'The password must contain minimum 8 and maximum 64 characters, at least one uppercase letter, one lowercase letter, one number and one special character #?!@$%^&*()-'
    );
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - organizationRepository(new CommunityOrganizationRepository();

  before(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should throw validation error for no...)
 - DISABLE_USER_REGISTRATION('false';
  });

  it('should create a new user successfully', async ())
 - jwtContent(await jwt.decode(body.data.token)) as UserSessionData;

    expect(jwtContent.firstName).to.equal('t...)
 - environments(await environmentRepository.findOrganizationEnvironments(organization._id);

    // Check that each ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/e2e/user.auth.guard.e2e.ts
Tamao: 3814 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpRequestHeaderKeysEnum } from '@novu/application-generic';
import { ApiAuthSchemeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('UserAuthGuard #novu-v2', () => {
  let session: UserSession;
  const defaultPath = '/v1/test-auth/user-route';
  const apiInaccessiblePath = '/v1/test-auth/user-api-inaccessible-route';

  let request: (
    authHeader: string,
    path?: string
  ) => Promise<Awaited<ReturnType<typeof UserSession.prototype.testAgent.get>>>;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    request = (authHeader, path = defaultPath) =>
      session.testAgent.get(path).set(HttpRequestHeaderKeysEnum.AUTHORIZATION, authHeader);
  });

  describe('Invalid authentication scheme', () => {
    it('should return 401 when an invalid auth scheme is provided', async () => {
      const response = await request('Invalid invalid_value');
      expect(response.statusCode).to.equal(401);
      expect(response.body.message).to.equal('Invalid authentication scheme: "Invalid"');
    });

    it('should return 401 when no authorization header is provided', async () => {
      const response = await session.testAgent.get(defaultPath).unset(HttpRequestHeaderKeysEnum.AUTHORIZATION);

      expect(response.statusCode).to.equal(401);
      expect(response.body.message).to.equal('Missing authorization header');
    });
  });

  describe('ApiKey authentication scheme', () => {
    it('should return 401 when ApiKey auth scheme is provided without a value', async () => {
      const response = await request(`${ApiAuthSchemeEnum.API_KEY} `);
      expect(response.statusCode).to.equal(401);
      expect(response.body.message).to.equal('Unauthorized');
    });

    it('should return 401 when ApiKey auth scheme is provided with an invalid value', async () => {
      const response = await request(`${ApiAuthSchemeEnum.API_KEY} invalid_key`);
      expect(response.statusCode).to.equal(401);
      expect(response.body.message).to.equal('API Key not found');
    });

    it('should return 401 when ApiKey auth scheme is used for an externally inaccessible API route', async () => {
      const response = await request(`${ApiAuthSchemeEnum.API_KEY} ${session.apiKey}`, apiInaccessiblePath);
      expect(response.statusCode).to.equal(401);
      expect(response.body.message).to.equal('API endpoint not accessible');
    });

    it('should return 200 when ApiKey auth scheme is provided with a valid value', async () => {
      const response = await request(`${ApiAuthSchemeEnum.API_KEY} ${session.apiKey}`);
      expect(response.statusCode).to.equal(200);
    });
  });

  describe('Bearer authentication scheme', () => {
    it('should return 401 when Bearer auth scheme is provided without a value', async () => {
      const response = await request(`${ApiAuthSchemeEnum.BEARER} `);
      expect(response.statusCode).to.equal(401);
      expect(response.body.message).to.equal('Unauthorized');
    });

    it('should return 401 when Bearer auth scheme is provided with an invalid value', async () => {
      const response = await request(`${ApiAuthSchemeEnum.BEARER} invalid_token`);
      expect(response.statusCode).to.equal(401);
      expect(response.body.message).to.equal('Unauthorized');
    });

    it('should return 200 when Bearer auth scheme is used for an externally inaccessible API route', async () => {
      const response = await request(session.token, apiInaccessiblePath);
      expect(response.statusCode).to.equal(200);
    });

    it('should return 200 when Bearer auth scheme is provided with a valid value', async () => {
      const response = await request(session.token);
      expect(response.statusCode).to.equal(200);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - apiInaccessiblePath('/v1/test-auth/user-api-inaccessible-route';

  let request: (
    authHeader: string,
    path?: st...)
 - path(defaultPath))
 - response(await request('Invalid invalid_value');
      expect(response.statusCode).to.equal(401);
      expec...)
 - response(await session.testAgent.get(defaultPath).unset(HttpRequestHeaderKeysEnum.AUTHORIZATION);

      expe...)
 - response(await request(`${ApiAuthSchemeEnum.API_KEY} `);
      expect(response.statusCode).to.equal(401);
   ...)
 - response(await request(`${ApiAuthSchemeEnum.API_KEY} invalid_key`);
      expect(response.statusCode).to.equa...)
 - response(await request(`${ApiAuthSchemeEnum.API_KEY} ${session.apiKey}`, apiInaccessiblePath);
      expect(r...)
 - response(await request(`${ApiAuthSchemeEnum.API_KEY} ${session.apiKey}`);
      expect(response.statusCode).t...)
 - response(await request(`${ApiAuthSchemeEnum.BEARER} `);
      expect(response.statusCode).to.equal(401);
    ...)
 - response(await request(`${ApiAuthSchemeEnum.BEARER} invalid_token`);
      expect(response.statusCode).to.equ...)
 - response(await request(session.token, apiInaccessiblePath);
      expect(response.statusCode).to.equal(200);
...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/framework/auth.decorator.ts
Tamao: 611 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { applyDecorators, UseGuards } from '@nestjs/common';
import { ApiBearerAuth } from '@nestjs/swagger';
import { BEARER_SWAGGER_SECURITY_NAME } from '@novu/application-generic';
import { isClerkEnabled } from '@novu/shared';
import { CommunityUserAuthGuard } from './community.user.auth.guard';

export function RequireAuthentication() {
  if (isClerkEnabled()) {
    const { RequireAuthentication: EERequireAuthentication } = require('@novu/ee-auth');

    return EERequireAuthentication();
  }

  return applyDecorators(UseGuards(CommunityUserAuthGuard), ApiBearerAuth(BEARER_SWAGGER_SECURITY_NAME));
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - RequireAuthentication()
Declaraciones 'export' encontradas:
- export function RequireAuthentication

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/framework/community.user.auth.guard.ts
Tamao: 1768 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ExecutionContext, Injectable, UnauthorizedException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { AuthGuard, IAuthModuleOptions } from '@nestjs/passport';
import { PinoLogger } from '@novu/application-generic';
import { ApiAuthSchemeEnum, NONE_AUTH_SCHEME, PassportStrategyEnum } from '@novu/shared';

@Injectable()
export class CommunityUserAuthGuard extends AuthGuard([PassportStrategyEnum.JWT, PassportStrategyEnum.HEADER_API_KEY]) {
  constructor(
    private readonly reflector: Reflector,
    private readonly logger: PinoLogger
  ) {
    super();
    this.logger.setContext(this.constructor.name);
  }

  getAuthenticateOptions(context: ExecutionContext): IAuthModuleOptions<any> {
    const request = context.switchToHttp().getRequest();
    const authorizationHeader = request.headers.authorization;

    const authScheme = authorizationHeader?.split(' ')[0] || NONE_AUTH_SCHEME;
    request.authScheme = authScheme;

    this.logger.assign({ authScheme });

    switch (authScheme) {
      case ApiAuthSchemeEnum.BEARER: {
        return {
          session: false,
          defaultStrategy: PassportStrategyEnum.JWT,
        };
      }
      case ApiAuthSchemeEnum.API_KEY: {
        const apiEnabled = this.reflector.get<boolean>('external_api_accessible', context.getHandler());
        if (!apiEnabled) throw new UnauthorizedException('API endpoint not accessible');

        return {
          session: false,
          defaultStrategy: PassportStrategyEnum.HEADER_API_KEY,
        };
      }
      case NONE_AUTH_SCHEME:
        throw new UnauthorizedException('Missing authorization header');
      default:
        throw new UnauthorizedException(`Invalid authentication scheme: "${authScheme}"`);
    }
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class CommunityUserAuthGuard

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/framework/external-api.decorator.ts
Tamao: 102 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ExternalApiAccessible } from '@novu/application-generic';

export { ExternalApiAccessible };


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/framework/root-environment-guard.service.ts
Tamao: 641 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CanActivate, ExecutionContext, Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthService } from '../services/auth.service';

@Injectable()
export class RootEnvironmentGuard implements CanActivate {
  constructor(private authService: AuthService) {}

  async canActivate(context: ExecutionContext) {
    const request = context.switchToHttp().getRequest();
    const { user } = request;

    const environment = await this.authService.isRootEnvironment(user);

    if (environment) {
      throw new UnauthorizedException('This action is only allowed in Development environment');
    }

    return true;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class RootEnvironmentGuard

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/services/auth.service.ts
Tamao: 2238 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Inject, Injectable } from '@nestjs/common';
import { IAuthService } from '@novu/application-generic';
import { MemberEntity, SubscriberEntity, UserEntity } from '@novu/dal';
import { AuthenticateContext, AuthProviderEnum, ISubscriberJwt, UserSessionData } from '@novu/shared';

@Injectable()
export class AuthService implements IAuthService {
  constructor(@Inject('AUTH_SERVICE') private authService: IAuthService) {}

  authenticate(
    authProvider: AuthProviderEnum,
    accessToken: string,
    refreshToken: string,
    profile: {
      name: string;
      login: string;
      email: string;
      avatar_url: string;
      id: string;
    },
    distinctId: string,
    authContext: AuthenticateContext = {}
  ): Promise<{ newUser: boolean; token: string }> {
    return this.authService.authenticate(authProvider, accessToken, refreshToken, profile, distinctId, authContext);
  }

  refreshToken(userId: string): Promise<string> {
    return this.authService.refreshToken(userId);
  }

  isAuthenticatedForOrganization(userId: string, organizationId: string): Promise<boolean> {
    return this.authService.isAuthenticatedForOrganization(userId, organizationId);
  }

  getUserByApiKey(apiKey: string): Promise<UserSessionData> {
    return this.authService.getUserByApiKey(apiKey);
  }

  getSubscriberWidgetToken(subscriber: SubscriberEntity, contextKeys?: string[]): Promise<string> {
    return this.authService.getSubscriberWidgetToken(subscriber, contextKeys);
  }

  generateUserToken(user: UserEntity): Promise<string> {
    return this.authService.generateUserToken(user);
  }

  getSignedToken(
    user: UserEntity,
    organizationId?: string,
    member?: MemberEntity,
    environmentId?: string
  ): Promise<string> {
    return this.authService.getSignedToken(user, organizationId, member, environmentId);
  }

  validateUser(payload: UserSessionData): Promise<UserEntity> {
    return this.authService.validateUser(payload);
  }

  validateSubscriber(payload: ISubscriberJwt): Promise<SubscriberEntity | null> {
    return this.authService.validateSubscriber(payload);
  }

  isRootEnvironment(payload: UserSessionData): Promise<boolean> {
    return this.authService.isRootEnvironment(payload);
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class AuthService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/services/community.auth.service.ts
Tamao: 10327 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  BadRequestException,
  forwardRef,
  Inject,
  Injectable,
  NotFoundException,
  UnauthorizedException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import {
  AnalyticsService,
  buildSubscriberKey,
  buildUserKey,
  CachedResponse,
  IAuthService,
  Instrument,
} from '@novu/application-generic';

import {
  EnvironmentEntity,
  EnvironmentRepository,
  MemberEntity,
  MemberRepository,
  OrganizationRepository,
  SubscriberEntity,
  SubscriberRepository,
  UserEntity,
  UserRepository,
} from '@novu/dal';
import {
  ALL_PERMISSIONS,
  ApiAuthSchemeEnum,
  AuthenticateContext,
  AuthProviderEnum,
  ISubscriberJwt,
  MemberRoleEnum,
  normalizeEmail,
  UserSessionData,
} from '@novu/shared';
import { createHash } from 'crypto';
import { CreateUserCommand } from '../../user/usecases/create-user/create-user.command';
import { CreateUser } from '../../user/usecases/create-user/create-user.usecase';
import { SwitchOrganizationCommand } from '../usecases/switch-organization/switch-organization.command';
import { SwitchOrganization } from '../usecases/switch-organization/switch-organization.usecase';

@Injectable()
export class CommunityAuthService implements IAuthService {
  constructor(
    private userRepository: UserRepository,
    private subscriberRepository: SubscriberRepository,
    private createUserUsecase: CreateUser,
    private jwtService: JwtService,
    private analyticsService: AnalyticsService,
    private organizationRepository: OrganizationRepository,
    private environmentRepository: EnvironmentRepository,
    private memberRepository: MemberRepository,
    @Inject(forwardRef(() => SwitchOrganization))
    private switchOrganizationUsecase: SwitchOrganization
  ) {}

  public async authenticate(
    authProvider: AuthProviderEnum,
    accessToken: string,
    refreshToken: string,
    profile: {
      name: string;
      login: string;
      email: string;
      avatar_url: string;
      id: string;
    },
    distinctId: string,
    { origin, invitationToken }: AuthenticateContext = {}
  ) {
    const email = normalizeEmail(profile.email);
    let user = await this.userRepository.findByEmail(email);
    let newUser = false;

    if (!user) {
      const firstName = profile.name ? profile.name.split(' ').slice(0, -1).join(' ') : profile.login;
      const lastName = profile.name ? profile.name.split(' ').slice(-1).join(' ') : null;

      user = await this.createUserUsecase.execute(
        CreateUserCommand.create({
          picture: profile.avatar_url,
          email,
          firstName,
          lastName,
          auth: {
            username: profile.login,
            profileId: profile.id,
            provider: authProvider,
            accessToken,
            refreshToken,
          },
        })
      );
      newUser = true;

      if (distinctId) {
        this.analyticsService.alias(distinctId, user._id);
      }

      this.analyticsService.track('[Authentication] - Signup', user._id, {
        loginType: authProvider,
        origin,
        wasInvited: Boolean(invitationToken),
      });
    } else {
      if (authProvider === AuthProviderEnum.GITHUB) {
        user = await this.updateUserUsername(user, profile, authProvider);
      }

      this.analyticsService.track('[Authentication] - Login', user._id, {
        loginType: authProvider,
      });
    }

    this.analyticsService.upsertUser(user, user._id);

    return {
      newUser,
      token: await this.generateUserToken(user),
    };
  }

  private async updateUserUsername(
    user: UserEntity,
    profile: {
      name: string;
      login: string;
      email: string;
      avatar_url: string;
      id: string;
    },
    authProvider: AuthProviderEnum
  ) {
    const withoutUsername = user.tokens.find(
      (token) => token.provider === authProvider && !token.username && String(token.providerId) === String(profile.id)
    );

    if (withoutUsername) {
      await this.userRepository.update(
        {
          _id: user._id,
          'tokens.providerId': profile.id,
        },
        {
          $set: {
            'tokens.$.username': profile.login,
          },
        }
      );

      const dbUser = await this.userRepository.findById(user._id);
      if (!dbUser) throw new BadRequestException('User not found');
      user = dbUser;
    }

    return user;
  }

  public async refreshToken(userId: string) {
    const user = await this.getUser({ _id: userId });
    if (!user) throw new UnauthorizedException('User not found');

    return this.getSignedToken(user);
  }

  @Instrument()
  public async isAuthenticatedForOrganization(userId: string, organizationId: string): Promise<boolean> {
    return !!(await this.memberRepository.isMemberOfOrganization(organizationId, userId));
  }

  @Instrument()
  public async getUserByApiKey(apiKey: string): Promise<UserSessionData> {
    const { environment, user, error } = await this.getApiKeyUser({
      apiKey,
    });

    if (error) throw new UnauthorizedException(error);

    if (!user) throw new UnauthorizedException('User not found');

    return {
      _id: user._id,
      firstName: user.firstName,
      lastName: user.lastName || undefined,
      email: user.email,
      profilePicture: user.profilePicture || undefined,
      roles: [MemberRoleEnum.OSS_ADMIN],
      permissions: ALL_PERMISSIONS,
      organizationId: environment?._organizationId || '',
      environmentId: environment?._id || '',
      scheme: ApiAuthSchemeEnum.API_KEY,
    };
  }

  public async getSubscriberWidgetToken(subscriber: SubscriberEntity, contextKeys?: string[]): Promise<string> {
    return this.jwtService.sign(
      {
        _id: subscriber._id,
        firstName: subscriber.firstName,
        lastName: subscriber.lastName,
        email: subscriber.email,
        organizationId: subscriber._organizationId,
        environmentId: subscriber._environmentId,
        subscriberId: subscriber.subscriberId,
        contextKeys,
      },
      {
        expiresIn: process.env.SUBSCRIBER_WIDGET_JWT_EXPIRATION_TIME || '15 days',
        issuer: 'novu_api',
        audience: 'widget_user',
      }
    );
  }

  public async generateUserToken(user: UserEntity) {
    const userActiveOrganizations = await this.organizationRepository.findUserActiveOrganizations(user._id);

    if (userActiveOrganizations?.length > 0) {
      const organizationToSwitch = userActiveOrganizations[0];

      return this.switchOrganizationUsecase.execute(
        SwitchOrganizationCommand.create({
          newOrganizationId: organizationToSwitch._id,
          userId: user._id,
        })
      );
    }

    return this.getSignedToken(user);
  }

  public async getSignedToken(
    user: UserEntity,
    organizationId?: string,
    member?: MemberEntity,
    environmentId?: string
  ): Promise<string> {
    const roles: MemberRoleEnum[] = [];
    if (member && member.roles) {
      roles.push(...member.roles);
    }

    return this.jwtService.sign(
      {
        _id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        profilePicture: user.profilePicture,
        organizationId: organizationId || null,
        /*
         * TODO: Remove it after deploying the new env switching logic twice to cater for outdated,
         * cached versions of Dashboard web app in Netlify.
         */
        environmentId: environmentId || null,
        roles,
      },
      {
        expiresIn: '30 days',
        issuer: 'novu_api',
      }
    );
  }

  @Instrument()
  public async validateUser(payload: UserSessionData): Promise<UserEntity> {
    const userPromise = this.getUser({ _id: payload._id });

    const isMemberPromise = payload.organizationId
      ? this.isAuthenticatedForOrganization(payload._id, payload.organizationId)
      : Promise.resolve(true);

    const [user, isMember] = await Promise.all([userPromise, isMemberPromise]);

    if (!user) throw new UnauthorizedException('User not found');
    if (payload.organizationId && !isMember) {
      throw new UnauthorizedException(`User ${payload._id} is not a member of organization ${payload.organizationId}`);
    }

    return user;
  }

  public async validateSubscriber(payload: ISubscriberJwt): Promise<SubscriberEntity | null> {
    return await this.getSubscriber({
      _environmentId: payload.environmentId,
      subscriberId: payload.subscriberId,
    });
  }

  public async isRootEnvironment(payload: UserSessionData): Promise<boolean> {
    const environment = await this.environmentRepository.findOne({
      _id: payload.environmentId,
    });
    if (!environment) throw new NotFoundException('Environment not found');

    return !!environment._parentId;
  }

  @Instrument()
  @CachedResponse({
    builder: (command: { _id: string }) =>
      buildUserKey({
        _id: command._id,
      }),
  })
  private async getUser({ _id }: { _id: string }) {
    return await this.userRepository.findById(_id);
  }

  @CachedResponse({
    builder: (command: { subscriberId: string; _environmentId: string }) =>
      buildSubscriberKey({
        _environmentId: command._environmentId,
        subscriberId: command.subscriberId,
      }),
  })
  private async getSubscriber({
    subscriberId,
    _environmentId,
  }: {
    subscriberId: string;
    _environmentId: string;
  }): Promise<SubscriberEntity | null> {
    return await this.subscriberRepository.findBySubscriberId(_environmentId, subscriberId);
  }

  private async getApiKeyUser({ apiKey }: { apiKey: string }): Promise<{
    environment?: EnvironmentEntity;
    user?: UserEntity;
    error?: string;
  }> {
    const hashedApiKey = createHash('sha256').update(apiKey).digest('hex');

    const environment = await this.environmentRepository.findByApiKey({
      hash: hashedApiKey,
    });

    if (!environment) {
      // Failed to find the environment for the provided API key.
      return { error: 'API Key not found' };
    }

    const key = environment.apiKeys.find((i) => i.hash === hashedApiKey);

    if (!key) {
      return { error: 'API Key not found' };
    }

    const user = await this.userRepository.findById(key._userId);
    if (!user) {
      return { error: 'User not found' };
    }

    return { environment, user };
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - withoutUsername(user.tokens.find(
      (token))
 - environment(await this.environmentRepository.findOne({
      _id: payload.environmentId,
    });
    if (!enviro...)
 - key(environment.apiKeys.find((i))
Declaraciones 'export' encontradas:
- export class CommunityAuthService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/services/passport/apikey.strategy.ts
Tamao: 1014 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { HttpRequestHeaderKeysEnum } from '@novu/application-generic';
import { ApiAuthSchemeEnum, UserSessionData } from '@novu/shared';
import { HeaderAPIKeyStrategy } from 'passport-headerapikey';
import { AuthService } from '../auth.service';

@Injectable()
export class ApiKeyStrategy extends PassportStrategy(HeaderAPIKeyStrategy) {
  constructor(private readonly authService: AuthService) {
    super(
      { header: HttpRequestHeaderKeysEnum.AUTHORIZATION, prefix: `${ApiAuthSchemeEnum.API_KEY} ` },
      true,
      (apikey: string, verified: (err: Error | null, user?: UserSessionData | false) => void) => {
        this.authService
          .getUserByApiKey(apikey)
          .then((user) => {
            if (!user) {
              return verified(null, false);
            }

            return verified(null, user);
          })
          .catch((err) => verified(err, false));
      }
    );
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ApiKeyStrategy

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/services/passport/github.strategy.ts
Tamao: 1897 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { AuthProviderEnum } from '@novu/shared';
import githubPassport from 'passport-github2';
import { Metadata, StateStoreStoreCallback, StateStoreVerifyCallback } from 'passport-oauth2';
import { AuthService } from '../auth.service';

@Injectable()
export class GitHubStrategy extends PassportStrategy(githubPassport.Strategy, 'github') {
  constructor(private authService: AuthService) {
    super({
      clientID: process.env.GITHUB_OAUTH_CLIENT_ID,
      clientSecret: process.env.GITHUB_OAUTH_CLIENT_SECRET,
      callbackURL: `${process.env.API_ROOT_URL}/v1/auth/github/callback`,
      scope: ['user:email'],
      passReqToCallback: true,
      store: {
        verify(req, state: string, meta: Metadata, callback: StateStoreVerifyCallback) {
          callback(null, true, JSON.stringify(req.query));
        },
        store(req, meta: Metadata, callback: StateStoreStoreCallback) {
          callback(null, JSON.stringify(req.query));
        },
      },
    });
  }

  async validate(req, accessToken: string, refreshToken: string, githubProfile, done: (err, data) => void) {
    try {
      const profile = { ...githubProfile._json, email: githubProfile.emails[0].value };
      const parsedState = this.parseState(req);

      const response = await this.authService.authenticate(
        AuthProviderEnum.GITHUB,
        accessToken,
        refreshToken,
        profile,
        parsedState?.distinctId,
        { origin: parsedState?.source, invitationToken: parsedState?.invitationToken }
      );

      done(null, {
        token: response.token,
        newUser: response.newUser,
      });
    } catch (err) {
      done(err, false);
    }
  }

  private parseState(req) {
    try {
      return JSON.parse(req.query.state);
    } catch (e) {
      return {};
    }
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GitHubStrategy

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/services/passport/jwt.strategy.ts
Tamao: 1960 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { HttpRequestHeaderKeysEnum, Instrument } from '@novu/application-generic';
import { EnvironmentRepository } from '@novu/dal';
import { ApiAuthSchemeEnum, UserSessionData } from '@novu/shared';
import type http from 'http';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { AuthService } from '../auth.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    private readonly authService: AuthService,
    private environmentRepository: EnvironmentRepository
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: process.env.JWT_SECRET,
      passReqToCallback: true,
    });
  }
  @Instrument()
  async validate(req: http.IncomingMessage, session: UserSessionData) {
    // Set the scheme to Bearer, meaning the user is authenticated via a JWT coming from Dashboard
    session.scheme = ApiAuthSchemeEnum.BEARER;

    const user = await this.authService.validateUser(session);
    if (!user) {
      throw new UnauthorizedException();
    }

    const environmentId = this.resolveEnvironmentId(req, session);

    session.environmentId = environmentId;

    if (session.environmentId) {
      const environment = await this.environmentRepository.findOne(
        {
          _id: session.environmentId,
          _organizationId: session.organizationId,
        },
        '_id'
      );

      if (!environment) {
        throw new UnauthorizedException('Cannot find environment', JSON.stringify({ session }));
      }
    }

    return session;
  }

  @Instrument()
  resolveEnvironmentId(req: http.IncomingMessage, session: UserSessionData) {
    const environmentIdFromHeader =
      (req.headers[HttpRequestHeaderKeysEnum.NOVU_ENVIRONMENT_ID.toLowerCase()] as string) || '';

    return environmentIdFromHeader;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class JwtStrategy

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/services/passport/subscriber-jwt.strategy.ts
Tamao: 1453 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ApiAuthSchemeEnum, ISubscriberJwt } from '@novu/shared';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { SubscriberSession } from '../../../shared/framework/user.decorator';
import { AuthService } from '../auth.service';

@Injectable()
export class JwtSubscriberStrategy extends PassportStrategy(Strategy, 'subscriberJwt') {
  constructor(private readonly authService: AuthService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: process.env.JWT_SECRET,
    });
  }

  async validate(payload: ISubscriberJwt): Promise<SubscriberSession> {
    const subscriber = await this.authService.validateSubscriber(payload);

    if (!subscriber) {
      throw new UnauthorizedException();
    }

    if (payload.aud !== 'widget_user') {
      throw new UnauthorizedException();
    }

    /*
     * TODO: Create a unified session interface for both users and subscribers to eliminate property naming inconsistencies (e.g., _environmentId vs environmentId)
     * for user we have UserSessionData, we need to create SubscriberSessionData
     */
    return {
      ...subscriber,
      organizationId: subscriber._organizationId,
      environmentId: subscriber._environmentId,
      contextKeys: payload.contextKeys,
      scheme: ApiAuthSchemeEnum.BEARER,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class JwtSubscriberStrategy

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/index.ts
Tamao: 1059 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CreateOrganization } from '../../organization/usecases/create-organization/create-organization.usecase';
import { GetOrganization } from '../../organization/usecases/get-organization/get-organization.usecase';
import { AddMember } from '../../organization/usecases/membership/add-member/add-member.usecase';
import { Login } from './login/login.usecase';
import { PasswordReset } from './password-reset/password-reset.usecase';
import { PasswordResetRequest } from './password-reset-request/password-reset-request.usecase';
import { UserRegister } from './register/user-register.usecase';
import { SwitchEnvironment } from './switch-environment/switch-environment.usecase';
import { SwitchOrganization } from './switch-organization/switch-organization.usecase';
import { UpdatePassword } from './update-password/update-password.usecase';

export const USE_CASES = [
  UserRegister,
  Login,
  SwitchEnvironment,
  SwitchOrganization,
  PasswordResetRequest,
  PasswordReset,
  UpdatePassword,
  CreateOrganization,
  AddMember,
  GetOrganization,
];


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/login/login.command.ts
Tamao: 271 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsDefined, IsEmail, IsNotEmpty } from 'class-validator';

export class LoginCommand extends BaseCommand {
  @IsDefined()
  @IsNotEmpty()
  @IsEmail()
  email: string;

  @IsDefined()
  password: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class LoginCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/login/login.usecase.ts
Tamao: 5497 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, UnauthorizedException } from '@nestjs/common';
import { AnalyticsService, createHash } from '@novu/application-generic';
import { OrganizationRepository, UserEntity, UserRepository } from '@novu/dal';
import { normalizeEmail } from '@novu/shared';
import bcrypt from 'bcrypt';
import { differenceInMinutes, parseISO } from 'date-fns';
import { AuthService } from '../../services/auth.service';
import { LoginCommand } from './login.command';

@Injectable()
export class Login {
  private BLOCKED_PERIOD_IN_MINUTES = 5;
  private MAX_LOGIN_ATTEMPTS = 5;
  constructor(
    private userRepository: UserRepository,
    private authService: AuthService,
    private analyticsService: AnalyticsService,
    private organizationRepository: OrganizationRepository
  ) {}

  async execute(command: LoginCommand) {
    const email = normalizeEmail(command.email);
    const user = await this.userRepository.findByEmail(email);

    if (!user) {
      /**
       * maxWaitTime and minWaitTime(millisecond) are used to mimic the delay for server response times
       * received for existing users flow
       */
      const maxWaitTime = 110;
      const minWaitTime = 90;
      const randomWaitTime = Math.floor(Math.random() * (maxWaitTime - minWaitTime) + minWaitTime);
      await new Promise((resolve) => {
        setTimeout(resolve, randomWaitTime);
      }); // will wait randomly for the chosen time to sync response time

      throw new UnauthorizedException('Incorrect email or password provided.');
    }

    if (this.isAccountBlocked(user) && user.failedLogin) {
      const blockedMinutesLeft = this.getBlockedMinutesLeft(user.failedLogin.lastFailedAttempt);
      throw new UnauthorizedException(`Account blocked, Please try again after ${blockedMinutesLeft} minutes`);
    }

    // TODO: Trigger a password reset flow automatically for existing OAuth users instead of throwing an error
    if (!user.password) throw new BadRequestException('Please sign in using Github.');

    const isMatching = await bcrypt.compare(command.password, user.password);
    if (!isMatching) {
      const failedAttempts = await this.updateFailedAttempts(user);
      const remainingAttempts = this.MAX_LOGIN_ATTEMPTS - failedAttempts;

      if (remainingAttempts === 0 && user.failedLogin) {
        const blockedMinutesLeft = this.getBlockedMinutesLeft(user.failedLogin.lastFailedAttempt);
        throw new UnauthorizedException(`Account blocked, Please try again after ${blockedMinutesLeft} minutes`);
      }

      if (remainingAttempts < 3) {
        throw new UnauthorizedException(`Incorrect email or password provided. ${remainingAttempts} Attempts left`);
      }

      throw new UnauthorizedException(`Incorrect email or password provided.`);
    }

    if (process.env.INTERCOM_IDENTITY_VERIFICATION_SECRET_KEY && !user.servicesHashes?.intercom) {
      const intercomSecretKey = process.env.INTERCOM_IDENTITY_VERIFICATION_SECRET_KEY as string;
      const userHashForIntercom = createHash(intercomSecretKey, user._id);
      await this.userRepository.update(
        { _id: user._id },
        {
          $set: {
            'servicesHashes.intercom': userHashForIntercom,
          },
        }
      );
    }

    this.analyticsService.upsertUser(user, user._id);

    const userActiveOrganizations = (await this.organizationRepository.findUserActiveOrganizations(user._id)) || [];
    this.analyticsService.track('[Authentication] - Login', user._id, {
      loginType: 'email',
      _organization:
        userActiveOrganizations && userActiveOrganizations[0] ? userActiveOrganizations[0]?._id : undefined,
    });

    if (user?.failedLogin && user?.failedLogin?.times > 0) {
      await this.resetFailedAttempts(user);
    }

    return {
      token: await this.authService.generateUserToken(user),
    };
  }

  private isAccountBlocked(user: UserEntity) {
    const lastFailedAttempt = user?.failedLogin?.lastFailedAttempt;
    if (!lastFailedAttempt) return false;

    const diff = this.getTimeDiffForAttempt(lastFailedAttempt);

    return (
      user?.failedLogin && user?.failedLogin?.times >= this.MAX_LOGIN_ATTEMPTS && diff < this.BLOCKED_PERIOD_IN_MINUTES
    );
  }

  private async updateFailedAttempts(user: UserEntity) {
    const now = new Date();
    let times = user?.failedLogin?.times ?? 1;
    const lastFailedAttempt = user?.failedLogin?.lastFailedAttempt;

    if (lastFailedAttempt) {
      const diff = this.getTimeDiffForAttempt(lastFailedAttempt);
      times = diff < this.BLOCKED_PERIOD_IN_MINUTES ? times + 1 : 1;
    }

    await this.userRepository.update(
      {
        _id: user._id,
      },
      {
        $set: {
          failedLogin: {
            times,
            lastFailedAttempt: now,
          },
        },
      }
    );

    return times;
  }

  private async resetFailedAttempts(user: UserEntity) {
    await this.userRepository.update(
      {
        _id: user._id,
      },
      {
        $set: {
          'failedLogin.times': 0,
        },
      }
    );
  }

  private getTimeDiffForAttempt(lastFailedAttempt: string) {
    const now = new Date();
    const formattedLastAttempt = parseISO(lastFailedAttempt);
    const diff = differenceInMinutes(now, formattedLastAttempt);

    return diff;
  }

  private getBlockedMinutesLeft(lastFailedAttempt: string) {
    const diff = this.getTimeDiffForAttempt(lastFailedAttempt);

    return this.BLOCKED_PERIOD_IN_MINUTES - diff;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - randomWaitTime(Math.floor(Math.random() * (maxWaitTime - minWaitTime) + minWaitTime);
      await new Promise((reso...)
Declaraciones 'export' encontradas:
- export class Login

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/password-reset-request/password-reset-request.command.ts
Tamao: 377 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { PasswordResetFlowEnum } from '@novu/shared';
import { IsDefined, IsEmail, IsEnum, IsOptional } from 'class-validator';

export class PasswordResetRequestCommand extends BaseCommand {
  @IsEmail()
  @IsDefined()
  email: string;

  @IsEnum(PasswordResetFlowEnum)
  @IsOptional()
  src?: PasswordResetFlowEnum;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class PasswordResetRequestCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/password-reset-request/password-reset-request.usecase.ts
Tamao: 4478 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, UnauthorizedException } from '@nestjs/common';
import { buildUserKey, InvalidateCacheService } from '@novu/application-generic';
import { IUserResetTokenCount, UserEntity, UserRepository } from '@novu/dal';
import { normalizeEmail, PasswordResetFlowEnum } from '@novu/shared';
import { differenceInHours, differenceInSeconds, parseISO } from 'date-fns';
import { v4 as uuidv4 } from 'uuid';
import { PasswordResetRequestCommand } from './password-reset-request.command';

@Injectable()
export class PasswordResetRequest {
  private MAX_ATTEMPTS_IN_A_MINUTE = 5;
  private MAX_ATTEMPTS_IN_A_DAY = 15;
  private RATE_LIMIT_IN_SECONDS = 60;
  private RATE_LIMIT_IN_HOURS = 24;
  constructor(
    private invalidateCache: InvalidateCacheService,
    private userRepository: UserRepository
  ) {}

  async execute(command: PasswordResetRequestCommand): Promise<{ success: boolean }> {
    const email = normalizeEmail(command.email);
    const foundUser = await this.userRepository.findByEmail(email);
    if (foundUser && foundUser.email) {
      const { error, isBlocked } = this.isRequestBlocked(foundUser);
      if (isBlocked) {
        throw new UnauthorizedException(error);
      }
      const token = uuidv4();

      await this.invalidateCache.invalidateByKey({
        key: buildUserKey({
          _id: foundUser._id,
        }),
      });

      const resetTokenCount = this.getUpdatedRequestCount(foundUser);
      await this.userRepository.updatePasswordResetToken(foundUser._id, token, resetTokenCount);

      if ((process.env.NODE_ENV === 'dev' || process.env.NODE_ENV === 'production') && process.env.NOVU_API_KEY) {
        const resetPasswordLink = PasswordResetRequest.getResetRedirectLink(token, foundUser, command.src);
      }
    }

    return {
      success: true,
    };
  }

  private static getResetRedirectLink(token: string, user: UserEntity, src?: PasswordResetFlowEnum): string {
    // ensure that only users without passwords are allowed to reset
    if (src === PasswordResetFlowEnum.USER_PROFILE && !user.password) {
      return `${process.env.FRONT_BASE_URL}/settings/profile?token=${token}&view=password`;
    }

    /**
     * Default to the existing "forgot password flow". Works for:
     * 1. No src
     * 2. When src is explicitly FORGOT_PASSWORD
     * 3. User already has a password
     */
    return `${process.env.FRONT_BASE_URL}/auth/reset/${token}`;
  }

  private isRequestBlocked(user: UserEntity) {
    const lastResetAttempt = user.resetTokenDate;

    if (!lastResetAttempt) {
      return {
        isBlocked: false,
        error: '',
      };
    }
    const formattedDate = parseISO(lastResetAttempt);
    const diffSeconds = differenceInSeconds(new Date(), formattedDate);
    const diffHours = differenceInHours(new Date(), formattedDate);

    const withinDailyLimit = diffHours < this.RATE_LIMIT_IN_HOURS;
    const exceededDailyAttempt = user?.resetTokenCount
      ? user?.resetTokenCount?.reqInDay >= this.MAX_ATTEMPTS_IN_A_DAY
      : false;
    if (withinDailyLimit && exceededDailyAttempt) {
      return {
        isBlocked: true,
        error: `Too many requests, Try again after ${this.RATE_LIMIT_IN_HOURS} hours.`,
      };
    }

    const withinMinuteLimit = diffSeconds < this.RATE_LIMIT_IN_SECONDS;
    const exceededMinuteAttempt = user?.resetTokenCount
      ? user?.resetTokenCount?.reqInMinute >= this.MAX_ATTEMPTS_IN_A_MINUTE
      : false;
    if (withinMinuteLimit && exceededMinuteAttempt) {
      return {
        isBlocked: true,
        error: `Too many requests, Try again after a minute.`,
      };
    }

    return {
      isBlocked: false,
      error: '',
    };
  }

  private getUpdatedRequestCount(user: UserEntity): IUserResetTokenCount {
    const now = new Date().toISOString();
    const lastResetAttempt = user.resetTokenDate ?? now;
    const formattedDate = parseISO(lastResetAttempt);
    const diffSeconds = differenceInSeconds(new Date(), formattedDate);
    const diffHours = differenceInHours(new Date(), formattedDate);

    const resetTokenCount: IUserResetTokenCount = {
      reqInMinute: user.resetTokenCount?.reqInMinute ?? 0,
      reqInDay: user.resetTokenCount?.reqInDay ?? 0,
    };

    resetTokenCount.reqInMinute = diffSeconds < this.RATE_LIMIT_IN_SECONDS ? resetTokenCount.reqInMinute + 1 : 1;
    resetTokenCount.reqInDay = diffHours < this.RATE_LIMIT_IN_HOURS ? resetTokenCount.reqInDay + 1 : 1;

    return resetTokenCount;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class PasswordResetRequest

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/password-reset/password-reset.command.ts
Tamao: 343 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsDefined, IsString, IsUUID, MinLength } from 'class-validator';

export class PasswordResetCommand extends BaseCommand {
  @IsString()
  @IsDefined()
  @MinLength(8)
  password: string;

  @IsUUID(4, {
    message: 'Bad token provided',
  })
  @IsDefined()
  token: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class PasswordResetCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/password-reset/password-reset.usecase.ts
Tamao: 1533 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { buildUserKey, InvalidateCacheService } from '@novu/application-generic';
import { UserRepository } from '@novu/dal';
import { hash } from 'bcrypt';
import { isBefore, subDays } from 'date-fns';
import { AuthService } from '../../services/auth.service';
import { PasswordResetCommand } from './password-reset.command';

@Injectable()
export class PasswordReset {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private userRepository: UserRepository,
    private authService: AuthService
  ) {}

  async execute(command: PasswordResetCommand): Promise<{ token: string }> {
    const user = await this.userRepository.findUserByToken(command.token);
    if (!user) {
      throw new BadRequestException('Bad token provided');
    }

    if (user.resetTokenDate && isBefore(new Date(user.resetTokenDate), subDays(new Date(), 7))) {
      throw new BadRequestException('Token has expired');
    }

    const passwordHash = await hash(command.password, 10);

    await this.invalidateCache.invalidateByKey({
      key: buildUserKey({
        _id: user._id,
      }),
    });

    await this.userRepository.update(
      {
        _id: user._id,
      },
      {
        $set: {
          password: passwordHash,
        },
        $unset: {
          resetToken: 1,
          resetTokenDate: 1,
          resetTokenCount: '',
        },
      }
    );

    return {
      token: await this.authService.generateUserToken(user),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class PasswordReset

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/register/user-register.command.ts
Tamao: 938 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';

import { JobTitleEnum, ProductUseCases, SignUpOriginEnum } from '@novu/shared';
import { IsBoolean, IsDefined, IsEmail, IsEnum, IsNotEmpty, IsOptional, IsString, MinLength } from 'class-validator';

export class UserRegisterCommand extends BaseCommand {
  @IsDefined()
  @IsNotEmpty()
  @IsEmail()
  email: string;

  @IsDefined()
  @IsString()
  @MinLength(8)
  password: string;

  @IsDefined()
  @IsString()
  firstName: string;

  @IsOptional()
  @IsString()
  lastName?: string;

  @IsOptional()
  @IsString()
  organizationName?: string;

  @IsOptional()
  @IsEnum(SignUpOriginEnum)
  origin?: SignUpOriginEnum;

  @IsOptional()
  @IsEnum(JobTitleEnum)
  jobTitle?: JobTitleEnum;

  @IsString()
  @IsOptional()
  domain?: string;

  @IsOptional()
  productUseCases?: ProductUseCases;

  @IsOptional()
  @IsBoolean()
  wasInvited?: boolean = false;

  language?: string[];
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class UserRegisterCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/register/user-register.usecase.ts
Tamao: 2781 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { AnalyticsService, createHash } from '@novu/application-generic';
import { OrganizationEntity, UserRepository } from '@novu/dal';
import { normalizeEmail, SignUpOriginEnum } from '@novu/shared';
import { hash } from 'bcrypt';
import { CreateOrganizationCommand } from '../../../organization/usecases/create-organization/create-organization.command';
import { CreateOrganization } from '../../../organization/usecases/create-organization/create-organization.usecase';
import { AuthService } from '../../services/auth.service';
import { UserRegisterCommand } from './user-register.command';

@Injectable()
export class UserRegister {
  constructor(
    private authService: AuthService,
    private userRepository: UserRepository,
    private createOrganizationUsecase: CreateOrganization,
    private analyticsService: AnalyticsService
  ) {}

  async execute(command: UserRegisterCommand) {
    if (process.env.DISABLE_USER_REGISTRATION === 'true') throw new BadRequestException('Account creation is disabled');

    const email = normalizeEmail(command.email);
    const existingUser = await this.userRepository.findByEmail(email);
    if (existingUser) throw new BadRequestException('User already exists');

    const passwordHash = await hash(command.password, 10);
    const user = await this.userRepository.create({
      email,
      firstName: command.firstName.toLowerCase(),
      lastName: command.lastName?.toLowerCase(),
      password: passwordHash,
    });

    if (process.env.INTERCOM_IDENTITY_VERIFICATION_SECRET_KEY) {
      const intercomSecretKey = process.env.INTERCOM_IDENTITY_VERIFICATION_SECRET_KEY as string;
      const userHashForIntercom = createHash(intercomSecretKey, user._id);
      await this.userRepository.update(
        { _id: user._id },
        {
          $set: {
            'servicesHashes.intercom': userHashForIntercom,
          },
        }
      );
    }

    let organization: OrganizationEntity;
    if (command.organizationName) {
      organization = await this.createOrganizationUsecase.execute(
        CreateOrganizationCommand.create({
          name: command.organizationName,
          userId: user._id,
          jobTitle: command.jobTitle,
          domain: command.domain,
          language: command.language,
        })
      );
    }

    this.analyticsService.upsertUser(user, user._id);

    this.analyticsService.track('[Authentication] - Signup', user._id, {
      loginType: 'email',
      origin: command.origin || SignUpOriginEnum.WEB,
      wasInvited: Boolean(command.wasInvited),
    });

    return {
      user: await this.userRepository.findById(user._id),
      token: await this.authService.generateUserToken(user),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class UserRegister

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/switch-environment/index.ts
Tamao: 92 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './switch-environment.command';
export * from './switch-environment.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/switch-environment/switch-environment.command.ts
Tamao: 226 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { OrganizationCommand } from '@novu/application-generic';
import { IsNotEmpty } from 'class-validator';

export class SwitchEnvironmentCommand extends OrganizationCommand {
  @IsNotEmpty()
  newEnvironmentId: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class SwitchEnvironmentCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/switch-environment/switch-environment.usecase.ts
Tamao: 1428 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { forwardRef, Inject, Injectable, NotFoundException, UnauthorizedException } from '@nestjs/common';
import { EnvironmentRepository, MemberRepository, UserRepository } from '@novu/dal';
import { AuthService } from '../../services/auth.service';
import { SwitchEnvironmentCommand } from './switch-environment.command';

@Injectable()
export class SwitchEnvironment {
  constructor(
    private environmentRepository: EnvironmentRepository,
    private userRepository: UserRepository,
    private memberRepository: MemberRepository,
    private authService: AuthService
  ) {}

  async execute(command: SwitchEnvironmentCommand) {
    const environment = await this.environmentRepository.findOne({
      _id: command.newEnvironmentId,
    });
    if (!environment) throw new NotFoundException('Environment not found');
    if (environment._organizationId !== command.organizationId) {
      throw new UnauthorizedException('Not authorized for organization');
    }

    const member = await this.memberRepository.findMemberByUserId(command.organizationId, command.userId);
    if (!member) throw new NotFoundException('Member is not found');

    const user = await this.userRepository.findById(command.userId);
    if (!user) throw new NotFoundException('User is not found');

    const token = await this.authService.getSignedToken(user, command.organizationId, member, command.newEnvironmentId);

    return token;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class SwitchEnvironment

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/switch-organization/index.ts
Tamao: 94 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './switch-organization.command';
export * from './switch-organization.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/switch-organization/switch-organization.command.ts
Tamao: 230 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { AuthenticatedCommand } from '@novu/application-generic';
import { IsNotEmpty } from 'class-validator';

export class SwitchOrganizationCommand extends AuthenticatedCommand {
  @IsNotEmpty()
  newOrganizationId: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class SwitchOrganizationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/switch-organization/switch-organization.usecase.ts
Tamao: 1276 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, UnauthorizedException } from '@nestjs/common';
import { MemberRepository, UserRepository } from '@novu/dal';
import { AuthService } from '../../services/auth.service';
import { SwitchOrganizationCommand } from './switch-organization.command';

@Injectable()
export class SwitchOrganization {
  constructor(
    private userRepository: UserRepository,
    private memberRepository: MemberRepository,
    private authService: AuthService
  ) {}

  async execute(command: SwitchOrganizationCommand) {
    const isAuthenticated = await this.authService.isAuthenticatedForOrganization(
      command.userId,
      command.newOrganizationId
    );
    if (!isAuthenticated) {
      throw new UnauthorizedException(`Not authorized for organization ${command.newOrganizationId}`);
    }

    const member = await this.memberRepository.findMemberByUserId(command.newOrganizationId, command.userId);
    if (!member) throw new BadRequestException('Member not found');

    const user = await this.userRepository.findById(command.userId);
    if (!user) throw new BadRequestException(`User ${command.userId} not found`);

    const token = await this.authService.getSignedToken(user, command.newOrganizationId, member);

    return token;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class SwitchOrganization

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/update-password/update-password.command.ts
Tamao: 756 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { passwordConstraints } from '@novu/shared';
import { IsNotEmpty, Matches, MaxLength, MinLength } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class UpdatePasswordCommand extends EnvironmentWithUserCommand {
  @IsNotEmpty()
  @MinLength(passwordConstraints.minLength)
  @MaxLength(passwordConstraints.maxLength)
  @Matches(passwordConstraints.pattern, {
    message:
      'The new password must contain minimum 8 and maximum 64 characters,' +
      ' at least one uppercase letter, one lowercase letter, one number and one special character #?!@$%^&*()-',
  })
  newPassword: string;

  @IsNotEmpty()
  confirmPassword: string;

  @IsNotEmpty()
  currentPassword: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class UpdatePasswordCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/auth/usecases/update-password/update-password.usecase.ts
Tamao: 1543 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, UnauthorizedException } from '@nestjs/common';
import { buildUserKey, InvalidateCacheService } from '@novu/application-generic';
import { UserRepository } from '@novu/dal';
import { compare, hash } from 'bcrypt';

import { UpdatePasswordCommand } from './update-password.command';

@Injectable()
export class UpdatePassword {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private userRepository: UserRepository
  ) {}

  async execute(command: UpdatePasswordCommand) {
    if (command.newPassword !== command.confirmPassword) {
      throw new BadRequestException('Passwords do not match.');
    }

    const user = await this.userRepository.findById(command.userId);
    if (!user) {
      throw new UnauthorizedException();
    }
    if (!user.password) {
      throw new BadRequestException('OAuth user cannot change password.');
    }

    const isAuthorized = await compare(command.currentPassword, user.password);

    if (!isAuthorized) {
      throw new UnauthorizedException();
    }

    await this.setNewPassword(user._id, command.newPassword);

    await this.invalidateCache.invalidateByKey({
      key: buildUserKey({
        _id: user._id,
      }),
    });
  }

  private async setNewPassword(userId: string, newPassword: string) {
    const newPasswordHash = await hash(newPassword, 10);

    await this.userRepository.update(
      {
        _id: userId,
      },
      {
        $set: {
          password: newPasswordHash,
        },
      }
    );
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class UpdatePassword

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/billing/e2e/checkout-session-completed.e2e-ee.ts
Tamao: 6856 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiServiceLevelEnum, StripeBillingIntervalEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';

const mockCheckoutSessionCompletedEvent = {
  type: 'checkout.session.completed',
  data: {
    object: {
      id: 'cs_id_1',
      object: 'checkout.session',
      amount_subtotal: 270000,
      amount_total: 270000,
      billing_address_collection: 'auto',
      cancel_url: 'http://localhost:4200/manage-account/billing?result=canceled',
      created: 1728552369,
      currency: 'usd',
      customer: 'cus_R0JFO85Q8ThjEZ',
      expires_at: 1728638769,
      metadata: {
        apiServiceLevel: 'business',
        billingInterval: 'year',
      },
      mode: 'subscription',
      payment_method_collection: 'always',
      payment_method_types: ['card'],
      payment_status: 'paid',
      status: 'complete',
      subscription: 'current_subscription_id',
      success_url: 'http://localhost:4200/manage-account/billing?result=success&session_id={CHECKOUT_SESSION_ID}',
      tax_id_collection: {
        enabled: true,
        required: 'never',
      },
    },
  },
};

const verifyCustomerMock = {
  customer: {
    id: 'customer_id',
    deleted: false,
    metadata: {
      organizationId: 'organization_id',
    },
    subscriptions: {
      data: [{ id: 'subscription_id' }],
    },
  },
  organization: { _id: 'organization_id', apiServiceLevel: ApiServiceLevelEnum.FREE },
  subscriptions: [
    {
      id: 'subscription_id',
      items: {
        data: [
          {
            id: 'item_id_usage_notifications',
            plan: {
              interval: StripeBillingIntervalEnum.MONTH,
            },
            price: {
              recurring: {
                usage_type: 'licensed',
              },
              product: {
                metadata: {
                  apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
                },
              },
            },
          },
          {
            id: 'item_id_flat',
            plan: {
              interval: StripeBillingIntervalEnum.MONTH,
            },
            price: {
              recurring: {
                usage_type: 'licensed',
              },
              product: {
                metadata: {
                  apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
                },
              },
            },
          },
        ],
      },
    },
    {
      id: 'current_subscription_id',
      default_payment_method: 'payment_method_id',
      items: {
        data: [
          {
            id: 'item_id_usage_notifications',
            plan: {
              interval: 'test',
            },
            price: {
              recurring: {
                usage_type: 'licensed',
              },
              product: {
                metadata: {
                  apiServiceLevel: 'test',
                },
              },
            },
          },
          {
            id: 'item_id_flat',
            plan: {
              interval: 'test',
            },
            price: {
              recurring: {
                usage_type: 'licensed',
              },
              product: {
                metadata: {
                  apiServiceLevel: 'test',
                },
              },
            },
          },
        ],
      },
    },
  ],
};

const getPricesMock = {
  metered: [{ id: 'price_id' }],
  licensed: [{ id: 'price_id' }],
};

describe('webhook event - checkout.session.completed #novu-v2', () => {
  const stripeStub = {
    customers: {
      update: sinon.stub(),
    },
    subscriptions: {
      create: sinon.stub(),
      retrieve: sinon.stub(),
      cancel: sinon.stub(),
    },
  };

  const eeBilling = require('@novu/ee-billing');
  if (!eeBilling) {
    throw new Error('ee-billing does not exist');
  }

  const { CheckoutSessionCompletedHandler, VerifyCustomer, GetPrices } = eeBilling;

  let verifyCustomerStub: sinon.SinonStub;
  let getPricesStub: sinon.SinonStub;
  const analyticsServiceStub = {
    track: sinon.stub(),
  };
  const invalidateCacheServiceStub = {
    invalidateByKey: sinon.stub(),
  };

  beforeEach(() => {
    verifyCustomerStub = sinon.stub(VerifyCustomer.prototype, 'execute').resolves(verifyCustomerMock);
    getPricesStub = sinon.stub(GetPrices.prototype, 'execute').resolves(getPricesMock);
  });

  afterEach(() => {
    sinon.reset();
  });

  const createHandler = () => {
    const handler = new CheckoutSessionCompletedHandler(
      stripeStub,
      { execute: verifyCustomerStub },
      analyticsServiceStub,
      invalidateCacheServiceStub,
      { execute: getPricesStub }
    );

    return handler;
  };

  it('should exit early with unknown organization', async () => {
    verifyCustomerStub.resolves({
      organization: null,
      customer: { id: 'customer_id', metadata: { organizationId: 'org_id' } },
    });

    const handler = createHandler();
    await handler.handle(mockCheckoutSessionCompletedEvent);

    expect(analyticsServiceStub.track.called).to.be.false;
  });

  it('should cancel existing subscriptions except the one that triggered the event', async () => {
    const handler = createHandler();
    await handler.handle(mockCheckoutSessionCompletedEvent);

    expect(stripeStub.subscriptions.cancel.callCount).to.equal(1);
    expect(stripeStub.subscriptions.cancel.lastCall.args[0]).to.equal('subscription_id');
  });

  it('should update the customer with the default payment method', async () => {
    const handler = createHandler();
    await handler.handle(mockCheckoutSessionCompletedEvent);

    expect(stripeStub.customers.update.lastCall.args[1]).to.deep.equal({
      invoice_settings: {
        default_payment_method: 'payment_method_id',
      },
    });
  });

  it('should create a linked monthly metered subscription if yearly licensed subscription was bought', async () => {
    const mockCheckoutSessionCompletedEventYearly = {
      ...mockCheckoutSessionCompletedEvent,
      data: {
        object: {
          ...mockCheckoutSessionCompletedEvent.data.object,
          metadata: {
            billingInterval: StripeBillingIntervalEnum.YEAR,
            apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
          },
        },
      },
    };

    const handler = createHandler();
    await handler.handle(mockCheckoutSessionCompletedEventYearly);

    expect(stripeStub.subscriptions.create.lastCall.args[0]).to.deep.equal({
      customer: 'customer_id',
      items: [{ price: 'price_id' }],
      metadata: {
        parentSubscriptionId: 'current_subscription_id',
      },
    });
  });

  it('should invalidate the subscription cache', async () => {
    const handler = createHandler();
    await handler.handle(mockCheckoutSessionCompletedEvent);

    expect(invalidateCacheServiceStub.invalidateByKey.called).to.be.true;
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - getPricesMock({
  metered: [{ id: 'price_id' }],
  licensed: [{ id: 'price_id' }],
};

describe('webhook event - c...)
 - invalidateCacheServiceStub({
    invalidateByKey: sinon.stub(),
  };

  beforeEach(())
 - getPricesStub(sinon.stub(GetPrices.prototype, 'execute').resolves(getPricesMock);
  });

  afterEach(())
 - createHandler())
 - handler(new CheckoutSessionCompletedHandler(
      stripeStub,
      { execute: verifyCustomerStub },
      ...)
 - handler(createHandler();
    await handler.handle(mockCheckoutSessionCompletedEvent);

    expect(analyticsS...)
 - handler(createHandler();
    await handler.handle(mockCheckoutSessionCompletedEvent);

    expect(stripeStub...)
 - handler(createHandler();
    await handler.handle(mockCheckoutSessionCompletedEvent);

    expect(stripeStub...)
 - handler(createHandler();
    await handler.handle(mockCheckoutSessionCompletedEventYearly);

    expect(stri...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/billing/e2e/create-checkout-session.e2e-ee.ts
Tamao: 3349 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiServiceLevelEnum, StripeBillingIntervalEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';

const dashboardOrigin = process.env.FRONT_BASE_URL;
const checkoutSessionCreateParamsMock = {
  mode: 'subscription',
  customer: 'customer_id',
  payment_method_types: ['card'],
  tax_id_collection: {
    enabled: true,
  },
  automatic_tax: {
    enabled: true,
  },
  billing_address_collection: 'auto',
  customer_update: {
    name: 'auto',
    address: 'auto',
  },
  success_url: `${dashboardOrigin}/manage-account/billing?result=success&session_id={CHECKOUT_SESSION_ID}`,
  cancel_url: `${dashboardOrigin}/manage-account/billing?result=canceled`,
};

describe('Create checkout session #novu-v2', async () => {
  if (!require('@novu/ee-billing').CreateCheckoutSession) {
    throw new Error("CreateCheckoutSession doesn't exist");
  }

  const { CreateCheckoutSession } = require('@novu/ee-billing');

  const getOrCreateCustomer = {
    execute: () => Promise.resolve({ id: 'customer_id' }),
  };
  const getPrices = {
    execute: () =>
      Promise.resolve({
        licensed: [{ id: 'licensed_price_id_1' }],
        metered: [{ id: 'metered_price_id_1' }],
      }),
  };

  const stripeStub = {
    checkout: {
      sessions: {
        create: () => {},
      },
    },
  };
  let checkoutCreateStub: sinon.SinonStub;

  beforeEach(() => {
    checkoutCreateStub = sinon.stub(stripeStub.checkout.sessions, 'create').resolves({ url: 'url' });
  });

  afterEach(() => {
    checkoutCreateStub.reset();
  });

  it('Create checkout session with 1 subscription containing 1 licensed item and 1 metered item for monthly billing interval', async () => {
    const usecase = new CreateCheckoutSession(stripeStub, getOrCreateCustomer, getPrices);

    const result = await usecase.execute({
      organizationId: 'organization_id',
      userId: 'user_id',
      billingInterval: StripeBillingIntervalEnum.MONTH,
      apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
      origin: dashboardOrigin,
    });

    expect(checkoutCreateStub.lastCall.args.at(0)).to.deep.equal({
      ...checkoutSessionCreateParamsMock,
      line_items: [{ price: 'licensed_price_id_1', quantity: 1 }, { price: 'metered_price_id_1' }],
      metadata: {
        apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
        billingInterval: StripeBillingIntervalEnum.MONTH,
      },
    });

    expect(result).to.deep.equal({ stripeCheckoutUrl: 'url' });
  });

  it('Create checkout session with 1 subscription containing 1 licensed item for annual billing interval', async () => {
    const usecase = new CreateCheckoutSession(stripeStub, getOrCreateCustomer, getPrices);

    const result = await usecase.execute({
      organizationId: 'organization_id',
      userId: 'user_id',
      billingInterval: StripeBillingIntervalEnum.YEAR,
      apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
      origin: dashboardOrigin,
    });

    expect(checkoutCreateStub.lastCall.args.at(0)).to.deep.equal({
      ...checkoutSessionCreateParamsMock,
      line_items: [{ price: 'licensed_price_id_1', quantity: 1 }],
      metadata: {
        apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
        billingInterval: StripeBillingIntervalEnum.YEAR,
      },
    });

    expect(result).to.deep.equal({ stripeCheckoutUrl: 'url' });
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - result(canceled`,
};

describe('Create checkout session #novu-v2', async ())
 - getOrCreateCustomer({
    execute: ())
 - getPrices({
    execute: ())
 - stripeStub({
    checkout: {
      sessions: {
        create: ())
 - checkoutCreateStub(sinon.stub(stripeStub.checkout.sessions, 'create').resolves({ url: 'url' });
  });

  afterEach(())
 - result(await usecase.execute({
      organizationId: 'organization_id',
      userId: 'user_id',
      bill...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/billing/e2e/create-subscription.e2e-ee.ts
Tamao: 9646 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiServiceLevelEnum, StripeBillingIntervalEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';

const { StripeSubscriptionStatusEnum, StripeUsageTypeEnum } = require('@novu/ee-billing/src/stripe/types');

describe('CreateSubscription #novu-v2', () => {
  const eeBilling = require('@novu/ee-billing');
  if (!eeBilling) {
    throw new Error('ee-billing does not exist');
  }

  const { CreateSubscription, GetPrices, UpdateServiceLevel, CreateSubscriptionCommand } = eeBilling;

  const stripeStub = {
    subscriptions: {
      create: () => {},
    },
  };
  let createSubscriptionStub: sinon.SinonStub;
  let getPricesStub: sinon.SinonStub;
  let updateServiceLevelStub: sinon.SinonStub;

  const mockSubscription = {
    id: 'subscription_id',
    status: StripeSubscriptionStatusEnum.ACTIVE,
    billing_cycle_anchor: 123456789,
    items: {
      data: [
        {
          id: 'item_id_usage_notifications',
          price: { recurring: { usage_type: StripeUsageTypeEnum.METERED } },
        },
        { id: 'item_id_flat', price: { recurring: { usage_type: StripeUsageTypeEnum.LICENSED } } },
      ],
    },
  };

  const mockCustomerBase = {
    id: 'customer_id',
    deleted: false,
    metadata: {
      organizationId: 'organization_id',
    },
    subscriptions: {
      data: [mockSubscription],
    },
  };

  beforeEach(() => {
    getPricesStub = sinon.stub(GetPrices.prototype, 'execute').resolves({
      metered: [
        {
          id: 'price_id_notifications',
          recurring: { usage_type: StripeUsageTypeEnum.METERED },
        },
      ],
      licensed: [
        {
          id: 'price_id_flat',
          recurring: { usage_type: StripeUsageTypeEnum.LICENSED },
        },
      ],
    } as any);
    updateServiceLevelStub = sinon.stub(UpdateServiceLevel.prototype, 'execute').resolves({});
    createSubscriptionStub = sinon.stub(stripeStub.subscriptions, 'create').resolves(mockSubscription);
  });

  afterEach(() => {
    getPricesStub.reset();
    updateServiceLevelStub.reset();
    createSubscriptionStub.reset();
  });

  const createUseCase = () => {
    const useCase = new CreateSubscription(
      stripeStub as any,
      { execute: updateServiceLevelStub } as any,
      { execute: getPricesStub } as any
    );

    return useCase;
  };

  describe('Subscription creation', () => {
    describe('Monthly Billing Interval', () => {
      it('should create a single subscription with monthly prices', async () => {
        const useCase = createUseCase();

        const mockCustomerNoSubscriptions = {
          ...mockCustomerBase,
          subscriptions: { data: [] },
        };

        await useCase.execute(
          CreateSubscriptionCommand.create({
            customer: mockCustomerNoSubscriptions as any,
            apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
            billingInterval: StripeBillingIntervalEnum.MONTH,
          })
        );

        expect(createSubscriptionStub.lastCall.args[0]).to.deep.equal({
          customer: 'customer_id',
          items: [
            {
              price: 'price_id_notifications',
            },
            {
              price: 'price_id_flat',
            },
          ],
        });

        // Verify that idempotency key is passed in the second argument
        expect(createSubscriptionStub.lastCall.args[1]).to.have.property('idempotencyKey');
        expect(createSubscriptionStub.lastCall.args[1].idempotencyKey).to.equal(
          'subscription-create-organization_id-business-month-combined'
        );
      });

      it('should set the trial configuration for the subscription when trial days are provided', async () => {
        const useCase = createUseCase();

        const mockCustomerNoSubscriptions = {
          ...mockCustomerBase,
          subscriptions: { data: [] },
        };

        await useCase.execute(
          CreateSubscriptionCommand.create({
            customer: mockCustomerNoSubscriptions as any,
            apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
            billingInterval: StripeBillingIntervalEnum.MONTH,
            trialPeriodDays: 10,
          })
        );

        expect(createSubscriptionStub.lastCall.args[0]).to.deep.equal({
          customer: 'customer_id',
          trial_period_days: 10,
          trial_settings: {
            end_behavior: {
              missing_payment_method: 'cancel',
            },
          },
          items: [
            {
              price: 'price_id_notifications',
            },
            {
              price: 'price_id_flat',
            },
          ],
        });

        // Verify that idempotency key is passed
        expect(createSubscriptionStub.lastCall.args[1]).to.have.property('idempotencyKey');
      });
    });

    describe('Annual Billing Interval', () => {
      it('should create two subscriptions, one with monthly prices and one with annual prices', async () => {
        const useCase = createUseCase();

        const mockCustomerNoSubscriptions = {
          ...mockCustomerBase,
          subscriptions: { data: [] },
        };

        await useCase.execute(
          CreateSubscriptionCommand.create({
            customer: mockCustomerNoSubscriptions as any,
            apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
            billingInterval: StripeBillingIntervalEnum.YEAR,
          })
        );

        expect(createSubscriptionStub.callCount).to.equal(2);

        // Check first call (licensed subscription)
        expect(createSubscriptionStub.getCalls()[0].args[0]).to.deep.equal({
          customer: 'customer_id',
          items: [
            {
              price: 'price_id_flat',
            },
          ],
        });
        expect(createSubscriptionStub.getCalls()[0].args[1]).to.have.property('idempotencyKey');
        expect(createSubscriptionStub.getCalls()[0].args[1].idempotencyKey).to.equal(
          'subscription-create-organization_id-business-year-licensed'
        );

        // Check second call (metered subscription)
        expect(createSubscriptionStub.getCalls()[1].args[0]).to.deep.equal({
          customer: 'customer_id',
          items: [
            {
              price: 'price_id_notifications',
            },
          ],
        });
        expect(createSubscriptionStub.getCalls()[1].args[1]).to.have.property('idempotencyKey');
        expect(createSubscriptionStub.getCalls()[1].args[1].idempotencyKey).to.equal(
          'subscription-create-organization_id-business-year-metered'
        );
      });

      it('should set the trial configuration for both subscriptions when trial days are provided', async () => {
        const useCase = createUseCase();

        const mockCustomerNoSubscriptions = {
          ...mockCustomerBase,
          subscriptions: { data: [] },
        };

        await useCase.execute(
          CreateSubscriptionCommand.create({
            customer: mockCustomerNoSubscriptions as any,
            apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
            billingInterval: StripeBillingIntervalEnum.YEAR,
            trialPeriodDays: 10,
          })
        );

        expect(createSubscriptionStub.callCount).to.equal(2);

        // Check first call (licensed subscription)
        expect(createSubscriptionStub.getCalls()[0].args[0]).to.deep.equal({
          customer: 'customer_id',
          trial_period_days: 10,
          trial_settings: {
            end_behavior: {
              missing_payment_method: 'cancel',
            },
          },
          items: [
            {
              price: 'price_id_flat',
            },
          ],
        });
        expect(createSubscriptionStub.getCalls()[0].args[1]).to.have.property('idempotencyKey');

        // Check second call (metered subscription)
        expect(createSubscriptionStub.getCalls()[1].args[0]).to.deep.equal({
          customer: 'customer_id',
          trial_period_days: 10,
          trial_settings: {
            end_behavior: {
              missing_payment_method: 'cancel',
            },
          },
          items: [
            {
              price: 'price_id_notifications',
            },
          ],
        });
        expect(createSubscriptionStub.getCalls()[1].args[1]).to.have.property('idempotencyKey');
      });
    });

    it('should throw an error if the customer has more than two subscription', async () => {
      const useCase = createUseCase();
      const customer = { ...mockCustomerBase, subscriptions: { data: [{}, {}, {}] } };

      try {
        await useCase.execute(
          CreateSubscriptionCommand.create({
            customer: customer as any,
            apiServiceLevel: ApiServiceLevelEnum.FREE,
            billingInterval: StripeBillingIntervalEnum.MONTH,
          })
        );
        throw new Error('Should not reach here');
      } catch (e) {
        expect(e.message).to.equal(`Customer with id: 'customer_id' has more than two subscriptions`);
      }
    });

    it('should throw an error if the billing interval is not supported', async () => {
      const useCase = createUseCase();
      const customer = { ...mockCustomerBase, subscriptions: { data: [{}, {}] } };

      try {
        await useCase.execute(
          CreateSubscriptionCommand.create({
            customer: customer as any,
            apiServiceLevel: ApiServiceLevelEnum.FREE,
            billingInterval: 'invalid',
          })
        );
        throw new Error('Should not reach here');
      } catch (e) {
        expect(e.message).to.equal(`Invalid billing interval: 'invalid'`);
      }
    });
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - stripeStub({
    subscriptions: {
      create: ())
 - mockCustomerBase({
    id: 'customer_id',
    deleted: false,
    metadata: {
      organizationId: 'organization_id'...)
 - createSubscriptionStub(sinon.stub(stripeStub.subscriptions, 'create').resolves(mockSubscription);
  });

  afterEach(())
 - createUseCase())
 - useCase(new CreateSubscription(
      stripeStub as any,
      { execute: updateServiceLevelStub } as any,
 ...)
 - mockCustomerNoSubscriptions({
          ...mockCustomerBase,
          subscriptions: { data: [] },
        };

        await us...)
 - mockCustomerNoSubscriptions({
          ...mockCustomerBase,
          subscriptions: { data: [] },
        };

        await us...)
 - mockCustomerNoSubscriptions({
          ...mockCustomerBase,
          subscriptions: { data: [] },
        };

        await us...)
 - mockCustomerNoSubscriptions({
          ...mockCustomerBase,
          subscriptions: { data: [] },
        };

        await us...)
 - customer({ ...mockCustomerBase, subscriptions: { data: [{}, {}, {}] } };

      try {
        await useCase.e...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/billing/e2e/create-usage-records.e2e-ee.ts
Tamao: 8752 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

// biome-ignore lint/style/noRestrictedImports: <explanation>
import { Logger } from '@nestjs/common';
import { ApiServiceLevelEnum, StripeBillingIntervalEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';

const { StripeUsageTypeEnum } = require('@novu/ee-billing/src/stripe/types');

const mockMonthlyBusinessSubscription = {
  id: 'subscription_id',
  items: {
    data: [
      {
        id: 'item_id_usage_notifications',
        price: { lookup_key: 'business_usage_notifications', recurring: { usage_type: StripeUsageTypeEnum.METERED } },
      },
      {
        id: 'item_id_flat',
        price: { lookup_key: 'business_flat_monthly', recurring: { usage_type: StripeUsageTypeEnum.LICENSED } },
      },
    ],
  },
};

describe('CreateUsageRecords #novu-v2', () => {
  const eeBilling = require('@novu/ee-billing');
  if (!eeBilling) {
    throw new Error('ee-billing does not exist');
  }
  const { CreateUsageRecords, CreateUsageRecordsCommand } = eeBilling;

  const stripeStub = {
    subscriptionItems: {
      createUsageRecord: () => {},
    },
  };
  const analyticsServiceStub = {
    track: sinon.stub(),
  };
  const createSubscriptionUsecase = { execute: () => Promise.resolve() };
  const getOrCreateCustomerUsecase = { execute: () => Promise.resolve() };
  const getPlatformNotificationUsageUsecase = { execute: () => Promise.resolve() };
  let createUsageRecordStub: sinon.SinonStub;
  let getPlatformNotificationUsageStub: sinon.SinonStub;
  let createSubscriptionStub: sinon.SinonStub;
  let getOrCreateCustomerStub: sinon.SinonStub;

  beforeEach(() => {
    createUsageRecordStub = sinon.stub(stripeStub.subscriptionItems, 'createUsageRecord').resolves({
      id: 'usage_record_id',
    });

    getPlatformNotificationUsageStub = sinon.stub(getPlatformNotificationUsageUsecase, 'execute').resolves([
      {
        _id: 'organization_id',
        apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
        notificationsCount: 100,
      },
    ] as any);
    createSubscriptionStub = sinon.stub(createSubscriptionUsecase, 'execute').resolves({
      id: 'subscription_id',
    } as any);
    getOrCreateCustomerStub = sinon.stub(getOrCreateCustomerUsecase, 'execute').resolves({
      id: 'customer_id',
      deleted: false,
      metadata: {
        organizationId: 'organization_id',
      },
      subscriptions: {
        data: [mockMonthlyBusinessSubscription],
      },
    } as any);
  });

  afterEach(() => {
    createUsageRecordStub.reset();
    getOrCreateCustomerStub.reset();
    createSubscriptionStub.reset();
    getPlatformNotificationUsageStub.reset();
    analyticsServiceStub.track.reset();
  });

  const createUseCase = () => {
    const useCase = new CreateUsageRecords(
      stripeStub,
      getOrCreateCustomerUsecase,
      createSubscriptionUsecase,
      getPlatformNotificationUsageUsecase,
      analyticsServiceStub
    );

    return useCase;
  };

  it('should fetch the platform usage records with usage dates between the start and end date of the previous day', async () => {
    const mockDate = new Date('2021-01-15T00:01:00Z');
    const useCase = createUseCase();

    await useCase.execute(
      CreateUsageRecordsCommand.create({
        startDate: mockDate,
      })
    );

    const expectedStartDate = new Date('2021-01-14T00:00:00Z');
    const expectedEndDate = new Date('2021-01-14T23:59:59.999Z');

    expect(getPlatformNotificationUsageStub.lastCall.args).to.deep.equal([
      {
        startDate: expectedStartDate,
        endDate: expectedEndDate,
      },
    ]);
  });

  it('should create a free-tier subscription if the customer has no subscriptions', async () => {
    const mockNoSubscriptionsCustomer = {
      id: 'customer_id',
      subscriptions: { data: [] },
    };
    getOrCreateCustomerStub.resolves(mockNoSubscriptionsCustomer);
    const useCase = createUseCase();

    await useCase.execute(
      CreateUsageRecordsCommand.create({
        startDate: new Date(),
      })
    );

    expect(createSubscriptionStub.callCount).to.equal(1); // this is failing without the promise above
    expect(createSubscriptionStub.lastCall.args).to.deep.equal([
      {
        customer: mockNoSubscriptionsCustomer,
        apiServiceLevel: ApiServiceLevelEnum.FREE,
        billingInterval: StripeBillingIntervalEnum.MONTH,
      },
    ]);
  });

  it('should set the usage timestamp to the subscription current period start if the subscription is new', async () => {
    const mockSubscriptionStartDate = new Date('2021-02-01T00:00:00Z');
    const mockSubscriptionCurrentPeriodStart = mockSubscriptionStartDate.getTime() / 1000;
    const mockUsageStartDate = new Date('2021-01-15T00:00:00Z');
    getOrCreateCustomerStub.resolves({
      subscriptions: {
        data: [
          {
            ...mockMonthlyBusinessSubscription,
            current_period_start: mockSubscriptionCurrentPeriodStart,
          },
        ],
      },
    });
    const useCase = createUseCase();

    await useCase.execute(
      CreateUsageRecordsCommand.create({
        startDate: mockUsageStartDate,
      })
    );

    expect(createUsageRecordStub.lastCall.args[1].timestamp).to.equal(mockSubscriptionCurrentPeriodStart);
  });

  it('should set the usage timestamp to the usage start date if the subscription is not new', async () => {
    const mockSubscriptionStartDate = new Date('2021-01-01T00:00:00Z');
    const mockSubscriptionCreated = mockSubscriptionStartDate.getTime() / 1000;
    const mockCurrentDate = new Date('2021-01-15T12:00:00Z');
    getOrCreateCustomerStub.resolves({
      subscriptions: {
        data: [
          {
            ...mockMonthlyBusinessSubscription,
            current_period_start: mockSubscriptionCreated,
          },
        ],
      },
    });
    const useCase = createUseCase();

    const expectedTimestamp = new Date('2021-01-15T00:00:00Z').getTime() / 1000;

    await useCase.execute(
      CreateUsageRecordsCommand.create({
        startDate: mockCurrentDate,
      })
    );

    expect(createUsageRecordStub.lastCall.args[1].timestamp).to.equal(expectedTimestamp);
  });

  it('should use the usage subscription item to create the usage record', async () => {
    const useCase = createUseCase();

    await useCase.execute(
      CreateUsageRecordsCommand.create({
        startDate: new Date(),
      })
    );

    expect(createUsageRecordStub.lastCall.args[0]).to.equal('item_id_usage_notifications');
  });

  it('should log an error if the usage subscription item is not found on the subscription', async () => {
    const logStub = sinon.spy(Logger, 'error');
    getPlatformNotificationUsageStub.resolves([
      {
        _id: 'organization_id_1',
        apiServiceLevel: ApiServiceLevelEnum.FREE,
        notificationsCount: 100,
      },
    ]);
    const mockNoMeteredSubscription = {
      id: 'subscription_id',
      items: {
        data: [
          {
            id: 'item_id_flat',
            price: { lookup_key: 'business_flat_monthly', recurring: { usage_type: StripeUsageTypeEnum.LICENSED } },
          },
        ],
      },
    };
    getOrCreateCustomerStub.resolves({
      subscriptions: {
        data: [mockNoMeteredSubscription],
      },
    });
    const useCase = createUseCase();

    await useCase.execute(
      CreateUsageRecordsCommand.create({
        startDate: new Date(),
      })
    );

    expect(logStub.lastCall.args[0].message).to.equal(
      "No metered subscription found for organizationId: 'organization_id_1'"
    );

    logStub.restore();
  });

  it('should create a usage record for each organization', async () => {
    const mockUsageStartDate = new Date('2021-01-15T12:00:00Z');
    getPlatformNotificationUsageStub.resolves([
      {
        _id: 'organization_id_1',
        apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
        notificationsCount: 100,
      },
      {
        _id: 'organization_id_2',
        apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
        notificationsCount: 200,
      },
    ]);
    const useCase = createUseCase();

    await useCase.execute(
      CreateUsageRecordsCommand.create({
        startDate: mockUsageStartDate,
      })
    );

    const expectedUsageTimestamp = new Date('2021-01-15T00:00:00Z').getTime() / 1000;

    expect(createUsageRecordStub.getCalls().map(({ args }) => args)).to.deep.equal([
      [
        'item_id_usage_notifications',
        {
          quantity: 100,
          timestamp: expectedUsageTimestamp,
          action: 'set',
        },
      ],
      [
        'item_id_usage_notifications',
        {
          quantity: 200,
          timestamp: expectedUsageTimestamp,
          action: 'set',
        },
      ],
    ]);
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockMonthlyBusinessSubscription({
  id: 'subscription_id',
  items: {
    data: [
      {
        id: 'item_id_usage_notifications',...)
 - stripeStub({
    subscriptionItems: {
      createUsageRecord: ())
 - createSubscriptionUsecase({ execute: ())
 - getOrCreateCustomerUsecase({ execute: ())
 - getPlatformNotificationUsageUsecase({ execute: ())
 - getOrCreateCustomerStub(sinon.stub(getOrCreateCustomerUsecase, 'execute').resolves({
      id: 'customer_id',
      deleted:...)
 - createUseCase())
 - useCase(new CreateUsageRecords(
      stripeStub,
      getOrCreateCustomerUsecase,
      createSubscription...)
 - expectedEndDate(new Date('2021-01-14T23:59:59.999Z');

    expect(getPlatformNotificationUsageStub.lastCall.args).to...)
 - useCase(createUseCase();

    await useCase.execute(
      CreateUsageRecordsCommand.create({
        startD...)
 - useCase(createUseCase();

    await useCase.execute(
      CreateUsageRecordsCommand.create({
        startD...)
 - expectedTimestamp(new Date('2021-01-15T00:00:00Z').getTime() / 1000;

    await useCase.execute(
      CreateUsageReco...)
 - useCase(createUseCase();

    await useCase.execute(
      CreateUsageRecordsCommand.create({
        startD...)
 - useCase(createUseCase();

    await useCase.execute(
      CreateUsageRecordsCommand.create({
        startD...)
 - expectedUsageTimestamp(new Date('2021-01-15T00:00:00Z').getTime() / 1000;

    expect(createUsageRecordStub.getCalls().map(...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/billing/e2e/customer-subscription-created.e2e-ee.ts
Tamao: 7694 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiServiceLevelEnum, StripeBillingIntervalEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';

const mockCustomerSubscriptionCreatedEvent = {
  data: {
    object: {
      id: 'subscription_id',
      customer: 'customer_id',
      items: {
        data: [
          {
            plan: {
              interval: StripeBillingIntervalEnum.MONTH,
            },
            price: {
              recurring: {
                usage_type: 'licensed',
              },
              product: {
                metadata: {
                  apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
                },
              },
            },
          },
        ],
      },
    },
  },
  created: 1234567890,
};

const verifyCustomerMock = {
  customer: {
    id: 'customer_id',
    deleted: false,
    metadata: {
      organizationId: 'organization_id',
    },
    subscriptions: {
      data: [{ id: 'subscription_id' }],
    },
  },
  organization: { _id: 'organization_id', apiServiceLevel: ApiServiceLevelEnum.FREE },
  subscriptions: [
    {
      id: 'subscription_id',
      items: {
        data: [
          {
            id: 'item_id_usage_notifications',
            plan: {
              interval: StripeBillingIntervalEnum.MONTH,
            },
            price: {
              recurring: {
                usage_type: 'licensed',
              },
              product: {
                metadata: {
                  apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
                },
              },
            },
          },
          {
            id: 'item_id_flat',
            plan: {
              interval: StripeBillingIntervalEnum.MONTH,
            },
            price: {
              recurring: {
                usage_type: 'licensed',
              },
              product: {
                metadata: {
                  apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
                },
              },
            },
          },
        ],
      },
    },
    {
      id: 'current_subscription_id',
      default_payment_method: 'payment_method_id',
      items: {
        data: [
          {
            id: 'item_id_usage_notifications',
            plan: {
              interval: 'test',
            },
            price: {
              recurring: {
                usage_type: 'licensed',
              },
              product: {
                metadata: {
                  apiServiceLevel: 'test',
                },
              },
            },
          },
          {
            id: 'item_id_flat',
            plan: {
              interval: 'test',
            },
            price: {
              recurring: {
                usage_type: 'licensed',
              },
              product: {
                metadata: {
                  apiServiceLevel: 'test',
                },
              },
            },
          },
        ],
      },
    },
  ],
};

describe('webhook event - customer.subscription.created #novu-v2', () => {
  const eeBilling = require('@novu/ee-billing');
  if (!eeBilling) {
    throw new Error('ee-billing does not exist');
  }

  const { CustomerSubscriptionCreatedHandler, VerifyCustomer, UpdateServiceLevel } = eeBilling;

  let verifyCustomerStub: sinon.SinonStub;
  let updateServiceLevelStub: sinon.SinonStub;

  const analyticsServiceStub = {
    track: sinon.stub(),
    upsertGroup: sinon.stub(),
  };
  const invalidateCacheServiceStub = {
    invalidateByKey: sinon.stub(),
  };

  beforeEach(() => {
    updateServiceLevelStub = sinon.stub(UpdateServiceLevel.prototype, 'execute').resolves({});
    verifyCustomerStub = sinon.stub(VerifyCustomer.prototype, 'execute').resolves(verifyCustomerMock);
  });

  afterEach(() => {
    sinon.reset();
  });

  const createHandler = () => {
    const handler = new CustomerSubscriptionCreatedHandler(
      { execute: verifyCustomerStub },
      analyticsServiceStub,
      invalidateCacheServiceStub,
      { execute: updateServiceLevelStub }
    );

    return handler;
  };

  it('should exit early with unknown organization', async () => {
    verifyCustomerStub.resolves({
      organization: null,
      customer: { id: 'customer_id', metadata: { organizationId: 'org_id' } },
    });

    const handler = createHandler();
    await handler.handle(mockCustomerSubscriptionCreatedEvent);

    expect(updateServiceLevelStub.called).to.be.false;
  });

  it('should handle event with known organization and licensed subscription', async () => {
    const handler = createHandler();
    await handler.handle(mockCustomerSubscriptionCreatedEvent);

    expect(updateServiceLevelStub.lastCall.args.at(0)).to.deep.equal({
      organizationId: 'organization_id',
      apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
      isTrial: false,
    });
  });

  it('should invalidate the subscription cache with known organization and licensed subscription', async () => {
    const handler = createHandler();
    await handler.handle(mockCustomerSubscriptionCreatedEvent);

    expect(invalidateCacheServiceStub.invalidateByKey.called).to.be.true;
  });

  it('should exit early with known organization and metered subscription', async () => {
    const event = {
      data: {
        object: {
          ...mockCustomerSubscriptionCreatedEvent.data.object,
          items: {
            data: [
              {
                plan: {
                  interval: StripeBillingIntervalEnum.MONTH,
                },
                price: {
                  recurring: {
                    usage_type: 'metered',
                  },
                  product: {
                    metadata: {
                      apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
                    },
                  },
                },
              },
            ],
          },
        },
      },
      created: 1234567890,
    };

    const handler = createHandler();
    await handler.handle(event);

    expect(updateServiceLevelStub.called).to.be.true;
  });

  it('should exit early with known organization and invalid apiServiceLevel', async () => {
    const event = {
      data: {
        object: {
          ...mockCustomerSubscriptionCreatedEvent.data.object,
          items: {
            id: 'item_id_usage_notifications',
            data: [
              {
                plan: {
                  interval: StripeBillingIntervalEnum.MONTH,
                },
                price: {
                  recurring: {
                    usage_type: 'licensed',
                  },
                  product: {
                    metadata: {
                      apiServiceLevel: 'invalid',
                    },
                  },
                },
              },
            ],
          },
        },
      },
      created: 1234567890,
    };

    verifyCustomerStub.resolves({
      ...verifyCustomerMock,
      subscriptions: [
        {
          id: 'subscription_id',
          items: {
            data: [
              {
                id: 'item_id_usage_notifications',
                plan: {
                  interval: StripeBillingIntervalEnum.MONTH,
                },
                price: {
                  recurring: {
                    usage_type: 'licensed',
                  },
                  product: {
                    metadata: {
                      apiServiceLevel: 'invalid',
                    },
                  },
                },
              },
            ],
          },
        },
      ],
    });

    const handler = createHandler();
    await handler.handle(event);

    expect(updateServiceLevelStub.called).to.be.false;
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - verifyCustomerMock({
  customer: {
    id: 'customer_id',
    deleted: false,
    metadata: {
      organizationId: 'or...)
 - invalidateCacheServiceStub({
    invalidateByKey: sinon.stub(),
  };

  beforeEach(())
 - verifyCustomerStub(sinon.stub(VerifyCustomer.prototype, 'execute').resolves(verifyCustomerMock);
  });

  afterEach(())
 - createHandler())
 - handler(new CustomerSubscriptionCreatedHandler(
      { execute: verifyCustomerStub },
      analyticsServic...)
 - handler(createHandler();
    await handler.handle(mockCustomerSubscriptionCreatedEvent);

    expect(updateS...)
 - handler(createHandler();
    await handler.handle(mockCustomerSubscriptionCreatedEvent);

    expect(updateS...)
 - handler(createHandler();
    await handler.handle(mockCustomerSubscriptionCreatedEvent);

    expect(invalid...)
 - handler(createHandler();
    await handler.handle(event);

    expect(updateServiceLevelStub.called).to.be.t...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/billing/e2e/customer-subscription-deleted.e2e-ee.ts
Tamao: 12907 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiServiceLevelEnum, StripeBillingIntervalEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';

const verifyCustomerMock = {
  customer: {
    id: 'customer_id',
    deleted: false,
    metadata: {
      organizationId: 'organization_id',
    },
    subscriptions: {
      data: [{ id: 'subscription_id' }],
    },
  },
  organization: { _id: 'organization_id', apiServiceLevel: ApiServiceLevelEnum.BUSINESS },
  subscriptions: [
    {
      id: 'subscription_id',
      items: {
        data: [
          {
            id: 'item_id_usage_notifications',
            plan: {
              interval: StripeBillingIntervalEnum.MONTH,
            },
            price: {
              recurring: {
                usage_type: 'licensed',
              },
              product: {
                metadata: {
                  apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
                },
              },
            },
          },
          {
            id: 'item_id_flat',
            plan: {
              interval: StripeBillingIntervalEnum.MONTH,
            },
            price: {
              recurring: {
                usage_type: 'licensed',
              },
              product: {
                metadata: {
                  apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
                },
              },
            },
          },
        ],
      },
    },
    {
      id: 'current_subscription_id',
      default_payment_method: 'payment_method_id',
      items: {
        data: [
          {
            id: 'item_id_usage_notifications',
            plan: {
              interval: 'test',
            },
            price: {
              recurring: {
                usage_type: 'licensed',
              },
              product: {
                metadata: {
                  apiServiceLevel: 'test',
                },
              },
            },
          },
          {
            id: 'item_id_flat',
            plan: {
              interval: 'test',
            },
            price: {
              recurring: {
                usage_type: 'licensed',
              },
              product: {
                metadata: {
                  apiServiceLevel: 'test',
                },
              },
            },
          },
        ],
      },
    },
  ],
};

describe.skip('webhook event - customer.subscription.deleted #novu-v2', () => {
  const eeBilling = require('@novu/ee-billing');
  if (!eeBilling) {
    throw new Error('ee-billing does not exist');
  }

  const {
    CustomerSubscriptionDeletedHandler,
    VerifyCustomer,
    UpdateServiceLevel,
    UpdateServiceLevelCommand,
    CreateSubscription,
  } = eeBilling;

  const stripeStub = {
    customers: {
      update: sinon.stub(),
    },
    subscriptions: {
      create: sinon.stub(),
      retrieve: sinon.stub(),
      cancel: sinon.stub(),
    },
  };

  let verifyCustomerStub: sinon.SinonStub;
  let updateServiceLevelStub: sinon.SinonStub;
  let createSubscriptionStub: sinon.SinonStub;

  const analyticsServiceStub = {
    track: sinon.stub(),
    upsertGroup: sinon.stub(),
  };
  const invalidateCacheServiceStub = {
    invalidateByKey: sinon.stub(),
  };

  beforeEach(() => {
    updateServiceLevelStub = sinon.stub(UpdateServiceLevel.prototype, 'execute').resolves({});
    verifyCustomerStub = sinon.stub(VerifyCustomer.prototype, 'execute').resolves({});
    createSubscriptionStub = sinon.stub(CreateSubscription.prototype, 'execute').resolves({});
  });

  afterEach(() => {
    sinon.reset();
  });

  const createHandler = () => {
    const handler = new CustomerSubscriptionDeletedHandler(
      stripeStub,
      { execute: verifyCustomerStub },
      analyticsServiceStub,
      invalidateCacheServiceStub,
      { execute: updateServiceLevelStub },
      { execute: createSubscriptionStub }
    );

    return handler;
  };

  it('should exit early with unknown organization', async () => {
    verifyCustomerStub.resolves({
      organization: null,
      customer: { id: 'customer_id', metadata: { organizationId: 'org_id' } },
    });

    const handler = createHandler();
    await handler.handle({
      data: {
        object: {},
      },
    });

    expect(updateServiceLevelStub.called).to.be.false;
  });

  it('should cancel also metered subscriptions in case of cancellation of annual licensed subscription', async () => {
    const event = {
      data: {
        object: {
          id: 'current_subscription_id',
          customer: 'customer_id',
          cancellation_details: {
            reason: 'cancellation_requested',
          },
          items: {
            data: [
              {
                price: {
                  recurring: {
                    usage_type: 'licensed',
                    interval: StripeBillingIntervalEnum.YEAR,
                  },
                  product: {
                    metadata: {
                      apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
                    },
                  },
                },
              },
            ],
          },
        },
      },
      created: 1234567890,
    };

    verifyCustomerStub.resolves({
      ...verifyCustomerMock,
      // existing subscriptions (apart from the deleted one)
      subscriptions: [
        {
          id: 'linked_metered_subscription_id',
          metadata: {
            parentSubscriptionId: 'current_subscription_id',
          },
          items: {
            data: [
              {
                price: {
                  recurring: { usage_type: 'metered', interval: 'month' },
                },
              },
            ],
          },
        },
      ],
    });

    // retrieve the deleted subscription from the event
    stripeStub.subscriptions.retrieve.resolves(event.data.object);

    const handler = createHandler();
    await handler.handle(event);

    expect(stripeStub.subscriptions.cancel.calledWith('linked_metered_subscription_id')).to.be.true;
  });

  it('should cancel also licensed subscriptions in case of cancellation of annual metered subscription', async () => {
    const event = {
      data: {
        object: {
          id: 'current_subscription_id',
          customer: 'customer_id',
          cancellation_details: {
            reason: 'cancellation_requested',
          },
          metadata: {
            parentSubscriptionId: 'licensed_subscription_id',
          },
          items: {
            data: [
              {
                price: {
                  recurring: {
                    usage_type: 'metered',
                    interval: StripeBillingIntervalEnum.MONTH,
                  },
                  product: {
                    metadata: {
                      apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
                    },
                  },
                },
              },
            ],
          },
        },
      },
      created: 1234567890,
    };

    verifyCustomerStub.resolves({
      ...verifyCustomerMock,
      // existing subscriptions (apart from the deleted one)
      subscriptions: [
        {
          id: 'licensed_subscription_id',
          items: {
            data: [
              {
                price: {
                  recurring: { usage_type: 'licensed', interval: 'year' },
                },
              },
            ],
          },
        },
      ],
    });

    // retrieve the deleted subscription from the event
    stripeStub.subscriptions.retrieve.resolves(event.data.object);

    const handler = createHandler();
    await handler.handle(event);

    expect(stripeStub.subscriptions.cancel.calledWith('licensed_subscription_id')).to.be.true;
  });

  it('should create a free subscription if there are no subscriptions left', async () => {
    const event = {
      data: {
        object: {
          id: 'current_subscription_id',
          customer: 'customer_id',
          cancellation_details: {
            reason: 'cancellation_requested',
          },
          metadata: {},
          items: {
            data: [
              {
                price: {
                  recurring: {
                    usage_type: 'metered',
                    interval: StripeBillingIntervalEnum.MONTH,
                  },
                  product: {
                    metadata: {
                      apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
                    },
                  },
                },
              },
            ],
          },
        },
      },
      created: 1234567890,
    };

    verifyCustomerStub.resolves({
      ...verifyCustomerMock,
      subscriptions: [],
    });

    // retrieve the deleted subscription from the event
    stripeStub.subscriptions.retrieve.resolves(event.data.object);

    const handler = createHandler();
    await handler.handle(event);

    expect(createSubscriptionStub.called).to.be.true;
    expect(
      updateServiceLevelStub.calledWith(
        UpdateServiceLevelCommand.create({
          organizationId: 'organization_id',
          apiServiceLevel: ApiServiceLevelEnum.FREE,
          isTrial: false,
        })
      )
    ).to.be.true;
  });

  it('should remain on the specific apiServiceLevel if there are subscriptions left', async () => {
    const event = {
      data: {
        object: {
          id: 'current_subscription_id',
          customer: 'customer_id',
          cancellation_details: {
            reason: 'cancellation_requested',
          },
          metadata: {},
          items: {
            data: [
              {
                price: {
                  recurring: {
                    usage_type: 'licensed',
                    interval: StripeBillingIntervalEnum.YEAR,
                  },
                  product: {
                    metadata: {
                      apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
                    },
                  },
                },
              },
            ],
          },
        },
      },
      created: 1234567890,
    };

    verifyCustomerStub.resolves({
      ...verifyCustomerMock,
      subscriptions: [
        {
          id: 'remaining_subscription_id',
          items: {
            data: [
              {
                price: {
                  recurring: { usage_type: 'licensed', interval: 'month' },
                  product: {
                    metadata: {
                      apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
                    },
                  },
                },
              },
            ],
          },
        },
        {
          id: 'to_be_cancelled_subscription_id',
          metadata: {
            parentSubscriptionId: 'current_subscription_id',
          },
          items: {
            data: [
              {
                price: {
                  recurring: { usage_type: 'metered', interval: 'month' },
                  product: {
                    metadata: {
                      apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
                    },
                  },
                },
              },
            ],
          },
        },
      ],
    });

    stripeStub.subscriptions.retrieve.resolves(event.data.object);

    const handler = createHandler();
    await handler.handle(event);

    expect(
      updateServiceLevelStub.calledWith(
        UpdateServiceLevelCommand.create({
          organizationId: 'organization_id',
          apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
          isTrial: false,
        })
      )
    ).to.be.true;
  });

  it('should invalidate the subscription cache with known organization and licensed subscription', async () => {
    const event = {
      data: {
        object: {
          id: 'current_subscription_id',
          customer: 'customer_id',
          cancellation_details: {
            reason: 'cancellation_requested',
          },
          metadata: {},
          items: {
            data: [
              {
                price: {
                  recurring: {
                    usage_type: 'metered',
                    interval: StripeBillingIntervalEnum.MONTH,
                  },
                  product: {
                    metadata: {
                      apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
                    },
                  },
                },
              },
            ],
          },
        },
      },
      created: 1234567890,
    };

    verifyCustomerStub.resolves({
      organization: { _id: 'organization_id', apiServiceLevel: ApiServiceLevelEnum.BUSINESS },
      customer: { id: 'customer_id', metadata: { organizationId: 'org_id' } },
      subscriptions: [],
    });

    const handler = createHandler();
    await handler.handle(event);

    expect(invalidateCacheServiceStub.invalidateByKey.called).to.be.true;
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - verifyCustomerMock({
  customer: {
    id: 'customer_id',
    deleted: false,
    metadata: {
      organizationId: 'or...)
 - invalidateCacheServiceStub({
    invalidateByKey: sinon.stub(),
  };

  beforeEach(())
 - createSubscriptionStub(sinon.stub(CreateSubscription.prototype, 'execute').resolves({});
  });

  afterEach(())
 - createHandler())
 - handler(new CustomerSubscriptionDeletedHandler(
      stripeStub,
      { execute: verifyCustomerStub },
   ...)
 - handler(createHandler();
    await handler.handle({
      data: {
        object: {},
      },
    });

    ...)
 - handler(createHandler();
    await handler.handle(event);

    expect(stripeStub.subscriptions.cancel.called...)
 - handler(createHandler();
    await handler.handle(event);

    expect(stripeStub.subscriptions.cancel.called...)
 - handler(createHandler();
    await handler.handle(event);

    expect(createSubscriptionStub.called).to.be.t...)
 - handler(createHandler();
    await handler.handle(event);

    expect(
      updateServiceLevelStub.calledWi...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/billing/e2e/get-event-resource-limit.e2e-ee.ts
Tamao: 4421 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { randomUUID } from 'node:crypto';
import { Test } from '@nestjs/testing';
import { CacheService, MockCacheService } from '@novu/application-generic';
import { GetEventResourceUsage, GetSubscription } from '@novu/ee-billing';
import { ApiServiceLevelEnum, GetSubscriptionDto } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import sinon from 'sinon';
import { AppModule } from '../../../app.module';

describe('GetEventResourceUsage #novu-v2', async () => {
  let useCase: GetEventResourceUsage;
  let session: UserSession;
  let getSubscription: GetSubscription;

  let getSubscriptionStub: sinon.SinonStub;

  const getSubscriptionResponse: GetSubscriptionDto = {
    apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
    isActive: true,
    status: 'trialing',
    hasPaymentMethod: false,
    currentPeriodStart: new Date('2021-01-01').toISOString(),
    currentPeriodEnd: new Date('2021-02-01').toISOString(),
    billingInterval: 'month',
    events: {
      current: 50,
      included: 100,
    },
    trial: {
      start: null,
      end: null,
      isActive: true,
      daysTotal: 0,
    },
    cancelAt: null,
  };

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    })
      .overrideProvider(CacheService)
      .useValue(MockCacheService.createClient())
      .compile();

    session = new UserSession();
    await session.initialize();

    useCase = moduleRef.get(GetEventResourceUsage);
    getSubscription = moduleRef.get<GetSubscription>(GetSubscription);
    getSubscriptionStub = sinon.stub(getSubscription, 'execute').resolves(getSubscriptionResponse);
  });

  afterEach(() => {
    getSubscriptionStub.restore();
  });

  describe('within the maximum evaluation duration', () => {
    it('should return a successful evaluation when events are within the limit', async () => {
      const result = await useCase.execute({
        organizationId: 'organization_id',
        environmentId: 'environment_id',
        userId: 'user_id',
      });

      expect(result).to.deep.equal({
        remaining: 50,
        limit: 100,
        success: true,
        start: 1609459200000,
        reset: 1612137600000,
        apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
      });
    });

    it('should return a failed evaluation when events are above the limit', async () => {
      getSubscriptionStub.resolves({
        ...getSubscriptionResponse,
        events: {
          current: 100,
          included: 100,
        },
      });

      const result = await useCase.execute({
        organizationId: 'organization_id',
        environmentId: 'environment_id',
        userId: 'user_id',
      });

      expect(result).to.deep.equal({
        remaining: 0,
        limit: 100,
        success: false,
        start: 1609459200000,
        reset: 1612137600000,
        apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
      });
    });
  });

  describe('fallback evaluation', () => {
    it('should return the fallback evaluation when the usage evaluation takes longer than the maximum evaluation duration', async () => {
      getSubscriptionStub.resolves(
        new Promise((resolve) => {
          setTimeout(async () => {
            resolve(getSubscriptionResponse);
          }, 1000);
        })
      );

      const result = await useCase.execute({
        organizationId: randomUUID(),
        environmentId: 'environment_id',
        userId: 'user_id',
      });

      expect(result).to.deep.equal({
        remaining: 0,
        limit: 0,
        success: true,
        reset: 0,
        start: 0,
        apiServiceLevel: ApiServiceLevelEnum.FREE,
        locked: false,
      });
    });

    it('should return the fallback evaluation when the subscription has no included events', async () => {
      getSubscriptionStub.resolves({
        ...getSubscriptionResponse,
        events: {
          current: 100,
          included: null,
        },
      });

      const result = await useCase.execute({
        organizationId: randomUUID(),
        environmentId: 'environment_id',
        userId: 'user_id',
      });

      expect(result).to.deep.equal({
        remaining: 0,
        limit: 0,
        success: true,
        reset: 0,
        start: 0,
        apiServiceLevel: ApiServiceLevelEnum.FREE,
        locked: false,
      });
    });
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - GetSubscriptionDto({
    apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
    isActive: true,
    status: 'trialing',
   ...)
 - getSubscriptionStub(sinon.stub(getSubscription, 'execute').resolves(getSubscriptionResponse);
  });

  afterEach(())
 - result(await useCase.execute({
        organizationId: 'organization_id',
        environmentId: 'environme...)
 - result(await useCase.execute({
        organizationId: 'organization_id',
        environmentId: 'environme...)
 - result(await useCase.execute({
        organizationId: randomUUID(),
        environmentId: 'environment_id...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/billing/e2e/get-platform-notification-usage.e2e-ee.ts
Tamao: 4457 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MockCacheService, PinoLogger } from '@novu/application-generic';
import { CommunityOrganizationRepository, EnvironmentRepository, NotificationRepository } from '@novu/dal';
import { ApiServiceLevelEnum, isClerkEnabled } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('GetPlatformNotificationUsage #novu-v2', () => {
  const eeBilling = require('@novu/ee-billing');
  if (!eeBilling) {
    throw new Error('ee-billing does not exist');
  }

  const { GetPlatformNotificationUsage, GetPlatformNotificationUsageCommand } = eeBilling;

  const environmentRepo = new EnvironmentRepository();
  const notificationRepo = new NotificationRepository();
  const communityOrganizationRepo = new CommunityOrganizationRepository();

  const createUseCase = () => {
    return new GetPlatformNotificationUsage(
      environmentRepo,
      notificationRepo,
      communityOrganizationRepo,
      new PinoLogger({})
    );
  };
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it(`should return an empty array when there is no recorded usage`, async () => {
    const useCase = createUseCase();

    // Create organizations without notifications
    const orgsWithoutNotificationsPromises = new Array(10).fill(null).map(async () => {
      const orgSession = new UserSession();
      await orgSession.initialize();

      return Promise.resolve(orgSession.organization._id);
    });
    await Promise.all(orgsWithoutNotificationsPromises);

    const result = await useCase.execute(
      GetPlatformNotificationUsageCommand.create({
        startDate: new Date('2021-01-01'),
        endDate: new Date('2021-01-31'),
      })
    );

    expect(result).to.deep.equal([]);
  });

  it(`should return the usage for the given date range`, async () => {
    const useCase = createUseCase();
    const mockStartDate = new Date('2021-01-01');
    const mockNotificationDate = new Date('2021-01-05');
    const mockEndDate = new Date('2021-01-31');
    const notificationCountPerIndex = 10;
    const orgCount = 10;

    const organizations: any[] = [];

    for (let index = 0; index < orgCount; index += 1) {
      const orgSession = new UserSession();
      await orgSession.initialize();

      const notificationsCount = notificationCountPerIndex * (index + 1);
      await notificationRepo.insertMany(
        new Array(notificationsCount).fill({
          _organizationId: orgSession.organization._id,
          _environmentId: orgSession.environment._id,
          createdAt: mockNotificationDate,
        })
      );
      await orgSession.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

      organizations.push({ id: orgSession.organization._id, notificationsCount });
    }

    let expectedResult = organizations.map((org) => ({
      _id: org.id.toString(),
      apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
      notificationsCount: org.notificationsCount,
    }));

    if (isClerkEnabled()) {
      // we have just one organization in Clerk - we don't create new ones on initialize()
      expectedResult = [expectedResult[expectedResult.length - 1]];
    }

    const result = await useCase.execute(
      GetPlatformNotificationUsageCommand.create({
        startDate: mockStartDate,
        endDate: mockEndDate,
      })
    );

    expect(result).to.include.deep.members(expectedResult.splice(0, 1));
  });

  it(`should return the usage for the given single organization`, async () => {
    await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

    const useCase = createUseCase();
    const notificationsCount = 110;
    const mockNotificationDate = new Date('2021-01-05');

    await notificationRepo.insertMany(
      new Array(notificationsCount).fill({
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        createdAt: mockNotificationDate,
      })
    );

    const result = await useCase.execute(
      GetPlatformNotificationUsageCommand.create({
        startDate: new Date('2021-01-01'),
        endDate: new Date('2021-01-31'),
        organizationId: session.organization._id,
      })
    );

    expect(result).to.deep.equal([
      {
        _id: session.organization._id.toString(),
        apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
        notificationsCount,
      },
    ]);
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - createUseCase())
 - session(new UserSession();
    await session.initialize();
  });

  it(`should return an empty array when th...)
 - orgsWithoutNotificationsPromises(new Array(10).fill(null).map(async ())
 - result(await useCase.execute(
      GetPlatformNotificationUsageCommand.create({
        startDate: new Dat...)
 - expectedResult(organizations.map((org))
 - result(await useCase.execute(
      GetPlatformNotificationUsageCommand.create({
        startDate: mockSta...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/billing/e2e/get-portal-link.e2e-ee.ts
Tamao: 1321 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect } from 'chai';
import sinon from 'sinon';

const dashboardOrigin = process.env.FRONT_BASE_URL;

describe('Get portal link #novu-v2', async () => {
  it('Get portal link', async () => {
    if (!require('@novu/ee-billing').GetPortalLink) {
      throw new Error("GetPortalLink doesn't exist");
    }
    const stubObject = {
      billingPortal: {
        sessions: {
          create: () => {},
        },
      },
    };

    const getCustomerUsecase = {
      execute: () =>
        Promise.resolve({
          id: 'customer_id',
        }),
    };

    const spy = sinon.spy(getCustomerUsecase, 'execute');

    const stub = sinon.stub(stubObject.billingPortal.sessions, 'create').resolves({ url: 'url' });

    const usecase = new (require('@novu/ee-billing').GetPortalLink)(stubObject, getCustomerUsecase);

    const result = await usecase.execute({
      environmentId: 'environment_dd',
      organizationId: 'organization_id',
      userId: 'user_id',
      origin: dashboardOrigin,
    });

    expect(stub.lastCall.args.at(0)).to.deep.equal({
      return_url: `${dashboardOrigin}/manage-account/billing`,
      customer: 'customer_id',
    });

    expect(spy.lastCall.args.at(0)).to.deep.equal({
      organizationId: 'organization_id',
    });

    expect(result).to.equal('url');
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - dashboardOrigin(process.env.FRONT_BASE_URL;

describe('Get portal link #novu-v2', async ())
 - stubObject({
      billingPortal: {
        sessions: {
          create: ())
 - getCustomerUsecase({
      execute: ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/billing/e2e/get-prices.e2e-ee.ts
Tamao: 4190 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiServiceLevelEnum, StripeBillingIntervalEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';

describe('GetPrices #novu-v2', () => {
  const eeBilling = require('@novu/ee-billing');
  if (!eeBilling) {
    throw new Error('ee-billing does not exist');
  }

  const { GetPrices, GetPricesCommand } = eeBilling;

  const stripeStub = {
    prices: {
      list: sinon.stub(),
    },
  };
  let listPricesStub: sinon.SinonStub;

  beforeEach(() => {
    listPricesStub = stripeStub.prices.list;
    listPricesStub.onFirstCall().resolves({
      data: [{ id: 'licensed_price_id_1' }],
    });
    listPricesStub.onSecondCall().resolves({
      data: [{ id: 'metered_price_id_1' }],
    });
  });

  afterEach(() => {
    listPricesStub.reset();
  });

  const createUseCase = () => new GetPrices(stripeStub);

  const freeMeteredPriceLookupKey = ['free_usage_notifications_10k'];

  const expectedPrices = [
    {
      apiServiceLevel: ApiServiceLevelEnum.FREE,
      billingInterval: StripeBillingIntervalEnum.MONTH,
      prices: {
        licensed: ['free_flat_monthly'],
        metered: freeMeteredPriceLookupKey,
      },
    },
    {
      apiServiceLevel: ApiServiceLevelEnum.PRO,
      billingInterval: StripeBillingIntervalEnum.MONTH,
      prices: {
        licensed: ['pro_flat_monthly'],
        metered: ['pro_usage_notifications'],
      },
    },
    {
      apiServiceLevel: ApiServiceLevelEnum.PRO,
      billingInterval: StripeBillingIntervalEnum.YEAR,
      prices: {
        licensed: ['pro_flat_annually'],
        metered: ['pro_usage_notifications'],
      },
    },
    {
      apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
      billingInterval: StripeBillingIntervalEnum.MONTH,
      prices: {
        licensed: ['business_flat_monthly'],
        metered: ['business_usage_notifications'],
      },
    },
    {
      apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
      billingInterval: StripeBillingIntervalEnum.YEAR,
      prices: {
        licensed: ['business_flat_annually'],
        metered: ['business_usage_notifications'],
      },
    },
    {
      apiServiceLevel: ApiServiceLevelEnum.ENTERPRISE,
      billingInterval: StripeBillingIntervalEnum.MONTH,
      prices: {
        licensed: ['enterprise_flat_monthly'],
        metered: ['enterprise_usage_notifications'],
      },
    },
    {
      apiServiceLevel: ApiServiceLevelEnum.ENTERPRISE,
      billingInterval: StripeBillingIntervalEnum.YEAR,
      prices: {
        licensed: ['enterprise_flat_annually'],
        metered: ['enterprise_usage_notifications'],
      },
    },
  ];

  expectedPrices
    .map(({ apiServiceLevel, billingInterval, prices }) => {
      return () => {
        describe(`apiServiceLevel of ${apiServiceLevel} and billingInterval of ${billingInterval}`, () => {
          it(`should fetch the prices list with the expected lookup keys`, async () => {
            const useCase = createUseCase();

            await useCase.execute(
              GetPricesCommand.create({
                apiServiceLevel,
                billingInterval,
                organizationId: 'system',
              })
            );

            const allCallsArgs = listPricesStub.getCalls().map((call) => call.args[0]);
            expect(allCallsArgs).to.deep.equal([
              {
                lookup_keys: prices.licensed,
              },
              {
                lookup_keys: prices.metered,
              },
            ]);
          });
        });
      };
    })
    .forEach((test) => {
      test();
    });

  it(`should throw an error if no prices are found`, async () => {
    listPricesStub.onFirstCall().resolves({ data: [] });
    listPricesStub.onSecondCall().resolves({ data: [] });
    const useCase = createUseCase();

    try {
      await useCase.execute(
        GetPricesCommand.create({
          apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
          billingInterval: StripeBillingIntervalEnum.MONTH,
          organizationId: 'system',
        })
      );
    } catch (e) {
      expect(e.message).to.include(`No prices found for apiServiceLevel: '${ApiServiceLevelEnum.BUSINESS}'`);
    }
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - stripeStub({
    prices: {
      list: sinon.stub(),
    },
  };
  let listPricesStub: sinon.SinonStub;

  befo...)
 - listPricesStub(stripeStub.prices.list;
    listPricesStub.onFirstCall().resolves({
      data: [{ id: 'licensed_pri...)
 - createUseCase())
 - expectedPrices([
    {
      apiServiceLevel: ApiServiceLevelEnum.FREE,
      billingInterval: StripeBillingInterva...)
 - allCallsArgs(listPricesStub.getCalls().map((call))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/billing/e2e/get-subscription.e2e-ee.ts
Tamao: 6491 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiServiceLevelEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import sinon from 'sinon';
import { Stripe } from 'stripe';

type DeepPartial<T> = T extends object ? { [P in keyof T]?: DeepPartial<T[P]> } : T;

const mockedStripeSubscriptionItems: DeepPartial<Stripe.ApiList<Stripe.SubscriptionItem>> = {
  data: [
    {
      price: {
        recurring: {
          usage_type: 'licensed',
          interval: 'month',
        },
        metadata: {
          includedEvents: '1000000',
        },
      },
    },
    {
      price: {
        recurring: {
          usage_type: 'metered',
          interval: 'month',
        },
        metadata: {
          includedEvents: '1000000',
        },
      },
    },
  ],
};

const mockedStripeCustomer: DeepPartial<Stripe.Customer> = {
  id: 'customer_id',
  invoice_settings: {
    default_payment_method: 'payment_method_id',
  },
  subscriptions: {
    data: [
      {
        id: 'subscription_id',
        status: 'active',
        current_period_end: new Date('2024-05-05T00:00:00.000Z').getTime() / 1000,
        current_period_start: new Date('2024-04-05T00:00:00.000Z').getTime() / 1000,
        trial_start: null,
        trial_end: null,
        items: mockedStripeSubscriptionItems,
      },
    ],
  },
};

describe('GetSubscription #novu-v2', async () => {
  let session: UserSession;

  const eeBilling = require('@novu/ee-billing');
  if (!eeBilling) {
    throw new Error('ee-billing does not exist');
  }

  const { GetPlatformNotificationUsageCommand, GetSubscription, GetSubscriptionCommand } = eeBilling;

  const communityOrganizationRepo = {
    findById: () =>
      Promise.resolve({
        _id: session.organization._id,
        apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
      }),
  };
  const getPlatformNotificationUsage = {
    execute: () =>
      Promise.resolve([
        {
          _id: session.organization._id,
          notificationsCount: 1000000,
          apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
        },
      ]),
  };
  let getOrCreateCustomer = {
    execute: () => Promise.resolve(mockedStripeCustomer),
  };
  let getPlatformNotificationUsageSpy: sinon.SinonSpy;

  const createUseCase = () => {
    const useCase = new GetSubscription(
      getOrCreateCustomer as any,
      getPlatformNotificationUsage as any,
      communityOrganizationRepo
    );

    return useCase;
  };

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    getPlatformNotificationUsageSpy = sinon.spy(getPlatformNotificationUsage, 'execute');
  });

  afterEach(() => {
    getPlatformNotificationUsageSpy.resetHistory();
  });

  it('should return the correct subscription details for a given organization', async () => {
    const result = await createUseCase().execute(
      GetSubscriptionCommand.create({
        organizationId: session.organization._id,
      })
    );

    expect(result).to.deep.equal({
      apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
      isActive: true,
      status: 'active',
      hasPaymentMethod: true,
      currentPeriodStart: '2024-04-05T00:00:00.000Z',
      currentPeriodEnd: '2024-05-05T00:00:00.000Z',
      billingInterval: 'month',
      events: {
        current: 1000000,
        included: 1000000,
      },
      trial: {
        start: null,
        end: null,
        isActive: false,
        daysTotal: 0,
      },
      cancelAt: null,
    });
  });

  it('should fetch usage with the subscription period dates and organizationId', async () => {
    await createUseCase().execute(
      GetSubscriptionCommand.create({
        organizationId: session.organization._id,
      })
    );

    expect(getPlatformNotificationUsageSpy.lastCall.args.at(0)).to.deep.equal(
      GetPlatformNotificationUsageCommand.create({
        organizationId: session.organization._id,
        startDate: new Date('2024-04-05T00:00:00.000Z'),
        endDate: new Date('2024-05-05T00:00:00.000Z'),
      })
    );
  });

  it('should throw error if no licensed subscription is found', async () => {
    getOrCreateCustomer = {
      execute: () =>
        Promise.resolve({
          ...mockedStripeCustomer,
          subscriptions: {
            data: [
              {
                ...mockedStripeCustomer.subscriptions?.data?.[0],
                items: {
                  data: [
                    {
                      price: {
                        recurring: {
                          usage_type: 'metered',
                          interval: 'month',
                        },
                        metadata: {
                          includedEvents: '1000000',
                        },
                      },
                    },
                  ],
                },
              },
            ],
          },
        } as unknown as Stripe.Customer),
    };

    try {
      await createUseCase().execute(
        GetSubscriptionCommand.create({
          organizationId: session.organization._id,
        })
      );
      // shouldn't get here
      throw new Error();
    } catch (e) {
      expect(e.message).to.include("No licensed subscription found for customerId: 'customer_id'");
    }
  });

  it('should throw error if no metered subscription is found', async () => {
    getOrCreateCustomer = {
      execute: () =>
        Promise.resolve({
          ...mockedStripeCustomer,
          subscriptions: {
            data: [
              {
                ...mockedStripeCustomer.subscriptions?.data?.[0],
                items: {
                  data: [
                    {
                      price: {
                        recurring: {
                          usage_type: 'licensed',
                          interval: 'month',
                        },
                        metadata: {
                          includedEvents: '1000000',
                        },
                      },
                    },
                  ],
                },
              },
            ],
          },
        } as unknown as Stripe.Customer),
    };

    try {
      await createUseCase().execute(
        GetSubscriptionCommand.create({
          organizationId: session.organization._id,
        })
      );
      // shouldn't get here
      throw new Error();
    } catch (e) {
      expect(e.message).to.include("No metered subscription found for customerId: 'customer_id'");
    }
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - communityOrganizationRepo({
    findById: ())
 - getPlatformNotificationUsage({
    execute: ())
 - getOrCreateCustomer({
    execute: ())
 - createUseCase())
 - useCase(new GetSubscription(
      getOrCreateCustomer as any,
      getPlatformNotificationUsage as any,
  ...)
 - getPlatformNotificationUsageSpy(sinon.spy(getPlatformNotificationUsage, 'execute');
  });

  afterEach(())
 - result(await createUseCase().execute(
      GetSubscriptionCommand.create({
        organizationId: session...)
 - getOrCreateCustomer({
      execute: ())
 - getOrCreateCustomer({
      execute: ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/billing/e2e/quota-throttler.guard.e2e-ee.ts
Tamao: 4623 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { GetEventResourceUsage } from '@novu/ee-billing';
import { ApiServiceLevelEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import sinon from 'sinon';

process.env.LAUNCH_DARKLY_SDK_KEY = ''; // disable Launch Darkly to allow test to define FF state
// process.env.CLERK_ENABLED = 'true';
describe('Resource Limiting #novu-v2', () => {
  let session: UserSession;
  const pathDefault = '/v1/testing/resource-limiting-default';
  const pathEvent = '/v1/testing/resource-limiting-events';
  let request: (
    path: string,
    authHeader?: string
  ) => Promise<Awaited<ReturnType<typeof UserSession.prototype.testAgent.get>>>;

  describe('IS_SELF_HOSTED is true', () => {
    beforeEach(async () => {
      process.env.IS_SELF_HOSTED = 'true';
      session = new UserSession();
      await session.initialize();

      request = (path: string) => session.testAgent.get(path);
    });

    it('should not block the request', async () => {
      const response = await request(pathEvent);

      expect(response.status).to.equal(200);
    });
  });

  describe('IS_SELF_HOSTED is false', () => {
    beforeEach(async () => {
      process.env.IS_SELF_HOSTED = 'false';
      session = new UserSession();
      await session.initialize();
      await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.PRO);

      request = (path: string, authHeader = `ApiKey ${session.apiKey}`) =>
        session.testAgent.get(path).set('authorization', authHeader);
    });

    describe('Event resource blocking', () => {
      describe('Base Quota FF is enabled', () => {
        let getEventResourceUsageStub: sinon.SinonStub;

        beforeEach(() => {
          const getEventResourceUsage = session.testServer?.getService(GetEventResourceUsage) as GetEventResourceUsage;
          getEventResourceUsageStub = sinon.stub(getEventResourceUsage, 'execute');
        });

        afterEach(() => {
          getEventResourceUsageStub.reset();
        });

        it('should NOT block the request when the quota limit is NOT exceeded', async () => {
          getEventResourceUsageStub.resolves({
            remaining: 50,
            limit: 100,
            success: true,
            start: 1609459200000,
            reset: 1612137600000,
            apiServiceLevel: ApiServiceLevelEnum.FREE,
          });
          const response = await request(pathEvent);

          expect(response.status).to.equal(200);
        });

        it('should block the request when the quota limit is exceeded and product tier is free', async () => {
          await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.FREE);
          getEventResourceUsageStub.resolves({
            remaining: 0,
            limit: 100,
            success: false,
            start: 1609459200000,
            reset: 1612137600000,
            apiServiceLevel: ApiServiceLevelEnum.FREE,
          });
          const response = await request(pathEvent);

          expect(response.status).to.equal(402);
        });

        it('should NOT block the request when the quota limit is exceeded and product tier is NOT free', async () => {
          getEventResourceUsageStub.resolves({
            remaining: 0,
            limit: 100,
            success: false,
            start: 1609459200000,
            reset: 1612137600000,
            apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
          });
          const response = await request(pathEvent);

          expect(response.status).to.equal(200);
        });

        it('should NOT block the request when the evaluation lock is false', async () => {
          getEventResourceUsageStub.resolves({
            remaining: 0,
            limit: 0,
            success: true,
            start: 0,
            reset: 0,
            apiServiceLevel: ApiServiceLevelEnum.FREE,
            locked: false,
          });
          const response = await request(pathEvent);

          expect(response.status).to.equal(200);
        });
      });
    });

    describe('Default resources (no decorator)', () => {
      it('should handle the request when the FF is enabled', async () => {
        process.env.IS_EVENT_QUOTA_THROTTLER_ENABLED = 'true';
        const response = await request(pathDefault);

        expect(response.status).to.equal(200);
      });

      it('should handle the request when the FF is disabled', async () => {
        process.env.IS_EVENT_QUOTA_THROTTLER_ENABLED = 'false';
        const response = await request(pathDefault);

        expect(response.status).to.equal(200);
      });
    });
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - CLERK_ENABLED('true';
describe('Resource Limiting #novu-v2', ())
 - pathEvent('/v1/testing/resource-limiting-events';
  let request: (
    path: string,
    authHeader?: string
 ...)
 - request(path: string))
 - response(await request(pathEvent);

      expect(response.status).to.equal(200);
    });
  });

  describe('I...)
 - authHeader(`ApiKey ${session.apiKey}`))
 - getEventResourceUsageStub(sinon.stub(getEventResourceUsage, 'execute');
        });

        afterEach(())
 - response(await request(pathEvent);

          expect(response.status).to.equal(200);
        });

        it(...)
 - response(await request(pathEvent);

          expect(response.status).to.equal(402);
        });

        it(...)
 - response(await request(pathEvent);

          expect(response.status).to.equal(200);
        });

        it(...)
 - response(await request(pathEvent);

          expect(response.status).to.equal(200);
        });
      });
  ...)
 - response(await request(pathDefault);

        expect(response.status).to.equal(200);
      });

      it('sho...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/billing/e2e/verify-customer.e2e-ee.ts
Tamao: 3930 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

// biome-ignore lint/style/noRestrictedImports: <explanation>
import { Logger } from '@nestjs/common';
import { CommunityOrganizationRepository } from '@novu/dal';
import { VerifyCustomerCommand } from '@novu/ee-billing';
import { ApiServiceLevelEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';

describe('VerifyCustomer #novu-v2', () => {
  const eeBilling = require('@novu/ee-billing');
  if (!eeBilling) {
    throw new Error('ee-billing does not exist');
  }

  const { VerifyCustomer } = eeBilling;

  const stripeStub = {
    customers: {
      retrieve: () => {},
    },
    subscriptions: {
      retrieve: () => {},
    },
  };
  let getCustomerStub: sinon.SinonStub;

  let getSubscriptionStub: sinon.SinonStub;

  const repo = new CommunityOrganizationRepository();
  let getOrgStub: sinon.SinonStub;

  beforeEach(() => {
    getCustomerStub = sinon.stub(stripeStub.customers, 'retrieve').resolves({
      id: 'customer_id',
      deleted: false,
      metadata: {
        organizationId: 'organization_id',
      },
      subscriptions: {
        data: [
          {
            id: 'subscription_id',
            items: { data: [{ id: 'item_id_usage_notifications' }, { id: 'item_id_flat' }] },
          },
        ],
      },
    });

    getSubscriptionStub = sinon.stub(stripeStub.subscriptions, 'retrieve').resolves({
      id: 'subscription_id',
      items: {
        data: [
          {
            id: 'item_id_usage_notifications',
            plan: {
              interval: 'month',
            },
          },
          {
            id: 'item_id_flat',
            plan: {
              interval: 'month',
            },
          },
        ],
      },
    });

    getOrgStub = sinon
      .stub(repo, 'findById')
      .resolves({ _id: 'organization_id', apiServiceLevel: ApiServiceLevelEnum.FREE } as any);
  });

  afterEach(() => {
    getCustomerStub.reset();

    getOrgStub.reset();
  });

  const createUseCase = () => {
    const useCase = new VerifyCustomer(stripeStub as any, repo);

    return useCase;
  };

  it('Should throw an error if the Customer does not exist', async () => {
    getCustomerStub.resolves(null);
    const useCase = createUseCase();

    try {
      await useCase.execute(
        VerifyCustomerCommand.create({
          customerId: 'customer_id',
        })
      );
      throw new Error('Should not reach here');
    } catch (e) {
      expect(e.message).to.equal(`Customer not found: 'customer_id'`);
    }
  });

  it('Should throw an error if the Customer is deleted', async () => {
    getCustomerStub.resolves({ deleted: true });
    const useCase = createUseCase();

    try {
      await useCase.execute(
        VerifyCustomerCommand.create({
          customerId: 'customer_id',
        })
      );
      throw new Error('Should not reach here');
    } catch (e) {
      expect(e.message).to.equal(`Customer is deleted: 'customer_id'`);
    }
  });

  it('Should return the organization and customer', async () => {
    const useCase = createUseCase();
    const result = await useCase.execute(
      VerifyCustomerCommand.create({
        customerId: 'customer_id',
      })
    );

    expect(result.organization?._id).to.equal('organization_id');
    expect(result.customer?.id).to.equal('customer_id');
    expect(result.customer?.subscriptions?.data[0].id).to.equal('subscription_id');
  });

  it('Should log a message and continue if the organization does not exist', async () => {
    getOrgStub.resolves(null);
    const useCase = createUseCase();
    const logStub = sinon.stub(Logger, 'verbose');

    const result = await useCase.execute(
      VerifyCustomerCommand.create({
        customerId: 'customer_id',
      })
    );

    expect(result.organization).to.equal(null);
    expect(logStub.lastCall.args[0]).to.equal(`Organization not found: 'organization_id'`);

    logStub.restore();
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - stripeStub({
    customers: {
      retrieve: ())
 - repo(new CommunityOrganizationRepository();
  let getOrgStub: sinon.SinonStub;

  beforeEach(())
 - getOrgStub(sinon
      .stub(repo, 'findById')
      .resolves({ _id: 'organization_id', apiServiceLevel: ApiSe...)
 - createUseCase())
 - useCase(new VerifyCustomer(stripeStub as any, repo);

    return useCase;
  };

  it('Should throw an error ...)
 - useCase(createUseCase();

    try {
      await useCase.execute(
        VerifyCustomerCommand.create({
    ...)
 - useCase(createUseCase();

    try {
      await useCase.execute(
        VerifyCustomerCommand.create({
    ...)
 - result(await useCase.execute(
      VerifyCustomerCommand.create({
        customerId: 'customer_id',
     ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/blueprint/blueprint.controller.ts
Tamao: 2126 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ClassSerializerInterceptor, Controller, Get, Param, UseInterceptors } from '@nestjs/common';
import { ApiExcludeController } from '@nestjs/swagger';
import { EnvironmentRepository, NotificationTemplateRepository } from '@novu/dal';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ApiCommonResponses } from '../shared/framework/response.decorator';
import { GetBlueprintResponse } from './dtos/get-blueprint.response.dto';
import { GroupedBlueprintResponse } from './dtos/grouped-blueprint.response.dto';
import { GetBlueprint, GetBlueprintCommand } from './usecases/get-blueprint';
import { GetGroupedBlueprints, GetGroupedBlueprintsCommand } from './usecases/get-grouped-blueprints';

@ApiCommonResponses()
@Controller('/blueprints')
@UseInterceptors(ClassSerializerInterceptor)
@ApiExcludeController()
@RequireAuthentication()
export class BlueprintController {
  constructor(
    private environmentRepository: EnvironmentRepository,
    private getBlueprintUsecase: GetBlueprint,
    private getGroupedBlueprintsUsecase: GetGroupedBlueprints
  ) {}

  @Get('/group-by-category')
  async getGroupedBlueprints(): Promise<GroupedBlueprintResponse> {
    const prodEnvironmentId = await this.getProdEnvironmentId();

    return this.getGroupedBlueprintsUsecase.execute(
      GetGroupedBlueprintsCommand.create({ environmentId: prodEnvironmentId })
    );
  }

  private async getProdEnvironmentId() {
    const productionEnvironmentId = (
      await this.environmentRepository.findOrganizationEnvironments(
        NotificationTemplateRepository.getBlueprintOrganizationId() || ''
      )
    )?.find((env) => env.name === 'Production')?._id;

    if (!productionEnvironmentId) {
      throw new Error('Production environment id was not found');
    }

    return productionEnvironmentId;
  }

  @Get('/:templateIdOrIdentifier')
  getBlueprintById(@Param('templateIdOrIdentifier') templateIdOrIdentifier: string): Promise<GetBlueprintResponse> {
    return this.getBlueprintUsecase.execute(
      GetBlueprintCommand.create({
        templateIdOrIdentifier,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - productionEnvironmentId(await this.environmentRepository.findOrganizationEnvironments(
        NotificationTemplateRepositor...)
Declaraciones 'export' encontradas:
- export class BlueprintController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/blueprint/blueprint.module.ts
Tamao: 583 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MiddlewareConsumer, Module, NestModule } from '@nestjs/common';

import { SharedModule } from '../shared/shared.module';
import { WorkflowModuleV1 } from '../workflows-v1/workflow-v1.module';
import { BlueprintController } from './blueprint.controller';
import { USE_CASES } from './usecases';

@Module({
  imports: [SharedModule, WorkflowModuleV1],
  controllers: [BlueprintController],
  providers: [...USE_CASES],
  exports: [...USE_CASES],
})
export class BlueprintModule implements NestModule {
  configure(consumer: MiddlewareConsumer): MiddlewareConsumer | void {}
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BlueprintModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/blueprint/dtos/get-blueprint.response.dto.ts
Tamao: 742 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { INotificationGroup, INotificationTrigger, IPreferenceChannels, NotificationStepDto } from '@novu/shared';

export class GetBlueprintResponse {
  _id: string;

  name: string;

  description: string;

  active: boolean;

  draft: boolean;

  preferenceSettings: IPreferenceChannels;

  critical: boolean;

  tags: string[];

  steps: NotificationStepDto[];

  _organizationId: string;

  _creatorId: string;

  _environmentId: string;

  triggers: INotificationTrigger[];

  _notificationGroupId: string;

  _parentId?: string;

  deleted: boolean;

  deletedAt: string;

  deletedBy: string;

  createdAt?: string;

  updatedAt?: string;

  notificationGroup?: INotificationGroup;

  isBlueprint: boolean;

  blueprintId?: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetBlueprintResponse

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/blueprint/dtos/grouped-blueprint.response.dto.ts
Tamao: 155 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IGroupedBlueprint } from '@novu/shared';

export class GroupedBlueprintResponse {
  general: IGroupedBlueprint[];
  popular: IGroupedBlueprint;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GroupedBlueprintResponse

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/blueprint/e2e/get-blueprints-by-id.e2e.ts
Tamao: 6406 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentRepository, NotificationTemplateRepository } from '@novu/dal';
import {
  EmailBlockTypeEnum,
  FieldLogicalOperatorEnum,
  FieldOperatorEnum,
  FilterPartTypeEnum,
  INotificationTemplateStep,
  StepTypeEnum,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { CreateWorkflowRequestDto } from '../../workflows-v1/dtos';
import { GroupedBlueprintResponse } from '../dtos/grouped-blueprint.response.dto';

describe('Get blueprints by id - /blueprints/:templateId (GET) #novu-v0', async () => {
  let session: UserSession;
  const notificationTemplateRepository: NotificationTemplateRepository = new NotificationTemplateRepository();
  const environmentRepository: EnvironmentRepository = new EnvironmentRepository();

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  afterEach(() => {});

  it('should get the blueprint by id', async () => {
    const prodEnv = await getProductionEnvironment();

    await createTemplateFromBlueprint({ session, notificationTemplateRepository, prodEnv });

    const allBlueprints = await session.testAgent.get(`/v1/blueprints/group-by-category`).send();

    const blueprint = (allBlueprints.body.data as GroupedBlueprintResponse).general[0].blueprints[0];

    const blueprintById = (await session.testAgent.get(`/v1/blueprints/${blueprint._id}`).send()).body.data;

    // validate that fetched blueprint by id is the same as from the initial allBlueprints fetch
    expect(blueprintById.isBlueprint).to.equal(true);
    expect(blueprint.name).to.equal(blueprintById.name);
    expect(blueprint.description).to.equal(blueprintById.description);
    expect(blueprint.active).to.equal(blueprintById.active);
    expect(blueprint.critical).to.equal(blueprintById.critical);
    expect(blueprintById.steps).to.be.exist;
    expect((blueprint.steps[0] as INotificationTemplateStep).active).to.equal(blueprintById.steps[0].active);
    expect(blueprintById.steps[0].template).to.exist;
    expect((blueprint.steps[0] as INotificationTemplateStep).template?.name).to.be.equal(
      blueprintById.steps[0].template?.name
    );
    expect((blueprint.steps[0] as INotificationTemplateStep).template?.subject).to.be.equal(
      blueprintById.steps[0].template?.subject
    );
  });

  it('should get the blueprint by trigger identifier', async () => {
    const prodEnv = await getProductionEnvironment();

    await createTemplateFromBlueprint({ session, notificationTemplateRepository, prodEnv });

    const allBlueprints = await session.testAgent.get(`/v1/blueprints/group-by-category`).send();

    const blueprint = (allBlueprints.body.data as GroupedBlueprintResponse).general[0].blueprints[0];

    const blueprintById = (await session.testAgent.get(`/v1/blueprints/${blueprint.triggers[0].identifier}`).send())
      .body.data;

    const test = await session.testAgent.get(`/v1/blueprints/${blueprint.triggers[0].identifier}`).send();

    // validate that fetched blueprint by trigger identifier is the same as from the initial allBlueprints fetch
    expect(blueprintById.isBlueprint).to.equal(true);
    expect(blueprint.name).to.equal(blueprintById.name);
    expect(blueprint.description).to.equal(blueprintById.description);
    expect(blueprint.active).to.equal(blueprintById.active);
    expect(blueprint.critical).to.equal(blueprintById.critical);
    expect(blueprintById.steps).to.be.exist;
    expect((blueprint.steps[0] as INotificationTemplateStep).active).to.equal(blueprintById.steps[0].active);
    expect(blueprintById.steps[0].template).to.exist;
    expect((blueprint.steps[0] as INotificationTemplateStep).template?.name).to.be.equal(
      blueprintById.steps[0].template?.name
    );
    expect((blueprint.steps[0] as INotificationTemplateStep).template?.subject).to.be.equal(
      blueprintById.steps[0].template?.subject
    );
  });

  async function getProductionEnvironment() {
    return await environmentRepository.findOne({
      _parentId: session.environment._id,
    });
  }
});

export async function createTemplateFromBlueprint({
  session,
  notificationTemplateRepository,
  prodEnv,
}: {
  session: UserSession;
  notificationTemplateRepository: NotificationTemplateRepository;
  prodEnv;
}) {
  const testTemplateRequestDto: Partial<CreateWorkflowRequestDto> = {
    name: 'test email template',
    description: 'This is a test description',
    tags: ['test-tag'],
    notificationGroupId: session.notificationGroups[0]._id,
    steps: [
      {
        template: {
          name: 'Message Name',
          subject: 'Test email subject',
          preheader: 'Test email preheader',
          content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
          type: StepTypeEnum.EMAIL,
        },
        filters: [
          {
            isNegated: false,
            type: 'GROUP',
            value: FieldLogicalOperatorEnum.AND,
            children: [
              {
                on: FilterPartTypeEnum.SUBSCRIBER,
                field: 'firstName',
                value: 'test value',
                operator: FieldOperatorEnum.EQUAL,
              },
            ],
          },
        ],
      },
    ],
  };

  const testTemplate = (await session.testAgent.post(`/v1/workflows`).send(testTemplateRequestDto)).body.data;

  process.env.BLUEPRINT_CREATOR = session.organization._id;

  const testEnvBlueprintTemplate = (await session.testAgent.post(`/v1/workflows`).send(testTemplateRequestDto)).body
    .data;

  expect(testEnvBlueprintTemplate).to.be.ok;

  await session.applyChanges({
    enabled: false,
  });

  if (!prodEnv) throw new Error('production environment was not found');

  const blueprintId = (
    await notificationTemplateRepository.findOne({
      _environmentId: prodEnv._id,
      _parentId: testEnvBlueprintTemplate._id,
    })
  )?._id;

  if (!blueprintId) throw new Error('blueprintId was not found');

  const blueprint = (await session.testAgent.get(`/v1/blueprints/${blueprintId}`).send()).body.data;

  blueprint.notificationGroupId = blueprint._notificationGroupId;
  blueprint.blueprintId = blueprint._id;

  const createdTemplate = (await session.testAgent.post(`/v1/workflows`).send({ ...blueprint })).body.data;

  return {
    testTemplateRequestDto,
    testTemplate,
    blueprintId,
    createdTemplate,
  };
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - getProductionEnvironment()
 - createTemplateFromBlueprint({
  session,
  notificationTemplateRepository,
  prodEnv,
}: {
  session: UserSession;
  notificationTemplateRepository: NotificationTemplateRepository;
  prodEnv;
})
Asignaciones con arrow functions encontradas (posibles funciones):
 - EnvironmentRepository(new EnvironmentRepository();

  before(async ())
 - session(new UserSession();
    await session.initialize();
  });

  afterEach(())
 - blueprintById(await session.testAgent.get(`/v1/blueprints/${blueprint._id}`).send()).body.data;

    // validate t...)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/blueprint/e2e/get-grouped-blueprints.e2e.ts
Tamao: 8585 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  buildGroupedBlueprintsKey,
  CacheInMemoryProviderService,
  CacheService,
  InvalidateCacheService,
  PinoLogger,
} from '@novu/application-generic';
import { EnvironmentEntity, EnvironmentRepository, NotificationTemplateRepository } from '@novu/dal';
import {
  EmailBlockTypeEnum,
  FieldLogicalOperatorEnum,
  FieldOperatorEnum,
  FilterPartTypeEnum,
  INotificationTemplate,
  INotificationTemplateStep,
  StepTypeEnum,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import sinon from 'sinon';
import { CreateWorkflowRequestDto } from '../../workflows-v1/dtos';
import { GroupedBlueprintResponse } from '../dtos/grouped-blueprint.response.dto';
import { GetGroupedBlueprints, POPULAR_TEMPLATES_ID_LIST } from '../usecases/get-grouped-blueprints';
import * as blueprintStaticModule from '../usecases/get-grouped-blueprints/consts';

describe('Get grouped notification template blueprints - /blueprints/group-by-category (GET) #novu-v0', async () => {
  let session: UserSession;
  const notificationTemplateRepository: NotificationTemplateRepository = new NotificationTemplateRepository();
  const environmentRepository: EnvironmentRepository = new EnvironmentRepository();

  let invalidateCache: InvalidateCacheService;
  let getGroupedBlueprints: GetGroupedBlueprints;
  let indexModuleStub: sinon.SinonStub;

  before(async () => {
    const cacheInMemoryProviderService = new CacheInMemoryProviderService();
    const cacheService = new CacheService(cacheInMemoryProviderService);
    await cacheService.initialize();
    invalidateCache = new InvalidateCacheService(cacheService);

    session = new UserSession();
    await session.initialize();

    getGroupedBlueprints = new GetGroupedBlueprints(new NotificationTemplateRepository(), new PinoLogger({}));
    indexModuleStub = sinon.stub(blueprintStaticModule, 'POPULAR_TEMPLATES_ID_LIST');
  });

  afterEach(() => {
    indexModuleStub.restore();
  });

  it('should get the grouped blueprints', async () => {
    const prodEnv = await getProductionEnvironment();
    if (!prodEnv) throw new Error('production environment was not found');

    await createTemplateFromBlueprint({ session, notificationTemplateRepository, prodEnv });

    const data = await session.testAgent.get(`/v1/blueprints/group-by-category`).send();

    expect(data.statusCode).to.equal(200);

    const groupedBlueprints = (data.body.data as GroupedBlueprintResponse).general;

    expect(groupedBlueprints[0]?.name).to.equal('General');

    for (const group of groupedBlueprints) {
      for (const blueprint of group.blueprints) {
        expect(blueprint.isBlueprint).to.equal(true);
        expect(blueprint.name).to.equal('test email template');
        expect(blueprint.description).to.equal('This is a test description');
        expect(blueprint.active).to.equal(false);
        expect(blueprint.critical).to.equal(false);
        expect(blueprint.steps).to.be.exist;
        const step: INotificationTemplateStep = blueprint.steps[0] as INotificationTemplateStep;
        expect(step.active).to.equal(true);
        expect(step.template).to.exist;
        expect(step.template?.name).to.be.equal('Message Name');
        expect(step.template?.subject).to.be.equal('Test email subject');
      }
    }
  });

  it('should get the updated grouped blueprints (after invalidation)', async () => {
    const prodEnv = await getProductionEnvironment();
    if (!prodEnv) throw new Error('production environment was not found');

    await createTemplateFromBlueprint({
      session,
      notificationTemplateRepository,
      prodEnv,
    });

    const res1 = await session.testAgent.get(`/v1/blueprints/group-by-category`).send();
    expect(res1.statusCode).to.equal(200);
    const groupedBlueprints = (res1.body.data as GroupedBlueprintResponse).general;

    expect(groupedBlueprints.length).to.equal(1);
    expect(groupedBlueprints[0].name).to.equal('General');

    const categoryName = 'Life Style';
    await updateBlueprintCategory({ categoryName });

    const res2 = await session.testAgent.get(`/v1/blueprints/group-by-category`).send();
    expect(res2.statusCode).to.equal(200);
    const updatedGroupedBluePrints = (res2.body.data as GroupedBlueprintResponse).general;

    expect(updatedGroupedBluePrints.length).to.equal(2);
    expect(updatedGroupedBluePrints[0].name).to.equal('General');
    expect(updatedGroupedBluePrints[1].name).to.equal(categoryName);
  });

  it('should update the static POPULAR_TEMPLATES_GROUPED with fresh data', async () => {
    const prodEnv = await getProductionEnvironment();
    if (!prodEnv) throw new Error('production environment was not found');

    await createTemplateFromBlueprint({ session, notificationTemplateRepository, prodEnv });

    const data = await session.testAgent.get(`/v1/blueprints/group-by-category`).send();

    const groupedPopularBlueprints = data.body.data as GroupedBlueprintResponse;

    const blueprintFromDb = groupedPopularBlueprints.general[0].blueprints[0];

    // switch id from db store - to mock blueprint id
    const storeBlueprintTemplateId = blueprintFromDb._id?.toString();
    const mockedValue = POPULAR_TEMPLATES_ID_LIST;
    mockedValue[0] = storeBlueprintTemplateId || '';

    indexModuleStub.value(mockedValue);

    await invalidateCache.invalidateByKey({
      key: buildGroupedBlueprintsKey(prodEnv._id),
    });

    const updatedBlueprintFromDb = (await session.testAgent.get(`/v1/blueprints/group-by-category`).send()).body.data
      .popular.blueprints[0] as INotificationTemplate;

    expect(updatedBlueprintFromDb).to.deep.equal(blueprintFromDb);
  });

  async function updateBlueprintCategory({ categoryName }: { categoryName: string }) {
    const { body: notificationGroupsResult } = await session.testAgent
      .post(`/v1/notification-groups`)
      .send({ name: categoryName });

    await session.testAgent
      .post(`/v1/workflows`)
      .send({ notificationGroupId: notificationGroupsResult.data._id, name: 'test email template', steps: [] });

    await session.applyChanges({
      enabled: false,
    });
  }

  async function getProductionEnvironment() {
    return await environmentRepository.findOne({
      _parentId: session.environment._id,
    });
  }
});

export async function createTemplateFromBlueprint({
  session,
  notificationTemplateRepository,
  prodEnv,
}: {
  session: UserSession;
  notificationTemplateRepository: NotificationTemplateRepository;
  prodEnv: EnvironmentEntity;
}) {
  const testTemplateRequestDto: Partial<CreateWorkflowRequestDto> = {
    name: 'test email template',
    description: 'This is a test description',
    tags: ['test-tag'],
    notificationGroupId: session.notificationGroups[0]._id,
    steps: [
      {
        template: {
          name: 'Message Name',
          subject: 'Test email subject',
          preheader: 'Test email preheader',
          content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
          type: StepTypeEnum.EMAIL,
        },
        filters: [
          {
            isNegated: false,
            type: 'GROUP',
            value: FieldLogicalOperatorEnum.AND,
            children: [
              {
                on: FilterPartTypeEnum.SUBSCRIBER,
                field: 'firstName',
                value: 'test value',
                operator: FieldOperatorEnum.EQUAL,
              },
            ],
          },
        ],
      },
    ],
  };

  const testTemplate = (await session.testAgent.post(`/v1/workflows`).send(testTemplateRequestDto)).body.data;

  process.env.BLUEPRINT_CREATOR = session.organization._id;

  const testEnvBlueprintTemplate = (await session.testAgent.post(`/v1/workflows`).send(testTemplateRequestDto)).body
    .data;

  expect(testEnvBlueprintTemplate).to.be.ok;

  await session.applyChanges({
    enabled: false,
  });

  const blueprintId = (
    await notificationTemplateRepository.findOne({
      _environmentId: prodEnv._id,
      _parentId: testEnvBlueprintTemplate._id,
    })
  )?._id;

  if (!blueprintId) throw new Error('blueprintId was not found');

  const blueprint = (await session.testAgent.get(`/v1/blueprints/${blueprintId}`).send()).body.data;

  blueprint.notificationGroupId = blueprint._notificationGroupId;
  blueprint.blueprintId = blueprint._id;

  const createdTemplate = (await session.testAgent.post(`/v1/workflows`).send({ ...blueprint })).body.data;

  return {
    testTemplateRequestDto,
    testTemplate,
    blueprintId,
    createdTemplate,
  };
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - updateBlueprintCategory({ categoryName }: { categoryName: string })
 - getProductionEnvironment()
 - createTemplateFromBlueprint({
  session,
  notificationTemplateRepository,
  prodEnv,
}: {
  session: UserSession;
  notificationTemplateRepository: NotificationTemplateRepository;
  prodEnv: EnvironmentEntity;
})
Asignaciones con arrow functions encontradas (posibles funciones):
 - EnvironmentRepository(new EnvironmentRepository();

  let invalidateCache: InvalidateCacheService;
  let getGroupedBluepri...)
 - indexModuleStub(sinon.stub(blueprintStaticModule, 'POPULAR_TEMPLATES_ID_LIST');
  });

  afterEach(())
 - INotificationTemplateStep(blueprint.steps[0] as INotificationTemplateStep;
        expect(step.active).to.equal(true);
       ...)
 - updatedGroupedBluePrints(res2.body.data as GroupedBlueprintResponse).general;

    expect(updatedGroupedBluePrints.length).to...)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/blueprint/usecases/index.ts
Tamao: 189 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { GetBlueprint } from './get-blueprint';
import { GetGroupedBlueprints } from './get-grouped-blueprints';

export const USE_CASES = [
  //
  GetBlueprint,
  GetGroupedBlueprints,
];


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/blueprint/usecases/get-blueprint/get-blueprint.command.ts
Tamao: 233 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsDefined, IsString } from 'class-validator';

export class GetBlueprintCommand extends BaseCommand {
  @IsDefined()
  @IsString()
  templateIdOrIdentifier: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetBlueprintCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/blueprint/usecases/get-blueprint/get-blueprint.usecase.ts
Tamao: 1137 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';

import { NotificationTemplateEntity, NotificationTemplateRepository } from '@novu/dal';
import { GetBlueprintResponse } from '../../dtos/get-blueprint.response.dto';
import { GetBlueprintCommand } from './get-blueprint.command';

@Injectable()
export class GetBlueprint {
  constructor(private notificationTemplateRepository: NotificationTemplateRepository) {}

  async execute(command: GetBlueprintCommand): Promise<GetBlueprintResponse> {
    const isInternalId = NotificationTemplateRepository.isInternalId(command.templateIdOrIdentifier);

    let template: NotificationTemplateEntity | null;

    if (isInternalId) {
      template = await this.notificationTemplateRepository.findBlueprintById(command.templateIdOrIdentifier);
    } else {
      template = await this.notificationTemplateRepository.findBlueprintByTriggerIdentifier(
        command.templateIdOrIdentifier
      );
    }

    if (!template) {
      throw new NotFoundException(`Blueprint with id ${command.templateIdOrIdentifier} not found`);
    }

    return template as GetBlueprintResponse;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetBlueprint

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/blueprint/usecases/get-blueprint/index.ts
Tamao: 82 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-blueprint.command';
export * from './get-blueprint.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/blueprint/usecases/get-grouped-blueprints/consts.ts
Tamao: 221 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { getPopularTemplateIds } from '@novu/shared';

export const POPULAR_GROUPED_NAME = 'Popular';
export const POPULAR_TEMPLATES_ID_LIST = getPopularTemplateIds({ production: process.env.NODE_ENV === 'production' });


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/blueprint/usecases/get-grouped-blueprints/get-grouped-blueprints.command.ts
Tamao: 146 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentLevelCommand } from '@novu/application-generic';

export class GetGroupedBlueprintsCommand extends EnvironmentLevelCommand {}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetGroupedBlueprintsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/blueprint/usecases/get-grouped-blueprints/get-grouped-blueprints.usecase.ts
Tamao: 2760 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { buildGroupedBlueprintsKey, CachedResponse, PinoLogger } from '@novu/application-generic';
import { NotificationTemplateEntity, NotificationTemplateRepository } from '@novu/dal';
import { IGroupedBlueprint } from '@novu/shared';

import { GroupedBlueprintResponse } from '../../dtos/grouped-blueprint.response.dto';
import { GetGroupedBlueprintsCommand, POPULAR_GROUPED_NAME, POPULAR_TEMPLATES_ID_LIST } from './index';

const WEEK_IN_SECONDS = 60 * 60 * 24 * 7;

@Injectable()
export class GetGroupedBlueprints {
  constructor(
    private notificationTemplateRepository: NotificationTemplateRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  @CachedResponse({
    builder: (command: GetGroupedBlueprintsCommand) => buildGroupedBlueprintsKey(command.environmentId),
    options: { ttl: WEEK_IN_SECONDS },
  })
  async execute(command: GetGroupedBlueprintsCommand): Promise<GroupedBlueprintResponse> {
    const generalGroups = await this.fetchGroupedBlueprints();

    const updatePopularBlueprints = this.getPopularGroupBlueprints(generalGroups);

    const popularGroup = { name: POPULAR_GROUPED_NAME, blueprints: updatePopularBlueprints };

    return {
      general: generalGroups as unknown as IGroupedBlueprint[],
      popular: popularGroup as unknown as IGroupedBlueprint,
    };
  }

  private async fetchGroupedBlueprints() {
    const groups = await this.notificationTemplateRepository.findAllGroupedByCategory();
    if (!groups?.length) {
      throw new NotFoundException(
        `Blueprints for organization id ${NotificationTemplateRepository.getBlueprintOrganizationId()} were not found`
      );
    }

    return groups;
  }

  private groupedToBlueprintsArray(groups: { name: string; blueprints: NotificationTemplateEntity[] }[]) {
    return groups.flatMap((group) => group.blueprints);
  }

  private getPopularGroupBlueprints(
    groups: { name: string; blueprints: NotificationTemplateEntity[] }[]
  ): NotificationTemplateEntity[] {
    const storedBlueprints = this.groupedToBlueprintsArray(groups);

    const localPopularIds = [...POPULAR_TEMPLATES_ID_LIST];

    const result: NotificationTemplateEntity[] = [];

    for (const localPopularId of localPopularIds) {
      const storedBlueprint = storedBlueprints.find((blueprint) => blueprint._id === localPopularId);

      if (!storedBlueprint) {
        this.logger.warn(
          `Could not find stored popular blueprint id: ${localPopularId}, BLUEPRINT_CREATOR: 
          ${NotificationTemplateRepository.getBlueprintOrganizationId()}`
        );

        continue;
      }

      result.push(storedBlueprint);
    }

    return result;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - WEEK_IN_SECONDS(60 * 60 * 24 * 7;

@Injectable()
export class GetGroupedBlueprints {
  constructor(
    private noti...)
 - groups(await this.notificationTemplateRepository.findAllGroupedByCategory();
    if (!groups?.length) {
   ...)
 - storedBlueprint(storedBlueprints.find((blueprint))
Declaraciones 'export' encontradas:
- export class GetGroupedBlueprints

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/blueprint/usecases/get-grouped-blueprints/index.ts
Tamao: 126 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './consts';
export * from './get-grouped-blueprints.command';
export * from './get-grouped-blueprints.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/bridge.controller.ts
Tamao: 7225 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  BadRequestException,
  Body,
  ClassSerializerInterceptor,
  Controller,
  Get,
  Headers,
  NotFoundException,
  Param,
  Post,
  Put,
  Query,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { ApiExcludeController } from '@nestjs/swagger';
import {
  AnalyticsService,
  ExternalApiAccessible,
  RequirePermissions,
  SkipPermissionsCheck,
  UserSession,
} from '@novu/application-generic';
import { ControlValuesRepository, EnvironmentRepository, NotificationTemplateRepository } from '@novu/dal';
import { HttpHeaderKeysEnum } from '@novu/framework/internal';
import {
  ControlValuesLevelEnum,
  PermissionsEnum,
  ResourceOriginEnum,
  ResourceTypeEnum,
  UserSessionData,
} from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { CreateBridgeRequestDto } from './dtos/create-bridge-request.dto';
import { CreateBridgeResponseDto } from './dtos/create-bridge-response.dto';
import { ValidateBridgeUrlRequestDto } from './dtos/validate-bridge-url-request.dto';
import { ValidateBridgeUrlResponseDto } from './dtos/validate-bridge-url-response.dto';
import { GetBridgeStatusCommand } from './usecases/get-bridge-status/get-bridge-status.command';
import { GetBridgeStatus } from './usecases/get-bridge-status/get-bridge-status.usecase';
import { PreviewStep, PreviewStepCommand } from './usecases/preview-step';
import { StoreControlValuesCommand, StoreControlValuesUseCase } from './usecases/store-control-values';
import { SyncCommand } from './usecases/sync';
import { Sync } from './usecases/sync/sync.usecase';

@Controller('/bridge')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiExcludeController()
export class BridgeController {
  constructor(
    private syncUsecase: Sync,
    private getBridgeStatus: GetBridgeStatus,
    private environmentRepository: EnvironmentRepository,
    private notificationTemplateRepository: NotificationTemplateRepository,
    private controlValuesRepository: ControlValuesRepository,
    private storeControlValuesUseCase: StoreControlValuesUseCase,
    private previewStep: PreviewStep,
    private analyticsService: AnalyticsService
  ) {}

  @Get('/status')
  @SkipPermissionsCheck()
  async health(@UserSession() user: UserSessionData) {
    return this.getBridgeStatus.execute(
      GetBridgeStatusCommand.create({
        environmentId: user.environmentId,
      })
    );
  }

  @Post('/preview/:workflowId/:stepId')
  @RequirePermissions(PermissionsEnum.WORKFLOW_READ)
  async preview(
    @Param('workflowId') workflowId: string,
    @Param('stepId') stepId: string,
    @Body() data: any,
    @UserSession() user: UserSessionData
  ) {
    return this.previewStep.execute(
      PreviewStepCommand.create({
        workflowId,
        stepId,
        controls: data.controls,
        payload: data.payload,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        workflowOrigin: ResourceOriginEnum.EXTERNAL,
      })
    );
  }

  @Post('/sync')
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.WORKFLOW_WRITE)
  async createBridgesByDiscovery(
    @Headers(HttpHeaderKeysEnum.NOVU_ANONYMOUS) anonymousId: string,
    @UserSession() user: UserSessionData,
    @Body() body: CreateBridgeRequestDto,
    @Query('source') source?: string
  ): Promise<CreateBridgeResponseDto> {
    if (anonymousId) {
      this.analyticsService.alias(anonymousId, user._id);
    }

    return this.syncUsecase.execute(
      SyncCommand.create({
        organizationId: user.organizationId,
        userId: user._id,
        environmentId: user.environmentId,
        workflows: body.workflows,
        bridgeUrl: body.bridgeUrl,
        source,
      })
    );
  }

  @Post('/diff')
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.WORKFLOW_READ)
  async createDiscoverySoft(
    @Headers(HttpHeaderKeysEnum.NOVU_ANONYMOUS) anonymousId: string,
    @UserSession() user: UserSessionData,
    @Body() body: CreateBridgeRequestDto
  ): Promise<CreateBridgeResponseDto> {
    const environment = await this.environmentRepository.findOne({ _id: user.environmentId });

    if (!environment?.echo?.url) {
      throw new BadRequestException('Bridge URL not found');
    }

    if (anonymousId) {
      this.analyticsService.alias(anonymousId, user._id);
    }

    this.analyticsService.track('Diff Request - [Bridge API]', user._id, {
      _organization: user.organizationId,
      _environment: user.environmentId,
      workflowsCount: body.workflows?.length || 0,
    });

    const templates = await this.notificationTemplateRepository.find({
      _environmentId: user.environmentId,
      type: {
        $in: [ResourceTypeEnum.ECHO, ResourceTypeEnum.BRIDGE],
      },
    });

    const templatesDefinitions = templates?.map((i) => i.rawData);

    return {
      current: {
        workflows: templatesDefinitions,
        bridgeUrl: environment.echo?.url,
      },
      new: body,
    };
  }

  @Get('/controls/:workflowId/:stepId')
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.WORKFLOW_READ)
  async getControls(
    @UserSession() user: UserSessionData,
    @Param('workflowId') workflowId: string,
    @Param('stepId') stepId: string
  ) {
    const workflowExist = await this.notificationTemplateRepository.findByTriggerIdentifier(
      user.environmentId,
      workflowId
    );
    if (!workflowExist) {
      throw new NotFoundException('Workflow not found');
    }
    const step = workflowExist?.steps.find((item) => item.stepId === stepId);

    if (!step || !step._id) {
      throw new NotFoundException('Step not found');
    }

    const result = await this.controlValuesRepository.findOne({
      _environmentId: user.environmentId,
      _organizationId: user.organizationId,
      _workflowId: workflowExist._id,
      _stepId: step._id,
      level: ControlValuesLevelEnum.STEP_CONTROLS,
    });

    return result;
  }

  @Put('/controls/:workflowId/:stepId')
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.WORKFLOW_WRITE)
  async createControls(
    @Param('workflowId') workflowId: string,
    @Param('stepId') stepId: string,
    @UserSession() user: UserSessionData,
    @Body() body: any
  ) {
    return this.storeControlValuesUseCase.execute(
      StoreControlValuesCommand.create({
        stepId,
        workflowId,
        controlValues: body.variables,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
      })
    );
  }

  @Post('/validate')
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.BRIDGE_WRITE)
  async validateBridgeUrl(
    @UserSession() user: UserSessionData,
    @Body() body: ValidateBridgeUrlRequestDto
  ): Promise<ValidateBridgeUrlResponseDto> {
    try {
      const result = await this.getBridgeStatus.execute(
        GetBridgeStatusCommand.create({
          environmentId: user.environmentId,
          statelessBridgeUrl: body.bridgeUrl,
        })
      );

      return { isValid: result.status === 'ok' };
    } catch (err: any) {
      return { isValid: false, error: err.message };
    }
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - templatesDefinitions(templates?.map((i))
 - step(workflowExist?.steps.find((item))
Declaraciones 'export' encontradas:
- export class BridgeController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/bridge.module.ts
Tamao: 2378 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MiddlewareConsumer, Module, NestModule } from '@nestjs/common';
import {
  CreateChange,
  CreateMessageTemplate,
  DeleteMessageTemplate,
  DeletePreferencesUseCase,
  GetPreferences,
  GetWorkflowByIdsUseCase,
  ResourceValidatorService,
  TierRestrictionsValidateUsecase,
  UpdateChange,
  UpdateMessageTemplate,
  UpsertControlValuesUseCase,
  UpsertPreferences,
} from '@novu/application-generic';
import { CommunityOrganizationRepository, PreferencesRepository } from '@novu/dal';
import { OutboundWebhooksModule } from '../outbound-webhooks/outbound-webhooks.module';
import { SharedModule } from '../shared/shared.module';
import { CreateVariablesObject } from '../shared/usecases/create-variables-object/create-variables-object.usecase';
import { CreateWorkflow } from '../workflows-v1/usecases/create-workflow/create-workflow.usecase';
import { DeleteWorkflowUseCase } from '../workflows-v1/usecases/delete-workflow/delete-workflow.usecase';
import { GetWorkflowWithPreferencesUseCase } from '../workflows-v1/usecases/get-workflow-with-preferences/get-workflow-with-preferences.usecase';
import { UpdateWorkflow } from '../workflows-v1/usecases/update-workflow/update-workflow.usecase';
import { BuildVariableSchemaUsecase } from '../workflows-v2/usecases';
import { BuildStepIssuesUsecase } from '../workflows-v2/usecases/build-step-issues/build-step-issues.usecase';
import { BridgeController } from './bridge.controller';
import { USECASES } from './usecases';

const PROVIDERS = [
  CreateWorkflow,
  UpdateWorkflow,
  GetWorkflowByIdsUseCase,
  GetWorkflowWithPreferencesUseCase,
  DeleteWorkflowUseCase,
  UpsertControlValuesUseCase,
  CreateMessageTemplate,
  UpdateMessageTemplate,
  DeleteMessageTemplate,
  CreateChange,
  UpdateChange,
  PreferencesRepository,
  GetPreferences,
  UpsertPreferences,
  DeletePreferencesUseCase,
  UpsertControlValuesUseCase,
  BuildVariableSchemaUsecase,
  CommunityOrganizationRepository,
  CreateVariablesObject,
  BuildStepIssuesUsecase,
  ResourceValidatorService,
  TierRestrictionsValidateUsecase,
];

const MODULES = [SharedModule, OutboundWebhooksModule.forRoot()];

@Module({
  imports: MODULES,
  providers: [...PROVIDERS, ...USECASES],
  controllers: [BridgeController],
  exports: [...USECASES],
})
export class BridgeModule implements NestModule {
  public configure(consumer: MiddlewareConsumer) {}
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BridgeModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/index.ts
Tamao: 76 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { BridgeModule } from './bridge.module';
export * from './usecases';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/dtos/create-bridge-request.dto.ts
Tamao: 275 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsOptional, IsString } from 'class-validator';
import { ICreateBridges, IWorkflowDefine } from '../usecases/sync';

export class CreateBridgeRequestDto implements ICreateBridges {
  workflows: IWorkflowDefine[];

  @IsOptional()
  @IsString()
  bridgeUrl: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class CreateBridgeRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/dtos/create-bridge-response.dto.ts
Tamao: 40 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export class CreateBridgeResponseDto {}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class CreateBridgeResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/dtos/validate-bridge-url-request.dto.ts
Tamao: 240 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsUrl } from 'class-validator';

export class ValidateBridgeUrlRequestDto {
  @ApiProperty()
  @IsUrl({
    require_protocol: true,
    require_tld: false,
  })
  bridgeUrl: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ValidateBridgeUrlRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/dtos/validate-bridge-url-response.dto.ts
Tamao: 196 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class ValidateBridgeUrlResponseDto {
  @ApiProperty()
  isValid: boolean;

  @ApiPropertyOptional()
  error?: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ValidateBridgeUrlResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/e2e/health-check.e2e.ts
Tamao: 2125 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SubscriberEntity } from '@novu/dal';
import { workflow } from '@novu/framework';
import { SubscribersService, UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import getPort from 'get-port';
import { TestBridgeServer } from '../../../../e2e/test-bridge-server';

describe('Bridge Health Check #novu-v2', async () => {
  let session: UserSession;
  let bridgeServer: TestBridgeServer;
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;

  before(async () => {
    const healthCheckWorkflow = workflow('health-check', async ({ step }) => {
      await step.email('send-email', async (controls) => {
        return {
          subject: 'This is an email subject',
          body: 'Body result',
        };
      });
    });
    const port = await getPort();
    bridgeServer = new TestBridgeServer(port);
    await bridgeServer.start({ workflows: [healthCheckWorkflow] });
  });

  after(async () => {
    await bridgeServer.stop();
  });

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
  });

  it('should have a status', async () => {
    const result = await axios.get(`${bridgeServer.serverPath}/novu?action=health-check`);

    expect(result.data.status).to.equal('ok');
  });

  it('should have an sdk version', async () => {
    const result = await axios.get(`${bridgeServer.serverPath}/novu?action=health-check`);

    expect(result.data.sdkVersion).to.be.a('string');
  });

  it('should have a framework version', async () => {
    const result = await axios.get(`${bridgeServer.serverPath}/novu?action=health-check`);

    expect(result.data.frameworkVersion).to.be.a('string');
  });

  it('should return the discovered resources', async () => {
    const result = await axios.get(`${bridgeServer.serverPath}/novu?action=health-check`);

    expect(result.data.discovered).to.deep.equal({ workflows: 1, steps: 1 });
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - healthCheckWorkflow(workflow('health-check', async ({ step }))
 - bridgeServer(new TestBridgeServer(port);
    await bridgeServer.start({ workflows: [healthCheckWorkflow] });
  })...)
 - subscriber(await subscriberService.createSubscriber();
  });

  it('should have a status', async ())
 - action(health-check`);

    expect(result.data.status).to.equal('ok');
  });

  it('should have an sdk vers...)
 - action(health-check`);

    expect(result.data.sdkVersion).to.be.a('string');
  });

  it('should have a fr...)
 - action(health-check`);

    expect(result.data.frameworkVersion).to.be.a('string');
  });

  it('should ret...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/e2e/sync.e2e.ts
Tamao: 24397 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  ControlValuesRepository,
  EnvironmentRepository,
  MessageTemplateRepository,
  NotificationTemplateRepository,
} from '@novu/dal';
import { SeverityLevelEnum, workflow } from '@novu/framework';
import { ResourceOriginEnum, ResourceTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import getPort from 'get-port';
import { TestBridgeServer } from '../../../../e2e/test-bridge-server';

describe('Bridge Sync - /bridge/sync (POST) #novu-v2', async () => {
  let session: UserSession;
  const environmentRepository = new EnvironmentRepository();
  const workflowsRepository = new NotificationTemplateRepository();
  const messageTemplateRepository = new MessageTemplateRepository();
  const controlValuesRepository = new ControlValuesRepository();

  const inputPostPayload = {
    schema: {
      type: 'object',
      properties: {
        showButton: { type: 'boolean', default: true },
      },
    },
  } as const;

  let bridgeServer: TestBridgeServer;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    const port = await getPort();
    bridgeServer = new TestBridgeServer(port);
  });

  afterEach(async () => {
    await bridgeServer.stop();
  });

  it('should update bridge url', async () => {
    await bridgeServer.start({ workflows: [] });

    const result = await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });

    expect(result.body.data?.length).to.equal(0);

    const environment = await environmentRepository.findOne({ _id: session.environment._id });

    expect(environment?.echo.url).to.equal(bridgeServer.serverPath);

    const workflows = await workflowsRepository.find({ _environmentId: session.environment._id });
    expect(workflows.length).to.equal(0);
  });

  it('should create a workflow', async () => {
    const workflowId = 'hello-world';
    const newWorkflow = workflow(
      workflowId,
      async ({ step, payload }) => {
        await step.email(
          'send-email',
          async (controls) => {
            return {
              subject: `This is an email subject ${controls.name}`,
              body: `Body result ${payload.name}`,
            };
          },
          {
            controlSchema: {
              type: 'object',
              properties: {
                name: { type: 'string', default: 'TEST' },
              },
            } as const,
          }
        );
      },
      {
        severity: SeverityLevelEnum.HIGH,
        payloadSchema: {
          type: 'object',
          properties: {
            name: { type: 'string', default: 'default_name' },
          },
          required: [],
          additionalProperties: false,
        } as const,
      }
    );
    await bridgeServer.start({ workflows: [newWorkflow] });

    const result = await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });
    expect(result.body.data?.length).to.equal(1);

    const workflowsCount = await workflowsRepository.find({ _environmentId: session.environment._id });
    const workflowData = await workflowsRepository.findById(result.body.data[0]._id, session.environment._id);

    expect(workflowData).to.be.ok;
    if (!workflowData) {
      throw new Error('Workflow not found');
    }

    expect(workflowsCount.length).to.equal(1);

    expect(workflowData.name).to.equal(workflowId);
    expect(workflowData.type).to.equal(ResourceTypeEnum.BRIDGE);
    expect(workflowData.rawData.workflowId).to.equal(workflowId);
    expect(workflowData.triggers[0].identifier).to.equal(workflowId);

    expect(workflowData.severity).to.equal(SeverityLevelEnum.HIGH);
    expect(workflowData.steps.length).to.equal(1);
    expect(workflowData.steps[0].stepId).to.equal('send-email');
    expect(workflowData.steps[0].uuid).to.equal('send-email');
    expect(workflowData.steps[0].template?.name).to.equal('send-email');
  });

  it('should create a workflow identified by a space-separated identifier', async () => {
    const workflowId = 'My Workflow';
    const spaceSeparatedIdWorkflow = workflow(workflowId, async ({ step }) => {
      await step.email('send-email', () => ({
        subject: 'Welcome!',
        body: 'Hello there',
      }));
    });
    await bridgeServer.start({ workflows: [spaceSeparatedIdWorkflow] });

    const result = await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });
    expect(result.body.data?.length).to.equal(1);

    const workflowsCount = await workflowsRepository.find({ _environmentId: session.environment._id });
    const workflowData = await workflowsRepository.findById(result.body.data[0]._id, session.environment._id);

    expect(workflowData).to.be.ok;
    if (!workflowData) {
      throw new Error('Workflow not found');
    }

    expect(workflowsCount.length).to.equal(1);

    expect(workflowData.name).to.equal(workflowId);
    expect(workflowData.type).to.equal(ResourceTypeEnum.BRIDGE);
    expect(workflowData.rawData.workflowId).to.equal(workflowId);
    expect(workflowData.triggers[0].identifier).to.equal(workflowId);

    expect(workflowData.steps.length).to.equal(1);
    expect(workflowData.steps[0].stepId).to.equal('send-email');
    expect(workflowData.steps[0].uuid).to.equal('send-email');
    expect(workflowData.steps[0].template?.name).to.equal('send-email');
  });

  it('should create a message template', async () => {
    const workflowId = 'hello-world';
    const newWorkflow = workflow(
      workflowId,
      async ({ step, payload }) => {
        await step.email(
          'send-email',
          async (controls) => {
            return {
              subject: 'This is an email subject ',
              body: 'Body result ',
            };
          },
          {
            controlSchema: inputPostPayload.schema,
          }
        );
      },
      {
        payloadSchema: {
          type: 'object',
          properties: {
            name: { type: 'string', default: 'default_name' },
          },
          required: [],
          additionalProperties: false,
        } as const,
      }
    );
    await bridgeServer.start({ workflows: [newWorkflow] });

    const result = await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });
    expect(result.body.data?.length).to.equal(1);

    const workflowsCount = await workflowsRepository.find({ _environmentId: session.environment._id });
    expect(workflowsCount.length).to.equal(1);

    const workflowData = await workflowsRepository.findById(result.body.data[0]._id, session.environment._id);
    expect(workflowData).to.be.ok;
    if (!workflowData) {
      throw new Error('Workflow not found');
    }

    const messageTemplates = await messageTemplateRepository.find({
      _id: workflowData.steps[0]._id,
      _environmentId: session.environment._id,
    });
    expect(messageTemplates.length).to.equal(1);
    const messageTemplatesToTest = messageTemplates[0];

    expect(messageTemplatesToTest.controls).to.deep.equal(inputPostPayload);
  });

  it('should update a workflow', async () => {
    const workflowId = 'hello-world';
    const newWorkflow = workflow(
      workflowId,
      async ({ step, payload }) => {
        await step.email(
          'send-email',
          async (controls) => {
            return {
              subject: `This is an email subject ${controls.name}`,
              body: `Body result ${payload.name}`,
            };
          },
          {
            controlSchema: {
              type: 'object',
              properties: {
                name: { type: 'string', default: 'TEST' },
              },
            } as const,
          }
        );
      },
      {
        payloadSchema: {
          type: 'object',
          properties: {
            name: { type: 'string', default: 'default_name' },
          },
          required: [],
          additionalProperties: false,
        } as const,
      }
    );
    await bridgeServer.start({ workflows: [newWorkflow] });

    await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });

    await bridgeServer.stop();

    bridgeServer = new TestBridgeServer();
    const workflowId2 = 'hello-world-2';
    const newWorkflow2 = workflow(
      workflowId2,
      async ({ step, payload }) => {
        await step.email(
          'send-email-2',
          async (controls) => {
            return {
              subject: `This is an email subject ${controls.name}`,
              body: `Body result ${payload.name}`,
            };
          },
          {
            controlSchema: {
              type: 'object',
              properties: {
                name: { type: 'string', default: 'TEST' },
              },
            } as const,
          }
        );

        await step.sms('send-sms-2', async () => {
          return {
            body: 'test',
          };
        });
      },
      {
        payloadSchema: {
          type: 'object',
          properties: {
            name: { type: 'string', default: 'default_name' },
          },
          required: [],
          additionalProperties: false,
        } as const,
      }
    );
    await bridgeServer.start({ workflows: [newWorkflow2] });

    await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });

    const workflows = await workflowsRepository.find({ _environmentId: session.environment._id });
    expect(workflows.length).to.equal(1);

    const workflowData = workflows[0];

    expect(workflowData.name).to.equal(workflowId2);
    expect(workflowData.type).to.equal(ResourceTypeEnum.BRIDGE);
    expect(workflowData.rawData.workflowId).to.equal(workflowId2);
    expect(workflowData.triggers[0].identifier).to.equal(workflowId2);

    expect(workflowData.steps[0].stepId).to.equal('send-email-2');
    expect(workflowData.steps[0].uuid).to.equal('send-email-2');
    expect(workflowData.steps[0].name).to.equal('send-email-2');

    expect(workflowData.steps[1].stepId).to.equal('send-sms-2');
    expect(workflowData.steps[1].uuid).to.equal('send-sms-2');
    expect(workflowData.steps[1].name).to.equal('send-sms-2');
  });

  it('should create workflow preferences', async () => {
    const workflowId = 'hello-world-preferences';
    const newWorkflow = workflow(
      workflowId,
      async ({ step }) => {
        await step.inApp('send-in-app', () => ({
          subject: 'Welcome!',
          body: 'Hello there',
        }));
      },
      {
        preferences: {
          all: {
            enabled: false,
            readOnly: true,
          },
          channels: {
            inApp: {
              enabled: true,
            },
          },
        },
      }
    );
    await bridgeServer.start({ workflows: [newWorkflow] });

    const result = await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });

    const dashboardPreferences = {
      all: { enabled: false, readOnly: true },
      channels: {
        email: { enabled: true },
        sms: { enabled: true },
        inApp: { enabled: false },
        chat: { enabled: true },
        push: { enabled: true },
      },
    };

    await session.testAgent.post(`/v1/preferences`).send({
      preferences: dashboardPreferences,
      workflowId: result.body.data[0]._id,
    });

    const response = await session.testAgent
      .get('/v1/inbox/preferences')
      .set('Authorization', `Bearer ${session.subscriberToken}`);

    expect(response.status).to.equal(200);
  });

  it('should create a workflow with a name', async () => {
    const workflowId = 'hello-world-description';
    const newWorkflow = workflow(
      workflowId,
      async ({ step }) => {
        await step.email('send-email', () => ({
          subject: 'Welcome!',
          body: 'Hello there',
        }));
      },
      {
        name: 'My Workflow',
      }
    );
    await bridgeServer.start({ workflows: [newWorkflow] });

    const result = await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });

    const workflows = await workflowsRepository.find({
      _environmentId: session.environment._id,
      _id: result.body.data[0]._id,
    });
    expect(workflows.length).to.equal(1);

    const workflowData = workflows[0];
    expect(workflowData.name).to.equal('My Workflow');
  });

  it('should create a workflow with a name that defaults to the workflowId', async () => {
    const workflowId = 'hello-world-description';
    const newWorkflow = workflow(workflowId, async ({ step }) => {
      await step.email('send-email', () => ({
        subject: 'Welcome!',
        body: 'Hello there',
      }));
    });
    await bridgeServer.start({ workflows: [newWorkflow] });

    const result = await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });

    const workflows = await workflowsRepository.find({
      _environmentId: session.environment._id,
      _id: result.body.data[0]._id,
    });
    expect(workflows.length).to.equal(1);

    const workflowData = workflows[0];
    expect(workflowData.name).to.equal(workflowId);
  });

  it('should preserve the original workflow resource when syncing a workflow that has added a name', async () => {
    const workflowId = 'hello-world-description';
    const newWorkflow = workflow(workflowId, async ({ step }) => {
      await step.email('send-email', () => ({
        subject: 'Welcome!',
        body: 'Hello there',
      }));
    });
    await bridgeServer.start({ workflows: [newWorkflow] });

    const result = await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });
    const workflowDbId = result.body.data[0]._id;

    const workflows = await workflowsRepository.find({
      _environmentId: session.environment._id,
      _id: workflowDbId,
    });
    expect(workflows.length).to.equal(1);

    const workflowData = workflows[0];
    expect(workflowData.name).to.equal(workflowId);

    await bridgeServer.stop();

    bridgeServer = new TestBridgeServer();
    const newWorkflowWithName = workflow(
      workflowId,
      async ({ step }) => {
        await step.email('send-email', () => ({
          subject: 'Welcome!',
          body: 'Hello there',
        }));
      },
      {
        name: 'My Workflow',
      }
    );
    await bridgeServer.start({ workflows: [newWorkflowWithName] });

    await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });

    const workflowsWithName = await workflowsRepository.find({
      _environmentId: session.environment._id,
      _id: workflowDbId,
    });
    expect(workflowsWithName.length).to.equal(1);

    const workflowDataWithName = workflowsWithName[0];
    expect(workflowDataWithName.name).to.equal('My Workflow');
  });

  it('should create a workflow with a description', async () => {
    const workflowId = 'hello-world-description';
    const newWorkflow = workflow(
      workflowId,
      async ({ step }) => {
        await step.email('send-email', () => ({
          subject: 'Welcome!',
          body: 'Hello there',
        }));
      },
      {
        description: 'This is a description',
      }
    );
    await bridgeServer.start({ workflows: [newWorkflow] });

    const result = await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });

    const workflows = await workflowsRepository.find({
      _environmentId: session.environment._id,
      _id: result.body.data[0]._id,
    });
    expect(workflows.length).to.equal(1);

    const workflowData = workflows[0];
    expect(workflowData.description).to.equal('This is a description');
  });

  it('should unset the workflow description after the description is removed', async () => {
    const workflowId = 'hello-world-description';
    const newWorkflow = workflow(
      workflowId,
      async ({ step }) => {
        await step.email('send-email', () => ({
          subject: 'Welcome!',
          body: 'Hello there',
        }));
      },
      {
        description: 'This is a description',
      }
    );
    await bridgeServer.start({ workflows: [newWorkflow] });

    const result = await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });
    const workflowDbId = result.body.data[0]._id;
    const workflows = await workflowsRepository.find({
      _environmentId: session.environment._id,
      _id: workflowDbId,
    });
    expect(workflows.length).to.equal(1);

    const workflowData = workflows[0];
    expect(workflowData.description).to.equal('This is a description');

    await bridgeServer.stop();

    bridgeServer = new TestBridgeServer();
    const newWorkflowWithName = workflow(workflowId, async ({ step }) => {
      await step.email('send-email', () => ({
        subject: 'Welcome!',
        body: 'Hello there',
      }));
    });
    await bridgeServer.start({ workflows: [newWorkflowWithName] });

    await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });

    const workflowsWithDescription = await workflowsRepository.find({
      _environmentId: session.environment._id,
      _id: workflowDbId,
    });
    expect(workflowsWithDescription.length).to.equal(1);

    const workflowDataWithName = workflowsWithDescription[0];
    expect(workflowDataWithName.description).to.equal('');
  });

  it('should preserve control values across workflow syncs', async () => {
    const workflowId = 'My Workflow';
    const spaceSeparatedIdWorkflow = workflow(workflowId, async ({ step }) => {
      await step.email('send-email', () => ({
        subject: 'Welcome!',
        body: 'Hello there',
      }));
    });
    await bridgeServer.start({ workflows: [spaceSeparatedIdWorkflow] });

    const firstSyncResponse = await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });
    expect(firstSyncResponse.body.data?.length).to.equal(1);

    const firstWorkflowCountResponse = await workflowsRepository.count({ _environmentId: session.environment._id });
    expect(firstWorkflowCountResponse).to.equal(1);

    const firstWorkflowResponse = await workflowsRepository.findById(
      firstSyncResponse.body.data[0]._id,
      session.environment._id
    );

    expect(firstWorkflowResponse).to.be.ok;
    if (!firstWorkflowResponse) {
      throw new Error('Workflow not found');
    }

    expect(firstWorkflowResponse.name).to.equal(workflowId);
    expect(firstWorkflowResponse.type).to.equal(ResourceTypeEnum.BRIDGE);
    expect(firstWorkflowResponse.rawData.workflowId).to.equal(workflowId);
    expect(firstWorkflowResponse.triggers[0].identifier).to.equal(workflowId);

    expect(firstWorkflowResponse.steps.length).to.equal(1);
    expect(firstWorkflowResponse.steps[0].stepId).to.equal('send-email');
    expect(firstWorkflowResponse.steps[0]._templateId).to.exist;

    await session.testAgent.put(`/v1/bridge/controls/${workflowId}/send-email`).send({
      variables: { subject: 'Hello World again' },
    });

    const firstControlValueResponse = await controlValuesRepository.find({
      _environmentId: session.environment._id,
      _workflowId: firstWorkflowResponse._id,
    });

    expect(firstControlValueResponse.length).to.equal(1);
    expect(firstControlValueResponse[0].controls.subject).to.equal('Hello World again');

    const firstStepResponse = await session.testAgent.get(`/v1/bridge/controls/${workflowId}/send-email`);
    expect(firstStepResponse.body.data.controls.subject).to.equal('Hello World again');

    const secondSyncResponse = await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });
    expect(secondSyncResponse.body.data?.length).to.equal(1);

    const secondWorkflowCountResponse = await workflowsRepository.count({ _environmentId: session.environment._id });
    expect(secondWorkflowCountResponse).to.equal(1);

    const secondWorkflowResponse = await workflowsRepository.findById(
      firstSyncResponse.body.data[0]._id,
      session.environment._id
    );

    expect(secondWorkflowResponse).to.be.ok;
    if (!secondWorkflowResponse) {
      throw new Error('Workflow not found');
    }

    expect(secondWorkflowResponse.name).to.equal(workflowId);
    expect(secondWorkflowResponse.type).to.equal(ResourceTypeEnum.BRIDGE);
    expect(secondWorkflowResponse.rawData.workflowId).to.equal(workflowId);
    expect(secondWorkflowResponse.triggers[0].identifier).to.equal(workflowId);

    expect(secondWorkflowResponse.steps.length).to.equal(1);
    expect(secondWorkflowResponse.steps[0].stepId).to.equal('send-email');
    expect(secondWorkflowResponse.steps[0]._templateId).to.exist;

    const secondControlValueResponse = await controlValuesRepository.find({
      _environmentId: session.environment._id,
      _workflowId: secondWorkflowResponse._id,
    });

    expect(secondControlValueResponse.length).to.equal(1);
    expect(secondControlValueResponse[0].controls.subject).to.equal('Hello World again');

    const secondStepResponse = await session.testAgent.get(`/v1/bridge/controls/${workflowId}/send-email`);
    expect(secondStepResponse.body.data.controls.subject).to.equal('Hello World again');
  });

  it('should throw an error when trying to sync a workflow with an ID that exists in dashboard', async () => {
    const workflowId = 'dashboard-created-workflow';

    // First create a workflow directly (simulating dashboard creation)
    const dashboardWorkflow = await workflowsRepository.create({
      _environmentId: session.environment._id,
      name: workflowId,
      triggers: [{ identifier: workflowId, type: 'event', variables: [] }],
      steps: [],
      active: true,
      draft: false,
      workflowId,
      origin: ResourceOriginEnum.NOVU_CLOUD,
    });

    // Now try to sync a workflow with the same ID through bridge
    const newWorkflow = workflow(workflowId, async ({ step }) => {
      await step.email('send-email', () => ({
        subject: 'Welcome!',
        body: 'Hello there',
      }));
    });
    await bridgeServer.start({ workflows: [newWorkflow] });

    const result = await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });

    expect(result.status).to.equal(400);
    expect(result.body.message).to.contain(`was already created in Dashboard. Please use another workflowId.`);

    // Verify the original workflow wasn't modified
    const workflows = await workflowsRepository.findOne({
      _environmentId: session.environment._id,
      _id: dashboardWorkflow._id,
    });
    expect(workflows).to.deep.equal(dashboardWorkflow);
  });

  it('should allow syncing a workflow with same ID if original was created externally', async () => {
    const workflowId = 'external-created-workflow';

    // First create a workflow as external
    const externalWorkflow = await workflowsRepository.create({
      _environmentId: session.environment._id,
      name: workflowId,
      triggers: [{ identifier: workflowId, type: 'event', variables: [] }],
      steps: [],
      active: true,
      draft: false,
      workflowId,
      origin: ResourceOriginEnum.EXTERNAL,
    });

    // Now try to sync a workflow with the same ID through bridge
    const newWorkflow = workflow(workflowId, async ({ step }) => {
      await step.email('send-email', () => ({
        subject: 'Updated Welcome!',
        body: 'Updated Hello there',
      }));
    });
    await bridgeServer.start({ workflows: [newWorkflow] });

    const result = await session.testAgent.post(`/v1/bridge/sync`).send({
      bridgeUrl: bridgeServer.serverPath,
    });

    expect(result.status).to.equal(201);

    // Verify the workflow was updated
    const workflows = await workflowsRepository.findOne({
      _environmentId: session.environment._id,
      _id: externalWorkflow._id,
    });
    expect(workflows?.origin).to.equal(ResourceOriginEnum.EXTERNAL);
    expect(workflows?.steps[0]?.stepId).to.equal('send-email');
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - inputPostPayload({
    schema: {
      type: 'object',
      properties: {
        showButton: { type: 'boolean', def...)
 - bridgeServer(new TestBridgeServer(port);
  });

  afterEach(async ())
 - workflows(await workflowsRepository.find({ _environmentId: session.environment._id });
    expect(workflows.le...)
 - newWorkflow(workflow(
      workflowId,
      async ({ step, payload }))
 - workflowData(await workflowsRepository.findById(result.body.data[0]._id, session.environment._id);

    expect(wo...)
 - spaceSeparatedIdWorkflow(workflow(workflowId, async ({ step }))
 - workflowData(await workflowsRepository.findById(result.body.data[0]._id, session.environment._id);

    expect(wo...)
 - newWorkflow(workflow(
      workflowId,
      async ({ step, payload }))
 - messageTemplatesToTest(messageTemplates[0];

    expect(messageTemplatesToTest.controls).to.deep.equal(inputPostPayload);
 ...)
 - newWorkflow(workflow(
      workflowId,
      async ({ step, payload }))
 - newWorkflow2(workflow(
      workflowId2,
      async ({ step, payload }))
 - workflowData(workflows[0];

    expect(workflowData.name).to.equal(workflowId2);
    expect(workflowData.type).to...)
 - newWorkflow(workflow(
      workflowId,
      async ({ step }))
 - response(await session.testAgent
      .get('/v1/inbox/preferences')
      .set('Authorization', `Bearer ${se...)
 - newWorkflow(workflow(
      workflowId,
      async ({ step }))
 - workflowData(workflows[0];
    expect(workflowData.name).to.equal('My Workflow');
  });

  it('should create a wo...)
 - newWorkflow(workflow(workflowId, async ({ step }))
 - workflowData(workflows[0];
    expect(workflowData.name).to.equal(workflowId);
  });

  it('should preserve the o...)
 - newWorkflow(workflow(workflowId, async ({ step }))
 - newWorkflowWithName(workflow(
      workflowId,
      async ({ step }))
 - workflowDataWithName(workflowsWithName[0];
    expect(workflowDataWithName.name).to.equal('My Workflow');
  });

  it('sh...)
 - newWorkflow(workflow(
      workflowId,
      async ({ step }))
 - workflowData(workflows[0];
    expect(workflowData.description).to.equal('This is a description');
  });

  it('s...)
 - newWorkflow(workflow(
      workflowId,
      async ({ step }))
 - newWorkflowWithName(workflow(workflowId, async ({ step }))
 - workflowDataWithName(workflowsWithDescription[0];
    expect(workflowDataWithName.description).to.equal('');
  });

  it(...)
 - spaceSeparatedIdWorkflow(workflow(workflowId, async ({ step }))
 - secondStepResponse(await session.testAgent.get(`/v1/bridge/controls/${workflowId}/send-email`);
    expect(secondStepRe...)
 - newWorkflow(workflow(workflowId, async ({ step }))
 - workflows(await workflowsRepository.findOne({
      _environmentId: session.environment._id,
      _id: dashbo...)
 - newWorkflow(workflow(workflowId, async ({ step }))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/usecases/index.ts
Tamao: 290 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { GetBridgeStatus } from './get-bridge-status';
import { PreviewStep } from './preview-step';
import { StoreControlValuesUseCase } from './store-control-values';
import { Sync } from './sync';

export const USECASES = [GetBridgeStatus, PreviewStep, StoreControlValuesUseCase, Sync];


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/usecases/get-bridge-status/get-bridge-status.command.ts
Tamao: 173 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentLevelCommand } from '@novu/application-generic';

export class GetBridgeStatusCommand extends EnvironmentLevelCommand {
  statelessBridgeUrl?: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetBridgeStatusCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/usecases/get-bridge-status/get-bridge-status.usecase.ts
Tamao: 998 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { ExecuteBridgeRequest, ExecuteBridgeRequestCommand, ExecuteBridgeRequestDto } from '@novu/application-generic';
import { GetActionEnum, HealthCheck } from '@novu/framework/internal';
import { ResourceOriginEnum } from '@novu/shared';
import { GetBridgeStatusCommand } from './get-bridge-status.command';

export const LOG_CONTEXT = 'GetBridgeStatusUsecase';

@Injectable()
export class GetBridgeStatus {
  constructor(private executeBridgeRequest: ExecuteBridgeRequest) {}

  async execute(command: GetBridgeStatusCommand): Promise<HealthCheck> {
    return (await this.executeBridgeRequest.execute(
      ExecuteBridgeRequestCommand.create({
        environmentId: command.environmentId,
        action: GetActionEnum.HEALTH_CHECK,
        workflowOrigin: ResourceOriginEnum.EXTERNAL,
        statelessBridgeUrl: command.statelessBridgeUrl,
        retriesLimit: 1,
      })
    )) as ExecuteBridgeRequestDto<GetActionEnum.HEALTH_CHECK>;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export  const
- export class GetBridgeStatus

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/usecases/get-bridge-status/index.ts
Tamao: 133 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { GetBridgeStatusCommand } from './get-bridge-status.command';
export { GetBridgeStatus } from './get-bridge-status.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/usecases/preview-step/index.ts
Tamao: 115 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { PreviewStepCommand } from './preview-step.command';
export { PreviewStep } from './preview-step.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/usecases/preview-step/preview-step.command.ts
Tamao: 842 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '@novu/application-generic';
import { ContextResolved } from '@novu/framework/internal';
import { JobStatusEnum, ResourceOriginEnum } from '@novu/shared';
import { SubscriberResponseDtoOptional } from '../../../subscribers/dtos';

export class PreviewStepCommand extends EnvironmentWithUserCommand {
  workflowId: string;
  stepId: string;
  controls: Record<string, unknown>;
  payload: Record<string, unknown>;
  context?: ContextResolved;
  subscriber?: SubscriberResponseDtoOptional;
  workflowOrigin: ResourceOriginEnum;
  state?: FrameworkPreviousStepsOutputState[];
  skipLayoutRendering?: boolean;
  layoutId?: string;
}
export type FrameworkPreviousStepsOutputState = {
  stepId: string;
  outputs: Record<string, unknown>;
  state: {
    status: JobStatusEnum;
    error?: string;
  };
};


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class PreviewStepCommand
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/usecases/preview-step/preview-step.usecase.ts
Tamao: 1742 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { ExecuteBridgeRequest, ExecuteBridgeRequestCommand, InstrumentUsecase } from '@novu/application-generic';
import { Event, ExecuteOutput, HttpQueryKeysEnum, PostActionEnum } from '@novu/framework/internal';

import { PreviewStepCommand } from './preview-step.command';

@Injectable()
export class PreviewStep {
  constructor(private executeBridgeRequest: ExecuteBridgeRequest) {}

  @InstrumentUsecase()
  async execute(command: PreviewStepCommand): Promise<ExecuteOutput> {
    const event = this.buildBridgeEventPayload(command);
    const executeCommand = this.createExecuteCommand(command, event);

    const bridgeResult = await this.executeBridgeRequest.execute(executeCommand);

    return bridgeResult as ExecuteOutput;
  }

  private createExecuteCommand(command: PreviewStepCommand, event: Event) {
    return ExecuteBridgeRequestCommand.create({
      environmentId: command.environmentId,
      action: PostActionEnum.PREVIEW,
      event,
      searchParams: {
        [HttpQueryKeysEnum.WORKFLOW_ID]: command.workflowId,
        [HttpQueryKeysEnum.STEP_ID]: command.stepId,
        layoutId: command.layoutId,
        skipLayoutRendering: command.skipLayoutRendering ? 'true' : 'false',
      },
      workflowOrigin: command.workflowOrigin,
      retriesLimit: 1,
    });
  }

  private buildBridgeEventPayload(command: PreviewStepCommand): Event {
    return {
      controls: command.controls || {},
      payload: command.payload || {},
      state: command.state || [],
      subscriber: command.subscriber || {},
      context: command.context || {},
      stepId: command.stepId,
      workflowId: command.workflowId,
      action: PostActionEnum.PREVIEW,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class PreviewStep

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/usecases/store-control-values/index.ts
Tamao: 96 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './store-control-values.command';
export * from './store-control-values.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/usecases/store-control-values/store-control-values.command.ts
Tamao: 233 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '@novu/application-generic';

export class StoreControlValuesCommand extends EnvironmentWithUserCommand {
  stepId: string;
  workflowId: string;
  controlValues: Record<string, unknown>;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class StoreControlValuesCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/usecases/store-control-values/store-control-values.usecase.ts
Tamao: 1444 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { UpsertControlValuesCommand, UpsertControlValuesUseCase } from '@novu/application-generic';
import { NotificationTemplateRepository } from '@novu/dal';
import { ControlValuesLevelEnum } from '@novu/shared';
import { StoreControlValuesCommand } from './store-control-values.command';

@Injectable()
export class StoreControlValuesUseCase {
  constructor(
    private notificationTemplateRepository: NotificationTemplateRepository,
    private upsertControlValuesUseCase: UpsertControlValuesUseCase
  ) {}

  async execute(command: StoreControlValuesCommand) {
    const workflowExist = await this.notificationTemplateRepository.findByTriggerIdentifier(
      command.environmentId,
      command.workflowId
    );

    if (!workflowExist) {
      throw new NotFoundException('Workflow not found');
    }

    const step = workflowExist?.steps.find((item) => item.stepId === command.stepId);

    if (!step || !step._id) {
      throw new NotFoundException('Step not found');
    }

    return await this.upsertControlValuesUseCase.execute(
      UpsertControlValuesCommand.create({
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        stepId: step._templateId,
        workflowId: workflowExist._id,
        level: ControlValuesLevelEnum.STEP_CONTROLS,
        newControlValues: command.controlValues,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - step(workflowExist?.steps.find((item))
Declaraciones 'export' encontradas:
- export class StoreControlValuesUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/usecases/sync/index.ts
Tamao: 64 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './sync.command';
export * from './sync.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/usecases/sync/sync.command.ts
Tamao: 1740 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand, IStepControl } from '@novu/application-generic';
import type { CustomDataType, IPreferenceChannels, JSONSchemaDto, StepType } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsDefined, IsOptional, IsString, ValidateNested } from 'class-validator';

interface IStepOutput {
  schema: JSONSchemaDto;
}

interface IWorkflowDefineStep {
  stepId: string;

  type: StepType;

  controls: IStepControl;

  outputs: IStepOutput;

  description: string;

  preferenceSettings?: IPreferenceChannels;

  data?: CustomDataType;
}

interface IStepDefineOptions {
  version: `${number}.${number}.${number}`;
  failOnErrorEnabled: boolean;
  skip: boolean;
  active?: boolean;
}

class WorkflowDefineStep implements IWorkflowDefineStep {
  description: string;
  preferenceSettings?: any;
  data?: any;
  @IsString()
  stepId: string;

  @IsString()
  type: StepType;

  controls: IStepControl;

  outputs: IStepOutput;

  code: string;
}

export interface IWorkflowDefine {
  workflowId: string;

  code: string;

  steps: IWorkflowDefineStep[];

  controls?: IStepControl;
}

export class WorkflowDefine implements IWorkflowDefine {
  @IsString()
  workflowId: string;

  code: string;

  @ValidateNested({ each: true })
  @Type(() => WorkflowDefineStep)
  steps: IWorkflowDefineStep[];

  controls?: IStepControl;
}

export interface ICreateBridges {
  workflows?: IWorkflowDefine[];
}

export class SyncCommand extends EnvironmentWithUserCommand implements ICreateBridges {
  @IsOptional()
  @ValidateNested({ each: true })
  @Type(() => WorkflowDefine)
  workflows?: WorkflowDefine[];

  @IsString()
  @IsDefined()
  bridgeUrl: string;

  @IsOptional()
  @IsString()
  source?: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export  interface
- export class WorkflowDefine
- export  interface
- export class SyncCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/bridge/usecases/sync/sync.usecase.ts
Tamao: 13179 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, HttpException, Injectable } from '@nestjs/common';
import { AnalyticsService, ExecuteBridgeRequest, JSONSchema, NotificationStep } from '@novu/application-generic';
import {
  EnvironmentEntity,
  EnvironmentRepository,
  NotificationGroupRepository,
  NotificationTemplateEntity,
  NotificationTemplateRepository,
} from '@novu/dal';
import { DiscoverOutput, DiscoverStepOutput, DiscoverWorkflowOutput, GetActionEnum } from '@novu/framework/internal';
import {
  buildWorkflowPreferences,
  ResourceOriginEnum,
  ResourceTypeEnum,
  SeverityLevelEnum,
  StepTypeEnum,
  UserSessionData,
  WorkflowCreationSourceEnum,
  WorkflowPreferences,
} from '@novu/shared';
import { JSONSchemaDto } from '../../../shared/dtos/json-schema.dto';
import { CreateWorkflowCommand } from '../../../workflows-v1/usecases/create-workflow/create-workflow.command';
import { CreateWorkflow } from '../../../workflows-v1/usecases/create-workflow/create-workflow.usecase';
import { DeleteWorkflowCommand } from '../../../workflows-v1/usecases/delete-workflow/delete-workflow.command';
import { DeleteWorkflowUseCase } from '../../../workflows-v1/usecases/delete-workflow/delete-workflow.usecase';
import { UpdateWorkflowCommand } from '../../../workflows-v1/usecases/update-workflow/update-workflow.command';
import { UpdateWorkflow } from '../../../workflows-v1/usecases/update-workflow/update-workflow.usecase';
import { StepIssuesDto } from '../../../workflows-v2/dtos';
import { computeWorkflowStatus } from '../../../workflows-v2/shared/compute-workflow-status';
import { BuildStepIssuesUsecase } from '../../../workflows-v2/usecases/build-step-issues/build-step-issues.usecase';
import { CreateBridgeResponseDto } from '../../dtos/create-bridge-response.dto';
import { SyncCommand } from './sync.command';

@Injectable()
export class Sync {
  constructor(
    private createWorkflowUsecase: CreateWorkflow,
    private updateWorkflowUsecase: UpdateWorkflow,
    private deleteWorkflowUseCase: DeleteWorkflowUseCase,
    private notificationTemplateRepository: NotificationTemplateRepository,
    private notificationGroupRepository: NotificationGroupRepository,
    private environmentRepository: EnvironmentRepository,
    private executeBridgeRequest: ExecuteBridgeRequest,
    private buildStepIssuesUsecase: BuildStepIssuesUsecase,
    private analyticsService: AnalyticsService
  ) {}
  async execute(command: SyncCommand): Promise<CreateBridgeResponseDto> {
    const environment = await this.findEnvironment(command);
    const discover = await this.executeDiscover(command);
    this.sendAnalytics(command, environment, discover);
    const persistedWorkflowsInBridge = await this.processWorkflows(command, discover.workflows);

    await this.disposeOldWorkflows(command, persistedWorkflowsInBridge);
    await this.updateBridgeUrl(command);

    return persistedWorkflowsInBridge;
  }

  private sendAnalytics(command: SyncCommand, environment: EnvironmentEntity, discover: DiscoverOutput) {
    if (command.source !== 'sample-workspace') {
      this.analyticsService.track('Sync Request - [Bridge API]', command.userId, {
        _organization: command.organizationId,
        _environment: command.environmentId,
        environmentName: environment.name,
        workflowsCount: discover.workflows?.length || 0,
        localEnvironment: !!command.bridgeUrl?.includes('novu.sh'),
        source: command.source,
      });
    }
  }

  private async executeDiscover(command: SyncCommand): Promise<DiscoverOutput> {
    let discover: DiscoverOutput | undefined;
    try {
      discover = (await this.executeBridgeRequest.execute({
        statelessBridgeUrl: command.bridgeUrl,
        environmentId: command.environmentId,
        action: GetActionEnum.DISCOVER,
        retriesLimit: 1,
        workflowOrigin: ResourceOriginEnum.EXTERNAL,
      })) as DiscoverOutput;
    } catch (error) {
      if (error instanceof HttpException) {
        throw new BadRequestException(error.message);
      }

      throw error;
    }

    if (!discover) {
      throw new BadRequestException('Invalid Bridge URL Response');
    }

    return discover;
  }

  private async findEnvironment(command: SyncCommand): Promise<EnvironmentEntity> {
    const environment = await this.environmentRepository.findOne({ _id: command.environmentId });

    if (!environment) {
      throw new BadRequestException('Environment not found');
    }

    return environment;
  }

  private async updateBridgeUrl(command: SyncCommand): Promise<void> {
    await this.environmentRepository.update(
      { _id: command.environmentId },
      {
        $set: {
          echo: {
            url: command.bridgeUrl,
          },
          bridge: {
            url: command.bridgeUrl,
          },
        },
      }
    );
  }

  private async disposeOldWorkflows(
    command: SyncCommand,
    createdWorkflows: NotificationTemplateEntity[]
  ): Promise<void> {
    const persistedWorkflowIdsInBridge = createdWorkflows.map((i) => i._id);
    const workflowsToDelete = await this.findAllWorkflowsWithOtherIds(command, persistedWorkflowIdsInBridge);
    const deleteWorkflowFromStoragePromises = workflowsToDelete.map((workflow) =>
      this.deleteWorkflowUseCase.execute(
        DeleteWorkflowCommand.create({
          environmentId: command.environmentId,
          organizationId: command.organizationId,
          userId: command.userId,
          workflowIdOrInternalId: workflow._id,
        })
      )
    );

    await Promise.all([...deleteWorkflowFromStoragePromises]);
  }

  private async findAllWorkflowsWithOtherIds(
    command: SyncCommand,
    persistedWorkflowIdsInBridge: string[]
  ): Promise<NotificationTemplateEntity[]> {
    return await this.notificationTemplateRepository.find({
      _environmentId: command.environmentId,
      type: {
        $in: [ResourceTypeEnum.ECHO, ResourceTypeEnum.BRIDGE],
      },
      origin: {
        $in: [ResourceOriginEnum.EXTERNAL, undefined, null],
      },
      _id: { $nin: persistedWorkflowIdsInBridge },
    });
  }

  private async processWorkflows(
    command: SyncCommand,
    workflowsFromBridge: DiscoverWorkflowOutput[]
  ): Promise<NotificationTemplateEntity[]> {
    const existingFrameworkWorkflows = await Promise.all(
      workflowsFromBridge.map((workflow) =>
        this.notificationTemplateRepository.findByTriggerIdentifier(command.environmentId, workflow.workflowId)
      )
    );

    existingFrameworkWorkflows.forEach((workflow, index) => {
      if (workflow?.origin && workflow.origin !== ResourceOriginEnum.EXTERNAL) {
        const { workflowId } = workflowsFromBridge[index];
        throw new BadRequestException(
          `Workflow ${workflowId} was already created in Dashboard. Please use another workflowId.`
        );
      }
    });

    return Promise.all(
      workflowsFromBridge.map(async (workflow, index) => {
        const existingFrameworkWorkflow = existingFrameworkWorkflows[index];

        return await this.upsertWorkflow(command, workflow, existingFrameworkWorkflow);
      })
    );
  }

  private async upsertWorkflow(
    command: SyncCommand,
    workflow: DiscoverWorkflowOutput,
    existingFrameworkWorkflow: NotificationTemplateEntity | null
  ): Promise<NotificationTemplateEntity> {
    if (existingFrameworkWorkflow) {
      return await this.updateWorkflowUsecase.execute(
        UpdateWorkflowCommand.create(
          await this.mapDiscoverWorkflowToUpdateWorkflowCommand(existingFrameworkWorkflow, command, workflow)
        )
      );
    }

    return await this.createWorkflow(command, workflow);
  }

  private async createWorkflow(
    command: SyncCommand,
    workflow: DiscoverWorkflowOutput
  ): Promise<NotificationTemplateEntity> {
    const notificationGroupId = await this.getNotificationGroup(
      this.castToAnyNotSupportedParam(workflow)?.notificationGroupId,
      command.environmentId
    );

    if (!notificationGroupId) {
      throw new BadRequestException('Notification group not found');
    }
    const steps = await this.mapSteps(command, workflow.steps);
    const workflowActive = this.castToAnyNotSupportedParam(workflow)?.active ?? true;

    return await this.createWorkflowUsecase.execute(
      CreateWorkflowCommand.create({
        origin: ResourceOriginEnum.EXTERNAL,
        type: ResourceTypeEnum.BRIDGE,
        notificationGroupId,
        draft: workflowActive,
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        userId: command.userId,
        name: this.getWorkflowName(workflow),
        triggerIdentifier: workflow.workflowId,
        __source: WorkflowCreationSourceEnum.BRIDGE,
        steps,
        controls: {
          schema: workflow.controls?.schema as unknown as JSONSchema,
        },
        rawData: workflow as unknown as Record<string, unknown>,
        payloadSchema: workflow.payload?.schema as unknown as JSONSchema,
        active: workflowActive,
        status: computeWorkflowStatus(workflowActive, steps),
        description: this.getWorkflowDescription(workflow),
        severity: workflow.severity || SeverityLevelEnum.NONE,
        data: this.castToAnyNotSupportedParam(workflow)?.data,
        tags: this.getWorkflowTags(workflow),
        defaultPreferences: this.getWorkflowPreferences(workflow),
      })
    );
  }

  private async mapDiscoverWorkflowToUpdateWorkflowCommand(
    workflowExist: NotificationTemplateEntity,
    command: SyncCommand,
    workflow: DiscoverWorkflowOutput
  ): Promise<UpdateWorkflowCommand> {
    const steps = await this.mapSteps(command, workflow.steps, workflowExist);
    const workflowActive = this.castToAnyNotSupportedParam(workflow)?.active ?? true;

    return {
      id: workflowExist._id,
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      userId: command.userId,
      name: this.getWorkflowName(workflow),
      workflowId: workflow.workflowId,
      steps,
      controls: {
        schema: workflow.controls?.schema as unknown as JSONSchemaDto,
      },
      rawData: workflow,
      payloadSchema: workflow.payload?.schema as unknown as JSONSchemaDto,
      type: ResourceTypeEnum.BRIDGE,
      description: this.getWorkflowDescription(workflow),
      data: this.castToAnyNotSupportedParam(workflow)?.data,
      tags: this.getWorkflowTags(workflow),
      active: workflowActive,
      status: computeWorkflowStatus(workflowActive, steps),
      defaultPreferences: this.getWorkflowPreferences(workflow),
    };
  }

  private async mapSteps(
    command: SyncCommand,
    commandWorkflowSteps: DiscoverStepOutput[],
    workflow?: NotificationTemplateEntity | undefined
  ): Promise<NotificationStep[]> {
    return Promise.all(
      commandWorkflowSteps.map(async (step: DiscoverStepOutput) => {
        const foundStep = workflow?.steps?.find((workflowStep) => workflowStep.stepId === step.stepId);

        const issues: StepIssuesDto = await this.buildStepIssuesUsecase.execute({
          workflowOrigin: ResourceOriginEnum.EXTERNAL,
          user: {
            _id: command.userId,
            environmentId: command.environmentId,
            organizationId: command.organizationId,
          } as UserSessionData,
          stepInternalId: foundStep?._id,
          workflow,
          stepType: step.type as StepTypeEnum,
          controlSchema: step.controls?.schema as unknown as JSONSchemaDto,
        });

        const template = {
          _id: foundStep?._id,
          type: step.type,
          name: step.stepId,
          controls: step.controls,
          output: step.outputs,
          options: step.options,
          code: step.code,
        };

        return {
          template,
          name: step.stepId,
          stepId: step.stepId,
          uuid: step.stepId,
          _templateId: foundStep?._templateId,
          shouldStopOnFail: this.castToAnyNotSupportedParam(step.options)?.failOnErrorEnabled ?? false,
          issues,
        };
      })
    );
  }

  private async getNotificationGroup(
    notificationGroupIdCommand: string | undefined,
    environmentId: string
  ): Promise<string | undefined> {
    let notificationGroupId = notificationGroupIdCommand;

    if (!notificationGroupId) {
      notificationGroupId = (
        await this.notificationGroupRepository.findOne(
          {
            name: 'General',
            _environmentId: environmentId,
          },
          '_id'
        )
      )?._id;
    }

    return notificationGroupId;
  }

  private getWorkflowPreferences(workflow: DiscoverWorkflowOutput): WorkflowPreferences {
    return buildWorkflowPreferences(workflow.preferences || {});
  }

  private getWorkflowName(workflow: DiscoverWorkflowOutput): string {
    return workflow.name || workflow.workflowId;
  }

  private getWorkflowDescription(workflow: DiscoverWorkflowOutput): string {
    return workflow.description || '';
  }

  private getWorkflowTags(workflow: DiscoverWorkflowOutput): string[] {
    return workflow.tags || [];
  }

  private castToAnyNotSupportedParam(param: any): any {
    return param as any;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - persistedWorkflowIdsInBridge(createdWorkflows.map((i))
 - deleteWorkflowFromStoragePromises(workflowsToDelete.map((workflow))
 - existingFrameworkWorkflows(await Promise.all(
      workflowsFromBridge.map((workflow))
 - workflowActive(this.castToAnyNotSupportedParam(workflow)?.active ?? true;

    return {
      id: workflowExist._id...)
 - foundStep(workflow?.steps?.find((workflowStep))
Declaraciones 'export' encontradas:
- export class Sync

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/change.module.ts
Tamao: 1403 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  DynamicModule,
  ForwardReference,
  forwardRef,
  MiddlewareConsumer,
  Module,
  NestModule,
  Type,
} from '@nestjs/common';
import { AuthModule } from '../auth/auth.module';
import { SharedModule } from '../shared/shared.module';
import { ChangesController } from './changes.controller';
import { USE_CASES } from './usecases';
import { PromoteNotificationTemplateChange } from './usecases/promote-notification-template-change/promote-notification-template-change.usecase';

const enterpriseImports = (): Array<Type | DynamicModule | Promise<DynamicModule> | ForwardReference> => {
  const modules: Array<Type | DynamicModule | Promise<DynamicModule> | ForwardReference> = [];
  if (process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true') {
    if (require('@novu/ee-translation')?.EnterpriseTranslationModule) {
      modules.push(require('@novu/ee-translation')?.EnterpriseTranslationModule);
    }
  }

  return modules;
};

@Module({
  imports: [SharedModule, forwardRef(() => AuthModule), ...enterpriseImports()],
  providers: [
    ...USE_CASES,
    {
      provide: 'INotificationTemplateChangeService',
      useExisting: PromoteNotificationTemplateChange,
    },
  ],
  exports: [...USE_CASES],
  controllers: [ChangesController],
})
export class ChangeModule implements NestModule {
  configure(consumer: MiddlewareConsumer): MiddlewareConsumer | void {}
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - enterpriseImports(): Array<Type | DynamicModule | Promise<DynamicModule> | ForwardReference>)
Declaraciones 'export' encontradas:
- export class ChangeModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/changes.controller.ts
Tamao: 4295 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Body, ClassSerializerInterceptor, Controller, Get, Param, Post, Query, UseInterceptors } from '@nestjs/common';
import { ApiOperation, ApiTags } from '@nestjs/swagger';
import { ApiExcludeController } from '@nestjs/swagger/dist/decorators/api-exclude-controller.decorator';
import { ApiRateLimitCostEnum, UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { ThrottlerCost } from '../rate-limiting/guards';
import { DataNumberDto } from '../shared/dtos/data-wrapper-dto';
import { ApiCommonResponses, ApiOkResponse, ApiResponse } from '../shared/framework/response.decorator';
import { SdkMethodName } from '../shared/framework/swagger/sdk.decorators';
import { UserSession } from '../shared/framework/user.decorator';
import { BulkApplyChangeDto } from './dtos/bulk-apply-change.dto';
import { ChangesRequestDto } from './dtos/change-request.dto';
import { ChangeResponseDto, ChangesResponseDto } from './dtos/change-response.dto';
import { ApplyChange, ApplyChangeCommand } from './usecases';
import { BulkApplyChangeCommand } from './usecases/bulk-apply-change/bulk-apply-change.command';
import { BulkApplyChange } from './usecases/bulk-apply-change/bulk-apply-change.usecase';
import { CountChangesCommand } from './usecases/count-changes/count-changes.command';
import { CountChanges } from './usecases/count-changes/count-changes.usecase';
import { GetChangesCommand } from './usecases/get-changes/get-changes.command';
import { GetChanges } from './usecases/get-changes/get-changes.usecase';

@ApiCommonResponses()
@Controller('/changes')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiTags('Changes')
@ApiExcludeController()
export class ChangesController {
  constructor(
    private applyChange: ApplyChange,
    private getChangesUsecase: GetChanges,
    private bulkApplyChange: BulkApplyChange,
    private countChanges: CountChanges
  ) {}

  @Get('/')
  @ApiOkResponse({
    type: ChangesResponseDto,
  })
  @ApiOperation({
    summary: 'Get changes',
  })
  @ExternalApiAccessible()
  async getChanges(
    @UserSession() user: UserSessionData,
    @Query() query: ChangesRequestDto
  ): Promise<ChangesResponseDto> {
    return await this.getChangesUsecase.execute(
      GetChangesCommand.create({
        promoted: query.promoted === 'true',
        page: query.page ? query.page : 0,
        limit: query.limit ? query.limit : 10,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
      })
    );
  }

  @Get('/count')
  @ApiOkResponse({
    type: DataNumberDto,
  })
  @ApiOperation({
    summary: 'Get changes count',
  })
  @ExternalApiAccessible()
  @SdkMethodName('count')
  async getChangesCount(@UserSession() user: UserSessionData): Promise<number> {
    return await this.countChanges.execute(
      CountChangesCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
      })
    );
  }

  @ThrottlerCost(ApiRateLimitCostEnum.BULK)
  @Post('/bulk/apply')
  @ApiResponse(ChangeResponseDto, 201, true)
  @ApiOperation({
    summary: 'Apply changes',
  })
  @ExternalApiAccessible()
  @SdkMethodName('applyBulk')
  async bulkApplyDiff(
    @UserSession() user: UserSessionData,
    @Body() body: BulkApplyChangeDto
  ): Promise<ChangeResponseDto[][]> {
    return this.bulkApplyChange.execute(
      BulkApplyChangeCommand.create({
        changeIds: body.changeIds,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
      })
    );
  }

  @Post('/:changeId/apply')
  @ApiResponse(ChangeResponseDto, 201, true)
  @ApiOperation({
    summary: 'Apply change',
  })
  @ExternalApiAccessible()
  @SdkMethodName('apply')
  async applyDiff(
    @UserSession() user: UserSessionData,
    @Param('changeId') changeId: string
  ): Promise<ChangeResponseDto[]> {
    return this.applyChange.execute(
      ApplyChangeCommand.create({
        changeId,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ChangesController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/dtos/bulk-apply-change.dto.ts
Tamao: 132 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsString } from 'class-validator';

export class BulkApplyChangeDto {
  @IsString({ each: true })
  changeIds: string[];
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BulkApplyChangeDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/dtos/change-request.dto.ts
Tamao: 384 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsDefined, IsString } from 'class-validator';
import { PaginationRequestDto } from '../../shared/dtos/pagination-request';

export class ChangesRequestDto extends PaginationRequestDto(10, 100) {
  @ApiProperty({
    type: String,
    required: true,
    default: 'false',
  })
  @IsDefined()
  @IsString()
  promoted: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ChangesRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/dtos/change-response.dto.ts
Tamao: 804 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { ChangeEntityTypeEnum } from '@novu/shared';

export class ChangeResponseDto {
  @ApiPropertyOptional()
  _id?: string;

  @ApiProperty()
  _creatorId: string;

  @ApiProperty()
  _environmentId: string;

  @ApiProperty()
  _organizationId: string;

  @ApiProperty()
  _entityId: string;

  @ApiProperty()
  enabled: boolean;

  @ApiProperty({
    enum: ChangeEntityTypeEnum,
  })
  type: ChangeEntityTypeEnum;

  @ApiProperty()
  change: any;

  @ApiProperty()
  createdAt: string;

  @ApiPropertyOptional()
  _parentId?: string;
}

export class ChangesResponseDto {
  @ApiProperty()
  totalCount: number;

  @ApiProperty()
  data: ChangeResponseDto[];

  @ApiProperty()
  pageSize: number;

  @ApiProperty()
  page: number;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ChangeResponseDto
- export class ChangesResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/e2e/get-changes.e2e.ts
Tamao: 2471 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChangeRepository } from '@novu/dal';
import {
  EmailBlockTypeEnum,
  FieldLogicalOperatorEnum,
  FieldOperatorEnum,
  FilterPartTypeEnum,
  StepTypeEnum,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { CreateWorkflowRequestDto, UpdateWorkflowRequestDto } from '../../workflows-v1/dtos';

describe('Get changes #novu-v0', () => {
  let session: UserSession;
  const changeRepository: ChangeRepository = new ChangeRepository();

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('get list of changes', async () => {
    const testTemplate: Partial<CreateWorkflowRequestDto> = {
      name: 'test email template',
      description: 'This is a test description',
      tags: ['test-tag'],
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [
        {
          template: {
            name: 'Message Name',
            subject: 'Test email subject',
            content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
            type: StepTypeEnum.EMAIL,
          },
          filters: [
            {
              isNegated: false,
              type: 'GROUP',
              value: FieldLogicalOperatorEnum.AND,
              children: [
                {
                  on: FilterPartTypeEnum.SUBSCRIBER,
                  field: 'firstName',
                  value: 'test value',
                  operator: FieldOperatorEnum.EQUAL,
                },
              ],
            },
          ],
        },
      ],
    };

    const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);

    await session.applyChanges();

    const updateData: UpdateWorkflowRequestDto = {
      name: testTemplate.name || '',
      tags: testTemplate.tags || [],
      description: testTemplate.description || '',
      steps: [],
      notificationGroupId: session.notificationGroups[0]._id,
    };

    const notificationTemplateId = body.data._id;

    await session.testAgent.put(`/v1/workflows/${notificationTemplateId}`).send(updateData);

    const {
      body: { data },
    } = await session.testAgent.get(`/v1/changes?promoted=true`);

    const changes = await changeRepository.find({
      _environmentId: session.environment._id,
      enabled: true,
      _parentId: { $exists: false, $eq: null },
    });

    expect(data.length).to.eq(changes.length);
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - ChangeRepository(new ChangeRepository();

  before(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('get list of changes', async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/e2e/promote-changes.e2e.ts
Tamao: 24220 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  ChangeRepository,
  EnvironmentEntity,
  EnvironmentRepository,
  FeedRepository,
  MessageTemplateRepository,
  NotificationGroupRepository,
  NotificationTemplateRepository,
} from '@novu/dal';
import {
  ChangeEntityTypeEnum,
  ChannelCTATypeEnum,
  EmailBlockTypeEnum,
  FieldLogicalOperatorEnum,
  FieldOperatorEnum,
  FilterPartTypeEnum,
  StepTypeEnum,
  TemplateVariableTypeEnum,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { CreateWorkflowRequestDto, UpdateWorkflowRequestDto } from '../../workflows-v1/dtos';

describe('Promote changes #novu-v0', () => {
  let session: UserSession;
  let prodEnv: EnvironmentEntity;
  const changeRepository: ChangeRepository = new ChangeRepository();
  const notificationTemplateRepository = new NotificationTemplateRepository();
  const messageTemplateRepository: MessageTemplateRepository = new MessageTemplateRepository();
  const notificationGroupRepository: NotificationGroupRepository = new NotificationGroupRepository();
  const environmentRepository: EnvironmentRepository = new EnvironmentRepository();
  const feedRepository: FeedRepository = new FeedRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    prodEnv = await getProductionEnvironment();
  });

  describe('Notification template changes', () => {
    it('should set correct notification group for notification template', async () => {
      const parentGroup = await notificationGroupRepository.create({
        name: 'test',
        _environmentId: session.environment._id,
        _organizationId: session.organization._id,
      });

      const prodGroup = await notificationGroupRepository.create({
        name: 'test',
        _environmentId: prodEnv._id,
        _organizationId: session.organization._id,
        _parentId: parentGroup._id,
      });

      const testTemplate: Partial<CreateWorkflowRequestDto> = {
        name: 'test email template',
        description: 'This is a test description',
        tags: ['test-tag'],
        notificationGroupId: parentGroup._id,
        steps: [
          {
            template: {
              name: 'Message Name',
              subject: 'Test email subject',
              content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
              type: StepTypeEnum.EMAIL,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    on: FilterPartTypeEnum.SUBSCRIBER,
                    field: 'firstName',
                    value: 'test value',
                    operator: FieldOperatorEnum.EQUAL,
                  },
                ],
              },
            ],
          },
        ],
      };

      const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);
      const notificationTemplateId = body.data._id;

      await session.applyChanges({
        enabled: false,
      });

      const prodVersion = await notificationTemplateRepository.findOne({
        _environmentId: prodEnv._id,
        _parentId: notificationTemplateId,
      });

      expect(prodVersion?._notificationGroupId).to.eq(prodGroup._id);
    });

    it('should promote step variables default values', async () => {
      const testTemplate: Partial<CreateWorkflowRequestDto> = {
        name: 'test email template',
        description: 'This is a test description',
        notificationGroupId: session.notificationGroups[0]._id,
        steps: [
          {
            template: {
              name: 'Message Name',
              subject: 'Test email subject',
              content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a {{variable}}' }],
              type: StepTypeEnum.EMAIL,
              variables: [
                {
                  name: 'variable',
                  type: TemplateVariableTypeEnum.STRING,
                  defaultValue: 'Test Default Value',
                  required: false,
                },
              ],
            },
          },
        ],
      };

      const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);
      const notificationTemplateId = body.data._id;

      await session.applyChanges({
        enabled: false,
      });

      const prodVersion = await notificationTemplateRepository.findOne({
        _environmentId: prodEnv._id,
        _parentId: notificationTemplateId,
      });
      let prodVersionMessage = await messageTemplateRepository.findOne({
        _environmentId: prodEnv._id,
        _id: prodVersion?.steps[0]._templateId,
      });

      const variable = prodVersionMessage?.variables?.[0];
      expect(variable?.name).to.eq('variable');
      expect(variable?.type).to.eq(TemplateVariableTypeEnum.STRING);
      expect(variable?.required).to.eq(false);
      expect(variable?.defaultValue).to.eq('Test Default Value');

      const step = body.data.steps[0];
      const update: Partial<UpdateWorkflowRequestDto> = {
        steps: [
          {
            _id: step._templateId,
            _templateId: step._templateId,
            template: {
              type: step?.template?.type,
              content: step.template.content,
              variables: [
                {
                  name: 'variable',
                  type: TemplateVariableTypeEnum.STRING,
                  defaultValue: 'New Default Value',
                  required: true,
                },
              ],
            },
          },
        ],
      };

      await session.testAgent.put(`/v1/workflows/${notificationTemplateId}`).send(update);

      await session.applyChanges({
        enabled: false,
      });

      prodVersionMessage = await messageTemplateRepository.findOne({
        _environmentId: prodEnv._id,
        _id: prodVersion?.steps[0]._templateId,
      });

      const updatedVariable = prodVersionMessage?.variables?.[0];
      expect(updatedVariable?.name).to.eq('variable');
      expect(updatedVariable?.type).to.eq(TemplateVariableTypeEnum.STRING);
      expect(updatedVariable?.required).to.eq(true);
      expect(updatedVariable?.defaultValue).to.eq('New Default Value');
    });

    it('delete message', async () => {
      const testTemplate: Partial<CreateWorkflowRequestDto> = {
        name: 'test email template',
        description: 'This is a test description',
        tags: ['test-tag'],
        notificationGroupId: session.notificationGroups[0]._id,
        steps: [
          {
            template: {
              name: 'Message Name',
              subject: 'Test email subject',
              content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
              type: StepTypeEnum.EMAIL,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    on: FilterPartTypeEnum.SUBSCRIBER,
                    field: 'firstName',
                    value: 'test value',
                    operator: FieldOperatorEnum.EQUAL,
                  },
                ],
              },
            ],
          },
        ],
      };

      let { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);

      const updateData: UpdateWorkflowRequestDto = {
        name: testTemplate.name || '',
        tags: testTemplate.tags || [],
        description: testTemplate.description || '',
        steps: [],
        notificationGroupId: session.notificationGroups[0]._id,
      };

      const notificationTemplateId = body.data._id;

      body = await session.testAgent.put(`/v1/workflows/${notificationTemplateId}`).send(updateData);

      await session.applyChanges({
        enabled: false,
      });

      const prodVersion = await notificationTemplateRepository.findOne({
        _environmentId: prodEnv._id,
        _parentId: notificationTemplateId,
      } as any);

      expect(prodVersion?.steps.length).to.eq(0);
    });

    it('update active flag on notification template', async () => {
      const testTemplate: Partial<CreateWorkflowRequestDto> = {
        name: 'test email template',
        description: 'This is a test description',
        tags: ['test-tag'],
        notificationGroupId: session.notificationGroups[0]._id,
        steps: [],
      };

      const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);

      await session.applyChanges({
        enabled: false,
      });

      const notificationTemplateId = body.data._id;

      await session.testAgent.put(`/v1/workflows/${notificationTemplateId}/status`).send({ active: true });

      await session.applyChanges({
        enabled: false,
      });

      const prodVersion = await notificationTemplateRepository.findOne({
        _organizationId: session.organization._id,
        _environmentId: prodEnv._id,
        _parentId: notificationTemplateId,
      });

      expect(prodVersion?.active).to.eq(true);
    });

    it('update existing message', async () => {
      const testTemplate: Partial<CreateWorkflowRequestDto> = {
        name: 'test email template',
        description: 'This is a test description',
        tags: ['test-tag'],
        notificationGroupId: session.notificationGroups[0]._id,
        steps: [
          {
            template: {
              name: 'Message Name',
              subject: 'Test email subject',
              content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
              type: StepTypeEnum.EMAIL,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    on: FilterPartTypeEnum.SUBSCRIBER,
                    field: 'firstName',
                    value: 'test value',
                    operator: FieldOperatorEnum.EQUAL,
                  },
                ],
              },
            ],
          },
        ],
      };

      let {
        body: { data },
      } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);

      await session.applyChanges({
        enabled: false,
      });

      const notificationTemplateId = data._id;

      const step = data.steps[0];
      const update: UpdateWorkflowRequestDto = {
        name: data.name,
        description: data.description,
        tags: data.tags,
        notificationGroupId: data._notificationGroupId,
        steps: [
          {
            _id: step._templateId,
            _templateId: step._templateId,
            template: {
              name: 'test',
              type: step.template.type,
              cta: step.template.cta,
              content: step.template.content,
            },
          },
        ],
      };

      const body: any = await session.testAgent.put(`/v1/workflows/${notificationTemplateId}`).send(update);
      data = body.data;

      await session.applyChanges({
        enabled: false,
      });

      const prodVersion = await messageTemplateRepository.findOne({
        _environmentId: prodEnv._id,
        _parentId: step._templateId,
      });

      expect(prodVersion?.name).to.eq('test');
    });

    it('add one more message', async () => {
      const testTemplate: Partial<CreateWorkflowRequestDto> = {
        name: 'test email template',
        description: 'This is a test description',
        tags: ['test-tag'],
        notificationGroupId: session.notificationGroups[0]._id,
        steps: [
          {
            template: {
              name: 'Message Name',
              subject: 'Test email subject',
              content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
              type: StepTypeEnum.EMAIL,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    on: FilterPartTypeEnum.SUBSCRIBER,
                    field: 'firstName',
                    value: 'test value',
                    operator: FieldOperatorEnum.EQUAL,
                  },
                ],
              },
            ],
          },
        ],
      };

      let {
        body: { data },
      } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);
      await session.applyChanges({
        enabled: false,
      });

      const notificationTemplateId = data._id;

      const step = data.steps[0];
      const update: UpdateWorkflowRequestDto = {
        name: data.name,
        description: data.description,
        tags: data.tags,
        notificationGroupId: data._notificationGroupId,
        steps: [
          {
            _id: step._templateId,
            _templateId: step._templateId,
            template: {
              name: 'Message Name',
              content: step.template.content,
              type: step.template.type,
              cta: step.template.cta,
            },
          },
          {
            template: {
              name: 'Message Name',
              subject: 'Test email subject',
              content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
              type: step.template.type,
              cta: {
                type: ChannelCTATypeEnum.REDIRECT,
                data: {
                  url: '',
                },
              },
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    on: FilterPartTypeEnum.SUBSCRIBER,
                    field: 'secondName',
                    value: 'test value',
                    operator: FieldOperatorEnum.EQUAL,
                  },
                ],
              },
            ],
          },
        ],
      };

      const body: any = await session.testAgent.put(`/v1/workflows/${notificationTemplateId}`).send(update);
      data = body.data;

      await session.applyChanges({
        enabled: false,
      });

      const prodVersion = await notificationTemplateRepository.find({
        _environmentId: prodEnv._id,
        _parentId: notificationTemplateId,
      });

      expect(prodVersion[0].steps.length).to.eq(2);
    });

    it('should count not applied changes', async () => {
      const testTemplate: Partial<CreateWorkflowRequestDto> = {
        name: 'test email template',
        description: 'This is a test description',
        tags: ['test-tag'],
        notificationGroupId: session.notificationGroups[0]._id,
        steps: [
          {
            template: {
              name: 'Message Name',
              subject: 'Test email subject',
              content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
              type: StepTypeEnum.EMAIL,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    on: FilterPartTypeEnum.SUBSCRIBER,
                    field: 'firstName',
                    value: 'test value',
                    operator: FieldOperatorEnum.EQUAL,
                  },
                ],
              },
            ],
          },
        ],
      };

      await session.testAgent.post(`/v1/workflows`).send(testTemplate);

      const {
        body: { data },
      } = await session.testAgent.get('/v1/changes/count');

      expect(data).to.eq(1);
    });

    it('should count delete change', async () => {
      const testTemplate: Partial<CreateWorkflowRequestDto> = {
        name: 'test email template',
        description: 'This is a test description',
        tags: ['test-tag'],
        notificationGroupId: session.notificationGroups[0]._id,
        steps: [
          {
            template: {
              name: 'Message Name',
              subject: 'Test email subject',
              content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
              type: StepTypeEnum.EMAIL,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    on: FilterPartTypeEnum.SUBSCRIBER,
                    field: 'firstName',
                    value: 'test value',
                    operator: FieldOperatorEnum.EQUAL,
                  },
                ],
              },
            ],
          },
        ],
      };

      const {
        body: { data },
      } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);
      const notificationTemplateId = data._id;
      await session.applyChanges({
        enabled: false,
      });

      await session.testAgent.delete(`/v1/workflows/${notificationTemplateId}`);

      const {
        body: { data: count },
      } = await session.testAgent.get('/v1/changes/count');

      expect(count).to.eq(1);
    });

    it('should promote notification group if it is not already promoted', async () => {
      const {
        body: { data: group },
      } = await session.testAgent.post(`/v1/notification-groups`).send({
        name: 'Test name',
      });

      const testTemplate: Partial<CreateWorkflowRequestDto> = {
        name: 'test email template',
        description: 'This is a test description',
        tags: ['test-tag'],
        notificationGroupId: group._id,
        steps: [],
      };

      const {
        body: { data },
      } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);
      const notificationTemplateId = data._id;
      const changes = await changeRepository.find(
        {
          _environmentId: session.environment._id,
          _organizationId: session.organization._id,
          enabled: false,
          _entityId: notificationTemplateId,
          type: ChangeEntityTypeEnum.NOTIFICATION_TEMPLATE,
        },
        '',
        {
          sort: { createdAt: 1 },
        }
      );

      await changes.reduce(async (prev, change) => {
        await session.testAgent.post(`/v1/changes/${change._id}/apply`);
      }, Promise.resolve());

      const count = await changeRepository.count({
        _environmentId: session.environment._id,
        _organizationId: session.organization._id,
        enabled: false,
      });

      expect(count).to.eq(0);
    });

    it('should set isBlueprint correctly', async () => {
      process.env.BLUEPRINT_CREATOR = session.organization._id;

      const parentGroup = await notificationGroupRepository.create({
        name: 'test',
        _environmentId: session.environment._id,
        _organizationId: session.organization._id,
      });

      await notificationGroupRepository.create({
        name: 'test',
        _environmentId: prodEnv._id,
        _organizationId: session.organization._id,
        _parentId: parentGroup._id,
      });

      const testTemplate: Partial<CreateWorkflowRequestDto> = {
        name: 'test email template',
        description: 'This is a test description',
        tags: ['test-tag'],
        notificationGroupId: parentGroup._id,
        steps: [
          {
            template: {
              name: 'Message Name',
              subject: 'Test email subject',
              content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
              type: StepTypeEnum.EMAIL,
            },
            filters: [
              {
                isNegated: false,
                type: 'GROUP',
                value: FieldLogicalOperatorEnum.AND,
                children: [
                  {
                    on: FilterPartTypeEnum.SUBSCRIBER,
                    field: 'firstName',
                    value: 'test value',
                    operator: FieldOperatorEnum.EQUAL,
                  },
                ],
              },
            ],
          },
        ],
      };

      const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);
      const notificationTemplateId = body.data._id;

      await session.applyChanges({
        enabled: false,
      });

      const prodVersion = await notificationTemplateRepository.findOne({
        _environmentId: prodEnv._id,
        _parentId: notificationTemplateId,
      });

      expect(prodVersion?.isBlueprint).to.equal(true);
    });

    it('should merge creation, and status changes to one change', async () => {
      const testTemplate: Partial<CreateWorkflowRequestDto> = {
        name: 'test email template',
        description: 'This is a test description',
        tags: ['test-tag'],
        notificationGroupId: session.notificationGroups[0]._id,
        steps: [],
      };

      const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);

      const notificationTemplateId = body.data._id;

      await session.testAgent.put(`/v1/workflows/${notificationTemplateId}/status`).send({ active: true });

      await session.testAgent.put(`/v1/workflows/${notificationTemplateId}/status`).send({ active: false });

      const changes = await changeRepository.find(
        {
          _environmentId: session.environment._id,
          _organizationId: session.organization._id,
          _parentId: { $exists: false, $eq: null },
          enabled: false,
        },
        '',
        {
          sort: { createdAt: 1 },
        }
      );

      expect(changes.length).to.eq(1);
    });

    it('should not have feed in production after feed delete', async () => {
      const testFeed = {
        name: 'Test delete feed in message',
      };

      const {
        body: { data: feed },
      } = await session.testAgent.post(`/v1/feeds`).send(testFeed);

      await session.testAgent.delete(`/v1/feeds/${feed._id}`).send();

      await session.applyChanges({
        enabled: false,
      });

      const devFeeds = await feedRepository.find({
        _environmentId: session.environment._id,
        name: feed.name,
      });
      expect(devFeeds.length).to.equal(0);

      const prodFeeds = await feedRepository.find({
        _environmentId: prodEnv._id,
        name: feed.name,
      });
      expect(prodFeeds.length).to.equal(0);
    });

    it('should update workflow preferences on promote', async () => {
      const testTemplate: Partial<CreateWorkflowRequestDto> = {
        name: 'test email template',
        description: 'This is a test description',
        tags: ['test-tag'],
        notificationGroupId: session.notificationGroups[0]._id,
        steps: [],
        preferenceSettings: {
          email: true,
          in_app: false,
          sms: true,
          chat: false,
          push: false,
        },
      };

      const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);
      const notificationTemplateId = body.data._id;

      await session.testAgent.put(`/v1/workflows/${notificationTemplateId}/status`).send({ active: true });

      await session.applyChanges({
        enabled: false,
      });

      const { body: prodVersion } = await session.testAgent.get(`/v1/workflows/${notificationTemplateId}`);

      expect(prodVersion?.data?.preferenceSettings).to.deep.equal(testTemplate.preferenceSettings);
    });
  });

  async function getProductionEnvironment(): Promise<EnvironmentEntity> {
    const production = await environmentRepository.findOne({
      _parentId: session.environment._id,
    });

    if (!production) {
      throw new Error('No production environment');
    }

    return production;
  }
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - getProductionEnvironment()
Asignaciones con arrow functions encontradas (posibles funciones):
 - FeedRepository(new FeedRepository();

  beforeEach(async ())
 - prodEnv(await getProductionEnvironment();
  });

  describe('Notification template changes', ())
 - prodVersion(await notificationTemplateRepository.findOne({
        _environmentId: prodEnv._id,
        _parentI...)
 - updatedVariable(prodVersionMessage?.variables?.[0];
      expect(updatedVariable?.name).to.eq('variable');
      exp...)
 - prodVersion(await notificationTemplateRepository.findOne({
        _environmentId: prodEnv._id,
        _parentI...)
 - prodVersion(await notificationTemplateRepository.findOne({
        _organizationId: session.organization._id,
  ...)
 - prodVersion(await messageTemplateRepository.findOne({
        _environmentId: prodEnv._id,
        _parentId: st...)
 - prodVersion(await notificationTemplateRepository.find({
        _environmentId: prodEnv._id,
        _parentId: ...)
 - changes(await changeRepository.find(
        {
          _environmentId: session.environment._id,
          ...)
 - count(await changeRepository.count({
        _environmentId: session.environment._id,
        _organizatio...)
 - prodVersion(await notificationTemplateRepository.findOne({
        _environmentId: prodEnv._id,
        _parentI...)
 - changes(await changeRepository.find(
        {
          _environmentId: session.environment._id,
          ...)
 - prodFeeds(await feedRepository.find({
        _environmentId: prodEnv._id,
        name: feed.name,
      });
...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/e2e/promote-layout-changes.e2e.ts
Tamao: 11295 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChangeRepository, EnvironmentRepository, LayoutRepository } from '@novu/dal';
import {
  ChangeEntityTypeEnum,
  ITemplateVariable,
  LayoutDescription,
  LayoutId,
  LayoutIdentifier,
  LayoutName,
  TemplateVariableTypeEnum,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Promote Layout Changes #novu-v0', () => {
  let session: UserSession;
  const changeRepository: ChangeRepository = new ChangeRepository();
  const layoutRepository = new LayoutRepository();
  const environmentRepository: EnvironmentRepository = new EnvironmentRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should promote a new layout created to production', async () => {
    const layoutName = 'layout-name-creation';
    const layoutIdentifier = 'layout-identifier-creation';
    const layoutDescription = 'Amazing new layout';
    const content = '<html><body><div>Hello {{organizationName}} {{{body}}}</div></body></html>';
    const variables = [
      { name: 'organizationName', type: TemplateVariableTypeEnum.STRING, defaultValue: 'Company', required: false },
    ];
    const isDefault = true;

    const createLayoutPayload = {
      name: layoutName,
      identifier: layoutIdentifier,
      description: layoutDescription,
      content,
      variables,
      isDefault,
    };

    const {
      body: {
        data: { _id: layoutId },
      },
    } = await session.testAgent.post('/v1/layouts').send(createLayoutPayload);

    expect(layoutId).to.be.ok;

    const {
      body: { data: devLayout },
    } = await session.testAgent.get(`/v1/layouts/${layoutId}`);

    const changes = await changeRepository.find(
      {
        _environmentId: session.environment._id,
        _organizationId: session.organization._id,
        enabled: false,
        _entityId: layoutId,
        type: ChangeEntityTypeEnum.DEFAULT_LAYOUT,
      },
      '',
      {
        sort: { createdAt: 1 },
      }
    );

    expect(changes.length).to.eql(1);
    expect(changes[0]._entityId).to.eql(layoutId);
    expect(changes[0].type).to.eql(ChangeEntityTypeEnum.DEFAULT_LAYOUT);
    expect(changes[0].change).to.deep.include({ op: 'add', path: ['_id'], val: layoutId });

    await session.applyChanges({
      enabled: false,
    });

    const prodEnv = await getProductionEnvironment();
    expect(prodEnv).to.be.ok;

    const prodLayout = await layoutRepository.findOne({
      _environmentId: prodEnv?._id!,
      _parentId: layoutId,
    });

    expect(prodLayout).to.be.ok;
    expect(prodLayout?._parentId).to.eql(devLayout._id);
    expect(prodLayout?._environmentId).to.eql(prodEnv?._id);
    expect(prodLayout?._organizationId).to.eql(session.organization._id);
    expect(prodLayout?._creatorId).to.eql(session.user._id);
    expect(prodLayout?.name).to.eql(layoutName);
    expect(prodLayout?.identifier).to.eql(layoutIdentifier);
    expect(prodLayout?.content).to.eql(content);
    // TODO: Awful but it comes from the repository directly.
    const { _id: _, ...prodVariables } = prodLayout?.variables?.[0] as any;
    expect(prodVariables).to.deep.include(variables[0]);
    expect(prodLayout?.contentType).to.eql(devLayout.contentType);
    expect(prodLayout?.isDefault).to.eql(isDefault);
    expect(prodLayout?.channel).to.eql(devLayout.channel);
  });

  it('should promote the updates done to a layout existing to production', async () => {
    const layoutName = 'layout-name-update';
    const layoutIdentifier = 'layout-identifier-update';
    const layoutDescription = 'Amazing new layout';
    const content = '<html><body><div>Hello {{organizationName}} {{{body}}}</div></body></html>';
    const variables = [
      { name: 'organizationName', type: TemplateVariableTypeEnum.STRING, defaultValue: 'Company', required: false },
    ];
    const isDefault = false;

    const layoutId = await createLayout(layoutName, layoutIdentifier, layoutDescription, content, variables, isDefault);

    await session.applyChanges({
      enabled: false,
    });

    const updatedLayoutName = 'layout-name-creation-updated';
    const updatedLayoutIdentifier = 'layout-identifier-creation-updated';
    const updatedDescription = 'Amazing new layout updated';
    const updatedContent = '<html><body><div>Hello {{organizationName}}, you all {{{body}}}</div></body></html>';
    const updatedVariables = [
      {
        name: 'organizationName',
        type: TemplateVariableTypeEnum.STRING,
        defaultValue: 'Organization',
        required: true,
      },
    ];
    const updatedIsDefault = false;

    const patchLayoutPayload = {
      name: updatedLayoutName,
      identifier: updatedLayoutIdentifier,
      description: updatedDescription,
      content: updatedContent,
      variables: updatedVariables,
      isDefault: updatedIsDefault,
    };

    const {
      status,
      body: { data: patchedLayout },
    } = await session.testAgent.patch(`/v1/layouts/${layoutId}`).send(patchLayoutPayload);
    expect(status).to.eql(200);

    const changes = await changeRepository.find(
      {
        _environmentId: session.environment._id,
        _organizationId: session.organization._id,
        enabled: false,
        _entityId: layoutId,
        type: ChangeEntityTypeEnum.LAYOUT,
      },
      '',
      {
        sort: { createdAt: 1 },
      }
    );

    expect(changes.length).to.eql(1);
    expect(changes[0]._entityId).to.eql(layoutId);
    expect(changes[0].type).to.eql(ChangeEntityTypeEnum.LAYOUT);
    expect(changes[0].change).to.deep.include.members([
      {
        op: 'update',
        path: ['name'],
        val: updatedLayoutName,
        oldVal: layoutName,
      },
      {
        op: 'update',
        path: ['identifier'],
        val: updatedLayoutIdentifier,
        oldVal: layoutIdentifier,
      },
      {
        op: 'update',
        path: ['description'],
        val: updatedDescription,
        oldVal: layoutDescription,
      },
      {
        op: 'update',
        path: ['description'],
        val: updatedDescription,
        oldVal: layoutDescription,
      },
      {
        op: 'update',
        path: ['content'],
        val: '<html><body><div>Hello {{organizationName}}, you all {{{body}}}</div></body></html>',
        oldVal: '<html><body><div>Hello {{organizationName}} {{{body}}}</div></body></html>',
      },
      {
        op: 'update',
        path: ['variables', 0, 'defaultValue'],
        val: 'Organization',
        oldVal: 'Company',
      },
      {
        op: 'update',
        path: ['variables', 0, 'required'],
        val: true,
        oldVal: false,
      },
    ]);

    await session.applyChanges({
      enabled: false,
    });

    const prodEnv = await getProductionEnvironment();
    expect(prodEnv).to.be.ok;

    const prodLayout = await layoutRepository.findOne({
      _environmentId: prodEnv?._id!,
      _parentId: layoutId,
    });

    expect(prodLayout).to.be.ok;
    expect(prodLayout?._parentId).to.eql(patchedLayout._id);
    expect(prodLayout?._environmentId).to.eql(prodEnv?._id!);
    expect(prodLayout?._organizationId).to.eql(session.organization._id);
    expect(prodLayout?._creatorId).to.eql(session.user._id);
    expect(prodLayout?.name).to.eql(updatedLayoutName);
    expect(prodLayout?.identifier).to.eql(updatedLayoutIdentifier);
    expect(prodLayout?.content).to.eql(updatedContent);
    // TODO: Awful but it comes from the repository directly.
    const { _id, ...prodVariables } = prodLayout?.variables?.[0] as any;
    expect(prodVariables).to.deep.include(updatedVariables[0]);
    expect(prodLayout?.contentType).to.eql(patchedLayout.contentType);
    expect(prodLayout?.isDefault).to.eql(updatedIsDefault);
    expect(prodLayout?.channel).to.eql(patchedLayout.channel);
  });

  it('should promote the deletion of a layout to production', async () => {
    const layoutName = 'layout-name-deletion';
    const layoutIdentifier = 'layout-identifier-deletion';
    const layoutDescription = 'Amazing new layout';
    const content = '<html><body><div>Hello {{organizationName}} {{{body}}}</div></body></html>';
    const variables = [
      { name: 'organizationName', type: TemplateVariableTypeEnum.STRING, defaultValue: 'Company', required: false },
    ];
    const isDefault = false;

    const layoutId = await createLayout(layoutName, layoutIdentifier, layoutDescription, content, variables, isDefault);
    const {
      body: { data: devLayout },
    } = await session.testAgent.get(`/v1/layouts/${layoutId}`);

    const changes = await changeRepository.find(
      {
        _environmentId: session.environment._id,
        _organizationId: session.organization._id,
        enabled: false,
        _entityId: layoutId,
        type: ChangeEntityTypeEnum.LAYOUT,
      },
      '',
      {
        sort: { createdAt: 1 },
      }
    );

    expect(changes.length).to.eql(1);
    expect(changes[0]._entityId).to.eql(layoutId);
    expect(changes[0].type).to.eql(ChangeEntityTypeEnum.LAYOUT);
    expect(changes[0].change).to.deep.include({ op: 'add', path: ['_id'], val: layoutId });

    await session.applyChanges({
      enabled: false,
    });

    const {
      body: { data: deletedLayout },
      status,
    } = await session.testAgent.delete(`/v1/layouts/${layoutId}`);

    expect(status).to.eql(204);

    const deletionChanges = await changeRepository.find(
      {
        _environmentId: session.environment._id,
        _organizationId: session.organization._id,
        enabled: false,
        _entityId: layoutId,
        type: ChangeEntityTypeEnum.LAYOUT,
      },
      '',
      {
        sort: { createdAt: 1 },
      }
    );

    expect(deletionChanges.length).to.eql(1);
    expect(deletionChanges[0]._entityId).to.eql(layoutId);
    expect(deletionChanges[0].type).to.eql(ChangeEntityTypeEnum.LAYOUT);
    expect(deletionChanges[0].change).to.deep.include.members([
      {
        op: 'update',
        path: ['deleted'],
        val: true,
        oldVal: false,
      },
      {
        op: 'add',
        path: ['isDeleted'],
        val: true,
      },
    ]);

    await session.applyChanges({
      enabled: false,
    });

    const prodEnv = await getProductionEnvironment();
    expect(prodEnv).to.be.ok;

    const prodLayout = await layoutRepository.findOne({
      _environmentId: prodEnv?._id!,
      _parentId: layoutId,
    });

    expect(prodLayout).to.not.be.ok;
  });

  async function createLayout(
    layoutName: LayoutName,
    layoutIdentifier: LayoutIdentifier,
    layoutDescription: LayoutDescription,
    content: string,
    variables: ITemplateVariable[],
    isDefault: boolean
  ): Promise<LayoutId> {
    const createLayoutPayload = {
      name: layoutName,
      identifier: layoutIdentifier,
      description: layoutDescription,
      content,
      variables,
      isDefault,
    };

    const {
      body: {
        data: { _id: layoutId },
      },
    } = await session.testAgent.post('/v1/layouts').send(createLayoutPayload);

    expect(layoutId).to.be.ok;

    return layoutId;
  }

  async function getProductionEnvironment() {
    return await environmentRepository.findOne({
      _parentId: session.environment._id,
    });
  }
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - createLayout(layoutName: LayoutName,
    layoutIdentifier: LayoutIdentifier,
    layoutDescription: LayoutDescription,
    content: string,
    variables: ITemplateVariable[],
    isDefault: boolean)
 - getProductionEnvironment()
Asignaciones con arrow functions encontradas (posibles funciones):
 - EnvironmentRepository(new EnvironmentRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should promote a new layout created ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/index.ts
Tamao: 1813 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  CreateChange,
  DeletePreferencesUseCase,
  GetPreferences,
  UpdateChange,
  UpsertPreferences,
} from '@novu/application-generic';
import { ApplyChange } from './apply-change/apply-change.usecase';
import { BulkApplyChange } from './bulk-apply-change/bulk-apply-change.usecase';
import { CountChanges } from './count-changes/count-changes.usecase';
import { GetChanges } from './get-changes/get-changes.usecase';
import { PromoteChangeToEnvironment } from './promote-change-to-environment/promote-change-to-environment.usecase';
import { PromoteFeedChange } from './promote-feed-change/promote-feed-change';
import { PromoteLayoutChange } from './promote-layout-change/promote-layout-change.use-case';
import { PromoteMessageTemplateChange } from './promote-message-template-change/promote-message-template-change';
import { PromoteNotificationGroupChange } from './promote-notification-group-change/promote-notification-group-change';
import { PromoteNotificationTemplateChange } from './promote-notification-template-change/promote-notification-template-change.usecase';
import { PromoteTranslationChange } from './promote-translation-change';
import { PromoteTranslationGroupChange } from './promote-translation-group-change';

export * from './apply-change';
export * from './promote-change-to-environment';
export * from './promote-notification-template-change';

export const USE_CASES = [
  CreateChange,
  PromoteChangeToEnvironment,
  PromoteFeedChange,
  PromoteLayoutChange,
  PromoteNotificationGroupChange,
  PromoteNotificationTemplateChange,
  PromoteMessageTemplateChange,
  ApplyChange,
  GetChanges,
  BulkApplyChange,
  CountChanges,
  UpdateChange,
  PromoteTranslationChange,
  PromoteTranslationGroupChange,
  GetPreferences,
  UpsertPreferences,
  DeletePreferencesUseCase,
];


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/promote-type-change.command.ts
Tamao: 108 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PromoteTypeChangeCommand } from '@novu/application-generic';

export { PromoteTypeChangeCommand };


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/apply-change/apply-change.command.ts
Tamao: 265 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsMongoId } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class ApplyChangeCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  @IsMongoId()
  changeId: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ApplyChangeCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/apply-change/apply-change.usecase.ts
Tamao: 2269 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';

import { ChangeEntity, ChangeRepository } from '@novu/dal';

import { PromoteChangeToEnvironment, PromoteChangeToEnvironmentCommand } from '../promote-change-to-environment';
import { ApplyChangeCommand } from './apply-change.command';

@Injectable()
export class ApplyChange {
  constructor(
    private changeRepository: ChangeRepository,
    private promoteChangeToEnvironment: PromoteChangeToEnvironment
  ) {}

  async execute(command: ApplyChangeCommand): Promise<ChangeEntity[]> {
    const parentChange = await this.changeRepository.findOne({
      _id: command.changeId,
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
    });

    if (!parentChange) throw new NotFoundException('Parent Change not found');

    const changes = await this.changeRepository.find(
      { _environmentId: parentChange._environmentId, _parentId: parentChange._id },
      '',
      {
        sort: { createdAt: 1 },
      }
    );

    const items: ChangeEntity[] = [];
    for (const change of [...changes, parentChange]) {
      const item = await this.applyChange(change, command);
      items.push(item);
    }

    return items;
  }

  async applyChange(change, command: ApplyChangeCommand): Promise<ChangeEntity> {
    if (!change) {
      throw new NotFoundException();
    }

    try {
      await this.changeRepository.update(
        {
          _id: change._id,
          _environmentId: command.environmentId,
          _organizationId: command.organizationId,
        },
        {
          enabled: true,
        }
      );

      await this.promoteChangeToEnvironment.execute(
        PromoteChangeToEnvironmentCommand.create({
          itemId: change._entityId,
          type: change.type,
          environmentId: change._environmentId,
          organizationId: change._organizationId,
          userId: command.userId,
        })
      );
    } catch (e) {
      await this.changeRepository.update(
        {
          _id: change._id,
          _environmentId: command.environmentId,
          _organizationId: command.organizationId,
        },
        {
          enabled: false,
        }
      );

      throw e;
    }

    return change;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ApplyChange

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/apply-change/index.ts
Tamao: 80 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './apply-change.command';
export * from './apply-change.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/bulk-apply-change/bulk-apply-change.command.ts
Tamao: 268 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsArray, IsDefined } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class BulkApplyChangeCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  @IsArray()
  changeIds: string[];
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BulkApplyChangeCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/bulk-apply-change/bulk-apply-change.usecase.ts
Tamao: 1162 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { ChangeEntity, ChangeRepository } from '@novu/dal';
import { ApplyChange, ApplyChangeCommand } from '../apply-change';
import { BulkApplyChangeCommand } from './bulk-apply-change.command';

@Injectable()
export class BulkApplyChange {
  constructor(
    private changeRepository: ChangeRepository,
    private applyChange: ApplyChange
  ) {}

  async execute(command: BulkApplyChangeCommand): Promise<ChangeEntity[][]> {
    const changes = await this.changeRepository.find(
      {
        _id: {
          $in: command.changeIds,
        },
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
      },
      '',
      { sort: { createdAt: 1 } }
    );

    const results: ChangeEntity[][] = [];

    for (const change of changes) {
      const item = await this.applyChange.execute(
        ApplyChangeCommand.create({
          changeId: change._id,
          environmentId: command.environmentId,
          organizationId: command.organizationId,
          userId: command.userId,
        })
      );

      results.push(item);
    }

    return results;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class BulkApplyChange

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/count-changes/count-changes.command.ts
Tamao: 159 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class CountChangesCommand extends EnvironmentWithUserCommand {}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class CountChangesCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/count-changes/count-changes.usecase.ts
Tamao: 547 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { ChangeRepository } from '@novu/dal';
import { CountChangesCommand } from './count-changes.command';

@Injectable()
export class CountChanges {
  constructor(private changeRepository: ChangeRepository) {}

  async execute(command: CountChangesCommand): Promise<number> {
    return await this.changeRepository.count({
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
      enabled: false,
      _parentId: { $exists: false, $eq: null },
    });
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class CountChanges

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/create-change/create-change.spec.ts
Tamao: 2516 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import { CreateChange, CreateChangeCommand } from '@novu/application-generic';
import { ChangeEntityTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { SharedModule } from '../../../shared/shared.module';
import { ChangeModule } from '../../change.module';

describe('Create Change', () => {
  let useCase: CreateChange;
  let session: UserSession;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [SharedModule, ChangeModule],
      providers: [],
    }).compile();

    session = new UserSession();
    await session.initialize();

    useCase = moduleRef.get<CreateChange>(CreateChange);
  });

  it('should create a change', async () => {
    const _id = '6256ade0099f90172d1cc435';

    const result = await useCase.execute(
      CreateChangeCommand.create({
        changeId: _id,
        organizationId: session.organization._id,
        environmentId: session.environment._id,
        type: ChangeEntityTypeEnum.NOTIFICATION_TEMPLATE,
        userId: session.user._id,
        item: {
          _id,
        },
      })
    );
    expect(result.enabled).to.be.eq(false);
    expect(result._entityId).to.be.eq(_id);
    expect(result._creatorId).to.be.eq(session.user._id);
    expect(result._environmentId).to.be.eq(session.environment._id);
    expect(result._organizationId).to.be.eq(session.organization._id);
    expect(result.type).to.be.eq(ChangeEntityTypeEnum.NOTIFICATION_TEMPLATE);
  });

  it('should find diff for item', async () => {
    const _id = '6256ade0099f90172d1cc436';

    await useCase.execute(
      CreateChangeCommand.create({
        changeId: _id,
        organizationId: session.organization._id,
        environmentId: session.environment._id,
        type: ChangeEntityTypeEnum.NOTIFICATION_TEMPLATE,
        userId: session.user._id,
        item: {
          _id,
        },
      })
    );
    const change = await useCase.execute(
      CreateChangeCommand.create({
        changeId: _id,
        organizationId: session.organization._id,
        environmentId: session.environment._id,
        type: ChangeEntityTypeEnum.NOTIFICATION_TEMPLATE,
        userId: session.user._id,
        item: {
          _id,
          name: 'test',
        },
      })
    );

    expect(change.change[1].op).to.eq('add');
    expect(change.change[1].val).to.eq('test');
    expect(change.change[1].path).to.eql(['name']);
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useCase(moduleRef.get<CreateChange>(CreateChange);
  });

  it('should create a change', async ())
 - result(await useCase.execute(
      CreateChangeCommand.create({
        changeId: _id,
        organizatio...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/get-changes/get-changes.command.ts
Tamao: 375 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsBoolean, IsDefined, IsNumber, IsOptional } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetChangesCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  @IsBoolean()
  promoted: boolean;

  @IsNumber()
  @IsOptional()
  page = 0;

  @IsNumber()
  @IsOptional()
  limit = 10;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetChangesCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/get-changes/get-changes.usecase.ts
Tamao: 8637 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { PinoLogger } from '@novu/application-generic';
import {
  ChangeEntity,
  ChangeRepository,
  FeedRepository,
  LayoutRepository,
  MessageTemplateRepository,
  NotificationGroupRepository,
  NotificationTemplateRepository,
} from '@novu/dal';
import { ChangeEntityTypeEnum } from '@novu/shared';
import { ChangesResponseDto } from '../../dtos/change-response.dto';
import { GetChangesCommand } from './get-changes.command';

interface IViewEntity {
  templateName: string;
  templateId?: string;
  messageType?: string;
}

interface IChangeViewEntity extends ChangeEntity {
  templateName?: string;
  templateId?: string;
  messageType?: string;
}

@Injectable()
export class GetChanges {
  constructor(
    private changeRepository: ChangeRepository,
    private notificationTemplateRepository: NotificationTemplateRepository,
    private messageTemplateRepository: MessageTemplateRepository,
    private notificationGroupRepository: NotificationGroupRepository,
    private feedRepository: FeedRepository,
    private layoutRepository: LayoutRepository,
    protected moduleRef: ModuleRef,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: GetChangesCommand): Promise<ChangesResponseDto> {
    const { data: changeItems, totalCount } = await this.changeRepository.getList(
      command.organizationId,
      command.environmentId,
      command.promoted,
      command.page * command.limit,
      command.limit
    );

    const changes = await changeItems.reduce(async (prev, change) => {
      const list: any[] = await prev;
      let item: Record<string, unknown> | IViewEntity = {};
      if (change.type === ChangeEntityTypeEnum.MESSAGE_TEMPLATE) {
        item = await this.getTemplateDataForMessageTemplate(change._entityId, command.environmentId);
      }
      if (change.type === ChangeEntityTypeEnum.NOTIFICATION_TEMPLATE) {
        item = await this.getTemplateDataForNotificationTemplate(change._entityId, command.environmentId);
      }
      if (change.type === ChangeEntityTypeEnum.NOTIFICATION_GROUP) {
        item = await this.getTemplateDataForNotificationGroup(change._entityId, command.environmentId);
      }
      if (change.type === ChangeEntityTypeEnum.FEED) {
        item = await this.getTemplateDataForFeed(change._entityId, command.environmentId);
      }
      if (change.type === ChangeEntityTypeEnum.LAYOUT) {
        item = await this.getTemplateDataForLayout(change._entityId, command.environmentId);
      }
      if (change.type === ChangeEntityTypeEnum.DEFAULT_LAYOUT) {
        item = await this.getTemplateDataForDefaultLayout(change._entityId, command.environmentId);
      }
      if (change.type === ChangeEntityTypeEnum.TRANSLATION) {
        item = await this.getTemplateDataForTranslation(change._entityId, command.environmentId);
      }
      if (change.type === ChangeEntityTypeEnum.TRANSLATION_GROUP) {
        item = await this.getTemplateDataForTranslationGroup(change._entityId, command.environmentId);
      }

      list.push({
        ...change,
        ...item,
      });

      return list;
    }, Promise.resolve([]));

    return { data: changes, totalCount, page: command.page, pageSize: command.limit };
  }

  private async getTemplateDataForMessageTemplate(
    entityId: string,
    environmentId: string
  ): Promise<IViewEntity | Record<string, unknown>> {
    const item = await this.notificationTemplateRepository.findOne({
      _environmentId: environmentId,
      'steps._templateId': entityId,
    });

    if (!item) {
      this.logger.error(`Could not find notification template for message template id ${entityId}`);

      return {};
    }

    const message = await this.messageTemplateRepository.findOne({
      _environmentId: environmentId,
      _id: entityId,
    });

    return {
      templateId: item._id,
      templateName: item.name,
      messageType: message?.type,
    };
  }

  private async getTemplateDataForNotificationTemplate(
    entityId: string,
    environmentId: string
  ): Promise<IViewEntity | Record<string, unknown>> {
    let item = await this.notificationTemplateRepository.findOne({
      _environmentId: environmentId,
      _id: entityId,
    });

    if (!item) {
      const items = await this.notificationTemplateRepository.findDeleted({
        _id: entityId,
        _environmentId: environmentId,
      });
      item = items[0];
    }

    if (!item) {
      this.logger.error(`Could not find notification template for template id ${entityId}`);

      return {};
    }

    return {
      templateId: item._id,
      templateName: item.name,
    };
  }

  private async getTemplateDataForTranslationGroup(
    entityId: string,
    environmentId: string
  ): Promise<IViewEntity | Record<string, unknown>> {
    try {
      if (process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true') {
        if (!require('@novu/ee-shared-services')?.TranslationsService) {
          throw new BadRequestException('Translation module is not loaded');
        }
        const service = this.moduleRef.get(require('@novu/ee-shared-services')?.TranslationsService, { strict: false });
        const { name, identifier } = await service.getTranslationGroupData(environmentId, entityId);

        return {
          templateId: identifier,
          templateName: name,
        };
      }
    } catch (e) {
      this.logger.error({ err: e }, `Unexpected error while importing enterprise modules`);
    }

    return {};
  }

  private async getTemplateDataForTranslation(
    entityId: string,
    environmentId: string
  ): Promise<IViewEntity | Record<string, unknown>> {
    try {
      if (process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true') {
        if (!require('@novu/ee-shared-services')?.TranslationsService) {
          throw new BadRequestException('Translation module is not loaded');
        }
        const service = this.moduleRef.get(require('@novu/ee-shared-services')?.TranslationsService, { strict: false });
        const { name, group } = await service.getTranslationData(environmentId, entityId);

        return {
          templateName: name,
          translationGroup: group,
        };
      }
    } catch (e) {
      this.logger.error({ err: e }, `Unexpected error while importing enterprise modules`);
    }

    return {};
  }

  private async getTemplateDataForNotificationGroup(
    entityId: string,
    environmentId: string
  ): Promise<IViewEntity | Record<string, unknown>> {
    const item = await this.notificationGroupRepository.findOne({
      _environmentId: environmentId,
      _id: entityId,
    });

    if (!item) {
      this.logger.error(`Could not find notification group for id ${entityId}`);

      return {};
    }

    return {
      templateName: item.name,
    };
  }

  private async getTemplateDataForFeed(
    entityId: string,
    environmentId: string
  ): Promise<IViewEntity | Record<string, unknown>> {
    let item = await this.feedRepository.findOne({
      _environmentId: environmentId,
      _id: entityId,
    });

    if (!item) {
      const items = await this.feedRepository.findDeleted({ _id: entityId, _environmentId: environmentId });
      item = items[0];
      if (!item) {
        this.logger.error(`Could not find feed for id ${entityId}`);

        return {};
      }
    }

    return {
      templateName: item.name,
    };
  }

  private async getTemplateDataForLayout(
    entityId: string,
    environmentId: string
  ): Promise<IViewEntity | Record<string, unknown>> {
    let item = await this.layoutRepository.findOne({
      _environmentId: environmentId,
      _id: entityId,
    });

    if (!item) {
      item = await this.layoutRepository.findDeleted(entityId, environmentId);
      if (!item) {
        this.logger.error(`Could not find layout for id ${entityId}`);

        return {};
      }
    }

    return {
      templateName: item.name,
    };
  }

  private async getTemplateDataForDefaultLayout(
    entityId: string,
    environmentId: string
  ): Promise<IViewEntity | Record<string, unknown>> {
    const currentDefaultLayout = await this.getTemplateDataForLayout(entityId, environmentId);

    const defaultLayout = await this.layoutRepository.findOne({
      _environmentId: environmentId,
      isDefault: true,
      _id: { $ne: entityId },
    });

    return {
      templateName: currentDefaultLayout?.templateName,
      previousDefaultLayout: defaultLayout?.name,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - changes(await changeItems.reduce(async (prev, change))
Declaraciones 'export' encontradas:
- export class GetChanges

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/promote-change-to-environment/index.ts
Tamao: 114 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './promote-change-to-environment.command';
export * from './promote-change-to-environment.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/promote-change-to-environment/promote-change-to-environment.command.ts
Tamao: 401 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChangeEntityTypeEnum } from '@novu/shared';
import { IsDefined, IsMongoId, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class PromoteChangeToEnvironmentCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  @IsMongoId()
  itemId: string;

  @IsDefined()
  @IsString()
  type: ChangeEntityTypeEnum;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class PromoteChangeToEnvironmentCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/promote-change-to-environment/promote-change-to-environment.usecase.ts
Tamao: 3811 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { forwardRef, Inject, Injectable, NotFoundException } from '@nestjs/common';
import { PinoLogger } from '@novu/application-generic';
import { ChangeRepository, EnvironmentRepository } from '@novu/dal';
import { ChangeEntityTypeEnum } from '@novu/shared';
import { applyDiff } from 'recursive-diff';
import { PromoteFeedChange } from '../promote-feed-change/promote-feed-change';
import { PromoteLayoutChange } from '../promote-layout-change';
import { PromoteMessageTemplateChange } from '../promote-message-template-change/promote-message-template-change';
import { PromoteNotificationGroupChange } from '../promote-notification-group-change/promote-notification-group-change';
import { PromoteTranslationChange } from '../promote-translation-change';
import { PromoteTranslationGroupChange } from '../promote-translation-group-change';
import { PromoteTypeChangeCommand } from '../promote-type-change.command';
import { INotificationTemplateChangeService } from '../shared';
import { PromoteChangeToEnvironmentCommand } from './promote-change-to-environment.command';

@Injectable()
export class PromoteChangeToEnvironment {
  constructor(
    private changeRepository: ChangeRepository,
    private environmentRepository: EnvironmentRepository,
    private promoteLayoutChange: PromoteLayoutChange,
    @Inject('INotificationTemplateChangeService')
    private promoteNotificationTemplateChange: INotificationTemplateChangeService,
    private promoteMessageTemplateChange: PromoteMessageTemplateChange,
    private promoteNotificationGroupChange: PromoteNotificationGroupChange,
    private promoteFeedChange: PromoteFeedChange,
    private promoteTranslationChange: PromoteTranslationChange,
    private promoteTranslationGroupChange: PromoteTranslationGroupChange,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: PromoteChangeToEnvironmentCommand) {
    const changes = await this.changeRepository.getEntityChanges(command.organizationId, command.type, command.itemId);
    const aggregatedItem = changes
      .filter((change) => change.enabled)
      .reduce((prev, change) => {
        return applyDiff(prev, change.change);
      }, {});

    const environment = await this.environmentRepository.findOne({
      _parentId: command.environmentId,
    });
    if (!environment) throw new NotFoundException(`Environment ${command.environmentId} not found`);

    const typeCommand = PromoteTypeChangeCommand.create({
      organizationId: command.organizationId,
      environmentId: environment._id,
      item: aggregatedItem,
      userId: command.userId,
    });

    switch (command.type) {
      case ChangeEntityTypeEnum.NOTIFICATION_TEMPLATE:
        await this.promoteNotificationTemplateChange.execute(typeCommand);
        break;
      case ChangeEntityTypeEnum.MESSAGE_TEMPLATE:
        await this.promoteMessageTemplateChange.execute(typeCommand);
        break;
      case ChangeEntityTypeEnum.NOTIFICATION_GROUP:
        await this.promoteNotificationGroupChange.execute(typeCommand);
        break;
      case ChangeEntityTypeEnum.FEED:
        await this.promoteFeedChange.execute(typeCommand);
        break;
      case ChangeEntityTypeEnum.LAYOUT:
      case ChangeEntityTypeEnum.DEFAULT_LAYOUT:
        await this.promoteLayoutChange.execute(typeCommand);
        break;
      case ChangeEntityTypeEnum.TRANSLATION:
        await this.promoteTranslationChange.execute(typeCommand);
        break;
      case ChangeEntityTypeEnum.TRANSLATION_GROUP:
        await this.promoteTranslationGroupChange.execute(typeCommand);
        break;
      default:
        this.logger.error(
          `Change with type ${command.type} could not be enabled from environment ${command.environmentId}`
        );
    }
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - aggregatedItem(changes
      .filter((change))
Declaraciones 'export' encontradas:
- export class PromoteChangeToEnvironment

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/promote-feed-change/promote-feed-change.ts
Tamao: 1011 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { FeedEntity, FeedRepository } from '@novu/dal';
import { PromoteTypeChangeCommand } from '../promote-type-change.command';

@Injectable()
export class PromoteFeedChange {
  constructor(private feedRepository: FeedRepository) {}

  async execute(command: PromoteTypeChangeCommand) {
    let item: FeedEntity | null = null;
    if (command.item.name) {
      item = await this.feedRepository.findOne({
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
        name: command.item.name,
      });
    }

    if (!item) {
      if (command.item.deleted) {
        return;
      }

      return this.feedRepository.create({
        name: command.item.name,
        identifier: command.item.name,
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
      });
    }

    return await this.feedRepository.delete({ _environmentId: command.environmentId, _id: item._id });
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class PromoteFeedChange

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/promote-layout-change/index.ts
Tamao: 50 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './promote-layout-change.use-case';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/promote-layout-change/promote-layout-change.use-case.ts
Tamao: 2164 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { LayoutEntity, LayoutRepository } from '@novu/dal';

import { PromoteTypeChangeCommand } from '../promote-type-change.command';

@Injectable()
export class PromoteLayoutChange {
  constructor(private layoutRepository: LayoutRepository) {}

  async execute(command: PromoteTypeChangeCommand) {
    let item = await this.layoutRepository.findOne({
      _environmentId: command.environmentId,
      _parentId: command.item._id,
    });

    // For the scenario where the layout is deleted and an active default layout change was pending
    if (!item) {
      item = await this.layoutRepository.findDeletedByParentId(command.item._id, command.environmentId);
    }

    const newItem = command.item as LayoutEntity;

    if (!item) {
      const layoutEntity = {
        name: newItem.name,
        identifier: newItem.identifier,
        content: newItem.content,
        description: newItem.description,
        contentType: newItem.contentType,
        variables: newItem.variables,
        isDefault: newItem.isDefault,
        channel: newItem.channel,
        _creatorId: command.userId,
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
        _parentId: newItem._id,
      };

      return await this.layoutRepository.create(layoutEntity);
    }

    const count = await this.layoutRepository.count({
      _organizationId: command.organizationId,
      _id: command.item._id,
    });

    if (count === 0) {
      await this.layoutRepository.deleteLayout(item._id, command.environmentId, command.organizationId);

      return;
    }

    return await this.layoutRepository.update(
      {
        _environmentId: command.environmentId,
        _id: item._id,
      },
      {
        name: newItem.name,
        identifier: newItem.identifier,
        content: newItem.content,
        description: newItem.description,
        contentType: newItem.contentType,
        variables: newItem.variables,
        isDefault: newItem.isDefault,
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
      }
    );
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class PromoteLayoutChange

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/promote-message-template-change/promote-message-template-change.ts
Tamao: 2982 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { FeedRepository, LayoutRepository, MessageTemplateEntity, MessageTemplateRepository } from '@novu/dal';
import { PromoteTypeChangeCommand } from '../promote-type-change.command';

@Injectable()
export class PromoteMessageTemplateChange {
  constructor(
    private messageTemplateRepository: MessageTemplateRepository,
    private feedRepository: FeedRepository,
    private layoutRepository: LayoutRepository
  ) {}

  async execute(command: PromoteTypeChangeCommand) {
    const item = await this.messageTemplateRepository.findOne({
      _environmentId: command.environmentId,
      _parentId: command.item._id,
    });

    const newItem = command.item as MessageTemplateEntity;

    const feedDev = await this.feedRepository.findOne({
      _id: newItem._feedId,
      _organizationId: command.organizationId,
    });

    const feed = await this.feedRepository.findOne({
      _environmentId: command.environmentId,
      identifier: feedDev?.identifier,
    });

    const layout = await this.layoutRepository.findOne({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      _parentId: newItem._layoutId,
    });

    if (!item) {
      if (newItem.deleted) {
        return;
      }

      return this.messageTemplateRepository.create({
        type: newItem.type,
        name: newItem.name,
        subject: newItem.subject,
        content: newItem.content,
        contentType: newItem.contentType,
        title: newItem.title,
        preheader: newItem.preheader,
        senderName: newItem.senderName,
        cta: newItem.cta,
        active: newItem.active,
        actor: newItem.actor,
        variables: newItem.variables,
        _parentId: newItem._id,
        _feedId: feed?._id,
        _layoutId: layout?._id,
        _environmentId: command.environmentId,
        _creatorId: command.userId,
        _organizationId: command.organizationId,
      });
    }

    const count = await this.messageTemplateRepository.count({
      _organizationId: command.organizationId,
      _id: command.item._id,
    });

    if (count === 0) {
      await this.messageTemplateRepository.delete({
        _id: item._id,
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
      });

      return;
    }

    return this.messageTemplateRepository.update(
      {
        _environmentId: command.environmentId,
        _id: item._id,
      },
      {
        type: newItem.type,
        name: newItem.name,
        subject: newItem.subject,
        content: newItem.content,
        contentType: newItem.contentType,
        title: newItem.title,
        cta: newItem.cta,
        preheader: newItem.preheader,
        senderName: newItem.senderName,
        active: newItem.active,
        actor: newItem.actor,
        variables: newItem.variables,
        _feedId: feed?._id,
        _layoutId: layout?._id,
      }
    );
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class PromoteMessageTemplateChange

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/promote-notification-group-change/promote-notification-group-change.ts
Tamao: 1160 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { NotificationGroupEntity, NotificationGroupRepository } from '@novu/dal';
import { PromoteTypeChangeCommand } from '../promote-type-change.command';

@Injectable()
export class PromoteNotificationGroupChange {
  constructor(private notificationGroupRepository: NotificationGroupRepository) {}

  async execute(command: PromoteTypeChangeCommand) {
    const item = await this.notificationGroupRepository.findOne({
      _environmentId: command.environmentId,
      _parentId: command.item._id,
    });

    const newItem = command.item as NotificationGroupEntity;

    if (!item) {
      return this.notificationGroupRepository.create({
        name: newItem.name,
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
        _parentId: newItem._id,
      });
    }

    return await this.notificationGroupRepository.update(
      {
        _environmentId: command.environmentId,
        _id: item._id,
      },
      {
        name: newItem.name,
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
      }
    );
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class PromoteNotificationGroupChange

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/promote-notification-template-change/index.ts
Tamao: 64 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './promote-notification-template-change.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/promote-notification-template-change/promote-notification-template-change.usecase.ts
Tamao: 10268 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { forwardRef, Inject, Injectable, NotFoundException } from '@nestjs/common';
import {
  buildGroupedBlueprintsKey,
  DeletePreferencesCommand,
  DeletePreferencesUseCase,
  InvalidateCacheService,
  PinoLogger,
  UpsertPreferences,
  UpsertUserWorkflowPreferencesCommand,
  UpsertWorkflowPreferencesCommand,
} from '@novu/application-generic';
import {
  ChangeRepository,
  EnvironmentRepository,
  MessageTemplateRepository,
  NotificationGroupRepository,
  NotificationStepData,
  NotificationStepEntity,
  NotificationTemplateEntity,
  NotificationTemplateRepository,
} from '@novu/dal';
import {
  buildWorkflowPreferencesFromPreferenceChannels,
  ChangeEntityTypeEnum,
  DEFAULT_WORKFLOW_PREFERENCES,
  IPreferenceChannels,
  PreferencesTypeEnum,
} from '@novu/shared';
import { ApplyChange, ApplyChangeCommand } from '../apply-change';
import { PromoteTypeChangeCommand } from '../promote-type-change.command';
import { INotificationTemplateChangeService } from '../shared';

/**
 * Promote a notification template change to a workflow
 *
 * TODO: update this use-case to use the following use-cases which fully handle
 * the workflow creation, update and deletion:
 * - CreateWorkflow
 * - UpdateWorkflow
 * - DeleteWorkflow
 */
@Injectable()
export class PromoteNotificationTemplateChange implements INotificationTemplateChangeService {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private notificationTemplateRepository: NotificationTemplateRepository,
    private environmentRepository: EnvironmentRepository,
    private messageTemplateRepository: MessageTemplateRepository,
    private notificationGroupRepository: NotificationGroupRepository,
    @Inject(forwardRef(() => ApplyChange)) private applyChange: ApplyChange,
    private changeRepository: ChangeRepository,
    private upsertPreferences: UpsertPreferences,
    private deletePreferences: DeletePreferencesUseCase,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: PromoteTypeChangeCommand) {
    await this.invalidateBlueprints(command);

    const item = await this.notificationTemplateRepository.findOne({
      _environmentId: command.environmentId,
      _parentId: command.item._id,
    });

    const newItem = command.item as NotificationTemplateEntity;

    const messages = await this.messageTemplateRepository.find({
      _environmentId: command.environmentId,
      _parentId: {
        $in: (newItem.steps || []).flatMap((step) => [
          step._templateId,
          ...(step.variants || []).flatMap((variant) => variant._templateId),
        ]),
      },
    });

    const missingMessages: string[] = [];

    const mapNewStepItem = (step: NotificationStepEntity) => {
      const oldMessage = messages.find((message) => {
        return message._parentId === step._templateId;
      });

      if (step.variants && step.variants.length > 0) {
        step.variants = step.variants
          ?.map(mapNewVariantItem)
          .filter((variant): variant is NotificationStepData => variant !== undefined);
      }

      if (!oldMessage) {
        missingMessages.push(step._templateId);

        return undefined;
      }

      if (step?._templateId && oldMessage._id) {
        step._templateId = oldMessage._id;
      }

      return step;
    };

    const mapNewVariantItem = (step: NotificationStepData) => {
      const oldMessage = messages.find((message) => {
        return message._parentId === step._templateId;
      });

      if (!oldMessage) {
        missingMessages.push(step._templateId);

        return undefined;
      }

      if (step?._templateId && oldMessage._id) {
        step._templateId = oldMessage._id;
      }

      return step;
    };

    const steps = newItem.steps
      ? newItem.steps.map(mapNewStepItem).filter((step): step is NotificationStepEntity => step !== undefined)
      : [];

    if (missingMessages.length > 0 && steps.length > 0 && item) {
      this.logger.error(
        `Message templates with ids ${missingMessages.join(', ')} are missing for notification template ${item._id}`
      );
    }

    let notificationGroup = await this.notificationGroupRepository.findOne({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      _parentId: newItem._notificationGroupId,
    });

    if (!notificationGroup) {
      const changes = await this.changeRepository.getEntityChanges(
        command.organizationId,
        ChangeEntityTypeEnum.NOTIFICATION_GROUP,
        newItem._notificationGroupId
      );

      for (const change of changes) {
        await this.applyChange.execute(
          ApplyChangeCommand.create({
            changeId: change._id,
            environmentId: change._environmentId,
            organizationId: change._organizationId,
            userId: command.userId,
          })
        );
      }
      notificationGroup = await this.notificationGroupRepository.findOne({
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
        _parentId: newItem._notificationGroupId,
      });
    }

    if (!notificationGroup) {
      throw new NotFoundException(
        `Notification Group Id ${newItem._notificationGroupId} not found, Notification Template: ${newItem.name}`
      );
    }

    if (!item) {
      if (newItem.deleted) {
        return;
      }

      const newNotificationTemplate: Partial<NotificationTemplateEntity> = {
        name: newItem.name,
        active: newItem.active,
        draft: newItem.draft,
        description: newItem.description,
        tags: newItem.tags,
        critical: newItem.critical,
        triggers: newItem.triggers,
        preferenceSettings: newItem.preferenceSettings,
        steps,
        _parentId: command.item._id,
        _creatorId: command.userId,
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
        _notificationGroupId: notificationGroup._id,
        isBlueprint: command.organizationId === this.blueprintOrganizationId,
        blueprintId: newItem.blueprintId,
        ...(newItem.data ? { data: newItem.data } : {}),
      };

      const createdTemplate = await this.notificationTemplateRepository.create(
        newNotificationTemplate as NotificationTemplateEntity
      );
      await this.updateWorkflowPreferences(createdTemplate._id, command, newItem.critical, newItem.preferenceSettings);

      return createdTemplate;
    }

    const count = await this.notificationTemplateRepository.count({
      _organizationId: command.organizationId,
      _id: command.item._id,
    });

    if (count === 0) {
      await this.notificationTemplateRepository.delete({ _environmentId: command.environmentId, _id: item._id });

      await this.deleteWorkflowPreferences(item._id, command);

      return;
    }

    const updatedTemplate = await this.notificationTemplateRepository.update(
      {
        _environmentId: command.environmentId,
        _id: item._id,
      },
      {
        name: newItem.name,
        active: newItem.active,
        draft: newItem.draft,
        description: newItem.description,
        tags: newItem.tags,
        critical: newItem.critical,
        triggers: newItem.triggers,
        preferenceSettings: newItem.preferenceSettings,
        steps,
        _notificationGroupId: notificationGroup._id,
        isBlueprint: command.organizationId === this.blueprintOrganizationId,
        ...(newItem.data ? { data: newItem.data } : {}),
      }
    );
    await this.updateWorkflowPreferences(item._id, command, newItem.critical, newItem.preferenceSettings);

    return updatedTemplate;
  }

  private async updateWorkflowPreferences(
    workflowId: string,
    command: PromoteTypeChangeCommand,
    critical: boolean,
    preferenceSettings: IPreferenceChannels
  ) {
    await this.upsertPreferences.upsertUserWorkflowPreferences(
      UpsertUserWorkflowPreferencesCommand.create({
        templateId: workflowId,
        preferences: buildWorkflowPreferencesFromPreferenceChannels(critical, preferenceSettings),
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        userId: command.userId,
      })
    );

    await this.upsertPreferences.upsertWorkflowPreferences(
      UpsertWorkflowPreferencesCommand.create({
        templateId: workflowId,
        preferences: DEFAULT_WORKFLOW_PREFERENCES,
        environmentId: command.environmentId,
        organizationId: command.organizationId,
      })
    );
  }

  private async deleteWorkflowPreferences(workflowId: string, command: PromoteTypeChangeCommand) {
    await this.deletePreferences.execute(
      DeletePreferencesCommand.create({
        templateId: workflowId,
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        userId: command.userId,
        type: PreferencesTypeEnum.USER_WORKFLOW,
      })
    );

    await this.deletePreferences.execute(
      DeletePreferencesCommand.create({
        templateId: workflowId,
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        userId: command.userId,
        type: PreferencesTypeEnum.WORKFLOW_RESOURCE,
      })
    );
  }

  private async getProductionEnvironmentId(organizationId: string) {
    const productionEnvironmentId = (
      await this.environmentRepository.findOrganizationEnvironments(organizationId)
    )?.find((env) => env.name === 'Production')?._id;

    if (!productionEnvironmentId) {
      throw new NotFoundException('Production environment not found');
    }

    return productionEnvironmentId;
  }

  private get blueprintOrganizationId() {
    return NotificationTemplateRepository.getBlueprintOrganizationId();
  }

  private async invalidateBlueprints(command: PromoteTypeChangeCommand) {
    if (command.organizationId === this.blueprintOrganizationId) {
      const productionEnvironmentId = await this.getProductionEnvironmentId(this.blueprintOrganizationId);

      if (productionEnvironmentId) {
        await this.invalidateCache.invalidateByKey({
          key: buildGroupedBlueprintsKey(productionEnvironmentId),
        });
      }
    }
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - messages(await this.messageTemplateRepository.find({
      _environmentId: command.environmentId,
      _pare...)
 - mapNewStepItem(step: NotificationStepEntity))
 - oldMessage(messages.find((message))
 - variants(step.variants
          ?.map(mapNewVariantItem)
          .filter((variant): variant is Notificatio...)
 - mapNewVariantItem(step: NotificationStepData))
 - oldMessage(messages.find((message))
 - steps(newItem.steps
      ? newItem.steps.map(mapNewStepItem).filter((step): step is NotificationStepEntit...)
 - productionEnvironmentId(await this.environmentRepository.findOrganizationEnvironments(organizationId)
    )?.find((env))
Declaraciones 'export' encontradas:
- export class PromoteNotificationTemplateChange

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/promote-translation-change/index.ts
Tamao: 54 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './promote-translation-change.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/promote-translation-change/promote-translation-change.usecase.ts
Tamao: 2023 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, forwardRef, Inject, Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { PinoLogger } from '@novu/application-generic';
import { ChangeRepository } from '@novu/dal';
import { ChangeEntityTypeEnum } from '@novu/shared';
import { ApplyChange, ApplyChangeCommand } from '../apply-change';
import { PromoteTypeChangeCommand } from '../promote-type-change.command';

@Injectable()
export class PromoteTranslationChange {
  constructor(
    private moduleRef: ModuleRef,
    @Inject(forwardRef(() => ApplyChange)) private applyChange: ApplyChange,
    private changeRepository: ChangeRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: PromoteTypeChangeCommand) {
    try {
      if (process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true') {
        if (!require('@novu/ee-translation')?.PromoteTranslationChange) {
          throw new BadRequestException('Translation module is not loaded');
        }
        const usecase = this.moduleRef.get(require('@novu/ee-translation')?.PromoteTranslationChange, {
          strict: false,
        });
        await usecase.execute(command, this.applyGroupChange.bind(this));
      }
    } catch (e) {
      this.logger.error({ err: e }, `Unexpected error while importing enterprise modules`);
    }
  }

  private async applyGroupChange(command: PromoteTypeChangeCommand) {
    const newItem = command.item as {
      _groupId: string;
    };

    const changes = await this.changeRepository.getEntityChanges(
      command.organizationId,
      ChangeEntityTypeEnum.TRANSLATION_GROUP,
      newItem._groupId
    );

    for (const change of changes) {
      await this.applyChange.execute(
        ApplyChangeCommand.create({
          changeId: change._id,
          environmentId: change._environmentId,
          organizationId: change._organizationId,
          userId: command.userId,
        })
      );
    }
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class PromoteTranslationChange

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/promote-translation-group-change/index.ts
Tamao: 60 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './promote-translation-group-change.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/promote-translation-group-change/promote-translation-group-change.usecase.ts
Tamao: 2008 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, forwardRef, Inject, Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { PinoLogger } from '@novu/application-generic';
import { ChangeRepository } from '@novu/dal';
import { ChangeEntityTypeEnum } from '@novu/shared';
import { ApplyChange, ApplyChangeCommand } from '../apply-change';
import { PromoteTypeChangeCommand } from '../promote-type-change.command';

@Injectable()
export class PromoteTranslationGroupChange {
  constructor(
    private moduleRef: ModuleRef,
    @Inject(forwardRef(() => ApplyChange)) private applyChange: ApplyChange,
    private changeRepository: ChangeRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: PromoteTypeChangeCommand) {
    try {
      if (process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true') {
        if (!require('@novu/ee-translation')?.PromoteTranslationGroupChange) {
          throw new BadRequestException('Translation module is not loaded');
        }
        const usecase = this.moduleRef.get(require('@novu/ee-translation')?.PromoteTranslationGroupChange, {
          strict: false,
        });
        await usecase.execute(command, this.applyDefaultTranslationChange.bind(this));
      }
    } catch (e) {
      this.logger.error({ err: e }, `Unexpected error while importing enterprise modules`);
    }
  }

  private async applyDefaultTranslationChange(command: PromoteTypeChangeCommand, translationId: string) {
    const changes = await this.changeRepository.getEntityChanges(
      command.organizationId,
      ChangeEntityTypeEnum.TRANSLATION,
      translationId
    );

    for (const change of changes) {
      await this.applyChange.execute(
        ApplyChangeCommand.create({
          changeId: change._id,
          environmentId: change._environmentId,
          organizationId: change._organizationId,
          userId: command.userId,
        })
      );
    }
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class PromoteTranslationGroupChange

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/shared/index.ts
Tamao: 58 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './notification-template-change.interface';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/change/usecases/shared/notification-template-change.interface.ts
Tamao: 192 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PromoteTypeChangeCommand } from '../promote-type-change.command';

export interface INotificationTemplateChangeService {
  execute(command: PromoteTypeChangeCommand): Promise<any>;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/channel-connections.module.ts
Tamao: 1296 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { featureFlagsService } from '@novu/application-generic';
import {
  ChannelConnectionRepository,
  CommunityOrganizationRepository,
  EnvironmentRepository,
  IntegrationRepository,
  SubscriberRepository,
} from '@novu/dal';
import { CreateChannelConnection } from './usecases/create-channel-connection/create-channel-connection.usecase';
import { DeleteChannelConnection } from './usecases/delete-channel-connection/delete-channel-connection.usecase';
import { GetChannelConnection } from './usecases/get-channel-connection/get-channel-connection.usecase';
import { GetChannelConnections } from './usecases/get-channel-connections/get-channel-connections.usecase';
import { UpdateChannelConnection } from './usecases/update-channel-connection/update-channel-connection.usecase';

const USE_CASES = [
  GetChannelConnection,
  GetChannelConnections,
  CreateChannelConnection,
  UpdateChannelConnection,
  DeleteChannelConnection,
];

const DAL_MODELS = [
  ChannelConnectionRepository,
  SubscriberRepository,
  IntegrationRepository,
  EnvironmentRepository,
  CommunityOrganizationRepository,
];

@Module({
  providers: [...USE_CASES, ...DAL_MODELS, featureFlagsService],
  exports: [...USE_CASES],
})
export class ChannelConnectionsModule {}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ChannelConnectionsModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/dtos/create-channel-connection-request.dto.ts
Tamao: 1030 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsDefined, IsOptional, IsString, ValidateNested } from 'class-validator';
import { AuthDto, WorkspaceDto } from './shared.dto';

export class CreateChannelConnectionRequestDto {
  @ApiPropertyOptional({
    description:
      'The unique identifier for the channel connection. If not provided, one will be generated automatically.',
    type: String,
    example: 'slack-prod-user123-abc4',
  })
  @IsOptional()
  @IsString()
  identifier?: string;

  @ApiProperty({
    description: 'The identifier of the integration to use for this channel connection.',
    type: String,
    example: 'slack-prod',
  })
  @IsString()
  @IsDefined()
  integrationIdentifier: string;

  @ApiProperty({ type: WorkspaceDto })
  @IsDefined()
  @ValidateNested()
  @Type(() => WorkspaceDto)
  workspace: WorkspaceDto;

  @ApiProperty({ type: AuthDto })
  @IsDefined()
  @ValidateNested()
  @Type(() => AuthDto)
  auth: AuthDto;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class CreateChannelConnectionRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/dtos/dto.mapper.ts
Tamao: 723 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelConnectionEntity } from '@novu/dal';
import { ProvidersIdEnum } from '@novu/shared';
import { GetChannelConnectionResponseDto } from './get-channel-connection-response.dto';

export function mapChannelConnectionEntityToDto(
  channelConnection: ChannelConnectionEntity
): GetChannelConnectionResponseDto {
  return {
    identifier: channelConnection.identifier,
    channel: channelConnection.channel,
    provider: channelConnection.providerId as ProvidersIdEnum,
    integrationIdentifier: channelConnection.integrationIdentifier,
    workspace: channelConnection.workspace,
    auth: channelConnection.auth,
    createdAt: channelConnection.createdAt,
    updatedAt: channelConnection.updatedAt,
  };
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - mapChannelConnectionEntityToDto(channelConnection: ChannelConnectionEntity)
Declaraciones 'export' encontradas:
- export function mapChannelConnectionEntityToDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/dtos/get-channel-connection-response.dto.ts
Tamao: 1362 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { ChannelTypeEnum, ProvidersIdEnum, ProvidersIdEnumConst } from '@novu/shared';
import { AuthDto, WorkspaceDto } from './shared.dto';

export class GetChannelConnectionResponseDto {
  @ApiProperty({
    description: 'The unique identifier of the channel endpoint.',
    type: String,
  })
  identifier: string;

  @ApiProperty({
    description: 'The channel type (email, sms, push, chat, etc.).',
    enum: ChannelTypeEnum,
  })
  channel: ChannelTypeEnum | null;

  @ApiProperty({
    description: 'The provider identifier (e.g., sendgrid, twilio, slack, etc.).',
    enum: Object.values(ProvidersIdEnumConst),
  })
  provider: ProvidersIdEnum | null;

  @ApiProperty({
    description: 'The identifier of the integration to use for this channel endpoint.',
    type: String,
    example: 'slack-prod',
  })
  integrationIdentifier: string | null;

  @ApiProperty({ type: WorkspaceDto })
  workspace: WorkspaceDto;

  @ApiProperty({ type: AuthDto })
  auth: AuthDto;

  @ApiProperty({
    description: 'The timestamp indicating when the channel endpoint was created, in ISO 8601 format.',
    type: String,
  })
  createdAt: string;

  @ApiProperty({
    description: 'The timestamp indicating when the channel endpoint was last updated, in ISO 8601 format.',
    type: String,
  })
  updatedAt: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetChannelConnectionResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/dtos/get-channel-connections-query.dto.ts
Tamao: 750 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { ChannelTypeEnum, ProvidersIdEnum, ProvidersIdEnumConst } from '@novu/shared';
import { IsEnum, IsOptional } from 'class-validator';

export class GetChannelConnectionsQueryDto {
  @ApiPropertyOptional({
    description: 'Filter by channel type (email, sms, push, chat, etc.).',
    enum: ChannelTypeEnum,
    example: ChannelTypeEnum.CHAT,
  })
  @IsOptional()
  @IsEnum(ChannelTypeEnum)
  channel?: ChannelTypeEnum;

  @ApiPropertyOptional({
    description: 'Filter by provider identifier (e.g., sendgrid, twilio, slack, etc.).',
    enum: Object.values(ProvidersIdEnumConst),
    example: 'slack',
  })
  @IsOptional()
  @IsEnum(ProvidersIdEnumConst)
  provider?: ProvidersIdEnum;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetChannelConnectionsQueryDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/dtos/shared.dto.ts
Tamao: 475 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsDefined, IsOptional, IsString } from 'class-validator';

export class WorkspaceDto {
  @ApiProperty({ example: 'T123456' })
  @IsDefined()
  @IsString()
  id: string;

  @ApiPropertyOptional({ example: 'Acme HQ' })
  @IsOptional()
  @IsString()
  name?: string;
}

export class AuthDto {
  @ApiProperty({ example: 'Workspace access token' })
  @IsDefined()
  @IsString()
  accessToken: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class WorkspaceDto
- export class AuthDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/dtos/update-channel-connection-request.dto.ts
Tamao: 495 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsDefined, ValidateNested } from 'class-validator';
import { AuthDto, WorkspaceDto } from './shared.dto';

export class UpdateChannelConnectionRequestDto {
  @ApiProperty({ type: WorkspaceDto })
  @IsDefined()
  @ValidateNested()
  @Type(() => WorkspaceDto)
  workspace: WorkspaceDto;

  @ApiProperty({ type: AuthDto })
  @IsDefined()
  @ValidateNested()
  @Type(() => AuthDto)
  auth: AuthDto;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class UpdateChannelConnectionRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/usecases/create-channel-connection/create-channel-connection.command.ts
Tamao: 813 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ResourceKey } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsDefined, IsOptional, IsString, ValidateNested } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';
import { IsResourceKey } from '../../../shared/validators/resource-key.validator';
import { AuthDto, WorkspaceDto } from '../../dtos/shared.dto';

export class CreateChannelConnectionCommand extends EnvironmentCommand {
  @IsOptional()
  @IsString()
  identifier?: string;

  @IsDefined()
  @IsString()
  integrationIdentifier: string;

  @IsDefined()
  @IsResourceKey()
  resource: ResourceKey;

  @IsDefined()
  @ValidateNested()
  @Type(() => WorkspaceDto)
  workspace: WorkspaceDto;

  @IsDefined()
  @ValidateNested()
  @Type(() => AuthDto)
  auth: AuthDto;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class CreateChannelConnectionCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/usecases/create-channel-connection/create-channel-connection.usecase.ts
Tamao: 4066 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ConflictException, Injectable, NotFoundException } from '@nestjs/common';
import { InstrumentUsecase, shortId } from '@novu/application-generic';
import {
  ChannelConnectionEntity,
  ChannelConnectionRepository,
  IntegrationEntity,
  IntegrationRepository,
  SubscriberRepository,
} from '@novu/dal';
import { parseResourceKey } from '@novu/shared';
import { CreateChannelConnectionCommand } from './create-channel-connection.command';

@Injectable()
export class CreateChannelConnection {
  constructor(
    private readonly channelConnectionRepository: ChannelConnectionRepository,
    private readonly integrationRepository: IntegrationRepository,
    private readonly subscriberRepository: SubscriberRepository
  ) {}

  @InstrumentUsecase()
  async execute(command: CreateChannelConnectionCommand): Promise<ChannelConnectionEntity> {
    const integration = await this.findIntegration(command);

    await this.assertSingleConnectionPerResourceAndIntegration(command, integration);
    await this.assertResourceExists(command);

    const identifier = command.identifier || this.generateIdentifier();

    // Check if channel connection already exists
    const existingChannelConnection = await this.channelConnectionRepository.findOne({
      identifier,
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
    });

    if (existingChannelConnection) {
      throw new ConflictException(
        `Channel connection with identifier "${identifier}" already exists in environment "${command.environmentId}"`
      );
    }

    const channelConnection = await this.createChannelConnection(command, identifier, integration);

    return channelConnection;
  }

  private async assertSingleConnectionPerResourceAndIntegration(
    command: CreateChannelConnectionCommand,
    integration: IntegrationEntity
  ) {
    const existingChannelConnection = await this.channelConnectionRepository.findOne({
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
      resource: command.resource,
      integrationIdentifier: integration.identifier,
    });

    if (existingChannelConnection) {
      throw new ConflictException(`Only one channel connection per resource and integration is allowed`);
    }
  }

  private async createChannelConnection(
    command: CreateChannelConnectionCommand,
    identifier: string,
    integration: IntegrationEntity
  ): Promise<ChannelConnectionEntity> {
    const channelConnection = await this.channelConnectionRepository.create({
      identifier,
      integrationIdentifier: integration.identifier,
      providerId: integration.providerId,
      channel: integration.channel,
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
      resource: command.resource,
      workspace: command.workspace,
      auth: command.auth,
    });

    return channelConnection;
  }

  private async assertResourceExists(command: CreateChannelConnectionCommand) {
    const { type, id } = parseResourceKey(command.resource);

    switch (type) {
      case 'subscriber': {
        const found = await this.subscriberRepository.findOne({
          subscriberId: id,
          _organizationId: command.organizationId,
          _environmentId: command.environmentId,
        });

        if (!found) throw new NotFoundException(`Subscriber not found: ${id}`);

        return;
      }
      default:
        throw new NotFoundException(`Resource type not found: ${type}`);
    }
  }

  private async findIntegration(command: CreateChannelConnectionCommand) {
    const integration = await this.integrationRepository.findOne({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      identifier: command.integrationIdentifier,
    });

    if (!integration) {
      throw new NotFoundException(`Integration not found: ${command.integrationIdentifier}`);
    }

    return integration;
  }

  private generateIdentifier(): string {
    return `chconn-${shortId(6)}`;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class CreateChannelConnection

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/usecases/delete-channel-connection/delete-channel-connection.command.ts
Tamao: 261 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class DeleteChannelConnectionCommand extends EnvironmentCommand {
  @IsDefined()
  @IsString()
  identifier: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class DeleteChannelConnectionCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/usecases/delete-channel-connection/delete-channel-connection.usecase.ts
Tamao: 1068 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { ChannelConnectionRepository } from '@novu/dal';
import { DeleteChannelConnectionCommand } from './delete-channel-connection.command';

@Injectable()
export class DeleteChannelConnection {
  constructor(private readonly channelConnectionRepository: ChannelConnectionRepository) {}

  @InstrumentUsecase()
  async execute(command: DeleteChannelConnectionCommand): Promise<void> {
    const channelConnection = await this.channelConnectionRepository.findOne({
      identifier: command.identifier,
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
    });

    if (!channelConnection) {
      throw new NotFoundException(`Channel connection with identifier '${command.identifier}' not found`);
    }

    await this.channelConnectionRepository.delete({
      _id: channelConnection._id,
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class DeleteChannelConnection

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/usecases/get-channel-connection/get-channel-connection.command.ts
Tamao: 470 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ResourceKey } from '@novu/shared';
import { IsDefined, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';
import { IsResourceKey } from '../../../shared/validators/resource-key.validator';

export class GetChannelConnectionCommand extends EnvironmentCommand {
  @IsDefined()
  @IsString()
  @IsResourceKey()
  resource: ResourceKey;

  @IsDefined()
  @IsString()
  integrationIdentifier: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetChannelConnectionCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/usecases/get-channel-connection/get-channel-connection.usecase.ts
Tamao: 1063 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { ChannelConnectionEntity, ChannelConnectionRepository } from '@novu/dal';
import { GetChannelConnectionCommand } from './get-channel-connection.command';

@Injectable()
export class GetChannelConnection {
  constructor(private readonly channelConnectionRepository: ChannelConnectionRepository) {}

  @InstrumentUsecase()
  async execute(command: GetChannelConnectionCommand): Promise<ChannelConnectionEntity> {
    const channelConnection = await this.channelConnectionRepository.findOne({
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
      resource: command.resource,
      integrationIdentifier: command.integrationIdentifier,
    });

    if (!channelConnection) {
      throw new NotFoundException(
        `Channel connection with resource '${command.resource}' and integration '${command.integrationIdentifier}' not found`
      );
    }

    return channelConnection;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetChannelConnection

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/usecases/get-channel-connections/get-channel-connections.command.ts
Tamao: 534 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelTypeEnum, ProvidersIdEnum, ProvidersIdEnumConst, ResourceKey } from '@novu/shared';
import { IsDefined, IsEnum, IsOptional, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class GetChannelConnectionsCommand extends EnvironmentCommand {
  @IsDefined()
  @IsString()
  resource: ResourceKey;

  @IsEnum(ChannelTypeEnum)
  @IsOptional()
  channel?: ChannelTypeEnum;

  @IsEnum(ProvidersIdEnumConst)
  @IsOptional()
  provider?: ProvidersIdEnum;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetChannelConnectionsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/usecases/get-channel-connections/get-channel-connections.usecase.ts
Tamao: 1340 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import {
  ChannelConnectionDBModel,
  ChannelConnectionEntity,
  ChannelConnectionRepository,
  EnforceEnvOrOrgIds,
} from '@novu/dal';
import { ProvidersIdEnum } from '@novu/shared';
import { FilterQuery } from 'mongoose';
import { GetChannelConnectionsCommand } from './get-channel-connections.command';

@Injectable()
export class GetChannelConnections {
  constructor(private readonly channelConnectionRepository: ChannelConnectionRepository) {}

  @InstrumentUsecase()
  async execute(command: GetChannelConnectionsCommand): Promise<ChannelConnectionEntity[]> {
    const channelConnections = await this.fetchChannelConnections(command);

    return channelConnections;
  }

  private async fetchChannelConnections(command: GetChannelConnectionsCommand): Promise<ChannelConnectionEntity[]> {
    const query: FilterQuery<ChannelConnectionDBModel> & EnforceEnvOrOrgIds = {
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
      resource: command.resource,
    };

    if (command.channel) {
      query.channel = command.channel;
    }

    if (command.provider) {
      query.providerId = command.provider;
    }

    return await this.channelConnectionRepository.find(query);
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetChannelConnections

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/usecases/update-channel-connection/update-channel-connection.command.ts
Tamao: 549 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Type } from 'class-transformer';
import { IsDefined, IsString, ValidateNested } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';
import { AuthDto, WorkspaceDto } from '../../dtos/shared.dto';

export class UpdateChannelConnectionCommand extends EnvironmentCommand {
  @IsDefined()
  @IsString()
  identifier: string;

  @IsDefined()
  @ValidateNested()
  @Type(() => WorkspaceDto)
  workspace: WorkspaceDto;

  @IsDefined()
  @ValidateNested()
  @Type(() => AuthDto)
  auth: AuthDto;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class UpdateChannelConnectionCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-connections/usecases/update-channel-connection/update-channel-connection.usecase.ts
Tamao: 1346 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { ChannelConnectionEntity, ChannelConnectionRepository } from '@novu/dal';
import { UpdateChannelConnectionCommand } from './update-channel-connection.command';

@Injectable()
export class UpdateChannelConnection {
  constructor(private readonly channelConnectionRepository: ChannelConnectionRepository) {}

  @InstrumentUsecase()
  async execute(command: UpdateChannelConnectionCommand): Promise<ChannelConnectionEntity> {
    const updatedChannelConnection = await this.updateChannelConnection(command);

    return updatedChannelConnection;
  }

  private async updateChannelConnection(command: UpdateChannelConnectionCommand): Promise<ChannelConnectionEntity> {
    const channelConnection = await this.channelConnectionRepository.findOneAndUpdate(
      {
        identifier: command.identifier,
        _organizationId: command.organizationId,
        _environmentId: command.environmentId,
      },
      {
        workspace: command.workspace,
        auth: command.auth,
      },
      {
        new: true,
      }
    );

    if (!channelConnection) {
      throw new NotFoundException(`Channel connection with identifier "${command.identifier}" not found`);
    }

    return channelConnection;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class UpdateChannelConnection

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/channel-endpoints.module.ts
Tamao: 1312 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { featureFlagsService } from '@novu/application-generic';
import {
  ChannelConnectionRepository,
  ChannelEndpointRepository,
  CommunityOrganizationRepository,
  EnvironmentRepository,
  IntegrationRepository,
  SubscriberRepository,
} from '@novu/dal';
import { CreateChannelEndpoint } from './usecases/create-channel-endpoint/create-channel-endpoint.usecase';
import { DeleteChannelEndpoint } from './usecases/delete-channel-endpoint/delete-channel-endpoint.usecase';
import { GetChannelEndpoint } from './usecases/get-channel-endpoint/get-channel-endpoint.usecase';
import { GetChannelEndpoints } from './usecases/get-channel-endpoints/get-channel-endpoints.usecase';
import { UpdateChannelEndpoint } from './usecases/update-channel-endpoint/update-channel-endpoint.usecase';

const USE_CASES = [
  GetChannelEndpoints,
  GetChannelEndpoint,
  CreateChannelEndpoint,
  UpdateChannelEndpoint,
  DeleteChannelEndpoint,
];

const DAL_MODELS = [
  ChannelEndpointRepository,
  ChannelConnectionRepository,
  SubscriberRepository,
  IntegrationRepository,
  EnvironmentRepository,
  CommunityOrganizationRepository,
];

@Module({
  providers: [...USE_CASES, ...DAL_MODELS, featureFlagsService],
  exports: [...USE_CASES],
})
export class ChannelEndpointsModule {}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ChannelEndpointsModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/dtos/create-channel-endpoint-request.dto.ts
Tamao: 1631 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { getApiPropertyExamples } from '@novu/application-generic';
import { ChannelEndpointByType, ChannelEndpointType, ENDPOINT_TYPES } from '@novu/shared';
import { IsDefined, IsEnum, IsOptional, IsString } from 'class-validator';
import { IsValidChannelEndpoint } from '../validators/channel-endpoint.validator';

export class CreateChannelEndpointRequestDto {
  @ApiPropertyOptional({
    description:
      'The unique identifier for the channel endpoint. If not provided, one will be generated automatically.',
    type: String,
    example: 'slack-channel-user123-abc4',
  })
  @IsOptional()
  @IsString()
  identifier?: string;

  @ApiProperty({
    description: 'The identifier of the integration to use for this channel endpoint.',
    type: String,
    example: 'slack-prod',
  })
  @IsString()
  @IsDefined()
  integrationIdentifier: string;

  @ApiPropertyOptional({
    description: 'The identifier of the channel connection to use for this channel endpoint.',
    type: String,
    example: 'slack-connection-abc123',
  })
  @IsOptional()
  @IsString()
  connectionIdentifier?: string;

  @ApiProperty({
    description: 'Type of channel endpoint',
    enum: Object.values(ENDPOINT_TYPES),
    example: ENDPOINT_TYPES.SLACK_CHANNEL,
  })
  @IsDefined()
  @IsEnum(Object.values(ENDPOINT_TYPES))
  type: ChannelEndpointType;

  @ApiProperty({
    description: 'Endpoint data specific to the channel type',
    oneOf: getApiPropertyExamples(),
  })
  @IsDefined()
  @IsValidChannelEndpoint()
  endpoint: ChannelEndpointByType[ChannelEndpointType];
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class CreateChannelEndpointRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/dtos/dto.mapper.ts
Tamao: 759 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelEndpointEntity } from '@novu/dal';
import { ProvidersIdEnum } from '@novu/shared';
import { GetChannelEndpointResponseDto } from './get-channel-endpoint-response.dto';

export function mapChannelEndpointEntityToDto(channelEndpoint: ChannelEndpointEntity): GetChannelEndpointResponseDto {
  return {
    identifier: channelEndpoint.identifier,
    channel: channelEndpoint.channel,
    provider: channelEndpoint.providerId as ProvidersIdEnum,
    integrationIdentifier: channelEndpoint.integrationIdentifier,
    connectionIdentifier: channelEndpoint.connectionIdentifier || null,
    type: channelEndpoint.type,
    endpoint: channelEndpoint.endpoint,
    createdAt: channelEndpoint.createdAt,
    updatedAt: channelEndpoint.updatedAt,
  };
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - mapChannelEndpointEntityToDto(channelEndpoint: ChannelEndpointEntity)
Declaraciones 'export' encontradas:
- export function mapChannelEndpointEntityToDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/dtos/get-channel-endpoint-response.dto.ts
Tamao: 1893 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { getApiPropertyExamples } from '@novu/application-generic';
import {
  ChannelEndpointByType,
  ChannelEndpointType,
  ChannelTypeEnum,
  ENDPOINT_TYPES,
  ProvidersIdEnum,
  ProvidersIdEnumConst,
} from '@novu/shared';

export class GetChannelEndpointResponseDto {
  @ApiProperty({
    description: 'The unique identifier of the channel endpoint.',
    type: String,
  })
  identifier: string;

  @ApiProperty({
    description: 'The channel type (email, sms, push, chat, etc.).',
    enum: ChannelTypeEnum,
  })
  channel: ChannelTypeEnum | null;

  @ApiProperty({
    description: 'The provider identifier (e.g., sendgrid, twilio, slack, etc.).',
    enum: Object.values(ProvidersIdEnumConst),
  })
  provider: ProvidersIdEnum | null;

  @ApiProperty({
    description: 'The identifier of the integration to use for this channel endpoint.',
    type: String,
    example: 'slack-prod',
  })
  integrationIdentifier: string | null;

  @ApiProperty({
    description: 'The identifier of the channel connection used for this endpoint.',
    type: String,
    example: 'slack-connection-abc123',
  })
  connectionIdentifier: string | null;

  @ApiProperty({
    description: 'Type of channel endpoint',
    enum: Object.values(ENDPOINT_TYPES),
    example: ENDPOINT_TYPES.SLACK_CHANNEL,
  })
  type: ChannelEndpointType;

  @ApiProperty({
    description: 'Endpoint data specific to the channel type',
    oneOf: getApiPropertyExamples(),
  })
  endpoint: ChannelEndpointByType[ChannelEndpointType];

  @ApiProperty({
    description: 'The timestamp indicating when the channel endpoint was created, in ISO 8601 format.',
    type: String,
  })
  createdAt: string;

  @ApiProperty({
    description: 'The timestamp indicating when the channel endpoint was last updated, in ISO 8601 format.',
    type: String,
  })
  updatedAt: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetChannelEndpointResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/dtos/get-channel-endpoints-query.dto.ts
Tamao: 944 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import {
  ChannelEndpointType,
  ChannelTypeEnum,
  ENDPOINT_TYPES,
  ProvidersIdEnum,
  ProvidersIdEnumConst,
} from '@novu/shared';
import { IsEnum, IsOptional } from 'class-validator';

export class GetChannelEndpointsQueryDto {
  @ApiProperty({
    description: 'Channel type to filter results.',
    enum: ChannelTypeEnum,
    required: false,
  })
  @IsEnum(ChannelTypeEnum)
  @IsOptional()
  channel?: ChannelTypeEnum;

  @ApiProperty({
    description: 'Provider identifier to filter results.',
    enum: Object.values(ProvidersIdEnumConst),
    required: false,
  })
  @IsEnum(Object.values(ProvidersIdEnumConst))
  @IsOptional()
  provider?: ProvidersIdEnum;

  @ApiProperty({
    description: 'Endpoint type to filter results.',
    enum: Object.values(ENDPOINT_TYPES),
    required: false,
  })
  @IsEnum(Object.values(ENDPOINT_TYPES))
  @IsOptional()
  type?: ChannelEndpointType;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetChannelEndpointsQueryDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/dtos/update-channel-endpoint-request.dto.ts
Tamao: 597 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { getApiPropertyExamples } from '@novu/application-generic';
import { ChannelEndpointByType, ChannelEndpointType } from '@novu/shared';
import { IsDefined } from 'class-validator';
import { IsValidChannelEndpoint } from '../validators/channel-endpoint.validator';

export class UpdateChannelEndpointRequestDto {
  @ApiProperty({
    description: 'Updated endpoint data specific to the channel type',
    oneOf: getApiPropertyExamples(),
  })
  @IsDefined()
  @IsValidChannelEndpoint()
  endpoint: ChannelEndpointByType[ChannelEndpointType];
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class UpdateChannelEndpointRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/usecases/create-channel-endpoint/create-channel-endpoint.command.ts
Tamao: 1669 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { ChannelEndpointByType, ChannelEndpointType, ENDPOINT_TYPES, ResourceKey } from '@novu/shared';
import { IsDefined, IsEnum, IsOptional, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';
import { IsValidChannelEndpoint } from '../../validators/channel-endpoint.validator';
import { IsResourceKey } from '../../../shared/validators/resource-key.validator';

// @ts-expect-error - Override with more specific typing for type safety
export class CreateChannelEndpointCommand<
  T extends ChannelEndpointType = ChannelEndpointType,
> extends EnvironmentCommand {
  @IsOptional()
  @IsString()
  identifier?: string;

  @IsDefined()
  @IsString()
  integrationIdentifier: string;

  @IsOptional()
  @IsString()
  connectionIdentifier?: string;

  @IsDefined()
  @IsResourceKey()
  resource: ResourceKey;

  @IsDefined()
  @IsEnum(Object.values(ENDPOINT_TYPES))
  type: T;

  @IsDefined()
  @IsValidChannelEndpoint()
  endpoint: ChannelEndpointByType[T];

  static create<T extends ChannelEndpointType>(data: {
    organizationId: string;
    environmentId: string;
    identifier?: string;
    integrationIdentifier: string;
    connectionIdentifier?: string;
    resource: ResourceKey;
    type: T;
    endpoint: ChannelEndpointByType[T];
  }): CreateChannelEndpointCommand<T> {
    // Call BaseCommand.create with the correct constructor to ensure full inheritance chain validation
    // biome-ignore lint/complexity/noThisInStatic: Required to maintain proper this context for validation
    return BaseCommand.create.call(this, data);
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class CreateChannelEndpointCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/usecases/create-channel-endpoint/create-channel-endpoint.usecase.ts
Tamao: 4258 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ConflictException, Injectable, NotFoundException } from '@nestjs/common';
import { InstrumentUsecase, shortId } from '@novu/application-generic';
import {
  ChannelConnectionEntity,
  ChannelConnectionRepository,
  ChannelEndpointEntity,
  ChannelEndpointRepository,
  IntegrationEntity,
  IntegrationRepository,
  SubscriberRepository,
} from '@novu/dal';
import { parseResourceKey } from '@novu/shared';
import { CreateChannelEndpointCommand } from './create-channel-endpoint.command';

@Injectable()
export class CreateChannelEndpoint {
  constructor(
    private readonly channelEndpointRepository: ChannelEndpointRepository,
    private readonly channelConnectionRepository: ChannelConnectionRepository,
    private readonly integrationRepository: IntegrationRepository,
    private readonly subscriberRepository: SubscriberRepository
  ) {}

  @InstrumentUsecase()
  async execute(command: CreateChannelEndpointCommand): Promise<ChannelEndpointEntity> {
    const integration = await this.findIntegration(command);

    await this.assertResourceExists(command);

    const identifier = command.identifier || this.generateIdentifier();

    // Check if channel endpoint already exists
    const existingChannelEndpoint = await this.channelEndpointRepository.findOne({
      identifier,
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
    });

    if (existingChannelEndpoint) {
      throw new ConflictException(
        `Channel endpoint with identifier "${identifier}" already exists in environment "${command.environmentId}"`
      );
    }

    let connection: ChannelConnectionEntity | null = null;

    if (command.connectionIdentifier) {
      connection = await this.findChannelConnection(command);
    }

    const channelEndpoint = await this.createChannelEndpoint(command, identifier, integration, connection);

    return channelEndpoint;
  }

  private async createChannelEndpoint(
    command: CreateChannelEndpointCommand,
    identifier: string,
    integration: IntegrationEntity,
    connection: ChannelConnectionEntity | null
  ): Promise<ChannelEndpointEntity> {
    const channelEndpoint = await this.channelEndpointRepository.create({
      identifier,
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
      connectionIdentifier: connection?.identifier,
      integrationIdentifier: integration.identifier,
      providerId: integration.providerId,
      channel: integration.channel,
      resource: command.resource,
      type: command.type,
      endpoint: command.endpoint,
    });

    return channelEndpoint;
  }

  private async assertResourceExists(command: CreateChannelEndpointCommand) {
    const { type, id } = parseResourceKey(command.resource);

    switch (type) {
      case 'subscriber': {
        const found = await this.subscriberRepository.findOne({
          subscriberId: id,
          _organizationId: command.organizationId,
          _environmentId: command.environmentId,
        });

        if (!found) throw new NotFoundException(`Subscriber not found: ${id}`);

        return;
      }
      default:
        throw new NotFoundException(`Resource type not found: ${type}`);
    }
  }

  private async findIntegration(command: CreateChannelEndpointCommand) {
    const integration = await this.integrationRepository.findOne({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      identifier: command.integrationIdentifier,
    });

    if (!integration) {
      throw new NotFoundException(`Integration not found: ${command.integrationIdentifier}`);
    }

    return integration;
  }

  private async findChannelConnection(command: CreateChannelEndpointCommand): Promise<ChannelConnectionEntity> {
    const connection = await this.channelConnectionRepository.findOne({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      identifier: command.connectionIdentifier,
    });

    if (!connection) {
      throw new NotFoundException(`Channel connection not found: ${command.connectionIdentifier}`);
    }

    return connection;
  }

  private generateIdentifier(): string {
    return `chendp-${shortId(6)}`;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class CreateChannelEndpoint

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/usecases/delete-channel-endpoint/delete-channel-endpoint.command.ts
Tamao: 259 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class DeleteChannelEndpointCommand extends EnvironmentCommand {
  @IsDefined()
  @IsString()
  identifier: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class DeleteChannelEndpointCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/usecases/delete-channel-endpoint/delete-channel-endpoint.usecase.ts
Tamao: 1042 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { ChannelEndpointRepository } from '@novu/dal';
import { DeleteChannelEndpointCommand } from './delete-channel-endpoint.command';

@Injectable()
export class DeleteChannelEndpoint {
  constructor(private readonly channelEndpointRepository: ChannelEndpointRepository) {}

  @InstrumentUsecase()
  async execute(command: DeleteChannelEndpointCommand): Promise<void> {
    const channelEndpoint = await this.channelEndpointRepository.findOne({
      identifier: command.identifier,
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
    });

    if (!channelEndpoint) {
      throw new NotFoundException(`Channel endpoint with identifier '${command.identifier}' not found`);
    }

    await this.channelEndpointRepository.delete({
      _id: channelEndpoint._id,
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class DeleteChannelEndpoint

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/usecases/get-channel-endpoint/get-channel-endpoint.command.ts
Tamao: 256 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class GetChannelEndpointCommand extends EnvironmentCommand {
  @IsDefined()
  @IsString()
  identifier: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetChannelEndpointCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/usecases/get-channel-endpoint/get-channel-endpoint.usecase.ts
Tamao: 916 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { ChannelEndpointEntity, ChannelEndpointRepository } from '@novu/dal';
import { GetChannelEndpointCommand } from './get-channel-endpoint.command';

@Injectable()
export class GetChannelEndpoint {
  constructor(private readonly channelEndpointRepository: ChannelEndpointRepository) {}

  @InstrumentUsecase()
  async execute(command: GetChannelEndpointCommand): Promise<ChannelEndpointEntity> {
    const channelEndpoint = await this.channelEndpointRepository.findOne({
      identifier: command.identifier,
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
    });

    if (!channelEndpoint) {
      throw new NotFoundException(`Channel endpoint with identifier '${command.identifier}' not found`);
    }

    return channelEndpoint;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetChannelEndpoint

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/usecases/get-channel-endpoints/get-channel-endpoints.command.ts
Tamao: 739 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  ChannelEndpointType,
  ChannelTypeEnum,
  ENDPOINT_TYPES,
  ProvidersIdEnum,
  ProvidersIdEnumConst,
  ResourceKey,
} from '@novu/shared';
import { IsEnum, IsOptional } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';
import { IsResourceKey } from '../../../shared/validators/resource-key.validator';

export class GetChannelEndpointsCommand extends EnvironmentCommand {
  @IsOptional()
  @IsResourceKey()
  resource?: ResourceKey;

  @IsEnum(ChannelTypeEnum)
  @IsOptional()
  channel?: ChannelTypeEnum;

  @IsEnum(ProvidersIdEnumConst)
  @IsOptional()
  provider?: ProvidersIdEnum;

  @IsEnum(Object.values(ENDPOINT_TYPES))
  @IsOptional()
  type?: ChannelEndpointType;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetChannelEndpointsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/usecases/get-channel-endpoints/get-channel-endpoints.usecase.ts
Tamao: 1434 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import type { EnforceEnvOrOrgIds } from '@novu/dal';
import { ChannelEndpointDBModel, ChannelEndpointEntity, ChannelEndpointRepository } from '@novu/dal';
import { ProvidersIdEnum } from '@novu/shared';
import { FilterQuery } from 'mongoose';
import { GetChannelEndpointsCommand } from './get-channel-endpoints.command';

@Injectable()
export class GetChannelEndpoints {
  constructor(private readonly channelEndpointRepository: ChannelEndpointRepository) {}

  @InstrumentUsecase()
  async execute(command: GetChannelEndpointsCommand): Promise<ChannelEndpointEntity[]> {
    const channelEndpoints = await this.fetchChannelEndpoints(command);

    return channelEndpoints;
  }

  private async fetchChannelEndpoints(command: GetChannelEndpointsCommand): Promise<ChannelEndpointEntity[]> {
    const query: FilterQuery<ChannelEndpointDBModel> & EnforceEnvOrOrgIds = {
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
    };

    if (command.resource) {
      query.resource = command.resource;
    }

    if (command.type) {
      query.type = command.type;
    }

    if (command.channel) {
      query.channel = command.channel;
    }

    if (command.provider) {
      query.providerId = command.provider;
    }

    return await this.channelEndpointRepository.find(query);
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetChannelEndpoints

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/usecases/update-channel-endpoint/update-channel-endpoint.command.ts
Tamao: 1169 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { ChannelEndpointByType, ChannelEndpointType } from '@novu/shared';
import { IsDefined, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';
import { IsValidChannelEndpoint } from '../../validators/channel-endpoint.validator';

// @ts-expect-error - Override with more specific typing for type safety
export class UpdateChannelEndpointCommand<
  T extends ChannelEndpointType = ChannelEndpointType,
> extends EnvironmentCommand {
  @IsDefined()
  @IsString()
  identifier: string;

  @IsDefined()
  @IsValidChannelEndpoint()
  endpoint: ChannelEndpointByType[T];

  static create<T extends ChannelEndpointType>(data: {
    organizationId: string;
    environmentId: string;
    identifier: string;
    endpoint: ChannelEndpointByType[T];
  }): UpdateChannelEndpointCommand<T> {
    // Call BaseCommand.create with the correct constructor to ensure full inheritance chain validation
    // biome-ignore lint/complexity/noThisInStatic: Required to maintain proper this context for validation
    return BaseCommand.create.call(this, data);
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class UpdateChannelEndpointCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/usecases/update-channel-endpoint/update-channel-endpoint.usecase.ts
Tamao: 1915 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { InstrumentUsecase, validateEndpointForType } from '@novu/application-generic';
import { ChannelEndpointEntity, ChannelEndpointRepository } from '@novu/dal';
import { UpdateChannelEndpointCommand } from './update-channel-endpoint.command';

@Injectable()
export class UpdateChannelEndpoint {
  constructor(private readonly channelEndpointRepository: ChannelEndpointRepository) {}

  @InstrumentUsecase()
  async execute(command: UpdateChannelEndpointCommand): Promise<ChannelEndpointEntity> {
    // Check if the channel endpoint exists
    const existingChannelEndpoint = await this.channelEndpointRepository.findOne({
      identifier: command.identifier,
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
    });

    if (!existingChannelEndpoint) {
      throw new NotFoundException(
        `Channel endpoint with identifier "${command.identifier}" not found in environment "${command.environmentId}"`
      );
    }

    // Validate that the new endpoint matches the existing type
    validateEndpointForType(existingChannelEndpoint.type, command.endpoint);

    const updatedChannelEndpoint = await this.updateChannelEndpoint(command);

    return updatedChannelEndpoint;
  }

  private async updateChannelEndpoint(command: UpdateChannelEndpointCommand): Promise<ChannelEndpointEntity> {
    const channelEndpoint = await this.channelEndpointRepository.findOneAndUpdate(
      {
        identifier: command.identifier,
        _organizationId: command.organizationId,
        _environmentId: command.environmentId,
      },
      {
        endpoint: command.endpoint,
      },
      {
        new: true,
      }
    );

    if (!channelEndpoint) {
      throw new NotFoundException(`Channel endpoint with identifier "${command.identifier}" not found`);
    }

    return channelEndpoint;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class UpdateChannelEndpoint

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/channel-endpoints/validators/channel-endpoint.validator.ts
Tamao: 1234 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { validateEndpointForTypeFromSchema } from '@novu/application-generic';
import { ChannelEndpointType } from '@novu/shared';
import { registerDecorator, ValidationArguments, ValidationOptions } from 'class-validator';

export function IsValidChannelEndpoint(validationOptions?: ValidationOptions) {
  return (object: object, propertyName: string) => {
    registerDecorator({
      name: 'isValidChannelEndpoint',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        validate(value: unknown, args: ValidationArguments) {
          const obj = args.object as Record<string, unknown>;
          const type = obj.type as ChannelEndpointType;

          if (!type || !value || typeof value !== 'object') {
            return false;
          }

          const endpointValue = value as Record<string, unknown>;
          return validateEndpointForTypeFromSchema(type, endpointValue);
        },
        defaultMessage(args: ValidationArguments) {
          const obj = args.object as Record<string, unknown>;
          const type = obj.type;
          return `Endpoint must match the required format for type "${type}"`;
        },
      },
    });
  };
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - IsValidChannelEndpoint(validationOptions?: ValidationOptions)
Declaraciones 'export' encontradas:
- export function IsValidChannelEndpoint

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/content-templates/content-templates.controller.ts
Tamao: 6041 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Body, Controller, Post } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { ApiExcludeController } from '@nestjs/swagger';
import {
  CompileEmailTemplate,
  CompileEmailTemplateCommand,
  CompileInAppTemplate,
  CompileInAppTemplateCommand,
  CompileStepTemplate,
  CompileStepTemplateCommand,
  PinoLogger,
} from '@novu/application-generic';
import { IEmailBlock, IMessageCTA, MessageTemplateContentType, UserSessionData } from '@novu/shared';
import { format } from 'date-fns';
import i18next from 'i18next';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { UserSession } from '../shared/framework/user.decorator';

@Controller('/content-templates')
@RequireAuthentication()
@ApiExcludeController()
export class ContentTemplatesController {
  constructor(
    private compileEmailTemplateUsecase: CompileEmailTemplate,
    private compileInAppTemplate: CompileInAppTemplate,
    private compileStepTemplate: CompileStepTemplate,
    private moduleRef: ModuleRef,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  @Post('/preview/email')
  public async previewEmail(
    @UserSession() user: UserSessionData,
    @Body('content') content: string | IEmailBlock[],
    @Body('contentType') contentType: MessageTemplateContentType,
    @Body('payload') payload: any,
    @Body('subject') subject: string,
    @Body('layoutId') layoutId: string,
    @Body('locale') locale?: string
  ) {
    const i18nInstance = await this.initiateTranslations(user.environmentId, user.organizationId, locale);

    return this.compileEmailTemplateUsecase.execute(
      CompileEmailTemplateCommand.create({
        userId: user._id,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        content,
        contentType,
        payload,
        subject,
        layoutId,
        locale,
      }),
      i18nInstance
    );
  }

  @Post('/preview/in-app')
  public async previewInApp(
    @UserSession() user: UserSessionData,
    @Body('content') content: string,
    @Body('payload') payload: any,
    @Body('cta') cta: IMessageCTA,
    @Body('locale') locale?: string
  ) {
    const i18nInstance = await this.initiateTranslations(user.environmentId, user.organizationId, locale);

    return this.compileInAppTemplate.execute(
      CompileInAppTemplateCommand.create({
        userId: user._id,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        content,
        payload,
        cta,
        locale,
      }),
      i18nInstance
    );
  }
  // TODO: refactor this to use params and single endpoint to manage all the channels
  @Post('/preview/sms')
  public async previewSms(
    @UserSession() user: UserSessionData,
    @Body('content') content: string,
    @Body('payload') payload: any,
    @Body('locale') locale?: string
  ) {
    const i18nInstance = await this.initiateTranslations(user.environmentId, user.organizationId, locale);

    return this.compileStepTemplate.execute(
      CompileStepTemplateCommand.create({
        userId: user._id,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        content,
        payload,
        locale,
      }),
      i18nInstance
    );
  }

  @Post('/preview/chat')
  public async previewChat(
    @UserSession() user: UserSessionData,
    @Body('content') content: string,
    @Body('payload') payload: any,
    @Body('locale') locale?: string
  ) {
    const i18nInstance = await this.initiateTranslations(user.environmentId, user.organizationId, locale);

    return this.compileStepTemplate.execute(
      CompileStepTemplateCommand.create({
        userId: user._id,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        content,
        payload,
        locale,
      }),
      i18nInstance
    );
  }

  @Post('/preview/push')
  public async previewPush(
    @UserSession() user: UserSessionData,
    @Body('content') content: string,
    @Body('title') title: string,
    @Body('payload') payload: any,
    @Body('locale') locale?: string
  ) {
    const i18nInstance = await this.initiateTranslations(user.environmentId, user.organizationId, locale);

    return this.compileStepTemplate.execute(
      CompileStepTemplateCommand.create({
        userId: user._id,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        content,
        payload,
        locale,
        title,
      }),
      i18nInstance
    );
  }

  protected async initiateTranslations(environmentId: string, organizationId: string, locale: string | undefined) {
    try {
      if (process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true') {
        if (!require('@novu/ee-shared-services')?.TranslationsService) {
          throw new BadRequestException('Translation module is not loaded');
        }
        const service = this.moduleRef.get(require('@novu/ee-shared-services')?.TranslationsService, { strict: false });
        const { namespaces, resources, defaultLocale } = await service.getTranslationsList(
          environmentId,
          organizationId
        );
        const instance = i18next.createInstance();
        await instance.init({
          resources,
          ns: namespaces,
          defaultNS: false,
          nsSeparator: '.',
          lng: locale || 'en',
          compatibilityJSON: 'v2',
          fallbackLng: defaultLocale,
          interpolation: {
            formatSeparator: ',',
            format(value, formatting, lng) {
              if (value && formatting && !Number.isNaN(Date.parse(value))) {
                return format(new Date(value), formatting);
              }

              return value.toString();
            },
          },
        });

        return instance;
      }
    } catch (e) {
      this.logger.error({ err: e }, `Unexpected error while importing enterprise modules`);
    }
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ContentTemplatesController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/content-templates/content-templates.module.ts
Tamao: 1249 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { DynamicModule, Module } from '@nestjs/common';
import { ForwardReference } from '@nestjs/common/interfaces/modules/forward-reference.interface';
import { Type } from '@nestjs/common/interfaces/type.interface';
import { CommunityOrganizationRepository } from '@novu/dal';
import { LayoutsV1Module } from '../layouts-v1/layouts-v1.module';
import { SharedModule } from '../shared/shared.module';
import { ContentTemplatesController } from './content-templates.controller';
import { USE_CASES } from './usecases';

const enterpriseImports = (): Array<Type | DynamicModule | Promise<DynamicModule> | ForwardReference> => {
  const modules: Array<Type | DynamicModule | Promise<DynamicModule> | ForwardReference> = [];
  if (process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true') {
    if (require('@novu/ee-translation')?.EnterpriseTranslationModule) {
      modules.push(require('@novu/ee-translation')?.EnterpriseTranslationModule);
    }
  }

  return modules;
};

@Module({
  imports: [SharedModule, LayoutsV1Module, ...enterpriseImports()],
  providers: [...USE_CASES, CommunityOrganizationRepository],
  exports: [...USE_CASES],
  controllers: [ContentTemplatesController],
})
export class ContentTemplatesModule {}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - enterpriseImports(): Array<Type | DynamicModule | Promise<DynamicModule> | ForwardReference>)
Declaraciones 'export' encontradas:
- export class ContentTemplatesModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/content-templates/e2e/preview-email.e2e.ts
Tamao: 781 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Preview email - /v1/content-templates/preview/email (POST) #novu-v0', () => {
  let session: UserSession;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should generate preview html email', async () => {
    const {
      body: {
        data: { html, subject },
      },
    } = await session.testAgent.post(`/v1/content-templates/preview/email`).send({
      contentType: 'editor',
      content: [{ type: 'text', content: 'test {{test}} test' }],
      payload: { test: 'test' },
      subject: 'test {{test}} test',
    });

    expect(html).to.contain('test test test');
    expect(subject).to.contain('test test test');
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should generate preview html email',...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/content-templates/e2e/preview-step.e2e.ts
Tamao: 1864 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Preview sms - /v1/content-templates/preview/sms (POST) #novu-v0', () => {
  let session: UserSession;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should generate preview sms content', async () => {
    const {
      body: {
        data: { content },
      },
    } = await session.testAgent.post(`/v1/content-templates/preview/sms`).send({
      content: 'Hello {{test}}',
      payload: { test: 'sms payload' },
      subject: 'test {{test}} test',
    });

    expect(content.includes('Hello sms payload')).true;
  });
});

describe('Preview chat - /v1/content-templates/preview/chat (POST)', () => {
  let session: UserSession;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should generate preview chat content', async () => {
    const {
      body: {
        data: { content },
      },
    } = await session.testAgent.post(`/v1/content-templates/preview/chat`).send({
      content: 'Hello {{test}}',
      payload: { test: 'chat payload' },
      subject: 'test {{test}} test',
    });

    expect(content.includes('Hello chat payload')).true;
  });
});

describe('Preview push - /v1/content-templates/preview/push (POST)', () => {
  let session: UserSession;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should generate preview push content', async () => {
    const {
      body: {
        data: { content },
      },
    } = await session.testAgent.post(`/v1/content-templates/preview/push`).send({
      content: 'Hello {{test}}',
      payload: { test: 'push payload' },
      subject: 'test {{test}} test',
    });

    expect(content.includes('Hello push payload')).true;
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should generate preview sms content'...)
 - session(new UserSession();
    await session.initialize();
  });

  it('should generate preview chat content...)
 - session(new UserSession();
    await session.initialize();
  });

  it('should generate preview push content...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/content-templates/usecases/index.ts
Tamao: 245 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  CompileEmailTemplate,
  CompileInAppTemplate,
  CompileStepTemplate,
  CompileTemplate,
} from '@novu/application-generic';

export const USE_CASES = [CompileTemplate, CompileEmailTemplate, CompileInAppTemplate, CompileStepTemplate];


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/content-templates/usecases/parse-preview/preview-email.command.ts
Tamao: 0 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###



### ANALISIS AUTOMATICO (ESPAOL) ###

No se detectaron funciones/exportaciones con heurstica JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/content-templates/usecases/parse-preview/preview-email.usecase.ts
Tamao: 0 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###



### ANALISIS AUTOMATICO (ESPAOL) ###

No se detectaron funciones/exportaciones con heurstica JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/contexts.controller.ts
Tamao: 7270 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  ClassSerializerInterceptor,
  Controller,
  Delete,
  ForbiddenException,
  Get,
  HttpCode,
  HttpStatus,
  Param,
  Patch,
  Post,
  Query,
  UseInterceptors,
} from '@nestjs/common';
import { ApiOperation, ApiParam, ApiTags } from '@nestjs/swagger';
import { FeatureFlagsService, RequirePermissions } from '@novu/application-generic';
import {
  ApiRateLimitCategoryEnum,
  ContextType,
  FeatureFlagsKeysEnum,
  PermissionsEnum,
  UserSessionData,
} from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { ThrottlerCategory } from '../rate-limiting/guards';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { UserSession } from '../shared/framework/user.decorator';
import {
  CreateContextRequestDto,
  GetContextResponseDto,
  ListContextsQueryDto,
  ListContextsResponseDto,
  mapContextEntityToDto,
  UpdateContextRequestDto,
} from './dtos';
import { CreateContextCommand } from './usecases/create-context/create-context.command';
import { CreateContext } from './usecases/create-context/create-context.usecase';
import { DeleteContext, DeleteContextCommand } from './usecases/delete-context';
import { GetContext, GetContextCommand } from './usecases/get-context';
import { ListContexts, ListContextsCommand } from './usecases/list-contexts';
import { UpdateContextCommand } from './usecases/update-context/update-context.command';
import { UpdateContext } from './usecases/update-context/update-context.usecase';

@Controller({ path: '/contexts', version: '2' })
@UseInterceptors(ClassSerializerInterceptor)
@ThrottlerCategory(ApiRateLimitCategoryEnum.GLOBAL)
@RequireAuthentication()
@ApiTags('Contexts')
@ApiCommonResponses()
export class ContextsController {
  constructor(
    private createContextUsecase: CreateContext,
    private updateContextUsecase: UpdateContext,
    private getContextUsecase: GetContext,
    private listContextsUsecase: ListContexts,
    private deleteContextUsecase: DeleteContext,
    private featureFlagsService: FeatureFlagsService
  ) {}

  private async checkFeatureEnabled(user: UserSessionData) {
    const isEnabled = await this.featureFlagsService.getFlag({
      key: FeatureFlagsKeysEnum.IS_CONTEXT_ENABLED,
      defaultValue: false,
      organization: { _id: user.organizationId },
      user: { _id: user._id },
    });

    if (!isEnabled) {
      throw new ForbiddenException('Context feature is not enabled');
    }
  }

  @Post('')
  @ApiResponse(GetContextResponseDto, 201)
  @ApiOperation({
    summary: 'Create context',
    description: 'Create a new context with the specified type, id, and data. Returns 409 if context already exists.',
  })
  @RequirePermissions(PermissionsEnum.WORKFLOW_WRITE)
  @ExternalApiAccessible()
  async createContext(
    @UserSession() user: UserSessionData,
    @Body() body: CreateContextRequestDto
  ): Promise<GetContextResponseDto> {
    await this.checkFeatureEnabled(user);

    const entity = await this.createContextUsecase.execute(
      CreateContextCommand.create({
        userId: user._id,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        type: body.type,
        id: body.id,
        data: body.data,
      })
    );

    return mapContextEntityToDto(entity);
  }

  @Patch('/:type/:id')
  @ApiParam({ name: 'type', type: String, description: 'Context type' })
  @ApiParam({ name: 'id', type: String, description: 'Context ID' })
  @ApiResponse(GetContextResponseDto, 200)
  @ApiOperation({
    summary: 'Update context data',
    description: 'Update the data of an existing context. Returns 404 if context does not exist.',
  })
  @RequirePermissions(PermissionsEnum.WORKFLOW_WRITE)
  @ExternalApiAccessible()
  async updateContext(
    @UserSession() user: UserSessionData,
    @Param('type') type: ContextType,
    @Param('id') id: string,
    @Body() body: UpdateContextRequestDto
  ): Promise<GetContextResponseDto> {
    await this.checkFeatureEnabled(user);

    const entity = await this.updateContextUsecase.execute(
      UpdateContextCommand.create({
        userId: user._id,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        type,
        id,
        data: body.data,
      })
    );

    return mapContextEntityToDto(entity);
  }

  @Get('')
  @ApiResponse(ListContextsResponseDto)
  @ApiOperation({
    summary: 'List contexts',
    description: 'Retrieve a paginated list of contexts, optionally filtered by type and key pattern',
  })
  @RequirePermissions(PermissionsEnum.WORKFLOW_READ)
  @ExternalApiAccessible()
  async listContexts(
    @UserSession() user: UserSessionData,
    @Query() query: ListContextsQueryDto
  ): Promise<ListContextsResponseDto> {
    await this.checkFeatureEnabled(user);

    const result = await this.listContextsUsecase.execute(
      ListContextsCommand.create({
        user,
        limit: query.limit || 10,
        after: query.after,
        before: query.before,
        orderDirection: query.orderDirection,
        orderBy: query.orderBy || 'createdAt',
        includeCursor: query.includeCursor,
        type: query.type,
        id: query.id,
        search: query.search,
      })
    );

    return {
      data: result.data.map(mapContextEntityToDto),
      next: result.next,
      previous: result.previous,
      totalCount: result.totalCount!,
      totalCountCapped: result.totalCountCapped!,
    };
  }

  @Get('/:type/:id')
  @ApiParam({ name: 'type', type: String, description: 'Context type' })
  @ApiParam({ name: 'id', type: String, description: 'Context ID' })
  @ApiResponse(GetContextResponseDto, 200)
  @ApiOperation({
    summary: 'Get context by id',
    description: 'Retrieve a specific context by its type and id',
  })
  @RequirePermissions(PermissionsEnum.WORKFLOW_READ)
  @ExternalApiAccessible()
  async getContext(
    @UserSession() user: UserSessionData,
    @Param('type') type: ContextType,
    @Param('id') id: string
  ): Promise<GetContextResponseDto> {
    await this.checkFeatureEnabled(user);

    const entity = await this.getContextUsecase.execute(
      GetContextCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        type,
        id,
      })
    );

    return mapContextEntityToDto(entity);
  }

  @Delete('/:type/:id')
  @ApiParam({ name: 'type', type: String, description: 'Context type' })
  @ApiParam({ name: 'id', type: String, description: 'Context ID' })
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Delete context',
    description: 'Delete a context by its type and id',
  })
  @RequirePermissions(PermissionsEnum.WORKFLOW_WRITE)
  @ExternalApiAccessible()
  async deleteContext(
    @UserSession() user: UserSessionData,
    @Param('type') type: ContextType,
    @Param('id') id: string
  ): Promise<void> {
    await this.checkFeatureEnabled(user);

    return this.deleteContextUsecase.execute(
      DeleteContextCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        type,
        id,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ContextsController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/contexts.module.ts
Tamao: 936 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { featureFlagsService } from '@novu/application-generic';
import { ContextRepository } from '@novu/dal';
import { SharedModule } from '../shared/shared.module';
import { ContextsController } from './contexts.controller';
import { CreateContext } from './usecases/create-context/create-context.usecase';
import { DeleteContext } from './usecases/delete-context';
import { GetContext } from './usecases/get-context';
import { ListContexts } from './usecases/list-contexts';
import { UpdateContext } from './usecases/update-context/update-context.usecase';

const USE_CASES = [CreateContext, UpdateContext, GetContext, ListContexts, DeleteContext];

const DAL_MODELS = [ContextRepository];

@Module({
  imports: [SharedModule],
  controllers: [ContextsController],
  providers: [...USE_CASES, ...DAL_MODELS, featureFlagsService],
  exports: [...USE_CASES],
})
export class ContextsModule {}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ContextsModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/dtos/create-context-request.dto.ts
Tamao: 1544 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsValidContextData } from '@novu/application-generic';
import { CONTEXT_IDENTIFIER_REGEX, ContextData, ContextId, ContextType } from '@novu/shared';
import { IsDefined, IsOptional, IsString, Matches, MaxLength, MinLength } from 'class-validator';

export class CreateContextRequestDto {
  @ApiProperty({
    description:
      'Context type (e.g., tenant, app, workspace). Must be lowercase alphanumeric with optional separators.',
    example: 'tenant',
    required: true,
    type: String,
    pattern: CONTEXT_IDENTIFIER_REGEX.source,
  })
  @IsDefined()
  @IsString()
  @MinLength(1)
  @MaxLength(100)
  @Matches(CONTEXT_IDENTIFIER_REGEX, {
    message: 'Type must be lowercase alphanumeric with optional ., _, or - separators',
  })
  type: ContextType;

  @ApiProperty({
    description: 'Unique identifier for this context. Must be lowercase alphanumeric with optional separators.',
    example: 'org-acme',
    required: true,
    type: String,
    pattern: CONTEXT_IDENTIFIER_REGEX.source,
  })
  @IsDefined()
  @IsString()
  @MinLength(1)
  @MaxLength(100)
  @Matches(CONTEXT_IDENTIFIER_REGEX, {
    message: 'ID must be lowercase alphanumeric with optional ., _, or - separators',
  })
  id: ContextId;

  @ApiProperty({
    description: 'Optional custom data to associate with this context.',
    example: { tenantName: 'Acme Corp', region: 'us-east-1', settings: { theme: 'dark' } },
    required: false,
  })
  @IsOptional()
  @IsValidContextData()
  data?: ContextData;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class CreateContextRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/dtos/dto.mapper.ts
Tamao: 353 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ContextEntity } from '@novu/dal';
import { GetContextResponseDto } from './get-context-response.dto';

export function mapContextEntityToDto(context: ContextEntity): GetContextResponseDto {
  return {
    createdAt: context.createdAt,
    updatedAt: context.updatedAt,
    type: context.type,
    id: context.id,
    data: context.data,
  };
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - mapContextEntityToDto(context: ContextEntity)
Declaraciones 'export' encontradas:
- export function mapContextEntityToDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/dtos/get-context-response.dto.ts
Tamao: 331 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { ContextData, ContextType } from '@novu/shared';

export class GetContextResponseDto {
  @ApiProperty()
  type: ContextType;

  @ApiProperty()
  id: string;

  @ApiProperty()
  data: ContextData;

  @ApiProperty()
  createdAt: string;

  @ApiProperty()
  updatedAt: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetContextResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/dtos/index.ts
Tamao: 255 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './create-context-request.dto';
export * from './dto.mapper';
export * from './get-context-response.dto';
export * from './list-contexts-query.dto';
export * from './list-contexts-response.dto';
export * from './update-context-request.dto';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/dtos/list-contexts-query.dto.ts
Tamao: 942 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { ContextType } from '@novu/shared';
import { IsOptional, IsString } from 'class-validator';
import { CursorPaginationQueryDto } from '../../subscribers-v2/dtos/cursor-pagination-query.dto';
import { GetContextResponseDto } from './get-context-response.dto';

export class ListContextsQueryDto extends CursorPaginationQueryDto<GetContextResponseDto, 'createdAt' | 'updatedAt'> {
  @ApiPropertyOptional({
    description: 'Filter contexts by type',
    example: 'tenant',
  })
  @IsString()
  @IsOptional()
  type?: ContextType;

  @ApiPropertyOptional({
    description: 'Filter contexts by id',
    example: 'tenant-prod-123',
  })
  @IsString()
  @IsOptional()
  id?: string;

  @ApiPropertyOptional({
    description: 'Search contexts by type or id (supports partial matching across both fields)',
    example: 'tenant',
  })
  @IsString()
  @IsOptional()
  search?: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ListContextsQueryDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/dtos/list-contexts-response.dto.ts
Tamao: 294 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { withCursorPagination } from '../../shared/dtos/cursor-paginated-response';
import { GetContextResponseDto } from './get-context-response.dto';

export class ListContextsResponseDto extends withCursorPagination(GetContextResponseDto, {
  description: 'List of returned Contexts',
}) {}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ListContextsResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/dtos/update-context-request.dto.ts
Tamao: 524 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsValidContextData } from '@novu/application-generic';
import { ContextData } from '@novu/shared';
import { IsDefined } from 'class-validator';

export class UpdateContextRequestDto {
  @ApiProperty({
    description: 'Custom data to associate with this context. Replaces existing data.',
    example: { tenantName: 'Acme Corp', region: 'us-east-1', settings: { theme: 'dark' } },
    required: true,
  })
  @IsDefined()
  @IsValidContextData()
  data: ContextData;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class UpdateContextRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/e2e/create-context.e2e.ts
Tamao: 4441 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ContextRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import axios, { AxiosResponse } from 'axios';
import { expect } from 'chai';

describe('Create Context - /contexts (POST) #novu-v2', () => {
  let session: UserSession;
  const contextRepository = new ContextRepository();

  before(() => {
    // @ts-expect-error process.env is not typed
    process.env.IS_CONTEXT_ENABLED = 'true';
  });

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  after(() => {
    // @ts-expect-error process.env is not typed
    delete process.env.IS_CONTEXT_ENABLED;
  });

  it('should create a new context', async () => {
    const response = await createContext({
      session,
      type: 'tenant',
      id: 'create-test-org-acme',
      data: { tenantName: 'Acme Corp', region: 'us-east-1' },
    });

    expect(response.status).to.equal(201);
    expect(response.data).to.be.ok;

    const createdContext = await contextRepository.findOne({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'create-test-org-acme',
    });

    expect(createdContext?.type).to.equal('tenant');
    expect(createdContext?.id).to.equal('create-test-org-acme');
    expect(createdContext?.data).to.deep.equal({ tenantName: 'Acme Corp', region: 'us-east-1' });
  });

  it('should create a context without data', async () => {
    const response = await createContext({
      session,
      type: 'workspace',
      id: 'create-test-workspace-123',
    });

    expect(response.status).to.equal(201);
    expect(response.data).to.be.ok;

    const createdContext = await contextRepository.findOne({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'workspace',
      id: 'create-test-workspace-123',
    });

    expect(createdContext?.type).to.equal('workspace');
    expect(createdContext?.id).to.equal('create-test-workspace-123');
    expect(createdContext?.data).to.deep.equal({});
  });

  it('should throw error if a context already exists', async () => {
    await createContext({
      session,
      type: 'tenant',
      id: 'create-test-duplicate',
      data: { tenantName: 'Acme Corp' },
    });

    try {
      await createContext({
        session,
        type: 'tenant',
        id: 'create-test-duplicate',
        data: { tenantName: 'Acme Corp Updated' },
      });

      throw new Error('Should not succeed');
    } catch (e) {
      expect(e.response.status).to.equal(409);
      expect(e.response.data.message).to.contains(
        `Context with type 'tenant' and id 'create-test-duplicate' already exists`
      );
    }
  });

  it('should throw error if type is missing', async () => {
    try {
      await createContext({
        session,
        id: 'org-acme',
      });

      throw new Error('Should not succeed');
    } catch (e) {
      expect(e.response.status).to.equal(422);
    }
  });

  it('should throw error if id is missing', async () => {
    try {
      await createContext({
        session,
        type: 'tenant',
      });

      throw new Error('Should not succeed');
    } catch (e) {
      expect(e.response.status).to.equal(422);
    }
  });

  it('should throw error if type has invalid format', async () => {
    try {
      await createContext({
        session,
        type: 'Invalid_Type!',
        id: 'create-test-invalid-type',
      });

      throw new Error('Should not succeed');
    } catch (e) {
      expect(e.response.status).to.equal(422);
    }
  });

  it('should throw error if id has invalid format', async () => {
    try {
      await createContext({
        session,
        type: 'tenant',
        id: 'Invalid ID!',
      });

      throw new Error('Should not succeed');
    } catch (e) {
      expect(e.response.status).to.equal(422);
    }
  });
});

// biome-ignore lint/suspicious/noExportsInTest: helper function used by other tests
export async function createContext({
  session,
  type,
  id,
  data,
}: {
  session;
  type?: string;
  id?: string;
  data?: any;
}): Promise<AxiosResponse> {
  const axiosInstance = axios.create();

  return await axiosInstance.post(
    `${session.serverUrl}/v2/contexts`,
    {
      type,
      id,
      data,
    },
    {
      headers: {
        authorization: `ApiKey ${session.apiKey}`,
      },
    }
  );
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - createContext({
  session,
  type,
  id,
  data,
}: {
  session;
  type?: string;
  id?: string;
  data?: any;
})
Asignaciones con arrow functions encontradas (posibles funciones):
 - contextRepository(new ContextRepository();

  before(())
 - IS_CONTEXT_ENABLED('true';
  });

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  after(())
 - createdContext(await contextRepository.findOne({
      _organizationId: session.organization._id,
      _environmen...)
 - createdContext(await contextRepository.findOne({
      _organizationId: session.organization._id,
      _environmen...)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/e2e/delete-context.e2e.ts
Tamao: 2710 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ContextRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import axios, { AxiosResponse } from 'axios';
import { expect } from 'chai';

describe('Delete Context - /contexts/:type/:id (DELETE) #novu-v2', () => {
  let session: UserSession;
  const contextRepository = new ContextRepository();

  before(() => {
    // @ts-expect-error process.env is not typed
    process.env.IS_CONTEXT_ENABLED = 'true';
  });

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  after(() => {
    // @ts-expect-error process.env is not typed
    delete process.env.IS_CONTEXT_ENABLED;
  });

  it('should delete newly created context', async () => {
    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'delete-test-org-acme',
      key: 'tenant:delete-test-org-acme',
      data: { tenantName: 'Acme Corp', region: 'us-east-1' },
    });

    const existingContext = await contextRepository.findOne({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      type: 'tenant',
      id: 'delete-test-org-acme',
    });

    expect(existingContext).to.be.ok;

    const response = await deleteContext({
      session,
      type: 'tenant',
      id: 'delete-test-org-acme',
    });

    expect(response.status).to.equal(204);

    const deletedContext = await contextRepository.findOne({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      type: 'tenant',
      id: 'delete-test-org-acme',
    });

    expect(deletedContext).to.equal(null);
  });

  it('should throw exception while trying to delete non-existing context', async () => {
    const type = 'tenant';
    const id = 'non-existent-context';

    try {
      await deleteContext({
        session,
        type,
        id,
      });

      throw new Error('Should not succeed');
    } catch (e) {
      expect(e.response.status).to.equal(404);
      expect(e?.response?.data?.message || e?.message).to.contains(
        `Context with id '${id}' and type '${type}' not found in environment ${session.environment._id}`
      );
    }
  });
});

// biome-ignore lint/suspicious/noExportsInTest: helper function used by other tests
export async function deleteContext({
  session,
  type,
  id,
}: {
  session;
  type?: string;
  id?: string;
}): Promise<AxiosResponse> {
  const axiosInstance = axios.create();

  return await axiosInstance.delete(`${session.serverUrl}/v2/contexts/${type}/${id}`, {
    headers: {
      authorization: `ApiKey ${session.apiKey}`,
    },
  });
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - deleteContext({
  session,
  type,
  id,
}: {
  session;
  type?: string;
  id?: string;
})
Asignaciones con arrow functions encontradas (posibles funciones):
 - contextRepository(new ContextRepository();

  before(())
 - IS_CONTEXT_ENABLED('true';
  });

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  after(())
 - deletedContext(await contextRepository.findOne({
      _environmentId: session.environment._id,
      _organization...)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/e2e/get-context.e2e.ts
Tamao: 3074 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ContextRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';

describe('Get Context - /contexts/:type/:id (GET) #novu-v2', () => {
  let session: UserSession;
  const contextRepository = new ContextRepository();

  before(() => {
    // @ts-expect-error process.env is not typed
    process.env.IS_CONTEXT_ENABLED = 'true';
  });

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  afterEach(async () => {
    await contextRepository.delete({
      _environmentId: session.environment._id,
    });
  });

  after(() => {
    // @ts-expect-error process.env is not typed
    delete process.env.IS_CONTEXT_ENABLED;
  });

  it('should get a newly created context', async () => {
    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'get-test-org-acme',
      key: 'tenant:get-test-org-acme',
      data: { tenantName: 'Acme Corp', region: 'us-east-1' },
    });

    const getContextResult = await getContext({ session, type: 'tenant', id: 'get-test-org-acme' });

    expect(getContextResult.data.type).to.equal('tenant');
    expect(getContextResult.data.id).to.equal('get-test-org-acme');
    expect(getContextResult.data.data).to.deep.equal({ tenantName: 'Acme Corp', region: 'us-east-1' });
    expect(getContextResult.data.createdAt).to.be.ok;
    expect(getContextResult.data.updatedAt).to.be.ok;
  });

  it('should get a context with empty data', async () => {
    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'workspace',
      id: 'get-test-workspace-123',
      key: 'workspace:get-test-workspace-123',
      data: {},
    });

    const getContextResult = await getContext({ session, type: 'workspace', id: 'get-test-workspace-123' });

    expect(getContextResult.data.type).to.equal('workspace');
    expect(getContextResult.data.id).to.equal('get-test-workspace-123');
    expect(getContextResult.data.data).to.deep.equal({});
  });

  it('should throw exception if context does not exist', async () => {
    const incorrectType = 'tenant';
    const incorrectId = 'non-existent';

    try {
      await getContext({ session, type: incorrectType, id: incorrectId });

      throw new Error('Should not succeed');
    } catch (e) {
      expect(e.response.status).to.equal(404);
      expect(e?.response?.data?.message || e?.message).to.contains(
        `Context with id '${incorrectId}' and type '${incorrectType}' not found in environment ${session.environment._id}`
      );
    }
  });
});

async function getContext({ session, type, id }: { session; type: string; id: string }) {
  const axiosInstance = axios.create();

  return (
    await axiosInstance.get(`${session.serverUrl}/v2/contexts/${type}/${id}`, {
      headers: {
        authorization: `ApiKey ${session.apiKey}`,
      },
    })
  ).data;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - getContext({ session, type, id }: { session; type: string; id: string })
Asignaciones con arrow functions encontradas (posibles funciones):
 - contextRepository(new ContextRepository();

  before(())
 - IS_CONTEXT_ENABLED('true';
  });

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  afterEach(async ())
 - getContextResult(await getContext({ session, type: 'tenant', id: 'get-test-org-acme' });

    expect(getContextResult...)
 - getContextResult(await getContext({ session, type: 'workspace', id: 'get-test-workspace-123' });

    expect(getConte...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/e2e/list-contexts.e2e.ts
Tamao: 8508 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ContextRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import axios, { AxiosResponse } from 'axios';
import { expect } from 'chai';

describe('List Contexts - /contexts (GET) #novu-v2', () => {
  let session: UserSession;
  const contextRepository = new ContextRepository();

  before(() => {
    // @ts-expect-error process.env is not typed
    process.env.IS_CONTEXT_ENABLED = 'true';
  });

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  after(() => {
    // @ts-expect-error process.env is not typed
    delete process.env.IS_CONTEXT_ENABLED;
  });

  it('should get the newly created contexts', async () => {
    for (let i = 0; i < 5; i += 1) {
      await contextRepository.create({
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        type: 'tenant',
        id: `list-test-1-org-${i}`,
        key: `tenant:list-test-1-org-${i}`,
        data: { index: i },
      });

      await timeout(5);
    }

    const response = await listContexts({ session });

    expect(response.status).to.equal(200);
    expect(response.data.data).to.be.an('array');
    expect(response.data.data.length).to.equal(5);
    expect(response.data.data[0].id).to.equal('list-test-1-org-4');
    expect(response.data.data[4].id).to.equal('list-test-1-org-0');
    expect(response.data.totalCount).to.equal(5);
  });

  it('should filter contexts by type', async () => {
    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'list-test-2-org-1',
      key: 'tenant:list-test-2-org-1',
      data: {},
    });

    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'workspace',
      id: 'list-test-2-workspace-1',
      key: 'workspace:list-test-2-workspace-1',
      data: {},
    });

    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'list-test-2-org-2',
      key: 'tenant:list-test-2-org-2',
      data: {},
    });

    const response = await listContexts({ session, type: 'tenant' });

    expect(response.status).to.equal(200);
    expect(response.data.data.length).to.equal(2);
    expect(response.data.data.every((ctx) => ctx.type === 'tenant')).to.be.true;
  });

  it('should filter contexts by id', async () => {
    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'list-test-3-org-acme',
      key: 'tenant:list-test-3-org-acme',
      data: {},
    });

    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'workspace',
      id: 'list-test-3-org-acme',
      key: 'workspace:list-test-3-org-acme',
      data: {},
    });

    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'list-test-3-org-other',
      key: 'tenant:list-test-3-org-other',
      data: {},
    });

    const response = await listContexts({ session, id: 'list-test-3-org-acme' });

    expect(response.status).to.equal(200);
    expect(response.data.data.length).to.equal(2);
    expect(response.data.data.every((ctx) => ctx.id === 'list-test-3-org-acme')).to.be.true;
  });

  it('should search contexts by key pattern', async () => {
    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'list-test-4-org-acme',
      key: 'tenant:list-test-4-org-acme',
      data: {},
    });

    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'workspace',
      id: 'list-test-4-workspace-acme',
      key: 'workspace:list-test-4-workspace-acme',
      data: {},
    });

    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'list-test-4-org-other',
      key: 'tenant:list-test-4-org-other',
      data: {},
    });

    const response = await listContexts({ session, search: 'list-test-4.*acme' });

    expect(response.status).to.equal(200);
    expect(response.data.data.length).to.equal(2);
  });

  it('should support cursor-based pagination with limit', async () => {
    for (let i = 0; i < 15; i += 1) {
      await contextRepository.create({
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        type: 'tenant',
        id: `list-test-5-org-${i}`,
        key: `tenant:list-test-5-org-${i}`,
        data: { index: i },
      });

      await timeout(5);
    }

    const page1 = await listContexts({ session, limit: 5 });

    expect(page1.data.data.length).to.equal(5);
    expect(page1.data.next).to.be.ok;
    expect(page1.data.totalCount).to.equal(15);

    const page2 = await listContexts({ session, limit: 5, after: page1.data.next });

    expect(page2.data.data.length).to.equal(5);
    expect(page2.data.next).to.be.ok;
    expect(page2.data.previous).to.be.ok;

    const page3 = await listContexts({ session, limit: 5, after: page2.data.next });

    expect(page3.data.data.length).to.equal(5);
    expect(page3.data.previous).to.be.ok;
  });

  it('should support orderBy and orderDirection', async () => {
    await timeout(10);

    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'list-test-6-org-1',
      key: 'tenant:list-test-6-org-1',
      data: {},
    });

    await timeout(10);

    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'list-test-6-org-2',
      key: 'tenant:list-test-6-org-2',
      data: {},
    });

    await timeout(10);

    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'list-test-6-org-3',
      key: 'tenant:list-test-6-org-3',
      data: {},
    });

    const responseDesc = await listContexts({ session, orderBy: 'createdAt', orderDirection: 'DESC' });

    expect(responseDesc.data.data[0].id).to.equal('list-test-6-org-3');
    expect(responseDesc.data.data[2].id).to.equal('list-test-6-org-1');

    const responseAsc = await listContexts({ session, orderBy: 'createdAt', orderDirection: 'ASC' });

    expect(responseAsc.data.data[0].id).to.equal('list-test-6-org-1');
    expect(responseAsc.data.data[2].id).to.equal('list-test-6-org-3');
  });

  it('should return empty list when no contexts exist', async () => {
    const response = await listContexts({ session });

    expect(response.status).to.equal(200);
    expect(response.data.data).to.be.an('array');
    expect(response.data.data.length).to.equal(0);
    expect(response.data.totalCount).to.equal(0);
  });
});

async function listContexts({
  session,
  limit,
  after,
  before,
  orderBy,
  orderDirection,
  type,
  id,
  search,
}: {
  session;
  limit?: number;
  after?: string;
  before?: string;
  orderBy?: string;
  orderDirection?: string;
  type?: string;
  id?: string;
  search?: string;
}): Promise<AxiosResponse> {
  const axiosInstance = axios.create();
  const params = new URLSearchParams();

  if (limit) params.append('limit', limit.toString());
  if (after) params.append('after', after);
  if (before) params.append('before', before);
  if (orderBy) params.append('orderBy', orderBy);
  if (orderDirection) params.append('orderDirection', orderDirection);
  if (type) params.append('type', type);
  if (id) params.append('id', id);
  if (search) params.append('search', search);

  const query = params.toString() ? `?${params.toString()}` : '';

  return await axiosInstance.get(`${session.serverUrl}/v2/contexts${query}`, {
    headers: {
      authorization: `ApiKey ${session.apiKey}`,
    },
  });
}

function timeout(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - listContexts({
  session,
  limit,
  after,
  before,
  orderBy,
  orderDirection,
  type,
  id,
  search,
}: {
  session;
  limit?: number;
  after?: string;
  before?: string;
  orderBy?: string;
  orderDirection?: string;
  type?: string;
  id?: string;
  search?: string;
})
 - timeout(ms)
Asignaciones con arrow functions encontradas (posibles funciones):
 - contextRepository(new ContextRepository();

  before(())
 - IS_CONTEXT_ENABLED('true';
  });

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  after(())
 - response(await listContexts({ session });

    expect(response.status).to.equal(200);
    expect(response.dat...)
 - response(await listContexts({ session, type: 'tenant' });

    expect(response.status).to.equal(200);
    exp...)
 - response(await listContexts({ session, id: 'list-test-3-org-acme' });

    expect(response.status).to.equal(2...)
 - response(await listContexts({ session, search: 'list-test-4.*acme' });

    expect(response.status).to.equal(...)
 - page3(await listContexts({ session, limit: 5, after: page2.data.next });

    expect(page3.data.data.lengt...)
 - responseAsc(await listContexts({ session, orderBy: 'createdAt', orderDirection: 'ASC' });

    expect(responseAs...)
 - query(params.toString() ? `?${params.toString()}` : '';

  return await axiosInstance.get(`${session.serve...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/e2e/update-context.e2e.ts
Tamao: 5115 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ContextRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import axios, { AxiosResponse } from 'axios';
import { expect } from 'chai';

describe('Update Context - /contexts/:type/:id (PATCH) #novu-v2', () => {
  let session: UserSession;
  const contextRepository = new ContextRepository();

  before(() => {
    // @ts-expect-error process.env is not typed
    process.env.IS_CONTEXT_ENABLED = 'true';
  });

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  afterEach(async () => {
    await contextRepository.delete({
      _environmentId: session.environment._id,
    });
  });

  after(() => {
    // @ts-expect-error process.env is not typed
    delete process.env.IS_CONTEXT_ENABLED;
  });

  it('should update context data', async () => {
    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'update-test-org-1',
      key: 'tenant:update-test-org-1',
      data: { tenantName: 'Acme Corp', region: 'us-east-1' },
    });

    const response = await updateContext({
      session,
      type: 'tenant',
      id: 'update-test-org-1',
      data: { tenantName: 'Acme Corporation', region: 'us-west-2', settings: { theme: 'dark' } },
    });

    expect(response?.status).to.equal(200);

    const updatedContext = await contextRepository.findOne({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      type: 'tenant',
      id: 'update-test-org-1',
    });

    expect(updatedContext?.data).to.deep.equal({
      tenantName: 'Acme Corporation',
      region: 'us-west-2',
      settings: { theme: 'dark' },
    });
  });

  it('should replace context data completely', async () => {
    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'update-test-org-2',
      key: 'tenant:update-test-org-2',
      data: { tenantName: 'Acme Corp', region: 'us-east-1', oldField: 'value' },
    });

    const response = await updateContext({
      session,
      type: 'tenant',
      id: 'update-test-org-2',
      data: { newField: 'newValue' },
    });

    expect(response?.status).to.equal(200);

    const updatedContext = await contextRepository.findOne({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      type: 'tenant',
      id: 'update-test-org-2',
    });

    expect(updatedContext?.data).to.deep.equal({ newField: 'newValue' });
    expect(updatedContext?.data).to.not.have.property('oldField');
  });

  it('should update context data to empty object', async () => {
    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'update-test-org-3',
      key: 'tenant:update-test-org-3',
      data: { tenantName: 'Acme Corp', region: 'us-east-1' },
    });

    const response = await updateContext({
      session,
      type: 'tenant',
      id: 'update-test-org-3',
      data: {},
    });

    expect(response?.status).to.equal(200);

    const updatedContext = await contextRepository.findOne({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      type: 'tenant',
      id: 'update-test-org-3',
    });

    expect(updatedContext?.data).to.deep.equal({});
  });

  it('should throw exception if context does not exist', async () => {
    try {
      await updateContext({
        session,
        type: 'tenant',
        id: 'non-existent',
        data: { test: 'value' },
      });

      throw new Error('Should not succeed');
    } catch (e) {
      expect(e.response.status).to.equal(404);
      expect(e?.response?.data?.message || e?.message).to.contains(
        `Context with type 'tenant' and id 'non-existent' not found`
      );
    }
  });

  it('should throw error if data is missing', async () => {
    await contextRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      type: 'tenant',
      id: 'update-test-org-4',
      key: 'tenant:update-test-org-4',
      data: { tenantName: 'Acme Corp' },
    });

    try {
      await updateContext({
        session,
        type: 'tenant',
        id: 'update-test-org-4',
      });

      throw new Error('Should not succeed');
    } catch (e) {
      expect(e.response.status).to.equal(422);
    }
  });
});

// biome-ignore lint/suspicious/noExportsInTest: helper function used by other tests
export async function updateContext({
  session,
  type,
  id,
  data,
}: {
  session;
  type?: string;
  id?: string;
  data?: any;
}): Promise<AxiosResponse> {
  const axiosInstance = axios.create();

  return await axiosInstance.patch(
    `${session.serverUrl}/v2/contexts/${type}/${id}`,
    {
      data,
    },
    {
      headers: {
        authorization: `ApiKey ${session.apiKey}`,
      },
    }
  );
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - updateContext({
  session,
  type,
  id,
  data,
}: {
  session;
  type?: string;
  id?: string;
  data?: any;
})
Asignaciones con arrow functions encontradas (posibles funciones):
 - contextRepository(new ContextRepository();

  before(())
 - IS_CONTEXT_ENABLED('true';
  });

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  afterEach(async ())
 - updatedContext(await contextRepository.findOne({
      _environmentId: session.environment._id,
      _organization...)
 - updatedContext(await contextRepository.findOne({
      _environmentId: session.environment._id,
      _organization...)
 - updatedContext(await contextRepository.findOne({
      _environmentId: session.environment._id,
      _organization...)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/usecases/create-context/create-context.command.ts
Tamao: 461 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand, IsValidContextData } from '@novu/application-generic';
import { ContextData, ContextId, ContextType } from '@novu/shared';
import { IsDefined, IsOptional, IsString } from 'class-validator';

export class CreateContextCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  @IsString()
  type: ContextType;

  @IsDefined()
  @IsString()
  id: ContextId;

  @IsOptional()
  @IsValidContextData()
  data?: ContextData;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class CreateContextCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/usecases/create-context/create-context.usecase.ts
Tamao: 1132 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ConflictException, Injectable } from '@nestjs/common';
import { ContextEntity, ContextRepository } from '@novu/dal';
import { createContextKey } from '@novu/shared';
import { CreateContextCommand } from './create-context.command';

@Injectable()
export class CreateContext {
  constructor(private contextRepository: ContextRepository) {}

  async execute(command: CreateContextCommand): Promise<ContextEntity> {
    // Check if context already exists
    const existingContext = await this.contextRepository.findOne({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      type: command.type,
      id: command.id,
    });

    if (existingContext) {
      throw new ConflictException(`Context with type '${command.type}' and id '${command.id}' already exists`);
    }

    // Create new context
    return this.contextRepository.create({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      type: command.type,
      id: command.id,
      key: createContextKey(command.type, command.id),
      data: command.data || {},
    });
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class CreateContext

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/usecases/create-context/index.ts
Tamao: 84 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './create-context.command';
export * from './create-context.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/usecases/delete-context/delete-context.command.ts
Tamao: 341 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ContextType } from '@novu/shared';
import { IsNotEmpty, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class DeleteContextCommand extends EnvironmentCommand {
  @IsString()
  @IsNotEmpty()
  id: string;

  @IsString()
  @IsNotEmpty()
  type: ContextType;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class DeleteContextCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/usecases/delete-context/delete-context.usecase.ts
Tamao: 943 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { ContextRepository } from '@novu/dal';
import { DeleteContextCommand } from './delete-context.command';

@Injectable()
export class DeleteContext {
  constructor(private contextRepository: ContextRepository) {}

  async execute(command: DeleteContextCommand) {
    const existingContext = await this.contextRepository.findOne({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      id: command.id,
      type: command.type,
    });

    if (!existingContext) {
      throw new NotFoundException(
        `Context with id '${command.id}' and type '${command.type}' not found in environment ${command.environmentId}`
      );
    }

    await this.contextRepository.delete({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      id: command.id,
      type: command.type,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class DeleteContext

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/usecases/delete-context/index.ts
Tamao: 84 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './delete-context.command';
export * from './delete-context.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/usecases/get-context/get-context.command.ts
Tamao: 338 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ContextType } from '@novu/shared';
import { IsNotEmpty, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class GetContextCommand extends EnvironmentCommand {
  @IsString()
  @IsNotEmpty()
  id: string;

  @IsString()
  @IsNotEmpty()
  type: ContextType;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetContextCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/usecases/get-context/get-context.usecase.ts
Tamao: 784 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { ContextEntity, ContextRepository } from '@novu/dal';
import { GetContextCommand } from './get-context.command';

@Injectable()
export class GetContext {
  constructor(private contextRepository: ContextRepository) {}

  async execute(command: GetContextCommand): Promise<ContextEntity> {
    const context = await this.contextRepository.findOne({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      id: command.id,
      type: command.type,
    });

    if (!context) {
      throw new NotFoundException(
        `Context with id '${command.id}' and type '${command.type}' not found in environment ${command.environmentId}`
      );
    }

    return context;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetContext

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/usecases/get-context/index.ts
Tamao: 78 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-context.command';
export * from './get-context.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/usecases/list-contexts/index.ts
Tamao: 82 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './list-contexts.command';
export * from './list-contexts.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/usecases/list-contexts/list-contexts.command.ts
Tamao: 440 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CursorBasedPaginatedCommand } from '@novu/application-generic';
import { Context, ContextType } from '@novu/shared';
import { IsOptional, IsString } from 'class-validator';

export class ListContextsCommand extends CursorBasedPaginatedCommand<Context, 'createdAt' | 'updatedAt'> {
  @IsString()
  @IsOptional()
  type?: ContextType;

  @IsString()
  @IsOptional()
  id?: string;

  @IsString()
  @IsOptional()
  search?: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ListContextsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/usecases/list-contexts/list-contexts.usecase.ts
Tamao: 2426 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { ContextEntity, ContextRepository, EnforceEnvOrOrgIds } from '@novu/dal';
import { DirectionEnum } from '@novu/shared';
import { FilterQuery } from 'mongoose';
import { ListContextsCommand } from './list-contexts.command';

@Injectable()
export class ListContexts {
  constructor(private contextRepository: ContextRepository) {}

  async execute(command: ListContextsCommand) {
    const filter: FilterQuery<ContextEntity> & EnforceEnvOrOrgIds = {
      _environmentId: command.user.environmentId,
      _organizationId: command.user.organizationId,
    };

    if (command.type) {
      filter.type = command.type;
    }

    if (command.id) {
      filter.id = command.id;
    }

    // Search across the composite key field (format: "type:id")
    if (command.search) {
      filter.key = { $regex: command.search, $options: 'i' };
    }

    // Handle cursor-based pagination
    let context: ContextEntity | null = null;
    const id = command.before || command.after;

    if (id) {
      context = await this.contextRepository.findOne({
        _environmentId: command.user.environmentId,
        _organizationId: command.user.organizationId,
        _id: id,
      });

      if (!context) {
        return {
          data: [],
          next: null,
          previous: null,
          totalCount: 0,
          totalCountCapped: false,
        };
      }
    }

    const afterCursor =
      command.after && context
        ? {
            sortBy: context[command.orderBy || 'createdAt'],
            paginateField: context._id,
          }
        : undefined;

    const beforeCursor =
      command.before && context
        ? {
            sortBy: context[command.orderBy || 'createdAt'],
            paginateField: context._id,
          }
        : undefined;

    const pagination = await this.contextRepository.findWithCursorBasedPagination({
      query: filter,
      paginateField: '_id',
      sortBy: command.orderBy || 'createdAt',
      sortDirection: command.orderDirection || DirectionEnum.DESC,
      limit: command.limit,
      after: afterCursor,
      before: beforeCursor,
      includeCursor: command.includeCursor,
    });

    return {
      data: pagination.data,
      next: pagination.next,
      previous: pagination.previous,
      totalCount: pagination.totalCount,
      totalCountCapped: pagination.totalCountCapped,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ListContexts

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/usecases/update-context/index.ts
Tamao: 84 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './update-context.command';
export * from './update-context.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/usecases/update-context/update-context.command.ts
Tamao: 447 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand, IsValidContextData } from '@novu/application-generic';
import { ContextData, ContextId, ContextType } from '@novu/shared';
import { IsDefined, IsString } from 'class-validator';

export class UpdateContextCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  @IsString()
  type: ContextType;

  @IsDefined()
  @IsString()
  id: ContextId;

  @IsDefined()
  @IsValidContextData()
  data: ContextData;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class UpdateContextCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/contexts/usecases/update-context/update-context.usecase.ts
Tamao: 1097 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { ContextEntity, ContextRepository } from '@novu/dal';
import { UpdateContextCommand } from './update-context.command';

@Injectable()
export class UpdateContext {
  constructor(private contextRepository: ContextRepository) {}

  async execute(command: UpdateContextCommand): Promise<ContextEntity> {
    const query = {
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      type: command.type,
      id: command.id,
    };

    // Check if context exists
    const existingContext = await this.contextRepository.findOne(query);

    if (!existingContext) {
      throw new NotFoundException(`Context with type '${command.type}' and id '${command.id}' not found`);
    }

    // Update only the data field
    const updatedContext = await this.contextRepository.findOneAndUpdate(
      query,
      { $set: { data: command.data } },
      { new: true }
    );

    // biome-ignore lint/style/noNonNullAssertion: we know it exists since we found it
    return updatedContext!;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class UpdateContext

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/environments-v1.controller.ts
Tamao: 9710 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  ClassSerializerInterceptor,
  Controller,
  Delete,
  Get,
  Param,
  Post,
  Put,
  UseInterceptors,
} from '@nestjs/common';
import { ApiExcludeEndpoint, ApiOperation, ApiParam, ApiTags } from '@nestjs/swagger';
import {
  FeatureFlagsService,
  ProductFeature,
  RequirePermissions,
  SkipPermissionsCheck,
} from '@novu/application-generic';
import { CommunityOrganizationRepository } from '@novu/dal';
import {
  ApiServiceLevelEnum,
  FeatureFlagsKeysEnum,
  FeatureNameEnum,
  getFeatureForTierAsBoolean,
  PermissionsEnum,
  ProductFeatureKeyEnum,
  UserSessionData,
} from '@novu/shared';
import { ErrorDto } from '../../error-dto';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { ApiKey } from '../shared/dtos/api-key';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { SdkGroupName, SdkMethodName } from '../shared/framework/swagger/sdk.decorators';
import { UserSession } from '../shared/framework/user.decorator';
import { CreateEnvironmentRequestDto } from './dtos/create-environment-request.dto';
import { EnvironmentResponseDto } from './dtos/environment-response.dto';
import { UpdateEnvironmentRequestDto } from './dtos/update-environment-request.dto';
import { CreateEnvironmentCommand } from './usecases/create-environment/create-environment.command';
import { CreateEnvironment } from './usecases/create-environment/create-environment.usecase';
import { DeleteEnvironmentCommand } from './usecases/delete-environment/delete-environment.command';
import { DeleteEnvironment } from './usecases/delete-environment/delete-environment.usecase';
import { GetApiKeysCommand } from './usecases/get-api-keys/get-api-keys.command';
import { GetApiKeys } from './usecases/get-api-keys/get-api-keys.usecase';
import { GetEnvironment, GetEnvironmentCommand } from './usecases/get-environment';
import { GetMyEnvironmentsCommand } from './usecases/get-my-environments/get-my-environments.command';
import { GetMyEnvironments } from './usecases/get-my-environments/get-my-environments.usecase';
import { RegenerateApiKeys } from './usecases/regenerate-api-keys/regenerate-api-keys.usecase';
import { UpdateEnvironmentCommand } from './usecases/update-environment/update-environment.command';
import { UpdateEnvironment } from './usecases/update-environment/update-environment.usecase';

/**
 * @deprecated use EnvironmentsControllerV2
 */
@ApiCommonResponses()
@Controller('/environments')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiTags('Environments')
export class EnvironmentsControllerV1 {
  constructor(
    private createEnvironmentUsecase: CreateEnvironment,
    private updateEnvironmentUsecase: UpdateEnvironment,
    private getApiKeysUsecase: GetApiKeys,
    private regenerateApiKeysUsecase: RegenerateApiKeys,
    private getEnvironmentUsecase: GetEnvironment,
    private getMyEnvironmentsUsecase: GetMyEnvironments,
    private deleteEnvironmentUsecase: DeleteEnvironment,
    private organizationRepository: CommunityOrganizationRepository,
    private featureFlagService: FeatureFlagsService
  ) {}

  @Get('/me')
  @ApiOperation({
    summary: 'Get current environment',
  })
  @ApiResponse(EnvironmentResponseDto)
  @ExternalApiAccessible()
  @ApiExcludeEndpoint()
  @SkipPermissionsCheck()
  async getCurrentEnvironment(@UserSession() user: UserSessionData): Promise<EnvironmentResponseDto> {
    return await this.getEnvironmentUsecase.execute(
      GetEnvironmentCommand.create({
        environmentId: user.environmentId,
        userId: user._id,
        organizationId: user.organizationId,
      })
    );
  }

  @Post('/')
  @ApiOperation({
    summary: 'Create an environment',
    description: `Creates a new environment within the current organization. 
    Environments allow you to manage different stages of your application development lifecycle.
    Each environment has its own set of API keys and configurations.`,
  })
  @ApiResponse(EnvironmentResponseDto, 201)
  @ApiResponse(ErrorDto, 402, false, false)
  @ProductFeature(ProductFeatureKeyEnum.MANAGE_ENVIRONMENTS)
  @SdkGroupName('Environments')
  @SdkMethodName('create')
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.ENVIRONMENT_WRITE)
  async createEnvironment(
    @UserSession() user: UserSessionData,
    @Body() body: CreateEnvironmentRequestDto
  ): Promise<EnvironmentResponseDto> {
    const canAccessApiKeys = await this.canUserAccessApiKeys(user);

    return await this.createEnvironmentUsecase.execute(
      CreateEnvironmentCommand.create({
        name: body.name,
        userId: user._id,
        organizationId: user.organizationId,
        color: body.color,
        system: false,
        returnApiKeys: canAccessApiKeys,
      })
    );
  }

  @Get('/')
  @ApiOperation({
    summary: 'List all environments',
    description: `This API returns a list of environments for the current organization. 
    Each environment contains its configuration, API keys (if user has access), and metadata.`,
  })
  @ApiResponse(EnvironmentResponseDto, 200, true)
  @SdkGroupName('Environments')
  @SdkMethodName('list')
  @ExternalApiAccessible()
  @SkipPermissionsCheck()
  async listMyEnvironments(@UserSession() user: UserSessionData): Promise<EnvironmentResponseDto[]> {
    const canAccessApiKeys = await this.canUserAccessApiKeys(user);

    return await this.getMyEnvironmentsUsecase.execute(
      GetMyEnvironmentsCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        returnApiKeys: canAccessApiKeys,
        userId: user._id,
      })
    );
  }

  @Put('/:environmentId')
  @ApiOperation({
    summary: 'Update an environment',
    description: `Update an environment by its unique identifier **environmentId**. 
    You can modify the environment name, identifier, color, and other configuration settings.`,
  })
  @ApiParam({ name: 'environmentId', description: 'The unique identifier of the environment', type: String })
  @ApiResponse(EnvironmentResponseDto)
  @SdkGroupName('Environments')
  @SdkMethodName('update')
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.ENVIRONMENT_WRITE)
  async updateMyEnvironment(
    @UserSession() user: UserSessionData,
    @Param('environmentId') environmentId: string,
    @Body() payload: UpdateEnvironmentRequestDto
  ) {
    return await this.updateEnvironmentUsecase.execute(
      UpdateEnvironmentCommand.create({
        environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        name: payload.name,
        identifier: payload.identifier,
        _parentId: payload.parentId,
        color: payload.color,
        dns: payload.dns,
        bridge: payload.bridge,
      })
    );
  }

  @Get('/api-keys')
  @ApiOperation({
    summary: 'Get api keys',
  })
  @ApiResponse(ApiKey, 200, true)
  @ExternalApiAccessible()
  @SdkGroupName('Environments.ApiKeys')
  @ApiExcludeEndpoint()
  @RequirePermissions(PermissionsEnum.API_KEY_READ)
  async listOrganizationApiKeys(@UserSession() user: UserSessionData): Promise<ApiKey[]> {
    const command = GetApiKeysCommand.create({
      userId: user._id,
      organizationId: user.organizationId,
      environmentId: user.environmentId,
    });

    return await this.getApiKeysUsecase.execute(command);
  }

  @Post('/api-keys/regenerate')
  @ApiResponse(ApiKey, 201, true)
  @ApiExcludeEndpoint()
  @RequirePermissions(PermissionsEnum.API_KEY_WRITE)
  async regenerateOrganizationApiKeys(@UserSession() user: UserSessionData): Promise<ApiKey[]> {
    const command = GetApiKeysCommand.create({
      userId: user._id,
      organizationId: user.organizationId,
      environmentId: user.environmentId,
    });

    return await this.regenerateApiKeysUsecase.execute(command);
  }

  @Delete('/:environmentId')
  @ApiOperation({
    summary: 'Delete an environment',
    description: `Delete an environment by its unique identifier **environmentId**. 
    This action is irreversible and will remove the environment and all its associated data.`,
  })
  @ApiParam({ name: 'environmentId', description: 'The unique identifier of the environment', type: String })
  @ProductFeature(ProductFeatureKeyEnum.MANAGE_ENVIRONMENTS)
  @SdkGroupName('Environments')
  @SdkMethodName('delete')
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.ENVIRONMENT_WRITE)
  async deleteEnvironment(@UserSession() user: UserSessionData, @Param('environmentId') environmentId: string) {
    return await this.deleteEnvironmentUsecase.execute(
      DeleteEnvironmentCommand.create({
        userId: user._id,
        organizationId: user.organizationId,
        environmentId,
      })
    );
  }

  private async canUserAccessApiKeys(user: UserSessionData): Promise<boolean> {
    const organization = await this.organizationRepository.findOne({
      _id: user.organizationId,
    });

    const [isRbacFlagEnabled, isRbacFeatureEnabled] = await Promise.all([
      this.featureFlagService.getFlag({
        organization: { _id: user.organizationId },
        user: { _id: user._id },
        key: FeatureFlagsKeysEnum.IS_RBAC_ENABLED,
        defaultValue: false,
      }),
      getFeatureForTierAsBoolean(
        FeatureNameEnum.ACCOUNT_ROLE_BASED_ACCESS_CONTROL_BOOLEAN,
        organization?.apiServiceLevel || ApiServiceLevelEnum.FREE
      ),
    ]);

    const isRbacEnabled = isRbacFlagEnabled && isRbacFeatureEnabled;

    if (!isRbacEnabled) {
      return true;
    }

    return user.permissions.includes(PermissionsEnum.API_KEY_READ);
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class EnvironmentsControllerV1

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/environments-v1.module.ts
Tamao: 916 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { forwardRef, Module } from '@nestjs/common';

import { AuthModule } from '../auth/auth.module';
import { IntegrationModule } from '../integrations/integrations.module';
import { LayoutsV1Module } from '../layouts-v1/layouts-v1.module';
import { NotificationGroupsModule } from '../notification-groups/notification-groups.module';
import { SharedModule } from '../shared/shared.module';
import { EnvironmentsControllerV1 } from './environments-v1.controller';
import { NovuBridgeModule } from './novu-bridge.module';
import { USE_CASES } from './usecases';

@Module({
  imports: [
    SharedModule,
    NotificationGroupsModule,
    forwardRef(() => AuthModule),
    forwardRef(() => LayoutsV1Module),
    forwardRef(() => IntegrationModule),
    NovuBridgeModule,
  ],
  controllers: [EnvironmentsControllerV1],
  providers: [...USE_CASES],
  exports: [...USE_CASES],
})
export class EnvironmentsModuleV1 {}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class EnvironmentsModuleV1

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/novu-bridge-client.ts
Tamao: 2784 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Inject, Injectable, Scope } from '@nestjs/common';
import { GetDecryptedSecretKey, GetDecryptedSecretKeyCommand } from '@novu/application-generic';
import { PostActionEnum, type Workflow } from '@novu/framework/internal';
import { Client, NovuHandler, NovuRequestHandler } from '@novu/framework/nest';
import type { Request, Response } from 'express';
import { ConstructFrameworkWorkflow, ConstructFrameworkWorkflowCommand } from './usecases/construct-framework-workflow';

/*
 * A custom framework name is specified for the Novu-managed Bridge endpoint
 * to provide a clear distinction between Novu-managed and self-managed Bridge endpoints.
 */
export const frameworkName = 'novu-nest';

/**
 * This class overrides the default NestJS Novu Bridge Client to allow for dynamic construction of
 * workflows to serve on the Novu Bridge.
 */
@Injectable({ scope: Scope.REQUEST })
export class NovuBridgeClient {
  public novuRequestHandler: NovuRequestHandler | null = null;

  constructor(
    @Inject(NovuHandler) private novuHandler: NovuHandler,
    private constructFrameworkWorkflow: ConstructFrameworkWorkflow,
    private getDecryptedSecretKey: GetDecryptedSecretKey
  ) {}

  public async handleRequest(req: Request, res: Response) {
    const secretKey = await this.getDecryptedSecretKey.execute(
      GetDecryptedSecretKeyCommand.create({
        environmentId: req.params.environmentId,
      })
    );

    const workflows: Workflow[] = [];

    /*
     * Only construct a workflow when dealing with a POST request to the Novu-managed Bridge endpoint.
     * Non-POST requests don't have a `workflowId` query parameter, so we can't construct a workflow.
     * Those non-POST requests are handled for the purpose of returning a successful health-check.
     */
    if (Object.values(PostActionEnum).includes(req.query.action as PostActionEnum)) {
      const programmaticallyConstructedWorkflow = await this.constructFrameworkWorkflow.execute(
        ConstructFrameworkWorkflowCommand.create({
          environmentId: req.params.environmentId,
          workflowId: req.query.workflowId as string,
          layoutId: req.query.layoutId as string,
          controlValues: req.body.controls,
          action: req.query.action as PostActionEnum,
          skipLayoutRendering: req.query.skipLayoutRendering === 'true',
          jobId: req.query.jobId ? (req.query.jobId as string) : undefined,
        })
      );

      workflows.push(programmaticallyConstructedWorkflow);
    }

    this.novuRequestHandler = new NovuRequestHandler({
      frameworkName,
      workflows,
      client: new Client({ secretKey, strictAuthentication: true }),
      handler: this.novuHandler.handler,
    });

    await this.novuRequestHandler.createHandler()(req, res);
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export  const
- export class NovuBridgeClient

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/novu-bridge.controller.ts
Tamao: 884 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Controller, Get, Inject, Options, Post, Req, Res } from '@nestjs/common';
import { ApiExcludeController } from '@nestjs/swagger';
import { NovuClient } from '@novu/framework/nest';
import type { Request, Response } from 'express';
import { NovuBridgeClient } from './novu-bridge-client';

@Controller('/environments/:environmentId/bridge')
@ApiExcludeController()
export class NovuBridgeController {
  constructor(@Inject(NovuClient) private novuService: NovuBridgeClient) {}

  @Get()
  async handleGet(@Req() req: Request, @Res() res: Response) {
    await this.novuService.handleRequest(req, res);
  }

  @Post()
  async handlePost(@Req() req: Request, @Res() res: Response) {
    await this.novuService.handleRequest(req, res);
  }

  @Options()
  async handleOptions(@Req() req: Request, @Res() res: Response) {
    await this.novuService.handleRequest(req, res);
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class NovuBridgeController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/novu-bridge.module.ts
Tamao: 2908 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import {
  AnalyticsService,
  ClickHouseService,
  CreateExecutionDetails,
  FeatureFlagsService,
  GetDecryptedSecretKey,
  GetLayoutUseCase as GetLayoutUseCaseV1,
  TraceLogRepository,
} from '@novu/application-generic';

import {
  CommunityOrganizationRepository,
  ControlValuesRepository,
  EnvironmentRepository,
  ExecutionDetailsRepository,
  IntegrationRepository,
  JobRepository,
  LayoutRepository,
  NotificationTemplateRepository,
} from '@novu/dal';
import { NovuClient, NovuHandler } from '@novu/framework/nest';
import { GetLayoutUseCase } from '../layouts-v2/usecases/get-layout';
import { LayoutVariablesSchemaUseCase } from '../layouts-v2/usecases/layout-variables-schema';
import { GetOrganizationSettings } from '../organization/usecases/get-organization-settings/get-organization-settings.usecase';
import { CreateVariablesObject } from '../shared/usecases/create-variables-object';
import { NovuBridgeController } from './novu-bridge.controller';
import { NovuBridgeClient } from './novu-bridge-client';
import { ConstructFrameworkWorkflow } from './usecases/construct-framework-workflow';
import {
  ChatOutputRendererUsecase,
  EmailOutputRendererUsecase,
  InAppOutputRendererUsecase,
  PushOutputRendererUsecase,
  SmsOutputRendererUsecase,
} from './usecases/output-renderers';
import { DelayOutputRendererUsecase } from './usecases/output-renderers/delay-output-renderer.usecase';
import { DigestOutputRendererUsecase } from './usecases/output-renderers/digest-output-renderer.usecase';
import { ThrottleOutputRendererUsecase } from './usecases/output-renderers/throttle-output-renderer.usecase';

export const featureFlagsService = {
  provide: FeatureFlagsService,
  useFactory: async (): Promise<FeatureFlagsService> => {
    const instance = new FeatureFlagsService();
    await instance.initialize();

    return instance;
  },
};

@Module({
  controllers: [NovuBridgeController],
  providers: [
    {
      provide: NovuClient,
      useClass: NovuBridgeClient,
    },
    NovuHandler,
    EnvironmentRepository,
    NotificationTemplateRepository,
    CommunityOrganizationRepository,
    IntegrationRepository,
    ControlValuesRepository,
    LayoutRepository,
    GetOrganizationSettings,
    ConstructFrameworkWorkflow,
    GetDecryptedSecretKey,
    InAppOutputRendererUsecase,
    EmailOutputRendererUsecase,
    SmsOutputRendererUsecase,
    ChatOutputRendererUsecase,
    PushOutputRendererUsecase,
    DelayOutputRendererUsecase,
    DigestOutputRendererUsecase,
    ThrottleOutputRendererUsecase,
    AnalyticsService,
    GetLayoutUseCaseV1,
    LayoutVariablesSchemaUseCase,
    CreateVariablesObject,
    GetLayoutUseCase,
    JobRepository,
    ExecutionDetailsRepository,
    TraceLogRepository,
    ClickHouseService,
    CreateExecutionDetails,
    featureFlagsService,
  ],
})
export class NovuBridgeModule {}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - featureFlagsService({
  provide: FeatureFlagsService,
  useFactory: async (): Promise<FeatureFlagsService>)
Declaraciones 'export' encontradas:
- export  const
- export class NovuBridgeModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/dtos/api-key.dto.ts
Tamao: 532 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class ApiKeyDto {
  @ApiProperty({
    type: String,
    description: 'API key',
    example: 'sk_test_1234567890abcdef',
  })
  key: string;

  @ApiProperty({
    type: String,
    description: 'User ID associated with the API key',
    example: '60d5ecb8b3b3a30015f3e1a4',
  })
  _userId: string;

  @ApiPropertyOptional({
    type: String,
    description: 'Hashed representation of the API key',
    example: 'hash_value_here',
  })
  hash?: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ApiKeyDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/dtos/create-environment-request.dto.ts
Tamao: 1013 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsDefined, IsHexColor, IsMongoId, IsOptional, IsString } from 'class-validator';

export class CreateEnvironmentRequestDto {
  @ApiProperty({
    type: String,
    description: 'Name of the environment to be created',
    example: 'Production Environment',
  })
  @IsDefined({ message: 'Environment name is required' })
  @IsString({ message: 'Environment name must be a string' })
  name: string;

  @ApiPropertyOptional({
    type: String,
    description: 'MongoDB ObjectId of the parent environment (optional)',
    example: '60d5ecb8b3b3a30015f3e1a1',
  })
  @IsOptional()
  @IsMongoId({ message: 'Parent ID must be a valid MongoDB ObjectId' })
  parentId?: string;

  @ApiProperty({
    type: String,
    description: 'Hex color code for the environment',
    example: '#3498db',
  })
  @IsDefined({ message: 'Environment color is required' })
  @IsHexColor({ message: 'Color must be a valid hex color code' })
  color: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class CreateEnvironmentRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/dtos/environment-response.dto.ts
Tamao: 1487 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { EnvironmentTypeEnum } from '@novu/shared';
import { ApiKeyDto } from './api-key.dto';

export class EnvironmentResponseDto {
  @ApiProperty({
    type: String,
    description: 'Unique identifier of the environment',
    example: '60d5ecb8b3b3a30015f3e1a1',
  })
  _id: string;

  @ApiProperty({
    type: String,
    description: 'Name of the environment',
    example: 'Production Environment',
  })
  name: string;

  @ApiProperty({
    type: String,
    description: 'Organization ID associated with the environment',
    example: '60d5ecb8b3b3a30015f3e1a2',
  })
  _organizationId: string;

  @ApiProperty({
    type: String,
    description: 'Unique identifier for the environment',
    example: 'prod-env-01',
  })
  identifier: string;

  @ApiPropertyOptional({
    enum: EnvironmentTypeEnum,
    description: 'Type of the environment',
    example: EnvironmentTypeEnum.PROD,
    nullable: true,
  })
  type: EnvironmentTypeEnum;

  @ApiPropertyOptional({
    type: ApiKeyDto,
    isArray: true,
    description: 'List of API keys associated with the environment',
  })
  apiKeys?: ApiKeyDto[];

  @ApiPropertyOptional({
    type: String,
    description: 'Parent environment ID',
    example: '60d5ecb8b3b3a30015f3e1a3',
  })
  _parentId?: string;

  @ApiPropertyOptional({
    type: String,
    description: 'URL-friendly slug for the environment',
    example: 'production',
  })
  slug?: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class EnvironmentResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/dtos/update-environment-request.dto.ts
Tamao: 887 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsHexColor, IsMongoId, IsOptional, IsString } from 'class-validator';

export class InBoundParseDomainDto {
  @ApiPropertyOptional({ type: String })
  inboundParseDomain?: string;
}

export class BridgeConfigurationDto {
  @ApiPropertyOptional({ type: String })
  url?: string;
}

export class UpdateEnvironmentRequestDto {
  @ApiProperty()
  @IsOptional()
  @IsString()
  name?: string;

  @ApiProperty()
  @IsOptional()
  @IsString()
  identifier?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsMongoId()
  parentId?: string;

  @ApiPropertyOptional()
  @IsOptional()
  @IsHexColor()
  color?: string;

  @ApiPropertyOptional({
    type: InBoundParseDomainDto,
  })
  dns?: InBoundParseDomainDto;

  @ApiPropertyOptional({
    type: BridgeConfigurationDto,
  })
  bridge?: BridgeConfigurationDto;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class InBoundParseDomainDto
- export class BridgeConfigurationDto
- export class UpdateEnvironmentRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/e2e/environments.controller.e2e.ts
Tamao: 5489 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { ApiServiceLevelEnum, EnvironmentEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { expectSdkExceptionGeneric, initNovuClassSdkInternalAuth } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Env Controller', async () => {
  let session: UserSession;
  let novuClient: Novu;
  before(async () => {
    session = new UserSession();
    await session.initialize({});
    novuClient = initNovuClassSdkInternalAuth(session);
  });
  describe('Create Env', () => {
    [ApiServiceLevelEnum.BUSINESS, ApiServiceLevelEnum.ENTERPRISE].forEach((serviceLevel) => {
      it(`should be able to create env in ${serviceLevel} tier`, async () => {
        await session.updateOrganizationServiceLevel(serviceLevel);
        const { name, environmentRequestDto } = generateRandomEnvRequest();
        const createdEnv = await novuClient.environments.create(environmentRequestDto);
        const { result } = createdEnv;
        expect(result).to.be.ok;
        expect(result.name).to.equal(name);
      });
    });

    [ApiServiceLevelEnum.PRO, ApiServiceLevelEnum.FREE].forEach((serviceLevel) => {
      it(`should not be able to create env in ${serviceLevel} tier`, async () => {
        await session.updateOrganizationServiceLevel(serviceLevel);
        const { error, successfulBody } = await expectSdkExceptionGeneric(() =>
          novuClient.environments.create(generateRandomEnvRequest().environmentRequestDto)
        );
        expect(error).to.be.ok;
        expect(error?.message).to.equal('Payment Required');
        expect(error?.statusCode).to.equal(402);
      });
    });
  });

  describe('Update Env Protection', () => {
    it('should prevent renaming Development environment', async () => {
      await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);
      
      // Find the Development environment
      const environments = await novuClient.environments.list();
      const devEnvironment = environments.result?.find(env => env.name === EnvironmentEnum.DEVELOPMENT);
      expect(devEnvironment).to.be.ok;

      // Try to update the Development environment name - should fail
      const { error } = await expectSdkExceptionGeneric(() =>
        novuClient.environments.update({
          name: 'Custom Development Name'
        }, devEnvironment!._id!)
      );

      expect(error).to.be.ok;
      expect(error?.message).to.include('Cannot update the name of Development or Production environments');
      expect(error?.statusCode).to.equal(422);
    });

    it('should prevent renaming Production environment', async () => {
      await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);
      
      // Find the Production environment
      const environments = await novuClient.environments.list();
      const prodEnvironment = environments.result?.find(env => env.name === EnvironmentEnum.PRODUCTION);
      expect(prodEnvironment).to.be.ok;

      // Try to update the Production environment name - should fail
      const { error } = await expectSdkExceptionGeneric(() =>
        novuClient.environments.update({
          name: 'Custom Production Name'
        }, prodEnvironment!._id!)
      );

      expect(error).to.be.ok;
      expect(error?.message).to.include('Cannot update the name of Development or Production environments');
      expect(error?.statusCode).to.equal(422);
    });

    it('should allow updating other properties of protected environments', async () => {
      await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);
      
      // Find the Development environment
      const environments = await novuClient.environments.list();
      const devEnvironment = environments.result?.find(env => env.name === EnvironmentEnum.DEVELOPMENT);
      expect(devEnvironment).to.be.ok;

      // Should be able to update color without changing name
      const updatedEnv = await novuClient.environments.update({
        color: '#ff0000'
      }, devEnvironment!._id!);

      expect(updatedEnv.result).to.be.ok;
      expect(updatedEnv.result?.name).to.equal(EnvironmentEnum.DEVELOPMENT); // Name should remain unchanged
    });

    it('should allow renaming custom environments', async () => {
      await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);
      
      // Create a custom environment
      const { environmentRequestDto } = generateRandomEnvRequest();
      const createdEnv = await novuClient.environments.create(environmentRequestDto);
      expect(createdEnv.result).to.be.ok;

      // Should be able to update custom environment name
      const newName = generateRandomName('updated-env');
      const updatedEnv = await novuClient.environments.update({
        name: newName
      }, createdEnv.result!._id!);

      expect(updatedEnv.result).to.be.ok;
      expect(updatedEnv.result?.name).to.equal(newName);
    });
  });

  function generateRandomEnvRequest() {
    const name = generateRandomName('env');
    const parentId = session.environment._id;
    const environmentRequestDto = {
      name,
      parentId,
      color: '#b15353',
    };

    return { name, parentId, environmentRequestDto };
  }
});
function generateRandomName(prefix: string = 'env'): string {
  const timestamp = Date.now();
  const randomPart = Math.random().toString(36).substring(2, 7);

  return `${prefix}-${randomPart}-${timestamp}`;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - generateRandomEnvRequest()
 - generateRandomName(prefix: string = 'env')
Asignaciones con arrow functions encontradas (posibles funciones):
 - novuClient(initNovuClassSdkInternalAuth(session);
  });
  describe('Create Env', ())
 - devEnvironment(environments.result?.find(env)
 - prodEnvironment(environments.result?.find(env)
 - devEnvironment(environments.result?.find(env)
 - updatedEnv(await novuClient.environments.update({
        color: '#ff0000'
      }, devEnvironment!._id!);

   ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/e2e/get-api-keys.e2e.ts
Tamao: 644 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NOVU_ENCRYPTION_SUB_MASK } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get Environment API Keys - /environments/api-keys (GET) #novu-v2', async () => {
  let session: UserSession;
  before(async () => {
    session = new UserSession();
    await session.initialize({});
  });

  it('should get environment api keys correctly', async () => {
    const { body } = await session.testAgent.get('/v1/environments/api-keys').send();

    expect(body.data[0].key).to.not.contains(NOVU_ENCRYPTION_SUB_MASK);
    expect(body.data[0]._userId).to.equal(session.user._id);
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize({});
  });

  it('should get environment api keys co...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/e2e/regenerate-api-keys.e2e.ts
Tamao: 1066 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NOVU_ENCRYPTION_SUB_MASK } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Environment - Regenerate Api Key #novu-v0-os', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should regenerate an Api Key', async () => {
    const {
      body: { data: oldApiKeys },
    } = await session.testAgent.get('/v1/environments/api-keys').send({});
    const oldApiKey = oldApiKeys[0].key;
    expect(oldApiKey).to.not.contains(NOVU_ENCRYPTION_SUB_MASK);

    const {
      body: { data: newApiKeys },
    } = await session.testAgent.post('/v1/environments/api-keys/regenerate').send({});
    const newApiKey = newApiKeys[0].key;
    expect(newApiKey).to.not.contains(NOVU_ENCRYPTION_SUB_MASK);

    expect(oldApiKey).to.not.equal(newApiKey);

    const {
      body: { data: organizations },
    } = await session.testAgent.get('/v1/organizations').send({});

    expect(organizations).not.to.be.empty;
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should regenerate an Api Key', async...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/index.ts
Tamao: 921 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { GetMxRecord } from '../../inbound-parse/usecases/get-mx-record/get-mx-record.usecase';
import { CreateEnvironment } from './create-environment/create-environment.usecase';
import { DeleteEnvironment } from './delete-environment';
import { GenerateUniqueApiKey } from './generate-unique-api-key/generate-unique-api-key.usecase';
import { GetApiKeys } from './get-api-keys/get-api-keys.usecase';
import { GetEnvironment } from './get-environment';
import { GetMyEnvironments } from './get-my-environments/get-my-environments.usecase';
import { RegenerateApiKeys } from './regenerate-api-keys/regenerate-api-keys.usecase';
import { UpdateEnvironment } from './update-environment/update-environment.usecase';

export const USE_CASES = [
  GetMxRecord,
  CreateEnvironment,
  UpdateEnvironment,
  GenerateUniqueApiKey,
  GetApiKeys,
  RegenerateApiKeys,
  GetEnvironment,
  GetMyEnvironments,
  DeleteEnvironment,
];


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/construct-framework-workflow/construct-framework-workflow.command.ts
Tamao: 650 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentLevelCommand } from '@novu/application-generic';
import { PostActionEnum } from '@novu/framework/internal';
import { IsBoolean, IsDefined, IsEnum, IsObject, IsOptional, IsString } from 'class-validator';

export class ConstructFrameworkWorkflowCommand extends EnvironmentLevelCommand {
  @IsString()
  @IsDefined()
  workflowId: string;

  @IsString()
  @IsOptional()
  layoutId?: string;

  @IsObject()
  @IsDefined()
  controlValues: Record<string, unknown>;

  @IsEnum(PostActionEnum)
  action: PostActionEnum;

  @IsOptional()
  @IsBoolean()
  skipLayoutRendering?: boolean;

  @IsOptional()
  @IsString()
  jobId?: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ConstructFrameworkWorkflowCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/construct-framework-workflow/construct-framework-workflow.usecase.ts
Tamao: 13708 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { emailControlSchema, Instrument, InstrumentUsecase, PinoLogger } from '@novu/application-generic';
import {
  CommunityOrganizationRepository,
  EnvironmentRepository,
  NotificationStepEntity,
  NotificationTemplateEntity,
  NotificationTemplateRepository,
  OrganizationEntity,
} from '@novu/dal';
import { workflow } from '@novu/framework/express';
import { ActionStep, ChannelStep, Schema, Step, StepOutput, Workflow } from '@novu/framework/internal';
import { LAYOUT_PREVIEW_EMAIL_STEP, LAYOUT_PREVIEW_WORKFLOW_ID, StepTypeEnum } from '@novu/shared';
import { AdditionalOperation, RulesLogic } from 'json-logic-js';
import _ from 'lodash';
import { evaluateRules } from '../../../shared/services/query-parser/query-parser.service';
import { isMatchingJsonSchema } from '../../../workflows-v2/util/jsonToSchema';
import {
  ChatOutputRendererUsecase,
  EmailOutputRendererUsecase,
  FullPayloadForRender,
  InAppOutputRendererUsecase,
  PushOutputRendererUsecase,
  SmsOutputRendererUsecase,
} from '../output-renderers';
import { DelayOutputRendererUsecase } from '../output-renderers/delay-output-renderer.usecase';
import { DigestOutputRendererUsecase } from '../output-renderers/digest-output-renderer.usecase';
import { ThrottleOutputRendererUsecase } from '../output-renderers/throttle-output-renderer.usecase';
import { ConstructFrameworkWorkflowCommand } from './construct-framework-workflow.command';

const LOG_CONTEXT = 'ConstructFrameworkWorkflow';

@Injectable()
export class ConstructFrameworkWorkflow {
  constructor(
    private logger: PinoLogger,
    private workflowsRepository: NotificationTemplateRepository,
    private environmentRepository: EnvironmentRepository,
    private communityOrganizationRepository: CommunityOrganizationRepository,
    private inAppOutputRendererUseCase: InAppOutputRendererUsecase,
    private emailOutputRendererUseCase: EmailOutputRendererUsecase,
    private smsOutputRendererUseCase: SmsOutputRendererUsecase,
    private chatOutputRendererUseCase: ChatOutputRendererUsecase,
    private pushOutputRendererUseCase: PushOutputRendererUsecase,
    private delayOutputRendererUseCase: DelayOutputRendererUsecase,
    private digestOutputRendererUseCase: DigestOutputRendererUsecase,
    private throttleOutputRendererUseCase: ThrottleOutputRendererUsecase
  ) {}

  @InstrumentUsecase()
  async execute(command: ConstructFrameworkWorkflowCommand): Promise<Workflow> {
    if (command.workflowId === LAYOUT_PREVIEW_WORKFLOW_ID) {
      return this.constructLayoutPreviewWorkflow(command);
    }

    const dbWorkflow = await this.getDbWorkflow(command.environmentId, command.workflowId);
    if (command.controlValues) {
      for (const step of dbWorkflow.steps) {
        step.controlVariables = command.controlValues;
      }
    }

    const organization = (await this.communityOrganizationRepository.findById(dbWorkflow._organizationId)) || undefined;

    return this.constructFrameworkWorkflow({
      dbWorkflow,
      organization,
      skipLayoutRendering: command.skipLayoutRendering,
      jobId: command.jobId,
    });
  }

  private async constructLayoutPreviewWorkflow(command: ConstructFrameworkWorkflowCommand): Promise<Workflow> {
    const environment = await this.environmentRepository.findOne({
      _id: command.environmentId,
    });
    if (!environment) {
      throw new InternalServerErrorException(`Environment ${command.environmentId} not found`);
    }

    return workflow(LAYOUT_PREVIEW_WORKFLOW_ID, async ({ step, payload, subscriber, context }) => {
      await step.email(
        LAYOUT_PREVIEW_EMAIL_STEP,
        async (controlValues) => {
          return this.emailOutputRendererUseCase.execute({
            controlValues,
            fullPayloadForRender: { payload, subscriber, context, steps: {} },
            environmentId: environment._id,
            organizationId: environment._organizationId,
            locale: subscriber.locale ?? undefined,
            stepId: LAYOUT_PREVIEW_EMAIL_STEP,
            layoutId: command.layoutId,
          });
        },
        {
          skip: () => false,
          controlSchema: emailControlSchema as unknown as Schema,
          disableOutputSanitization: true,
          providers: {},
        }
      );
    });
  }

  @Instrument()
  private constructFrameworkWorkflow({
    dbWorkflow,
    organization,
    skipLayoutRendering,
    jobId,
  }: {
    dbWorkflow: NotificationTemplateEntity;
    organization?: OrganizationEntity;
    skipLayoutRendering?: boolean;
    jobId?: string;
  }): Workflow {
    return workflow(
      dbWorkflow.triggers[0].identifier,
      async ({ step, payload, subscriber, context }) => {
        const fullPayloadForRender: FullPayloadForRender = {
          workflow: dbWorkflow as unknown as Record<string, unknown>,
          payload,
          subscriber,
          context,
          steps: {},
        };
        for (const staticStep of dbWorkflow.steps) {
          fullPayloadForRender.steps[staticStep.stepId || staticStep._templateId] = await this.constructStep({
            step,
            staticStep,
            fullPayloadForRender,
            dbWorkflow,
            organization,
            locale: subscriber.locale ?? undefined,
            skipLayoutRendering,
            jobId,
          });
        }
      },
      {
        payloadSchema: PERMISSIVE_EMPTY_SCHEMA,
        name: dbWorkflow.name,
        description: dbWorkflow.description,
        tags: dbWorkflow.tags,
        severity: dbWorkflow.severity,

        /*
         * TODO: Workflow options are not needed currently, given that this endpoint
         * focuses on execution only. However we should reconsider if we decide to
         * expose Workflow options to the `workflow` function.
         *
         * preferences: foundWorkflow.preferences,
         * tags: foundWorkflow.tags,
         */
      }
    );
  }

  @Instrument()
  private constructStep({
    step,
    staticStep,
    fullPayloadForRender,
    dbWorkflow,
    organization,
    locale,
    skipLayoutRendering,
    jobId,
  }: {
    step: Step;
    staticStep: NotificationStepEntity;
    fullPayloadForRender: FullPayloadForRender;
    dbWorkflow: NotificationTemplateEntity;
    organization?: OrganizationEntity;
    locale?: string;
    skipLayoutRendering?: boolean;
    jobId?: string;
  }): StepOutput<Record<string, unknown>> {
    const stepTemplate = staticStep.template;

    if (!stepTemplate) {
      throw new InternalServerErrorException(`Step template not found for step ${staticStep.stepId}`);
    }

    const stepType = stepTemplate.type;
    const { stepId } = staticStep;
    if (!stepId) {
      throw new InternalServerErrorException(`Step id not found for step ${staticStep.stepId}`);
    }
    const stepControls = stepTemplate.controls;

    if (!stepControls) {
      throw new InternalServerErrorException(`Step controls not found for step ${staticStep.stepId}`);
    }

    switch (stepType) {
      case StepTypeEnum.IN_APP:
        return step.inApp(
          // The step id is used internally by the framework to identify the step
          stepId,
          // The step callback function. Takes controls and returns the step outputs
          async (controlValues) => {
            return this.inAppOutputRendererUseCase.execute({
              controlValues,
              fullPayloadForRender,
              dbWorkflow,
              organization,
              locale,
            });
          },
          // Step options
          this.constructChannelStepOptions(staticStep, fullPayloadForRender)
        );
      case StepTypeEnum.EMAIL:
        return step.email(
          stepId,
          async (controlValues) => {
            return this.emailOutputRendererUseCase.execute({
              controlValues,
              fullPayloadForRender,
              environmentId: dbWorkflow._environmentId,
              organizationId: dbWorkflow._organizationId,
              workflowId: dbWorkflow._id,
              organization,
              locale,
              skipLayoutRendering,
              jobId,
              stepId,
            });
          },
          this.constructChannelStepOptions(staticStep, fullPayloadForRender)
        );
      case StepTypeEnum.SMS:
        return step.sms(
          stepId,
          async (controlValues) => {
            return this.smsOutputRendererUseCase.execute({
              controlValues,
              fullPayloadForRender,
              dbWorkflow,
              organization,
              locale,
            });
          },
          this.constructChannelStepOptions(staticStep, fullPayloadForRender)
        );
      case StepTypeEnum.CHAT:
        return step.chat(
          stepId,
          async (controlValues) => {
            return this.chatOutputRendererUseCase.execute({
              controlValues,
              fullPayloadForRender,
              dbWorkflow,
              organization,
              locale,
            });
          },
          this.constructChannelStepOptions(staticStep, fullPayloadForRender)
        );
      case StepTypeEnum.PUSH:
        return step.push(
          stepId,
          async (controlValues) => {
            return this.pushOutputRendererUseCase.execute({
              controlValues,
              fullPayloadForRender,
              dbWorkflow,
              organization,
              locale,
            });
          },
          this.constructChannelStepOptions(staticStep, fullPayloadForRender)
        );
      case StepTypeEnum.DIGEST:
        return step.digest(
          stepId,
          async (controlValues) => {
            return this.digestOutputRendererUseCase.execute({ controlValues, fullPayloadForRender });
          },
          this.constructActionStepOptions(staticStep, fullPayloadForRender)
        );
      case StepTypeEnum.DELAY:
        return step.delay(
          stepId,
          async (controlValues) => {
            return this.delayOutputRendererUseCase.execute({ controlValues, fullPayloadForRender });
          },
          this.constructActionStepOptions(staticStep, fullPayloadForRender)
        );
      case StepTypeEnum.THROTTLE:
        return step.throttle(
          stepId,
          async (controlValues) => {
            return this.throttleOutputRendererUseCase.execute({ controlValues, fullPayloadForRender });
          },
          this.constructActionStepOptions(staticStep, fullPayloadForRender)
        );
      default:
        throw new InternalServerErrorException(`Step type ${stepType} is not supported`);
    }
  }

  @Instrument()
  private constructChannelStepOptions(
    staticStep: NotificationStepEntity,
    fullPayloadForRender: FullPayloadForRender
  ): Required<Parameters<ChannelStep>[2]> {
    const skipFunction = (controlValues: Record<string, unknown>) =>
      this.processSkipOption(controlValues, fullPayloadForRender);

    return {
      skip: skipFunction,
      controlSchema: staticStep.template!.controls!.schema as unknown as Schema,
      disableOutputSanitization: true,
      providers: {},
    };
  }

  @Instrument()
  private constructActionStepOptions(
    staticStep: NotificationStepEntity,
    fullPayloadForRender: FullPayloadForRender
  ): Required<Parameters<ActionStep>[2]> {
    const stepType = staticStep.template!.type;
    const controlSchema = this.optionalAugmentControlSchemaDueToAjvBug(staticStep, stepType);

    return {
      controlSchema: controlSchema as unknown as Schema,
      skip: (controlValues: Record<string, unknown>) => this.processSkipOption(controlValues, fullPayloadForRender),
    };
  }

  private optionalAugmentControlSchemaDueToAjvBug(staticStep: NotificationStepEntity, stepType: StepTypeEnum) {
    let controlSchema = staticStep.template!.controls!.schema;

    /*
     * because of the known AJV issue with anyOf, we need to find the first schema that matches the control values
     * ref: https://ajv.js.org/guide/modifying-data.html#assigning-defaults
     */
    if (stepType === StepTypeEnum.DIGEST && typeof controlSchema === 'object' && controlSchema.anyOf) {
      const fistSchemaMatch = controlSchema.anyOf.find((item) => {
        return isMatchingJsonSchema(item, staticStep.controlVariables);
      });
      controlSchema = fistSchemaMatch ?? controlSchema.anyOf[0];
    }

    return controlSchema;
  }

  @Instrument()
  private async getDbWorkflow(environmentId: string, workflowId: string): Promise<NotificationTemplateEntity> {
    const foundWorkflow = await this.workflowsRepository.findByTriggerIdentifier(environmentId, workflowId);

    if (!foundWorkflow) {
      throw new InternalServerErrorException(`Workflow ${workflowId} not found`);
    }

    return foundWorkflow;
  }

  private async processSkipOption(
    controlValues: { [x: string]: unknown },
    variables: FullPayloadForRender
  ): Promise<boolean> {
    const skipRules = controlValues.skip as RulesLogic<AdditionalOperation>;

    if (_.isEmpty(skipRules)) {
      return false;
    }

    const { result, error } = evaluateRules(skipRules, {
      ...variables,
      subscriber: {
        ...variables.subscriber,
        isOnline: variables.subscriber.isOnline ?? false,
      },
    });

    if (error) {
      this.logger.error({ err: error }, 'Failed to evaluate skip rule', LOG_CONTEXT);
    }

    // The Step Conditions in the Dashboard control the step execution, that's why we need to invert the result.
    return !result;
  }
}

const PERMISSIVE_EMPTY_SCHEMA = {
  type: 'object',
  properties: {},
  required: [],
  additionalProperties: true,
} as const;


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - environment(await this.environmentRepository.findOne({
      _id: command.environmentId,
    });
    if (!enviro...)
 - stepControls(stepTemplate.controls;

    if (!stepControls) {
      throw new InternalServerErrorException(`Step ...)
 - skipFunction(controlValues: Record<string, unknown>))
 - controlSchema(this.optionalAugmentControlSchemaDueToAjvBug(staticStep, stepType);

    return {
      controlSchem...)
 - fistSchemaMatch(controlSchema.anyOf.find((item))
Declaraciones 'export' encontradas:
- export class ConstructFrameworkWorkflow

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/construct-framework-workflow/index.ts
Tamao: 112 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './construct-framework-workflow.command';
export * from './construct-framework-workflow.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/create-environment/create-environment.command.ts
Tamao: 664 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentTypeEnum } from '@novu/shared';
import { IsBoolean, IsDefined, IsEnum, IsHexColor, IsMongoId, IsOptional, IsString } from 'class-validator';
import { OrganizationCommand } from '../../../shared/commands/organization.command';

export class CreateEnvironmentCommand extends OrganizationCommand {
  @IsDefined()
  @IsString()
  name: string;

  @IsOptional()
  @IsMongoId()
  parentEnvironmentId?: string;

  @IsOptional()
  @IsHexColor()
  color?: string;

  @IsOptional()
  @IsEnum(EnvironmentTypeEnum)
  type?: EnvironmentTypeEnum;

  @IsBoolean()
  @IsDefined()
  system: boolean;

  @IsBoolean()
  @IsOptional()
  returnApiKeys?: boolean;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class CreateEnvironmentCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/create-environment/create-environment.e2e.ts
Tamao: 5795 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentRepository } from '@novu/dal';
import { ApiServiceLevelEnum, EnvironmentTypeEnum, FeatureFlagsKeysEnum, NOVU_ENCRYPTION_SUB_MASK } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

async function createEnv(name: string, session) {
  const demoEnvironment = {
    name,
    color: '#3A7F5C',
  };
  const { body } = await session.testAgent.post('/v1/environments').send(demoEnvironment);

  return { demoEnvironment, body };
}

describe('Create Environment - /environments (POST)', async () => {
  let session: UserSession;
  const environmentRepository = new EnvironmentRepository();
  before(async () => {
    session = new UserSession();
    await session.initialize({
      noEnvironment: true,
    });
    session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);
  });

  it('should create environment entity correctly', async () => {
    const demoEnvironment = {
      name: 'Hello App',
      color: '#3A7F5C',
    };
    const { body } = await session.testAgent.post('/v1/environments').send(demoEnvironment).expect(201);

    expect(body.data.name).to.eq(demoEnvironment.name);
    expect(body.data._organizationId).to.eq(session.organization._id);
    expect(body.data.identifier).to.be.ok;
    const dbApp = await environmentRepository.findOne({ _id: body.data._id });

    if (!dbApp) {
      expect(dbApp).to.be.ok;
      throw new Error('App not found');
    }

    expect(dbApp.apiKeys.length).to.equal(1);
    expect(dbApp.apiKeys[0].key).to.be.ok;
    expect(dbApp.apiKeys[0].key).to.contains(NOVU_ENCRYPTION_SUB_MASK);
    expect(dbApp.apiKeys[0]._userId).to.equal(session.user._id);
  });

  it('should create environment with correct default type', async () => {
    const demoEnvironment = {
      name: 'Test Environment',
      color: '#3A7F5C',
    };
    const { body } = await session.testAgent.post('/v1/environments').send(demoEnvironment).expect(201);

    expect(body.data.name).to.eq(demoEnvironment.name);
    expect(body.data.type).to.eq(EnvironmentTypeEnum.PROD);

    const dbApp = await environmentRepository.findOne({ _id: body.data._id });
    expect(dbApp?.type).to.equal(EnvironmentTypeEnum.PROD);
  });

  it('should create Development environment with DEV type', async () => {
    const demoEnvironment = {
      name: 'Development',
      color: '#3A7F5C',
    };
    const { body } = await session.testAgent.post('/v1/environments').send(demoEnvironment).expect(201);

    expect(body.data.name).to.eq(demoEnvironment.name);
    expect(body.data.type).to.eq(EnvironmentTypeEnum.DEV);

    const dbApp = await environmentRepository.findOne({ _id: body.data._id });
    expect(dbApp?.type).to.equal(EnvironmentTypeEnum.DEV);
  });

  it('should create Production environment with PROD type', async () => {
    const demoEnvironment = {
      name: 'Production',
      color: '#3A7F5C',
    };
    const { body } = await session.testAgent.post('/v1/environments').send(demoEnvironment).expect(201);

    expect(body.data.name).to.eq(demoEnvironment.name);
    expect(body.data.type).to.eq(EnvironmentTypeEnum.PROD);

    const dbApp = await environmentRepository.findOne({ _id: body.data._id });
    expect(dbApp?.type).to.equal(EnvironmentTypeEnum.PROD);
  });

  it('should default custom environments to PROD type', async () => {
    const demoEnvironment = {
      name: 'Staging Environment',
      color: '#3A7F5C',
    };
    const { body } = await session.testAgent.post('/v1/environments').send(demoEnvironment).expect(201);

    expect(body.data.name).to.eq(demoEnvironment.name);
    expect(body.data.type).to.eq(EnvironmentTypeEnum.PROD);

    const dbApp = await environmentRepository.findOne({ _id: body.data._id });
    expect(dbApp?.type).to.equal(EnvironmentTypeEnum.PROD);
  });

  it('should apply default type to existing environments without type field', async () => {
    // Create an environment and manually remove the type field to simulate old data
    const demoEnvironment = {
      name: 'Legacy Environment',
      color: '#3A7F5C',
    };
    const { body } = await session.testAgent.post('/v1/environments').send(demoEnvironment).expect(201);

    // Manually remove the type field to simulate legacy data
    await environmentRepository.update({ _id: body.data._id }, { $unset: { type: 1 } });

    // Fetch the environment - should have default type applied
    const fetchedEnv = await environmentRepository.findOne({ _id: body.data._id });
    expect(fetchedEnv?.type).to.equal(EnvironmentTypeEnum.PROD);
  });

  it('should fail when no name provided', async () => {
    const demoEnvironment = {};
    const { body } = await session.testAgent.post('/v1/environments').send(demoEnvironment).expect(400);

    expect(body.message[0]).to.contain('name should not be null');
  });

  it('should create a default layout for environment', async () => {
    const demoEnvironment = {
      name: 'Hello App',
    };
    const { body } = await session.testAgent.post('/v1/environments').send(demoEnvironment).expect(201);
    session.environment = body.data;

    await session.fetchJWT();
    const { body: layouts } = await session.testAgent.get('/v1/layouts');

    expect(layouts.data.length).to.equal(1);
    expect(layouts.data[0].isDefault).to.equal(true);
    expect(layouts.data[0].content.length).to.be.greaterThan(20);
  });

  it('should not set apiRateLimits field on environment by default', async () => {
    const demoEnvironment = {
      name: 'Hello App',
    };
    const { body } = await session.testAgent.post('/v1/environments').send(demoEnvironment).expect(201);
    const dbEnvironment = await environmentRepository.findOne({ _id: body.data._id });

    expect(dbEnvironment?.apiRateLimits).to.be.undefined;
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - createEnv(name: string, session)
Asignaciones con arrow functions encontradas (posibles funciones):
 - environmentRepository(new EnvironmentRepository();
  before(async ())
 - session(new UserSession();
    await session.initialize({
      noEnvironment: true,
    });
    session.upd...)
 - dbApp(await environmentRepository.findOne({ _id: body.data._id });

    if (!dbApp) {
      expect(dbApp)....)
 - dbApp(await environmentRepository.findOne({ _id: body.data._id });
    expect(dbApp?.type).to.equal(Enviro...)
 - dbApp(await environmentRepository.findOne({ _id: body.data._id });
    expect(dbApp?.type).to.equal(Enviro...)
 - dbApp(await environmentRepository.findOne({ _id: body.data._id });
    expect(dbApp?.type).to.equal(Enviro...)
 - dbApp(await environmentRepository.findOne({ _id: body.data._id });
    expect(dbApp?.type).to.equal(Enviro...)
 - fetchedEnv(await environmentRepository.findOne({ _id: body.data._id });
    expect(fetchedEnv?.type).to.equal(E...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/create-environment/create-environment.usecase.ts
Tamao: 6333 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, UnprocessableEntityException } from '@nestjs/common';
import { encryptApiKey, FeatureFlagsService, SYSTEM_LIMITS } from '@novu/application-generic';
import { EnvironmentEntity, EnvironmentRepository, NotificationGroupRepository } from '@novu/dal';
import { EnvironmentEnum, EnvironmentTypeEnum, FeatureFlagsKeysEnum, PROTECTED_ENVIRONMENTS } from '@novu/shared';
import { createHash } from 'crypto';
import { nanoid } from 'nanoid';
import { CreateNovuIntegrationsCommand } from '../../../integrations/usecases/create-novu-integrations/create-novu-integrations.command';
import { CreateNovuIntegrations } from '../../../integrations/usecases/create-novu-integrations/create-novu-integrations.usecase';
import { CreateDefaultLayout, CreateDefaultLayoutCommand } from '../../../layouts-v1/usecases';
import { EnvironmentResponseDto } from '../../dtos/environment-response.dto';
import { GenerateUniqueApiKey } from '../generate-unique-api-key/generate-unique-api-key.usecase';
import { CreateEnvironmentCommand } from './create-environment.command';

@Injectable()
export class CreateEnvironment {
  constructor(
    private environmentRepository: EnvironmentRepository,
    private notificationGroupRepository: NotificationGroupRepository,
    private generateUniqueApiKey: GenerateUniqueApiKey,
    private createDefaultLayoutUsecase: CreateDefaultLayout,
    private createNovuIntegrationsUsecase: CreateNovuIntegrations,
    private featureFlagsService: FeatureFlagsService
  ) {}

  async execute(command: CreateEnvironmentCommand): Promise<EnvironmentResponseDto> {
    if (command.returnApiKeys === undefined) {
      command.returnApiKeys = command.system === true;
    }

    const environmentCount = await this.environmentRepository.count({
      _organizationId: command.organizationId,
    });

    const maxEnvironmentCount = await this.getMaxEnvironmentCount(command.organizationId);
    if (environmentCount >= maxEnvironmentCount) {
      throw new BadRequestException(`Organization cannot have more than ${maxEnvironmentCount} environments`);
    }
    const normalizedName = command.name.trim();

    if (!command.system) {
      const { name } = command;

      if (PROTECTED_ENVIRONMENTS?.map((env) => env.toLowerCase()).includes(normalizedName.toLowerCase())) {
        throw new UnprocessableEntityException('Environment name cannot be Development or Production');
      }

      const environment = await this.environmentRepository.findOne({
        _organizationId: command.organizationId,
        name,
      });

      if (environment) {
        throw new BadRequestException('Environment name must be unique');
      }
    }

    const key = await this.generateUniqueApiKey.execute();
    const encryptedApiKey = encryptApiKey(key);
    const hashedApiKey = createHash('sha256').update(key).digest('hex');
    const color = this.getEnvironmentColor(command.name, command.color);

    if (!color) {
      throw new BadRequestException('Color property is required');
    }

    const type = await this.getEnvironmentType(command.name, command.type);

    const environment = await this.environmentRepository.create({
      _organizationId: command.organizationId,
      name: normalizedName,
      identifier: nanoid(12),
      _parentId: command.parentEnvironmentId,
      color,
      type,
      apiKeys: [
        {
          key: encryptedApiKey,
          _userId: command.userId,
          hash: hashedApiKey,
        },
      ],
    });

    if (!command.parentEnvironmentId) {
      await this.notificationGroupRepository.create({
        _environmentId: environment._id,
        _organizationId: command.organizationId,
        name: 'General',
      });

      await this.createDefaultLayoutUsecase.execute(
        CreateDefaultLayoutCommand.create({
          organizationId: command.organizationId,
          environmentId: environment._id,
          userId: command.userId,
        })
      );
    }

    if (command.parentEnvironmentId) {
      const group = await this.notificationGroupRepository.findOne({
        _organizationId: command.organizationId,
        _environmentId: command.parentEnvironmentId,
      });

      await this.notificationGroupRepository.create({
        _environmentId: environment._id,
        _organizationId: command.organizationId,
        name: group?.name,
        _parentId: group?._id,
      });
    }

    await this.createNovuIntegrationsUsecase.execute(
      CreateNovuIntegrationsCommand.create({
        environmentId: environment._id,
        organizationId: environment._organizationId,
        userId: command.userId,
        name: environment.name,
      })
    );

    return this.convertEnvironmentEntityToDto(environment, command.returnApiKeys);
  }

  private convertEnvironmentEntityToDto(environment: EnvironmentEntity, returnApiKeys: boolean) {
    const dto = new EnvironmentResponseDto();

    dto._id = environment._id;
    dto.name = environment.name;
    dto._organizationId = environment._organizationId;
    dto.identifier = environment.identifier;
    dto._parentId = environment._parentId;
    dto.type = environment.type;

    if (environment.apiKeys && environment.apiKeys.length > 0 && returnApiKeys) {
      dto.apiKeys = environment.apiKeys.map((apiKey) => ({
        key: apiKey.key,
        hash: apiKey.hash,
        _userId: apiKey._userId,
      }));
    }

    return dto;
  }

  private getEnvironmentColor(name: string, commandColor?: string): string | undefined {
    if (name === EnvironmentEnum.DEVELOPMENT) return '#ff8547';
    if (name === EnvironmentEnum.PRODUCTION) return '#7e52f4';

    return commandColor;
  }

  private async getEnvironmentType(name: string, commandType?: EnvironmentTypeEnum): Promise<EnvironmentTypeEnum> {
    if (commandType) return commandType;

    if (name === EnvironmentEnum.DEVELOPMENT) return EnvironmentTypeEnum.DEV;
    if (name === EnvironmentEnum.PRODUCTION) return EnvironmentTypeEnum.PROD;

    return EnvironmentTypeEnum.PROD;
  }

  private async getMaxEnvironmentCount(organizationId: string): Promise<number> {
    return await this.featureFlagsService.getFlag({
      key: FeatureFlagsKeysEnum.MAX_ENVIRONMENT_COUNT,
      organization: { _id: organizationId },
      defaultValue: SYSTEM_LIMITS.ENVIRONMENTS,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - apiKeys(environment.apiKeys.map((apiKey))
Declaraciones 'export' encontradas:
- export class CreateEnvironment

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/delete-environment/delete-environment.command.ts
Tamao: 164 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class DeleteEnvironmentCommand extends EnvironmentWithUserCommand {}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class DeleteEnvironmentCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/delete-environment/delete-environment.usecase.ts
Tamao: 2012 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { EnvironmentRepository, IntegrationRepository } from '@novu/dal';
import { EnvironmentEnum, PROTECTED_ENVIRONMENTS } from '@novu/shared';
import { RemoveIntegrationCommand } from '../../../integrations/usecases/remove-integration/remove-integration.command';
import { RemoveIntegration } from '../../../integrations/usecases/remove-integration/remove-integration.usecase';
import { DeleteEnvironmentCommand } from './delete-environment.command';

@Injectable()
export class DeleteEnvironment {
  constructor(
    private environmentRepository: EnvironmentRepository,
    private removeIntegration: RemoveIntegration,
    private integrationRepository: IntegrationRepository
  ) {}

  async execute(command: DeleteEnvironmentCommand): Promise<void> {
    const environment = await this.environmentRepository.findOne({
      _id: command.environmentId,
      _organizationId: command.organizationId,
    });

    if (!environment) {
      throw new NotFoundException(`Environment ${command.environmentId} not found`);
    }

    if (PROTECTED_ENVIRONMENTS.includes(environment.name as EnvironmentEnum)) {
      throw new BadRequestException(
        `The ${environment.name} environment is protected and cannot be deleted. Only custom environments can be deleted.`
      );
    }

    await this.environmentRepository.delete({
      _id: command.environmentId,
      _organizationId: command.organizationId,
    });

    const integrations = await this.integrationRepository.find({
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
    });

    for (const integration of integrations) {
      await this.removeIntegration.execute(
        RemoveIntegrationCommand.create({
          organizationId: command.organizationId,
          integrationId: integration._id,
          userId: command.userId,
          environmentId: command.environmentId,
        })
      );
    }
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class DeleteEnvironment

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/delete-environment/index.ts
Tamao: 92 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './delete-environment.command';
export * from './delete-environment.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/generate-unique-api-key/generate-unique-api-key.spec.ts
Tamao: 2505 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InternalServerErrorException } from '@nestjs/common';
import { EnvironmentRepository } from '@novu/dal';
import { expect } from 'chai';
import sinon from 'sinon';

import { GenerateUniqueApiKey } from './generate-unique-api-key.usecase';

const environmentRepository = new EnvironmentRepository();
const generateUniqueApiKey = new GenerateUniqueApiKey(environmentRepository);

let generateApiKeyStub;
let findByApiKeyStub;
describe('Generate Unique Api Key', () => {
  beforeEach(() => {
    findByApiKeyStub = sinon.stub(environmentRepository, 'findByApiKey');
    generateApiKeyStub = sinon.stub(generateUniqueApiKey, 'generateApiKey' as any);
  });

  afterEach(() => {
    findByApiKeyStub.restore();
    generateApiKeyStub.restore();
  });

  it('should generate an API key for the environment without any clashing', async () => {
    const expectedApiKey = 'expected-api-key';
    generateApiKeyStub.onFirstCall().returns(expectedApiKey);

    const apiKey = await generateUniqueApiKey.execute();

    expect(typeof apiKey).to.be.string;
    expect(apiKey).to.be.equal(expectedApiKey);
  });

  it('should generate a different valid API key after first one clashes with an existing one', async () => {
    const clashingApiKey = 'clashing-api-key';
    const expectedApiKey = 'expected-api-key';
    generateApiKeyStub.onFirstCall().returns(clashingApiKey);
    generateApiKeyStub.onSecondCall().returns(expectedApiKey);
    findByApiKeyStub.onFirstCall().returns({ key: clashingApiKey });
    findByApiKeyStub.onSecondCall().returns(undefined);

    const apiKey = await generateUniqueApiKey.execute();
    expect(typeof apiKey).to.be.string;
    expect(apiKey).to.be.equal(expectedApiKey);
  });

  it('should throw an error if the generation clashes 3 times', async () => {
    const clashingApiKey = 'clashing-api-key';
    generateApiKeyStub.onFirstCall().returns(clashingApiKey);
    generateApiKeyStub.onSecondCall().returns(clashingApiKey);
    generateApiKeyStub.onThirdCall().returns(clashingApiKey);
    findByApiKeyStub.onFirstCall().returns({ key: clashingApiKey });
    findByApiKeyStub.onSecondCall().returns({ key: clashingApiKey });
    findByApiKeyStub.onThirdCall().returns({ key: clashingApiKey });

    try {
      await generateUniqueApiKey.execute();
      throw new Error('Should not reach here');
    } catch (e) {
      expect(e).to.be.instanceOf(InternalServerErrorException);
      expect(e.message).to.eql('Clashing of the API key generation');
    }
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - generateUniqueApiKey(new GenerateUniqueApiKey(environmentRepository);

let generateApiKeyStub;
let findByApiKeyStub;
desc...)
 - generateApiKeyStub(sinon.stub(generateUniqueApiKey, 'generateApiKey' as any);
  });

  afterEach(())
 - apiKey(await generateUniqueApiKey.execute();

    expect(typeof apiKey).to.be.string;
    expect(apiKey).to...)
 - apiKey(await generateUniqueApiKey.execute();
    expect(typeof apiKey).to.be.string;
    expect(apiKey).to....)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/generate-unique-api-key/generate-unique-api-key.usecase.ts
Tamao: 1208 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { EnvironmentRepository } from '@novu/dal';
import { createHash, randomBytes } from 'crypto';

const API_KEY_GENERATION_MAX_RETRIES = 3;

@Injectable()
export class GenerateUniqueApiKey {
  constructor(private environmentRepository: EnvironmentRepository) {}

  async execute(): Promise<string> {
    let apiKey = '';
    let count = 0;
    let isApiKeyUsed = true;
    while (isApiKeyUsed) {
      apiKey = this.generateApiKey();
      isApiKeyUsed = await this.validateIsApiKeyUsed(apiKey);
      count += 1;

      if (count === API_KEY_GENERATION_MAX_RETRIES) {
        const errorMessage = 'Clashing of the API key generation';
        throw new InternalServerErrorException(new Error(errorMessage), errorMessage);
      }
    }

    return apiKey as string;
  }

  private async validateIsApiKeyUsed(apiKey: string) {
    const hashedApiKey = createHash('sha256').update(apiKey).digest('hex');

    const environment = await this.environmentRepository.findByApiKey({
      hash: hashedApiKey,
    });

    return !!environment;
  }

  private generateApiKey(): string {
    return randomBytes(16).toString('hex');
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GenerateUniqueApiKey

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/get-api-keys/get-api-keys.command.ts
Tamao: 157 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetApiKeysCommand extends EnvironmentWithUserCommand {}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetApiKeysCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/get-api-keys/get-api-keys.usecase.ts
Tamao: 697 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { decryptApiKey } from '@novu/application-generic';
import { EnvironmentRepository, IApiKey } from '@novu/dal';
import { ApiKey } from '../../../shared/dtos/api-key';
import { GetApiKeysCommand } from './get-api-keys.command';

@Injectable()
export class GetApiKeys {
  constructor(private environmentRepository: EnvironmentRepository) {}

  async execute(command: GetApiKeysCommand): Promise<ApiKey[]> {
    const keys = await this.environmentRepository.getApiKeys(command.environmentId);

    return keys.map((apiKey: IApiKey) => {
      return {
        key: decryptApiKey(apiKey.key),
        _userId: apiKey._userId,
      };
    });
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - keys(await this.environmentRepository.getApiKeys(command.environmentId);

    return keys.map((apiKey: IA...)
Declaraciones 'export' encontradas:
- export class GetApiKeys

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/get-environment/get-environment.command.ts
Tamao: 161 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetEnvironmentCommand extends EnvironmentWithUserCommand {}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetEnvironmentCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/get-environment/get-environment.e2e.ts
Tamao: 673 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get Environment - /environments/me (GET)', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should return correct environment to user', async () => {
    const { body } = await session.testAgent.get('/v1/environments/me');

    expect(body.data.name).to.eq(session.environment.name);
    expect(body.data._organizationId).to.eq(session.organization._id);
    expect(body.data.identifier).to.equal(session.environment.identifier);
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should return correct environment to...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/get-environment/get-environment.usecase.ts
Tamao: 848 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';

import { EnvironmentEntity, EnvironmentRepository } from '@novu/dal';
import { EnvironmentResponseDto } from '../../dtos/environment-response.dto';
import { GetEnvironmentCommand } from './get-environment.command';

@Injectable()
export class GetEnvironment {
  constructor(private environmentRepository: EnvironmentRepository) {}

  async execute(command: GetEnvironmentCommand): Promise<EnvironmentResponseDto> {
    const environment: Omit<EnvironmentEntity, 'apiKeys'> | null = await this.environmentRepository.findOne(
      {
        _id: command.environmentId,
        _organizationId: command.organizationId,
      },
      '-apiKeys'
    );

    if (!environment) throw new NotFoundException(`Environment ${command.environmentId} not found`);

    return environment;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetEnvironment

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/get-environment/index.ts
Tamao: 86 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-environment.command';
export * from './get-environment.usecase';


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/get-my-environments/get-my-environments.command.ts
Tamao: 376 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsNotEmpty, IsOptional } from 'class-validator';

export class GetMyEnvironmentsCommand extends BaseCommand {
  @IsNotEmpty()
  readonly organizationId: string;

  @IsOptional()
  readonly environmentId: string;

  @IsOptional()
  readonly returnApiKeys: boolean;

  @IsOptional()
  readonly userId: string;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class GetMyEnvironmentsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/get-my-environments/get-my-environments.e2e.ts
Tamao: 884 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NOVU_ENCRYPTION_SUB_MASK } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get My Environments - /environments (GET)', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should return all environments to user including API Keys when JWT auth is used', async () => {
    const { body } = await session.testAgent.get('/v1/environments');

    expect(body.data.length).to.be.greaterThanOrEqual(2);
    for (const elem of body.data) {
      expect(elem._organizationId).to.eq(session.organization._id);

      expect(elem.apiKeys.length).to.be.greaterThanOrEqual(1);
      expect(elem.apiKeys[0].key).to.not.contains(NOVU_ENCRYPTION_SUB_MASK);
      expect(elem.apiKeys[0]._userId).to.equal(session.user._id);
    }
  });
});


### ANALISIS AUTOMATICO (ESPAOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should return all environments to us...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/get-my-environments/get-my-environments.usecase.ts
Tamao: 2016 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException, Scope } from '@nestjs/common';
import { decryptApiKey, PinoLogger } from '@novu/application-generic';
import { EnvironmentEntity, EnvironmentRepository } from '@novu/dal';
import { EnvironmentEnum, ShortIsPrefixEnum } from '@novu/shared';
import { buildSlug } from '../../../shared/helpers/build-slug';
import { EnvironmentResponseDto } from '../../dtos/environment-response.dto';
import { GetMyEnvironmentsCommand } from './get-my-environments.command';

@Injectable({
  scope: Scope.REQUEST,
})
export class GetMyEnvironments {
  constructor(
    private environmentRepository: EnvironmentRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: GetMyEnvironmentsCommand): Promise<EnvironmentResponseDto[]> {
    this.logger.trace('Getting Environments');

    const environments = await this.environmentRepository.findOrganizationEnvironments(command.organizationId);

    if (!environments?.length) {
      throw new NotFoundException(`No environments were found for organization ${command.organizationId}`);
    }

    return environments.map((environment) => {
      const processedEnvironment = { ...environment };

      processedEnvironment.apiKeys = command.returnApiKeys ? this.decryptApiKeys(environment.apiKeys) : [];

      const shortEnvName = shortenEnvironmentName(processedEnvironment.name);

      return {
        ...processedEnvironment,
        slug: buildSlug(shortEnvName, ShortIsPrefixEnum.ENVIRONMENT, processedEnvironment._id),
      };
    });
  }

  private decryptApiKeys(apiKeys: EnvironmentEntity['apiKeys']) {
    return apiKeys.map((apiKey) => ({
      ...apiKey,
      key: decryptApiKey(apiKey.key),
    }));
  }
}

function shortenEnvironmentName(name: string): string {
  const mapToShotEnvName: Record<EnvironmentEnum, string> = {
    [EnvironmentEnum.PRODUCTION]: 'prod',
    [EnvironmentEnum.DEVELOPMENT]: 'dev',
  };

  return mapToShotEnvName[name] || name;
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Funciones 'function' encontradas:
 - shortenEnvironmentName(name: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - environments(await this.environmentRepository.findOrganizationEnvironments(command.organizationId);

    if (!env...)
 - shortEnvName(shortenEnvironmentName(processedEnvironment.name);

      return {
        ...processedEnvironment,
...)
Declaraciones 'export' encontradas:
- export class GetMyEnvironments

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/output-renderers/base-translation-renderer.usecase.ts
Tamao: 4744 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { LayoutDto, PinoLogger } from '@novu/application-generic';
import { LocalizationResourceEnum, NotificationTemplateEntity, OrganizationEntity } from '@novu/dal';
import { createLiquidEngine } from '@novu/framework/internal';
import { FullPayloadForRender } from './render-command';

@Injectable()
export abstract class BaseTranslationRendererUsecase {
  constructor(
    protected moduleRef: ModuleRef,
    protected logger: PinoLogger
  ) {}

  protected async processTranslations({
    controls,
    variables,
    environmentId,
    organizationId,
    resourceId,
    resourceType,
    locale,
    resourceEntity,
    organization,
  }: {
    controls: Record<string, unknown>;
    variables: FullPayloadForRender;
    environmentId: string;
    organizationId: string;
    resourceId?: string;
    resourceType?: LocalizationResourceEnum;
    locale?: string;
    resourceEntity?: NotificationTemplateEntity | LayoutDto;
    organization?: OrganizationEntity;
  }): Promise<Record<string, unknown>> {
    if (process.env.NOVU_ENTERPRISE !== 'true') {
      return controls;
    }

    return this.executeTranslation({
      content: controls,
      variables,
      environmentId,
      organizationId,
      resourceId,
      resourceType,
      locale,
      resourceEntity,
      organization,
    }) as Promise<Record<string, unknown>>;
  }

  protected async processStringTranslations({
    content,
    variables,
    environmentId,
    organizationId,
    resourceId,
    resourceType,
    locale,
    organization,
  }: {
    content: string;
    variables: FullPayloadForRender;
    environmentId: string;
    organizationId: string;
    resourceId?: string;
    resourceType?: LocalizationResourceEnum;
    locale?: string;
    organization?: OrganizationEntity;
  }): Promise<string> {
    if (process.env.NOVU_ENTERPRISE !== 'true') {
      return content;
    }

    return this.executeTranslation({
      content,
      variables,
      environmentId,
      organizationId,
      resourceId,
      resourceType,
      locale,
      organization,
    }) as Promise<string>;
  }

  private async executeTranslation({
    content,
    variables,
    environmentId,
    organizationId,
    resourceId,
    resourceType,
    locale,
    resourceEntity,
    organization,
  }: {
    content: string | Record<string, unknown>;
    variables: FullPayloadForRender;
    environmentId: string;
    organizationId: string;
    resourceId?: string;
    resourceType?: LocalizationResourceEnum;
    locale?: string;
    resourceEntity?: NotificationTemplateEntity | LayoutDto;
    organization?: OrganizationEntity;
  }): Promise<string | Record<string, unknown>> {
    if (!resourceId) {
      this.logger.warn('Resource ID is required for translation module', {
        resourceId,
        resourceType,
        organizationId,
        environmentId,
        locale,
      });

      return content;
    }

    try {
      const translate = this.getTranslationModule();

      const contentString = typeof content === 'string' ? content : JSON.stringify(content);
      const liquidEngine = createLiquidEngine();

      const translatedContent = await translate.execute({
        resourceId,
        resourceType,
        organizationId,
        environmentId,
        userId: 'system',
        locale,
        content: contentString,
        payload: variables,
        liquidEngine,
        resourceEntity,
        organization,
      });

      return typeof content === 'string' ? translatedContent : JSON.parse(translatedContent);
    } catch (error) {
      this.logger.error('Translation processing failed', {
        error: error?.message || error,
        resourceId,
        resourceType,
        organizationId,
        environmentId,
        locale,
        stack: error?.stack,
      });

      throw new InternalServerErrorException(
        `Translation processing failed for resource ${resourceId}: ${error?.message || String(error)}`
      );
    }
  }

  private getTranslationModule() {
    try {
      const translationModule = require('@novu/ee-translation')?.Translate;
      if (!translationModule) {
        throw new Error('Translation module (@novu/ee-translation) not found or Translate class not exported');
      }

      return this.moduleRef.get(translationModule, { strict: false });
    } catch (error) {
      this.logger.error('Translation module loading failed', {
        error: error?.message || error,
        stack: error?.stack,
      });

      throw new InternalServerErrorException(`Unable to load Translation module: ${error?.message || String(error)}`);
    }
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export  abstract

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/output-renderers/chat-output-renderer.usecase.ts
Tamao: 1548 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { InstrumentUsecase, PinoLogger } from '@novu/application-generic';
import { LocalizationResourceEnum, NotificationTemplateEntity } from '@novu/dal';
import { ChatRenderOutput } from '@novu/shared';
import { BaseTranslationRendererUsecase } from './base-translation-renderer.usecase';
import { RenderCommand } from './render-command';

export class ChatOutputRendererCommand extends RenderCommand {
  dbWorkflow: NotificationTemplateEntity;
  locale?: string;
}

@Injectable()
export class ChatOutputRendererUsecase extends BaseTranslationRendererUsecase {
  constructor(
    protected moduleRef: ModuleRef,
    protected logger: PinoLogger
  ) {
    super(moduleRef, logger);
  }

  @InstrumentUsecase()
  async execute(renderCommand: ChatOutputRendererCommand): Promise<ChatRenderOutput> {
    const { skip, ...outputControls } = renderCommand.controlValues ?? {};
    const { _environmentId, _organizationId, _id: workflowId } = renderCommand.dbWorkflow;

    const translatedControls = await this.processTranslations({
      controls: outputControls,
      variables: renderCommand.fullPayloadForRender,
      environmentId: _environmentId,
      organizationId: _organizationId,
      resourceId: workflowId,
      resourceType: LocalizationResourceEnum.WORKFLOW,
      locale: renderCommand.locale,
      resourceEntity: renderCommand.dbWorkflow,
      organization: renderCommand.organization,
    });

    return translatedControls as any;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class ChatOutputRendererCommand
- export class ChatOutputRendererUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/output-renderers/delay-output-renderer.usecase.ts
Tamao: 465 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { DelayRenderOutput } from '@novu/shared';
import { RenderCommand } from './render-command';

@Injectable()
export class DelayOutputRendererUsecase {
  @InstrumentUsecase()
  execute(renderCommand: RenderCommand): DelayRenderOutput {
    const { skip, ...outputControls } = renderCommand.controlValues ?? {};

    return outputControls as any;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class DelayOutputRendererUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/output-renderers/digest-output-renderer.usecase.ts
Tamao: 498 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { DigestRenderOutput } from '@novu/shared';
import { RenderCommand } from './render-command';

@Injectable()
export class DigestOutputRendererUsecase {
  @InstrumentUsecase()
  execute(renderCommand: RenderCommand): DigestRenderOutput {
    const { skip, ...outputControls } = renderCommand.controlValues ?? {};

    return outputControls as any;
  }
}


### ANALISIS AUTOMATICO (ESPAOL) ###

Declaraciones 'export' encontradas:
- export class DigestOutputRendererUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIN ###

- Revisa package.json para dependencias y scripts.
- Usa mdulos (import/export) y prueba con node o bundler.
- Aade un README con pasos de instalacin (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/environments-v1/usecases/output-renderers/email-output-renderer.spec.ts
Tamao: 86087 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { JSONContent as MailyJSONContent } from '@maily-to/render';
import { ModuleRef } from '@nestjs/core';
import { CreateExecutionDetails, DetailEnum, FeatureFlagsService, PinoLogger } from '@novu/application-generic';
import { ControlValuesRepository, JobEntity, JobRepository } from '@novu/dal';
import {
  ControlValuesLevelEnum,
  ExecutionDetailsSourceEnum,
  ExecutionDetailsStatusEnum,
  JobStatusEnum,
  LAYOUT_CONTENT_VARIABLE,
  StepTypeEnum,
} from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { GetLayoutUseCase } from '../../../layouts-v2/usecases/get-layout';
import { GetOrganizationSettings } from '../../../organization/usecases/get-organization-settings/get-organization-settings.usecase';
import { EmailOutputRendererCommand, EmailOutputRendererUsecase } from './email-output-renderer.usecase';
import { FullPayloadForRender } from './render-command';

/**
 * Sets up mocks for the enterprise translation module
 * Returns the translation stub for further customization if needed
 */
function setupTranslationMocks(moduleRef: sinon.SinonStubbedInstance<ModuleRef>): sinon.SinonStub {
  const eeTranslation = require('@novu/ee-translation');
  if (!eeTranslation) {
    throw new Error('ee-translation does not exist');
  }

  const { Translate } = eeTranslation;

  // Create translation service stub that returns original content (no translation applied)
  const translateStub = sinon.stub(Translate.prototype, 'execute').callsFake(async (command: any) => {
    return command.content || '';
  });

  const mockLogger = {
    setContext: sinon.stub(),
  };

  // Mock moduleRef.get to return the Translate class when requested
  (moduleRef as any).get = sinon.stub().callsFake((token) => {
    if (token === Translate) {
      return new Translate({} as any, {} as any, mockLogger as any, {} as any);
    }
    return null;
  });

  return translateStub;
}

describe('EmailOutputRendererUsecase', () => {
  let moduleRef: sinon.SinonStubbedInstance<ModuleRef>;
  let getOrganizationSettingsMock: sinon.SinonStubbedInstance<GetOrganizationSettings>;
  let pinoLoggerMock: sinon.SinonStubbedInstance<PinoLogger>;
  let controlValuesRepositoryMock: sinon.SinonStubbedInstance<ControlValuesRepository>;
  let getLayoutUseCase: sinon.SinonStubbedInstance<GetLayoutUseCase>;
  let jobRepositoryMock: sinon.SinonStubbedInstance<JobRepository>;
  let createExecutionDetailsMock: sinon.SinonStubbedInstance<CreateExecutionDetails>;
  let emailOutputRendererUsecase: EmailOutputRendererUsecase;
  let translateStub: sinon.SinonStub;

  beforeEach(async () => {
    moduleRef = sinon.createStubInstance(ModuleRef);
    translateStub = setupTranslationMocks(moduleRef);

    getOrganizationSettingsMock = sinon.createStubInstance(GetOrganizationSettings);
    getOrganizationSettingsMock.execute.resolves({
      removeNovuBranding: false,
      defaultLocale: 'en_US',
    });
    pinoLoggerMock = sinon.createStubInstance(PinoLogger);
    controlValuesRepositoryMock = sinon.createStubInstance(ControlValuesRepository);
    getLayoutUseCase = sinon.createStubInstance(GetLayoutUseCase);
    jobRepositoryMock = sinon.createStubInstance(JobRepository);
    createExecutionDetailsMock = sinon.createStubInstance(CreateExecutionDetails);

    emailOutputRendererUsecase = new EmailOutputRendererUsecase(
      getOrganizationSettingsMock as any,
      moduleRef as any,
      pinoLoggerMock as any,
      controlValuesRepositoryMock as any,
      getLayoutUseCase as any,
      jobRepositoryMock as any,
      createExecutionDetailsMock as any
    );
  });

  afterEach(() => {
    translateStub.restore();
    sinon.restore();
  });

  const mockFullPayload: FullPayloadForRender = {
    subscriber: { email: 'test@email.com' },
    payload: {},
    steps: {} as Record<string, unknown>,
  };

  const mockDbWorkflow = {
    _id: 'fake_workflow_id',
    _organizationId: 'fake_org_id',
    _environmentId: 'fake_env_id',
    _creatorId: 'fake_creator_id',
  } as any;

  describe('general flow', () => {
    it('should return subject and body when body is not string', async () => {
      let renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Test Subject',
          body: undefined,
        },
        fullPayloadForRender: mockFullPayload,
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      let result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result).to.deep.equal({
        subject: 'Test Subject',
        body: undefined,
      });

      renderCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Test Subject',
          body: 123 as any,
        },
        fullPayloadForRender: mockFullPayload,
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result).to.deep.equal({
        subject: 'Test Subject',
        body: 123,
      });
    });

    it('should process simple text with liquid variables', async () => {
      const mockTipTapNode: MailyJSONContent = {
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            content: [
              {
                type: 'text',
                text: 'Hello {{payload.name}}',
              },
            ],
          },
        ],
      };

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Welcome Email',
          body: JSON.stringify(mockTipTapNode),
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: { name: 'John' },
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result).to.have.property('subject', 'Welcome Email');
      expect(result.body).to.include('Hello John');
    });

    it('should handle nested object variables with liquid syntax', async () => {
      const mockTipTapNode: MailyJSONContent = {
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            content: [
              {
                type: 'text',
                text: 'Hello {{payload.user.name}}, your order #{{payload.order.id}} status is {{payload.order.status}}',
              },
            ],
          },
        ],
      };

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Order Update',
          body: JSON.stringify(mockTipTapNode),
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: {
            user: { name: 'John Doe' },
            order: { id: '12345', status: 'shipped' },
          },
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result).to.have.property('subject', 'Order Update');
      expect(result.body).to.include('Hello John Doe');
      expect(result.body).to.include('your order #12345');
      expect(result.body).to.include('status is shipped');
    });

    it('should handle liquid variables with default values', async () => {
      const mockTipTapNode: MailyJSONContent = {
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            content: [
              {
                type: 'text',
                text: `Hello {{payload.name | default: 'valued customer'}}`,
              },
            ],
          },
        ],
      };

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Welcome',
          body: JSON.stringify(mockTipTapNode),
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: {},
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result).to.have.property('subject', 'Welcome');
      expect(result.body).to.include('Hello valued customer');
    });
  });

  describe('variable node transformation to text', () => {
    it('should handle maily variables', async () => {
      const mockTipTapNode: MailyJSONContent = {
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            content: [
              {
                type: 'text',
                text: 'Welcome ',
              },
              {
                type: 'variable',
                attrs: {
                  id: 'payload.name',
                },
              },
              {
                type: 'text',
                text: '! Your order ',
              },
              {
                type: 'variable',
                attrs: {
                  id: 'payload.order.number',
                },
              },
              {
                type: 'text',
                text: ' has been ',
              },
              {
                type: 'variable',
                attrs: {
                  id: 'payload.order.status',
                },
              },
            ],
          },
        ],
      };

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Order Status',
          body: JSON.stringify(mockTipTapNode),
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: {
            name: 'John',
            order: {
              number: '#12345',
              status: 'shipped',
            },
          },
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.subject).to.equal('Order Status');
      expect(result.body).to.include('Welcome');
      expect(result.body).to.include('John');
      expect(result.body).to.include('Your order');
      expect(result.body).to.include('#12345');
      expect(result.body).to.include('has been');
      expect(result.body).to.include('shipped');
    });

    it('should handle maily variables with fallback values', async () => {
      const mockTipTapNode: MailyJSONContent = {
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            content: [
              {
                type: 'text',
                text: 'Hello ',
              },
              {
                type: 'variable',
                attrs: {
                  id: 'payload.name',
                  fallback: 'valued customer',
                },
              },
              {
                type: 'text',
                text: '! Your ',
              },
              {
                type: 'variable',
                attrs: {
                  id: 'payload.subscription.tier',
                  fallback: 'free',
                },
              },
              {
                type: 'text',
                text: ' subscription will expire in ',
              },
              {
                type: 'variable',
                attrs: {
                  id: 'payload.subscription.daysLeft',
                  fallback: '30',
                },
              },
              {
                type: 'text',
                text: ' days.',
              },
            ],
          },
        ],
      };

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Subscription Update',
          body: JSON.stringify(mockTipTapNode),
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: {}, // Empty payload to test fallback values
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      expect(result.subject).to.equal('Subscription Update');
      expect(result.body).to.include('Hello');
      expect(result.body).to.include('valued customer');
      expect(result.body).to.include('Your');
      expect(result.body).to.include('free');
      expect(result.body).to.include('subscription');
      expect(result.body).to.include('expire in');
      expect(result.body).to.include('30');
      expect(result.body).to.include('days');

      // Test with partial data
      const renderCommandWithPartialData = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Subscription Update',
          body: JSON.stringify(mockTipTapNode),
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: {
            name: 'John',
            subscription: {
              tier: 'premium',
            },
          },
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const resultWithPartialData = await emailOutputRendererUsecase.execute(renderCommandWithPartialData);

      expect(resultWithPartialData.body).to.include('Hello');
      expect(resultWithPartialData.body).to.include('John'); // variable
      expect(resultWithPartialData.body).to.include('Your');
      expect(resultWithPartialData.body).to.include('premium'); // variable
      expect(resultWithPartialData.body).to.include('subscription');
      expect(resultWithPartialData.body).to.include('expire in');
      expect(resultWithPartialData.body).to.include('30');
      expect(resultWithPartialData.body).to.include('days');
    });
  });

  describe('conditional block transformation (showIfKey)', () => {
    describe('truthy conditions', () => {
      const truthyValues = [
        { value: true, desc: 'boolean true' },
        { value: 1, desc: 'number 1' },
        { value: 'true', desc: 'string "true"' },
        { value: 'TRUE', desc: 'string "TRUE"' },
        { value: 'yes', desc: 'string "yes"' },
        { value: {}, desc: 'empty object' },
        { value: [], desc: 'empty array' },
      ];

      const mockTipTapNode: MailyJSONContent = {
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            content: [
              {
                type: 'text',
                text: 'Before condition',
              },
              {
                type: 'section',
                attrs: {
                  showIfKey: 'payload.isPremium',
                },
                content: [
                  {
                    type: 'paragraph',
                    content: [
                      {
                        type: 'text',
                        text: 'Premium content',
                      },
                    ],
                  },
                ],
              },
              {
                type: 'text',
                text: 'After condition',
              },
            ],
          },
        ],
      };

      truthyValues.forEach(({ value, desc }) => {
        it(`should render content when showIfKey is ${desc}`, async () => {
          const renderCommand: EmailOutputRendererCommand = {
            environmentId: 'fake_env_id',
            organizationId: 'fake_org_id',
            controlValues: {
              subject: 'Conditional Test',
              body: JSON.stringify(mockTipTapNode),
            },
            fullPayloadForRender: {
              ...mockFullPayload,
              payload: {
                isPremium: value,
              },
            },
            workflowId: mockDbWorkflow._id,
            stepId: 'fake_step_id',
          };

          const result = await emailOutputRendererUsecase.execute(renderCommand);

          expect(result.body).to.include('Before condition');
          expect(result.body).to.include('Premium content');
          expect(result.body).to.include('After condition');
        });
      });
    });

    describe('falsy conditions', () => {
      const falsyValues = [
        { value: false, desc: 'boolean false' },
        { value: 0, desc: 'number 0' },
        { value: '', desc: 'empty string' },
        { value: null, desc: 'null' },
        { value: undefined, desc: 'undefined' },
        { value: 'UNDEFINED', desc: 'string "UNDEFINED"' },
      ];

      const mockTipTapNode: MailyJSONContent = {
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            content: [
              {
                type: 'text',
                text: 'Before condition',
              },
              {
                type: 'section',
                attrs: {
                  showIfKey: 'payload.isPremium',
                },
                content: [
                  {
                    type: 'paragraph',
                    content: [
                      {
                        type: 'text',
                        text: 'Premium content',
                      },
                    ],
                  },
                ],
              },
              {
                type: 'text',
                text: 'After condition',
              },
            ],
          },
        ],
      };

      falsyValues.forEach(({ value, desc }) => {
        it(`should not render content when showIfKey is ${desc}`, async () => {
          const renderCommand: EmailOutputRendererCommand = {
            environmentId: 'fake_env_id',
            organizationId: 'fake_org_id',
            controlValues: {
              subject: 'Conditional Test',
              body: JSON.stringify(mockTipTapNode),
            },
            fullPayloadForRender: {
              ...mockFullPayload,
              payload: {
                isPremium: value,
              },
            },
            workflowId: mockDbWorkflow._id,
            stepId: 'fake_step_id',
          };

          const result = await emailOutputRendererUsecase.execute(renderCommand);

          expect(result.body).to.include('Before condition');
          expect(result.body).to.not.include('Premium content');
          expect(result.body).to.include('After condition');
        });
      });
    });

    it('should handle nested conditional blocks correctly', async () => {
      const mockTipTapNode: MailyJSONContent = {
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            content: [
              {
                type: 'section',
                attrs: {
                  showIfKey: 'payload.isSubscribed',
                },
                content: [
                  {
                    type: 'paragraph',
                    content: [
                      {
                        type: 'text',
                        text: 'Subscriber content',
                      },
                      {
                        type: 'section',
                        attrs: {
                          showIfKey: 'payload.isPremium',
                        },
                        content: [
                          {
                            type: 'paragraph',
                            content: [
                              {
                                type: 'text',
                                text: 'Premium content',
                              },
                            ],
                          },
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      };

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Nested Conditional Test',
          body: JSON.stringify(mockTipTapNode),
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: {
            isSubscribed: true,
            isPremium: true,
          },
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      let result = await emailOutputRendererUsecase.execute(renderCommand);
      expect(result.body).to.include('Subscriber content');
      expect(result.body).to.include('Premium content');

      // Test with outer true, inner false
      renderCommand.fullPayloadForRender.payload = {
        isSubscribed: true,
        isPremium: false,
      };
      result = await emailOutputRendererUsecase.execute(renderCommand);
      expect(result.body).to.include('Subscriber content');
      expect(result.body).to.not.include('Premium content');

      // Test with outer false
      renderCommand.fullPayloadForRender.payload = {
        isSubscribed: false,
        isPremium: true,
      };
      result = await emailOutputRendererUsecase.execute(renderCommand);
      expect(result.body).to.not.include('Subscriber content');
      expect(result.body).to.not.include('Premium content');
    });
  });

  describe('repeat block transformation and expansion', () => {
    it('should handle repeat loop block transformation with array of objects', async () => {
      const mockTipTapNode: MailyJSONContent = {
        type: 'doc',
        content: [
          {
            type: 'repeat',
            attrs: {
              each: 'payload.comments',
              isUpdatingKey: false,
              showIfKey: null,
            },
            content: [
              {
                type: 'paragraph',
                attrs: {
                  textAlign: 'left',
                },
                content: [
                  {
                    type: 'text',
                    text: 'This is an author: ',
                  },
                  {
                    type: 'variable',
                    attrs: {
                      id: 'payload.comments.author',
                      label: null,
                      fallback: null,
                      required: false,
                    },
                  },
                  {
                    type: 'variable',
                    attrs: {
                      // variable not belonging to the loop
                      id: 'payload.postTitle',
                      label: null,
                      fallback: null,
                      required: false,
                    },
                  },
                ],
              },
            ],
          },
        ],
      };

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Repeat Loop Test',
          body: JSON.stringify(mockTipTapNode),
          disableOutputSanitization: true,
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: {
            postTitle: 'Post Title',
            comments: [{ author: 'John' }, { author: 'Jane' }],
          },
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };
      const result = await emailOutputRendererUsecase.execute(renderCommand);
      expect(result.body).to.include('This is an author: JohnPost Title');
      expect(result.body).to.include('This is an author: JanePost Title');

      // Verify exact number of items rendered matches input array
      const matches = result.body.match(/This is an author:/g);
      expect(matches).to.have.length(2);
    });

    it('should handle repeat loop block transformation with array of primitives', async () => {
      const mockTipTapNode: MailyJSONContent = {
        type: 'doc',
        content: [
          {
            type: 'repeat',
            attrs: {
              each: 'payload.names',
              isUpdatingKey: false,
              showIfKey: null,
            },
            content: [
              {
                type: 'paragraph',
                attrs: {
                  textAlign: 'left',
                },
                content: [
                  {
                    type: 'variable',
                    attrs: {
                      id: 'payload.names',
                      label: null,
                      fallback: null,
                      required: false,
                    },
                  },
                ],
              },
            ],
          },
        ],
      };

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Repeat Loop Test',
          body: JSON.stringify(mockTipTapNode),
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: {
            names: ['John', 'Jane'],
          },
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };
      const result = await emailOutputRendererUsecase.execute(renderCommand);
      expect(result.body).to.include('John');
      expect(result.body).to.include('Jane');
    });

    it('should limit iterations when iterations attribute is smaller than array length', async () => {
      const mockTipTapNode: MailyJSONContent = {
        type: 'doc',
        content: [
          {
            type: 'repeat',
            attrs: {
              each: 'payload.items',
              iterations: 2,
              isUpdatingKey: false,
              showIfKey: null,
            },
            content: [
              {
                type: 'paragraph',
                attrs: {
                  textAlign: 'left',
                },
                content: [
                  {
                    type: 'text',
                    text: 'Item ',
                  },
                  {
                    type: 'variable',
                    attrs: {
                      id: 'payload.items',
                      label: null,
                      fallback: null,
                      required: false,
                    },
                  },
                ],
              },
            ],
          },
        ],
      };

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Repeat Loop Test Limited Iterations',
          body: JSON.stringify(mockTipTapNode),
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: {
            items: ['item1', 'item2', 'item3', 'item4'],
          },
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      // Should only create 2 items as iterations is set to 2
      expect(result.body).to.include('Item item1');
      expect(result.body).to.include('Item item2');
      expect(result.body).to.not.include('Item item3');
      expect(result.body).to.not.include('Item item4');
    });

    it('should render entire array when iterations attribute is larger than array length', async () => {
      const mockTipTapNode: MailyJSONContent = {
        type: 'doc',
        content: [
          {
            type: 'repeat',
            attrs: {
              each: 'payload.items',
              iterations: 10,
              isUpdatingKey: false,
              showIfKey: null,
            },
            content: [
              {
                type: 'paragraph',
                attrs: {
                  textAlign: 'left',
                },
                content: [
                  {
                    type: 'text',
                    text: 'Item ',
                  },
                  {
                    type: 'variable',
                    attrs: {
                      id: 'payload.items',
                      label: null,
                      fallback: null,
                      required: false,
                    },
                  },
                ],
              },
            ],
          },
        ],
      };

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Repeat Loop Test More Iterations',
          body: JSON.stringify(mockTipTapNode),
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: {
            items: ['item1', 'item2', 'item3'],
          },
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      // Should render all 3 items even though iterations is set to 10
      expect(result.body).to.include('Item item1');
      expect(result.body).to.include('Item item2');
      expect(result.body).to.include('Item item3');

      const matches = result.body.match(/Item item/g);
      expect(matches).to.have.length(3);
    });
  });

  describe('node attrs and marks attrs hydration', () => {
    it('should handle links with href attributes', async () => {
      const mockTipTapNode: MailyJSONContent = {
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            content: [
              {
                type: 'text',
                text: 'Click ',
              },
              {
                type: 'text',
                marks: [
                  {
                    type: 'link',
                    attrs: {
                      href: 'payload.linkUrl',
                      target: '_blank',
                      isUrlVariable: true,
                    },
                  },
                ],
                text: 'here',
              },
              {
                type: 'text',
                text: ' to continue',
              },
            ],
          },
        ],
      };

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Link Test',
          body: JSON.stringify(mockTipTapNode),
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: {
            linkUrl: 'https://example.com',
          },
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);
      expect(result.body).to.include('href="https://example.com"');
      expect(result.body).to.include('target="_blank"');
      expect(result.body).to.include('>here</a>');
    });

    it('should handle image nodes with variable attributes', async () => {
      const mockTipTapNode: MailyJSONContent = {
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            content: [
              {
                type: 'image',
                attrs: {
                  src: 'payload.imageUrl',
                  isSrcVariable: true,
                },
              },
            ],
          },
        ],
      };

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Image Test',
          body: JSON.stringify(mockTipTapNode),
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: {
            imageUrl: 'https://example.com/image.jpg',
          },
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);
      expect(result.body).to.include('src="https://example.com/image.jpg"');
    });

    it('should handle marks attrs href', async () => {
      const mockTipTapNode: MailyJSONContent = {
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            content: [
              {
                type: 'text',
                marks: [
                  {
                    type: 'link',
                    attrs: {
                      href: 'payload.href',
                      isUrlVariable: true,
                    },
                  },
                ],
                text: 'Colored text',
              },
            ],
          },
        ],
      };

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Color Test',
          body: JSON.stringify(mockTipTapNode),
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: {
            href: 'https://example.com',
          },
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);
      expect(result.body).to.include('href="https://example.com"');
    });
  });

  describe('enhanceContentVariable functionality', () => {
    it('should process content variable with shouldDangerouslySetInnerHTML behavior', async () => {
      const mockMailyContent = {
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            content: [
              {
                type: 'variable',
                attrs: {
                  id: LAYOUT_CONTENT_VARIABLE,
                  label: 'Content',
                },
              },
            ],
          },
        ],
      };

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Content Variable Test',
          body: JSON.stringify(mockMailyContent),
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          [LAYOUT_CONTENT_VARIABLE]: '<strong>Injected Content</strong>',
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      // The content variable should be processed and the HTML should contain the injected content
      expect(result.body).to.include('<strong>Injected Content</strong>');
      expect(result.subject).to.equal('Content Variable Test');
    });

    it('should process non-content variables normally through liquid templating', async () => {
      const mockMailyContent = {
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            content: [
              {
                type: 'variable',
                attrs: {
                  id: 'payload.name',
                  label: 'Name',
                },
              },
            ],
          },
        ],
      };

      const renderCommand: EmailOutputRendererCommand = {
        environmentId: 'fake_env_id',
        organizationId: 'fake_org_id',
        controlValues: {
          subject: 'Non-Content Variable Test',
          body: JSON.stringify(mockMailyContent),
        },
        fullPayloadForRender: {
          ...mockFullPayload,
          payload: { name: 'John Doe' },
        },
        workflowId: mockDbWorkflow._id,
        stepId: 'fake_step_id',
      };

      const result = await emailOutputRendererUsecase.execute(renderCommand);

      // Regular variables should be processed through liquid templating
      expect(result.body).to.include('John Doe');
      expect(result.subject).to.equal('Non-Content Variable Test');
    });
  });

  describe('skipLayoutRendering functionality', () => {
    const simpleBodyContent = '<p>Step content {{payload.name}}</p>';
    const layoutContent = '<html><body><div class="layout">{{content}}</div></body></html>';

    let mockControlValuesEntity: any;
    let mockLayoutDto: any;

    beforeEach(() => {
      mockControlValuesEntity = {
        controls: {
          email: {
            body: layoutContent,
          },
        },
      };

      mockLayoutDto = {
        _id: 'test_layout_id',
        isDefault: false,
        name: 'test_layout_name',
        layoutId: 'test_layout_id',
      };
